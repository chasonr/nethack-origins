Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!yale!mintaka!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i028:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7bb
Message-ID: <5242@tekred.CNA.TEK.COM>
Date: 24 Feb 90 01:10:12 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2289
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 28
Archive-name: NetHack3/Patch7bb
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 28 (of 30)."
# Contents:  amiga/Makefile.ami others/msdos.c others/ovlmgr.uu
# Wrapped by billr@saab on Wed Feb 21 10:04:52 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/Makefile.ami' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'amiga/Makefile.ami'\" to \"'amiga/Makefile.ami.orig'\"
  mv -f 'amiga/Makefile.ami' 'amiga/Makefile.ami.orig'
fi
echo shar: Extracting \"'amiga/Makefile.ami'\" \(21125 characters\)
sed "s/^X//" >'amiga/Makefile.ami' <<'END_OF_FILE'
X#	Hack Makefile.
X#	SCCS Id: @(#)Makefile.ami	3.0	90/02/13
X
X# This makefile is arranged for compiling for the Amiga with Lattice C but
X# can be configured for compiling with Manx C 3.6 with simple changes.
X# The appropriate changes are identified by #[LATTICE] and #[MANX3.6] in
X# this makefile as should be set according to the compiler being used.
X
X# The following assignments should be made before using this makefile:
X#
X#   HackExe:	directory where final executable should go
X#   NetHack:	directory where other runtime support files should go
X#   Amiga:	"amiga" directory
X#   Auxil:	"auxil" directory
X#   Incl:	"include" directory
X#   Others:	"others" directory
X#   Src1:	"src" directory (a* through l*)
X#   Src2:	"src" directory (m* through po*)
X#   Src3:	"src" directory (pr* through z*)
X#   O_Amiga:	destination for object files from Amiga:
X#   O_Others:	destination for object files from Others:
X#   O_Src1:	destination for object files from Src1:
X#   O_Src2:	destination for object files from Src2:
X#   O_Src3:	destination for object files from Src3:
X#
X# Startup makefile with:
X#
X#[LATTICE]
X#	cd NetHack:
X#	lmk -f Amiga:Makefile.ami
X#
X#[MANX3.6]
X#	cd NetHack:
X#	make -f Amiga:Makefile.ami
X#
X# May use following targets on lmk/make command line:
X#   all		do it all (default)
X#   link	just create $(GAME) from object files
X#   obj1	just create O_Src1 object files
X#   obj2	just create O_Src2 object files
X#   obj3	just create O_Src3 object files
X#   obja	just create O_Amiga object files
X#   objo	just create O_Others object files
X#   clean	deletes the object files
X#   spotless	deletes the object files, $(GAME), and more
X#
X# Note:  We do NOT build the Guidebook here since it needs tbl
X# (See the file Auxil:Makefile.auxil for more information)
X
X
X# Precompiled header file:
X#   $(HDEP) should appear in any dependency list for an object file where
X#   we would want to make use of the precompiled version of Incl:hack.h,
X#   while $(CSYM) should appear in the C compiler command line that creates
X#   any such object file.  (Changes made here should agree with the $(HDEP):
X#   target that appears later in this makefile.)
X#
X#   Notice that since this file would be created on Ram: that we would
X#   end up recompiling everything if we followed the normal make sequence.
X#   Thus, we could use:
X#
X#[LATTICE]
X#	cd NetHack:
X#	lmk -f Amiga:Makefile.ami Ram:hack.sym
X#	setdate Ram:hack.sym {date & time of Incl:hack.h}
X#	lmk -f Amiga:Makefile.ami
X#
X#[MANX3.6]
X#	cd NetHack:
X#	make -f Amiga:Makefile.ami Ram:hack.sym
X#	setdate Ram:hack.sym {date & time of Incl:hack.h}
X#	make -f Amiga:Makefile.ami
X
X#[LATTICE]
X#   If we were to use the precompiled header file feature, we would uncomment
X#   these following two lines.  However, there are still problems in the
X#   behavior of this feature in version 5.04, so these lines are commented
X#   out for now.
X
X#HDEP	= Ram:hack.sym
X#CSYM	= -HRam:hack.sym
X
X#[LATTICE]
X#   If we were to use the precompiled header file feature in a newer version
X#   of Lattice, we would comment out these following two lines.
X
XHDEP	= Incl:hack.h
XCSYM	=
X
X#[MANX3.6]
X#   If we were compiling with Aztec 3.6 and wanted to use the symbol table
X#   pre-loading feature, we would uncomment these following two lines.
X
X#HDEP	= Ram:hack.sym
X#CSYM	= +IRam:hack.sym
X
X
X# Pathname for (optional) uudecode program:
X#   If uudecode is available for use by this makefile, give its name below.
X#   Use a harmless command (like echo) otherwise.
X
XUUDEC	= echo
X#UUDEC	= uudecode
X
X
X# Pathname for the C compiler being used.
X
X#[LATTICE]
X
XCC	= lc
X
X#[MANX3.6]
X
X#CC	= cc
X
X
X# Compilation flags for selected C Compiler:
X#   $(CFLAGS) should appear before filename arguments of $(CC) command line.
X
X#[LATTICE]
X#   Note: do not use -ms with Lattice 5.04 (Others:lev_lex.c fails)
X
XCFLAGS	= -b0 -cfi -d1 -iIncl: -ma
X
X#[MANX3.6]
X
X#CFLAGS	= +c +d -e300 -z8000 +q -iIncl:
X
X
X# Components of varous link command lines:
X#   $(LINK) should be the pathname of the linker being used (with any options
X#   that should appear at the beginning of the command line).  The name of the
X#   output file should appear immediately after $(LINK).  $(LIN) should appear
X#   before the list of object files in each link command.  $(LLINK) should
X#   appear as the list of object files in the link command line that creates
X#   the NetHack executable.  $(LLIB) should appear at the end of each link
X#   command line.
X
X#[LATTICE]
X
XLINK	= Blink to
XLIN	= from Lib:catch.o
XLLINK	= with Amiga:ami.lnk
XLLIB	= lib Lib:lc.lib BATCH
X
X#[MANX3.6]
X
X#LINK	= ln +q +ss -o
X#LIN	=
X#LLINK	= -f Amiga:ami.lnk
X#LLIB	= -lcl
X
X
X# Name of the game:
X
XGAME	= HackExe:NetHack
X
X
X# A more reasonable random number generator (recommended for the Amiga):
X
XRANDOBJ	= O_Others:random.o
X
X
X.PRECIOUS:  Incl:config.h Incl:decl.h Incl:hack.h Incl:permonst.h Incl:you.h
X
X
X# Almost nothing below this line should have to be changed.
X# (Exceptions are marked by [LATTICE] and [MANX3.6].)
X#
X# Other things that have to be reconfigured are in config.h,
X# (amiconf.h, pcconf.h), and possibly system.h, tradstdc.h.
X
X
X# HSRC1 = \
X#	Src1:allmain.c		Src1:alloc.c		Src1:apply.c \
X#	Src1:artifact.c		Src1:attrib.c		Src1:bones.c \
X#	Src1:cmd.c		Src1:dbridge.c		Src1:decl.c \
X#	Src1:demon.c		Src1:do.c		Src1:do_name.c \
X#	Src1:do_wear.c		Src1:dog.c		Src1:dogmove.c \
X#	Src1:dokick.c		Src1:dothrow.c		Src1:eat.c \
X#	Src1:end.c		Src1:engrave.c		Src1:exper.c \
X#	Src1:extralev.c		Src1:fountain.c		Src1:getline.c \
X#	Src1:hack.c		Src1:invent.c		Src1:lock.c
X#
X# HSRC2 = \
X#	Src2:mail.c		Src2:makemon.c		Src2:mcastu.c \
X#	Src2:mhitm.c		Src2:mhitu.c		Src2:mklev.c \
X#	Src2:mkmaze.c		Src2:mkobj.c		Src2:mkroom.c \
X#	Src2:mon.c		Src2:mondata.c		Src2:monmove.c \
X#	Src2:monst.c		Src2:mthrowu.c		Src2:music.c \
X#	Src2:o_init.c		Src2:objects.c		Src2:objnam.c \
X#	Src2:options.c		Src2:pager.c		Src2:pickup.c \
X#	Src2:polyself.c		Src2:potion.c
X#
X# HSRC3 = \
X#	Src3:pray.c		Src3:pri.c		Src3:priest.c \
X#	Src3:prisym.c		Src3:read.c		Src3:restore.c \
X#	Src3:rip.c		Src3:rnd.c		Src3:rumors.c \
X#	Src3:save.c		Src3:search.c		Src3:shk.c \
X#	Src3:shknam.c		Src3:sit.c		Src3:sounds.c \
X#	Src3:sp_lev.c		Src3:spell.c		Src3:steal.c \
X#	Src3:timeout.c		Src3:topl.c		Src3:topten.c \
X#	Src3:track.c		Src3:trap.c		Src3:u_init.c \
X#	Src3:uhitm.c		Src3:vault.c		Src3:version.c \
X#	Src3:weapon.c		Src3:were.c		Src3:wield.c \
X#	Src3:wizard.c		Src3:worm.c		Src3:worn.c \
X#	Src3:write.c		Src3:zap.c
X
X
X# All .c that are part of the main NetHack program and not system specific:
X
X# HACKCSRC = $(HSRC1) $(HSRC2) $(HSRC3)
X
X
X# Other .c files (duplicates commented out):
X
X# MAKESRC = \
X#	Src2:makedefs.c #	Src2:monst.c		Src2:objects.c
X#
X# SPLEVSRC = \
X#	Src1:lev_comp.c		Others:lev_lex.c	Src1:lev_main.c
X#
X# AMIGASRC = \
X#	Amiga:amidos.c		Amiga:amitcap.c		Amiga:amitty.c \
X#	Amiga:amiunix.c		Amiga:amiwbench.c	Amiga:amiwind.c
X#
X# OTHERSRC = \
X#	Others:pcmain.c		Others:random.c
X
X
X# All .c that are used:
X
X# CSOURCES = $(HACKCSRC) $(MAKESRC) $(SPLEVSRC) $(AMIGASRC) $(OTHERSRC)
X
X
X# All .h files (except date.h, onames.h, pm.h, and trap.h, which would
X# cause dependency loops in run through "make depend"):
X
X# HACKINCL = \
X#	Incl:amiconf.h		Incl:anime.h		Incl:artifact.h \
X#	Incl:attrib.h		Incl:color.h		Incl:config.h \
X#	Incl:coord.h		Incl:decl.h		Incl:edog.h \
X#	Incl:epri.h		Incl:eshk.h		Incl:extern.h \
X#	Incl:flag.h		Incl:func_tab.h		Incl:global.h \
X#	Incl:gold.h		Incl:hack.h		Incl:lev.h \
X#	Incl:mfndpos.h		Incl:mkroom.h		Incl:monattk.h \
X#	Incl:mondata.h		Incl:monflag.h		Incl:monst.h \
X#	Incl:monsym.h		Incl:msdos.h		Incl:obj.h \
X#	Incl:objclass.h		Incl:patchlevel.h	Incl:pcconf.h \
X#	Incl:permonst.h		Incl:prop.h		Incl:rm.h \
X#	Incl:sp_lev.h		Incl:spell.h		Incl:system.h \
X#	Incl:tradstdc.h		Incl:vault.h		Incl:wseg.h \
X#	Incl:you.h		Incl:youprop.h
X
X
X# All .h files:
X
X# HSOURCES = \
X#	$(HACKINCL)		Incl:date.h		Incl:onames.h \
X#	Incl:pm.h		Incl:trap.h
X
X
X# All source files:
X
X# SOURCES = $(CSOURCES) $(HSOURCES)
X
X
X# Object files for makedefs:
X
XMAKEOBJS = \
X	O_Src2:makedefs.o	O_Src2:monst.o		O_Src2:objects.o
X
X
X# Object files for special levels compiler:
X
XSPLEVOBJS = \
X	O_Src1:lev_comp.o	O_Others:lev_lex.o	O_Src1:lev_main.o \
X	O_Src2:monst.o		O_Src2:objects.o
X
X
X# Object files for NetHack:
X
XHOBJ1 = \
X	O_Src1:allmain.o	O_Src1:alloc.o		O_Src1:apply.o \
X	O_Src1:artifact.o	O_Src1:attrib.o		O_Src1:bones.o \
X	O_Src1:cmd.o		O_Src1:dbridge.o	O_Src1:decl.o \
X	O_Src1:demon.o		O_Src1:do.o		O_Src1:do_name.o \
X	O_Src1:do_wear.o	O_Src1:dog.o		O_Src1:dogmove.o \
X	O_Src1:dokick.o		O_Src1:dothrow.o	O_Src1:eat.o \
X	O_Src1:end.o		O_Src1:engrave.o	O_Src1:exper.o \
X	O_Src1:extralev.o	O_Src1:fountain.o	O_Src1:getline.o \
X	O_Src1:hack.o		O_Src1:invent.o		O_Src1:lock.o
X
XHOBJ2 = \
X	O_Src2:mail.o		O_Src2:makemon.o	O_Src2:mcastu.o \
X	O_Src2:mhitm.o		O_Src2:mhitu.o		O_Src2:mklev.o \
X	O_Src2:mkmaze.o		O_Src2:mkobj.o		O_Src2:mkroom.o \
X	O_Src2:mon.o		O_Src2:mondata.o	O_Src2:monmove.o \
X	O_Src2:monst.o		O_Src2:mthrowu.o	O_Src2:music.o \
X	O_Src2:o_init.o		O_Src2:objects.o	O_Src2:objnam.o \
X	O_Src2:options.o	O_Src2:pager.o		O_Src2:pickup.o \
X	O_Src2:polyself.o	O_Src2:potion.o
X
XHOBJ3 = \
X	O_Src3:pray.o		O_Src3:pri.o		O_Src3:priest.o \
X	O_Src3:prisym.o		O_Src3:read.o		O_Src3:restore.o \
X	O_Src3:rip.o		O_Src3:rnd.o		O_Src3:rumors.o \
X	O_Src3:save.o		O_Src3:search.o		O_Src3:shk.o \
X	O_Src3:shknam.o		O_Src3:sit.o		O_Src3:sounds.o \
X	O_Src3:sp_lev.o		O_Src3:spell.o		O_Src3:steal.o \
X	O_Src3:timeout.o	O_Src3:topl.o		O_Src3:topten.o \
X	O_Src3:track.o		O_Src3:trap.o		O_Src3:u_init.o \
X	O_Src3:uhitm.o		O_Src3:vault.o		O_Src3:version.o \
X	O_Src3:weapon.o		O_Src3:were.o		O_Src3:wield.o \
X	O_Src3:wizard.o		O_Src3:worm.o		O_Src3:worn.o \
X	O_Src3:write.o		O_Src3:zap.o
X
XAMIGAOBJ = \
X	O_Amiga:amidos.o	O_Amiga:amitcap.o	O_Amiga:amitty.o \
X	O_Amiga:amiunix.o	O_Amiga:amiwbench.o	O_Amiga:amiwind.o
X
XOTHEROBJ = \
X	O_Others:pcmain.o	$(RANDOBJ)
X
X
X# All the object files for NetHack:
X
XHOBJ = $(HOBJ1) $(HOBJ2) $(HOBJ3) $(AMIGAOBJ) $(OTHEROBJ)
X
X
X# The auxiliary runtime files:
X
XAUXFILES = \
X	NetHack:data		NetHack:rumors		NetHack:castle \
X	NetHack:endgame		NetHack:tower1		NetHack:cmdhelp \
X	NetHack:help		NetHack:hh		NetHack:history \
X	NetHack:license		NetHack:opthelp		NetHack:oracles \
X	NetHack:perm		NetHack:record		NetHack:NetHack.cnf \
X	NetHack:hack.font	NetHack:hack		NetHack:hack/8 \
X	NetHack:default.icon	HackExe:NetHack.info	NetHack:NewGame.info \
X	NetHack:NetHackScore.info
X
X
X# Getting down to business:
X
Xall:  NetHack:lev_comp $(GAME) auxilstuff
X
X$(GAME):  $(HOBJ)
X	$(LINK) $(GAME) $(LIN) $(LLINK) $(LLIB)
X
Xlink:
X	$(LINK) $(GAME) $(LIN) $(LLINK) $(LLIB)
X
Xobj1:  $(HOBJ1)
Xobj2:  $(HOBJ2)
Xobj3:  $(HOBJ3)
Xobja:  $(AMIGAOBJ)
Xobjo:  $(OTHEROBJ)
X
X
X# The default method for creating object files:
X
X#[LATTICE]
X
X.c.o:
X	$(CC) $(CFLAGS) $(CSYM) -o$@ $<
X
X#[MANX3.6]
X
X#$(HOBJ1):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Src1:$*.c
X
X#$(HOBJ2):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Src2:$*.c
X
X#$(HOBJ3):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Src3:$*.c
X
X#$(AMIGAOBJ):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Amiga:$*.c
X
X#$(OTHEROBJ):
X#	$(CC) $(CFLAGS) $(CSYM) -o$@ Others:$*.c
X
X
Xclean:
X	-delete O_Amiga:\#?.o O_Others:\#?.o
X	-delete O_Src1:\#?.o O_Src2:\#?.o O_Src3:\#?.o
X
Xspotless:  clean
X	-delete $(GAME) NetHack:lev_comp NetHack:makedefs
X	-delete Auxil:data Auxil:rumors
X	-delete NetHack:data NetHack:rumors
X	-delete NetHack:castle NetHack:endgame
X	-delete NetHack:tower1 NetHack:tower2 NetHack:tower3
X	-delete Incl:onames.h Incl:pm.h
X	-echo > Incl:onames.h "" noline
X	-wait 2
X	-echo > Incl:pm.h "" noline
X	-wait 2
X	-setdate Src2:makedefs.c
X	-wait 2
X# (Make sure files exist and have timestamps in the right order for
X# next compile)
X
X
X# Creating precompiled version of Incl:hack.h to save disk I/O.
X
X#[LATTICE]
X#   If we were to use the precompiled header file feature of Lattice C, we
X#   would uncomment the following lines.  However, there are still problems
X#   in the behavior of this feature in version 5.04, so these lines are
X#   commented out for now.  (Also see defines for HDEP and CSYM near the
X#   beginning of this file, as these should be appropriately defined.)
X
X#$(HDEP):  Incl:hack.h NetHack:makedefs
X#	echo > Ram:hackincl.c "#include <Incl:hack.h>"
X#	$(CC) $(CFLAGS) -ph -o$@ Ram:hackincl.c
X#	-delete Ram:hackincl.c
X
X#[MANX3.6]
X#   If we were compiling with Aztec 3.6 and wanted to use the symbol table
X#   pre-loading feature, we would uncomment these following two lines.
X
X#$(HDEP):  Incl:hack.h NetHack:makedefs
X#	$(CC) $(CFLAGS) -a -oRam:hack.asm +h$@ Incl:hack.h
X#	-delete Ram:hack.asm
X
X
X#
X#	Please note:	The dependency lines for the modules here are
X#			deliberately incorrect.  Including "hack.h" in
X#			the dependency list would cause a dependency
X#			loop.
X#
X
XNetHack:makedefs:  $(MAKEOBJS)
X	$(LINK) NetHack:makedefs $(LIN) $(MAKEOBJS) $(LLIB)
X
XO_Src2:makedefs.o:  Src2:makedefs.c Incl:config.h Incl:permonst.h Incl:objclass.h
X	$(CC) -dMAKEDEFS_C $(CFLAGS) -o$@ Src2:makedefs.c
X
XNetHack:lev_comp:  $(SPLEVOBJS)
X	$(LINK) NetHack:lev_comp $(LIN) $(SPLEVOBJS) $(LLIB)
X
XO_Src1:lev_comp.o:  Src1:lev_comp.c $(HDEP) Incl:sp_lev.h
X	$(CC) -dLEV_LEX_C $(CFLAGS) -o$@ Src1:lev_comp.c
X
XO_Others:lev_lex.o:  Others:lev_lex.c $(HDEP) Incl:lev_comp.h Incl:sp_lev.h
X	$(CC) -dLEV_LEX_C $(CFLAGS) -o$@ Others:lev_lex.c
X
XO_Src1:lev_main.o:  Src1:lev_main.c $(HDEP) Incl:sp_lev.h
X	$(CC) -dLEV_LEX_C -dAMIGA $(CFLAGS) -o$@ Src1:lev_main.c
X
X#
X#	The following include files depend on makedefs to be created.
X#	As a result, they are not defined in HACKINCL, instead, their
X#	dependencies are explicitly outlined here.
X#
X
X#
X#	date.h should be remade any time any of the source or include code
X#	is modified.  Unfortunately, this would make the contents of this
X#	file far more complex.	Since "hack.h" depends on most of the include
X#	files, we kludge around this by making date.h dependent on hack.h,
X#	even though it doesn't include this file.
X#
X
XIncl:date.h:  $(HDEP) NetHack:makedefs $(AMIGAOBJ)
X	NetHack:makedefs -v
X
XIncl:trap.h:  Incl:config.h NetHack:makedefs
X	NetHack:makedefs -t
X	-copy makedefs.1 $@
X
XIncl:onames.h:  NetHack:makedefs
X	NetHack:makedefs -o
X
XIncl:pm.h:  NetHack:makedefs
X	NetHack:makedefs -p
X
X#
X#	The following programs vary depending on what OS you are using.
X#	As a result, they are not defined in HACKSRC and their dependancies
X#	are explicitly outlined here.
X#
X
XO_Amiga:amidos.o:  Amiga:amidos.c $(HDEP)
X
XO_Amiga:amitcap.o:  Amiga:amitcap.c $(HDEP)
X
XO_Amiga:amitty.o:  Amiga:amitty.c $(HDEP)
X
XO_Amiga:amiunix.o:  Amiga:amiunix.c $(HDEP)
X
XO_Amiga:amiwind.o:  Amiga:amiwind.c Amiga:amimenu.c $(HDEP)
X
XO_Amiga:amiwbench.o:  Amiga:amiwbench.c $(HDEP)
X
XO_Others:random.o:  Others:random.c
X	$(CC) $(CFLAGS) -o$@ Others:random.c
X
XO_Others:pcmain.o:  Others:pcmain.c $(HDEP)
X
X
X# Create/copy other stuff into NetHack: directory:
X
Xauxilstuff:  $(AUXFILES)
X
XNetHack:data:  Auxil:data
X	copy Auxil:data $@
X
XAuxil:data:  Auxil:data.base Incl:config.h NetHack:makedefs
X	NetHack:makedefs -d
X
XNetHack:rumors:  Auxil:rumors
X	copy Auxil:rumors $@
X
XAuxil:rumors:  Auxil:rumors.tru Auxil:rumors.fal NetHack:makedefs
X	NetHack:makedefs -r
X
XNetHack:castle:  Auxil:castle.des NetHack:lev_comp
X	NetHack:lev_comp Auxil:castle.des
X
XNetHack:endgame:  Auxil:endgame.des NetHack:lev_comp
X	NetHack:lev_comp Auxil:endgame.des
X
XNetHack:tower1:  Auxil:tower.des NetHack:lev_comp
X	NetHack:lev_comp Auxil:tower.des
X
XNetHack:cmdhelp:  Auxil:cmdhelp
X	copy Auxil:cmdhelp $@
X
XNetHack:help:  Auxil:help
X	copy Auxil:help $@
X
XNetHack:hh:  Auxil:hh
X	copy Auxil:hh $@
X
XNetHack:history:  Auxil:history
X	copy Auxil:history $@
X
XNetHack:license:  Auxil:license
X	copy Auxil:license $@
X
XNetHack:opthelp:  Auxil:opthelp
X	copy Auxil:opthelp $@
X
XNetHack:oracles:  Auxil:oracles
X	copy Auxil:oracles $@
X
XNetHack:perm:
X	echo > $@ "" NOLINE
X
XNetHack:record:
X	echo > $@ "" NOLINE
X
XNetHack:NetHack.cnf:  Amiga:NetHack.cnf
X	copy Amiga:NetHack.cnf $@
X
XNetHack:hack.font:  Amiga:amifont.uu
X	$(UUDEC) Amiga:amifont.uu
X
XNetHack:hack:
X	makedir $@
X
XNetHack:hack/8:  Amiga:amifont8.uu NetHack:hack
X	$(UUDEC) Amiga:amifont8.uu
X	-rename 8 hack/8
X
XNetHack:default.icon:  Amiga:dflticon.uu
X	$(UUDEC) Amiga:dflticon.uu
X
XHackExe:NetHack.info:  Amiga:NHinfo.uu
X	$(UUDEC) Amiga:NHinfo.uu
X
XNetHack:NewGame.info:  Amiga:NewGame.uu
X	$(UUDEC) Amiga:NewGame.uu
X
XNetHack:NetHackScore.info:  Amiga:NHScore.uu
X	$(UUDEC) Amiga:NHScore.uu
X
X
X# DO NOT DELETE THIS LINE
X
XO_Src1:allmain.o:  Src1:allmain.c $(HDEP)
XO_Src1:alloc.o:  Src1:alloc.c Incl:config.h
X	$(CC) $(CFLAGS) -o$@ Src1:alloc.c
XO_Src1:apply.o:  Src1:apply.c $(HDEP) Incl:edog.h
XO_Src1:artifact.o:  Src1:artifact.c $(HDEP) Incl:artifact.h
XO_Src1:attrib.o:  Src1:attrib.c $(HDEP)
XO_Src1:bones.o:  Src1:bones.c $(HDEP)
XO_Src1:cmd.o:  Src1:cmd.c $(HDEP) Incl:func_tab.h
XO_Src1:dbridge.o:  Src1:dbridge.c $(HDEP)
XO_Src1:decl.o:  Src1:decl.c $(HDEP)
XO_Src1:demon.o:  Src1:demon.c $(HDEP)
XO_Src1:do.o:  Src1:do.c $(HDEP)
XO_Src1:do_name.o:  Src1:do_name.c $(HDEP)
XO_Src1:do_wear.o:  Src1:do_wear.c $(HDEP)
XO_Src1:dog.o:  Src1:dog.c $(HDEP) Incl:edog.h
XO_Src1:dogmove.o:  Src1:dogmove.c $(HDEP) Incl:mfndpos.h Incl:edog.h
XO_Src1:dokick.o:  Src1:dokick.c $(HDEP)
XO_Src1:dothrow.o:  Src1:dothrow.c $(HDEP)
XO_Src1:eat.o:  Src1:eat.c $(HDEP)
XO_Src1:end.o:  Src1:end.c $(HDEP) Incl:eshk.h
XO_Src1:engrave.o:  Src1:engrave.c $(HDEP)
XO_Src1:exper.o:  Src1:exper.c $(HDEP)
XO_Src1:extralev.o:  Src1:extralev.c $(HDEP)
XO_Src1:fountain.o:  Src1:fountain.c $(HDEP)
XO_Src1:getline.o:  Src1:getline.c $(HDEP) Incl:func_tab.h
XO_Src1:hack.o:  Src1:hack.c $(HDEP)
XO_Src1:invent.o:  Src1:invent.c $(HDEP) Incl:lev.h Incl:wseg.h
XO_Src1:lock.o:  Src1:lock.c $(HDEP)
XO_Src2:mail.o:  Src2:mail.c $(HDEP)
XO_Src2:makemon.o:  Src2:makemon.c $(HDEP)
XO_Src2:mcastu.o:  Src2:mcastu.c $(HDEP)
XO_Src2:mhitm.o:  Src2:mhitm.c $(HDEP) Incl:artifact.h
XO_Src2:mhitu.o:  Src2:mhitu.c $(HDEP) Incl:artifact.h Incl:edog.h
XO_Src2:mklev.o:  Src2:mklev.c $(HDEP)
XO_Src2:mkmaze.o:  Src2:mkmaze.c $(HDEP)
XO_Src2:mkobj.o:  Src2:mkobj.c $(HDEP)
XO_Src2:mkroom.o:  Src2:mkroom.c $(HDEP)
XO_Src2:mon.o:  Src2:mon.c $(HDEP) Incl:mfndpos.h Incl:artifact.h
XO_Src2:mondata.o:  Src2:mondata.c $(HDEP) Incl:eshk.h Incl:epri.h
XO_Src2:monmove.o:  Src2:monmove.c $(HDEP) Incl:mfndpos.h Incl:artifact.h
XO_Src2:monst.o:  Src2:monst.c Incl:config.h Incl:permonst.h Incl:monsym.h Incl:eshk.h Incl:vault.h Incl:epri.h
X	$(CC) $(CFLAGS) -o$@ Src2:monst.c
XO_Src2:mthrowu.o:  Src2:mthrowu.c $(HDEP)
XO_Src2:music.o:  Src2:music.c $(HDEP)
XO_Src2:o_init.o:  Src2:o_init.c $(HDEP)
XO_Src2:objects.o:  Src2:objects.c Incl:config.h Incl:obj.h Incl:objclass.h Incl:prop.h
X	$(CC) $(CFLAGS) -o$@ Src2:objects.c
XO_Src2:objnam.o:  Src2:objnam.c $(HDEP)
XO_Src2:options.o:  Src2:options.c $(HDEP)
XO_Src2:pager.o:  Src2:pager.c $(HDEP)
XO_Src2:pickup.o:  Src2:pickup.c $(HDEP)
XO_Src2:polyself.o:  Src2:polyself.c $(HDEP)
XO_Src2:potion.o:  Src2:potion.c $(HDEP)
XO_Src3:pray.o:  Src3:pray.c $(HDEP)
XO_Src3:pri.o:  Src3:pri.c $(HDEP)
XO_Src3:priest.o:  Src3:priest.c $(HDEP) Incl:mfndpos.h Incl:eshk.h Incl:epri.h
XO_Src3:prisym.o:  Src3:prisym.c $(HDEP) Incl:wseg.h Incl:lev.h
XO_Src3:read.o:  Src3:read.c $(HDEP)
XO_Src3:restore.o:  Src3:restore.c $(HDEP) Incl:lev.h Incl:wseg.h
XO_Src3:rip.o:  Src3:rip.c $(HDEP)
XO_Src3:rnd.o:  Src3:rnd.c $(HDEP)
XO_Src3:rumors.o:  Src3:rumors.c $(HDEP)
XO_Src3:save.o:  Src3:save.c $(HDEP) Incl:lev.h Incl:wseg.h
XO_Src3:search.o:  Src3:search.c $(HDEP) Incl:artifact.h
XO_Src3:shk.o:  Src3:shk.c $(HDEP) Incl:eshk.h
XO_Src3:shknam.o:  Src3:shknam.c $(HDEP) Incl:eshk.h
XO_Src3:sit.o:  Src3:sit.c $(HDEP)
XO_Src3:sounds.o:  Src3:sounds.c $(HDEP) Incl:edog.h Incl:eshk.h
XO_Src3:sp_lev.o:  Src3:sp_lev.c $(HDEP) Incl:sp_lev.h
XO_Src3:spell.o:  Src3:spell.c $(HDEP)
XO_Src3:steal.o:  Src3:steal.c $(HDEP)
XO_Src3:timeout.o:  Src3:timeout.c $(HDEP)
XO_Src3:topl.o:  Src3:topl.c $(HDEP)
XO_Src3:topten.o:  Src3:topten.c $(HDEP)
XO_Src3:track.o:  Src3:track.c $(HDEP)
XO_Src3:trap.o:  Src3:trap.c $(HDEP) Incl:edog.h
XO_Src3:u_init.o:  Src3:u_init.c $(HDEP)
XO_Src3:uhitm.o:  Src3:uhitm.c $(HDEP) Incl:artifact.h
XO_Src3:vault.o:  Src3:vault.c $(HDEP) Incl:vault.h
XO_Src3:version.o:  Src3:version.c $(HDEP) Incl:date.h
XO_Src3:weapon.o:  Src3:weapon.c $(HDEP)
XO_Src3:were.o:  Src3:were.c $(HDEP)
XO_Src3:wield.o:  Src3:wield.c $(HDEP)
XO_Src3:wizard.o:  Src3:wizard.c $(HDEP)
XO_Src3:worm.o:  Src3:worm.c $(HDEP) Incl:wseg.h
XO_Src3:worn.o:  Src3:worn.c $(HDEP)
XO_Src3:write.o:  Src3:write.c $(HDEP)
XO_Src3:zap.o:  Src3:zap.c $(HDEP)
XIncl:config.h:  Incl:tradstdc.h Incl:global.h
X	-setdate Incl:config.h
X	-wait 2
XIncl:decl.h:  Incl:spell.h Incl:obj.h Incl:you.h Incl:onames.h Incl:pm.h
X	-setdate Incl:decl.h
X	-wait 2
XIncl:global.h:  Incl:coord.h Incl:unixconf.h Incl:pcconf.h Incl:tosconf.h Incl:amiconf.h
X	-setdate Incl:global.h
X	-wait 2
XIncl:hack.h:  Incl:config.h Incl:decl.h Incl:monsym.h Incl:mkroom.h Incl:objclass.h Incl:gold.h Incl:trap.h Incl:flag.h Incl:rm.h
X	-setdate Incl:hack.h
X	-wait 2
XIncl:permonst.h:  Incl:monattk.h Incl:monflag.h
X	-setdate Incl:permonst.h
X	-wait 2
XIncl:you.h:  Incl:attrib.h Incl:monst.h Incl:youprop.h
X	-setdate Incl:you.h
X	-wait 2
XIncl:youprop.h:  Incl:prop.h Incl:permonst.h Incl:mondata.h Incl:pm.h
X	-setdate Incl:youprop.h
X	-wait 2
X# DEPENDENCIES MUST END AT END OF FILE
X# IF YOU PUT STUFF HERE IT WILL GO AWAY
X# see make depend above
END_OF_FILE
if test 21125 -ne `wc -c <'amiga/Makefile.ami'`; then
    echo shar: \"'amiga/Makefile.ami'\" unpacked with wrong size!
fi
# end of 'amiga/Makefile.ami'
if test -f 'others/msdos.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'others/msdos.c'\" to \"'others/msdos.c.orig'\"
  mv -f 'others/msdos.c' 'others/msdos.c.orig'
fi
echo shar: Extracting \"'others/msdos.c'\" \(29447 characters\)
sed "s/^X//" >'others/msdos.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)msdos.c	3.0	89/12/26
X/* NetHack may be freely redistributed.  See license for details. */
X/* An assortment of MSDOS functions.
X */
X
X#define NEED_VARARGS
X#include "hack.h"
X
X#ifdef MSDOS
X
X# ifdef TOS
X#  include <osbind.h>
X#  ifndef WORD
X#    define WORD short		/* 16 bits -- redefine if necessary */
X#  endif
X# else
X#  ifdef __TURBOC__	/* avoid incompatible redeclaration */
X#   undef getdate
X#  endif
X#  include <dos.h>
X# endif
X# ifdef OS2
X#  include "def_os2.h"   /* OS2 definitions (Timo Hakulinen) */
X# endif
X
X#include <ctype.h>
X#include <fcntl.h>
X#include <process.h>
X
Xstatic char DOSgetch();
X# ifdef DGK
Xstatic char BIOSgetch();
X# endif
X# ifdef TOS
Xstatic void init_aline();
Xchar *_a_line;			/* for Line A variables */
X# else
Xstatic unsigned int ioctl();
X# endif
X
Xvoid
Xflushout()
X{
X	(void) fflush(stdout);
X	return;
X}
X
Xint
Xtgetch() {
X	char ch;
X
X# ifdef DGK
X	/* BIOSgetch can use the numeric key pad on IBM compatibles. */
X	if (flags.IBMBIOS)
X		ch = BIOSgetch();
X	else
X# endif
X		ch = DOSgetch();
X	return ((ch == '\r') ? '\n' : ch);
X}
X
X# if !defined(OS2) && !defined(TOS)
X/*
X * MS-DOS functions
X */
X#define DIRECT_INPUT	0x07	/* Unfiltered Character Input Without Echo */
X#define FATINFO 	0x1B	/* Get Default Drive Data */
X/* MS-DOS 2.0+: */
X#define GETDTA		0x2F	/* Get DTA Address */
X#define FREESPACE	0x36	/* Get Drive Allocation Info */
X#define GETSWITCHAR	0x3700	/* Get Switch Character */
X#define FINDFIRST	0x4E	/* Find First File */
X#define FINDNEXT	0x4F	/* Find Next File */
X#define SETFILETIME	0x5701	/* Set File Date & Time */
X/*
X * BIOS interrupts
X */
X#define KEYBRD_BIOS	0x16
X#define VIDEO_BIOS	0x10
X/*
X * Keyboard BIOS functions
X */
X#define READCHAR	0x00	/* Read Character from Keyboard */
X#define GETKEYFLAGS	0x02	/* Get Keyboard Flags */
X/*
X * Video BIOS functions
X */
X#define SETCURPOS	0x02	/* Set Cursor Position */
X#define GETMODE 	0x0f	/* Get Video Mode */
X#define FONTINFO	0x1130	/* Get Font Info */
X# endif
X
X
X/*
X *  Keyboard translation tables.
X */
X#  ifdef TOS
X#define KEYPADLO	0x61
X#define KEYPADHI	0x71
X#  else
X#define KEYPADLO	0x47
X#define KEYPADHI	0x53
X#  endif
X
X#define PADKEYS 	(KEYPADHI - KEYPADLO + 1)
X#define iskeypad(x)	(KEYPADLO <= (x) && (x) <= KEYPADHI)
X
X/*
X * Keypad keys are translated to the normal values below.
X * When IBM_BIOS is active, shifted keypad keys are translated to the
X *    shift values below.
X */
Xstatic const struct pad {
X	char normal, shift;
X} keypad[PADKEYS] = {
X#  ifdef TOS
X			{C('['), 'Q'},		/* UNDO */
X			{'?', '/'},		/* HELP */
X			{'(', 'a'},		/* ( */
X			{')', 'w'},		/* ) */
X			{'/', '/'},		/* / */
X			{C('p'), '$'},		/* * */
X#  endif
X			{'y', 'Y'},		/* 7 */
X			{'k', 'K'},		/* 8 */
X			{'u', 'U'},		/* 9 */
X#  ifndef TOS
X			{'m', C('p')},		/* - */
X#  endif
X			{'h', 'H'},		/* 4 */
X#  ifdef TOS
X			{'.', '.'},
X#  else
X			{'g', 'g'},		/* 5 */
X#  endif
X			{'l', 'L'},		/* 6 */
X#  ifndef TOS
X			{'p', 'P'},		/* + */
X#  endif
X			{'b', 'B'},		/* 1 */
X			{'j', 'J'},		/* 2 */
X			{'n', 'N'},		/* 3 */
X			{'i', 'I'},		/* Ins */
X			{'.', ':'}		/* Del */
X}, numpad[PADKEYS] = {
X#  ifdef TOS
X			{C('['), 'Q'}	,	/* UNDO */
X			{'?', '/'},		/* HELP */
X			{'(', 'a'},		/* ( */
X			{')', 'w'},		/* ) */
X			{'/', '/'},		/* / */
X			{C('p'), '$'},		/* * */
X#  endif
X			{'7', M('7')},		/* 7 */
X			{'8', M('8')},		/* 8 */
X			{'9', M('9')},		/* 9 */
X#  ifndef TOS
X			{'m', C('p')},		/* - */
X#  endif
X			{'4', M('4')},		/* 4 */
X#  ifdef TOS
X			{'.', '.'},		/* 5 */
X#  else
X			{'g', 'G'},		/* 5 */
X#  endif
X			{'6', M('6')},		/* 6 */
X#  ifndef TOS
X			{'p', 'P'},		/* + */
X#  endif
X			{'1', M('1')},		/* 1 */
X			{'2', M('2')},		/* 2 */
X			{'3', M('3')},		/* 3 */
X			{'i', 'I'},		/* Ins */
X			{'.', ':'}		/* Del */
X};
X
X/*
X * Unlike Ctrl-letter, the Alt-letter keystrokes have no specific ASCII
X * meaning unless assigned one by a keyboard conversion table, so the
X * keyboard BIOS normally does not return a character code when Alt-letter
X * is pressed.	So, to interpret unassigned Alt-letters, we must use a
X * scan code table to translate the scan code into a letter, then set the
X * "meta" bit for it.  -3.
X */
X#define SCANLO		0x10
X#define SCANHI		0x32
X#define SCANKEYS	(SCANHI - SCANLO + 1)
X#define inmap(x)	(SCANLO <= (x) && (x) <= SCANHI)
X
Xstatic const char scanmap[SCANKEYS] = { 	/* ... */
X	'q','w','e','r','t','y','u','i','o','p','[',']', '\n',
X	0, 'a','s','d','f','g','h','j','k','l',';','\'', '`',
X	0, '\\', 'z','x','c','v','b','N','m' 	/* ... */
X};
X
X# ifdef DGK
X/*
X * BIOSgetch gets keys directly with a BIOS call.
X */
X#define SHIFT		(0x1 | 0x2)
X#define CTRL		0x4
X#define ALT		0x8
X
Xstatic char
XBIOSgetch() {
X	unsigned char scan, shift, ch;
X	const struct pad *kpad;
X
X#  ifdef OS2
X	KBDKEYINFO CharData;
X	USHORT IOWait = 0;
X	HKBD KbdHandle = 0;
X
X	KbdCharIn(&CharData,IOWait,KbdHandle);
X	ch = CharData.chChar;
X	scan = CharData.chScan;
X	shift = CharData.fsState;
X#  else /* OS2 */
X#   ifdef TOS
X	long  x;
X#   else
X	union REGS regs;
X#   endif
X
X	/* Get scan code.
X	 */
X#   ifdef TOS
X	x = Crawcin();
X	ch = x & 0x0ff;
X	scan = (x & 0x00ff0000L) >> 16;
X#   else
X	regs.h.ah = READCHAR;
X	int86(KEYBRD_BIOS, &regs, &regs);
X	ch = regs.h.al;
X	scan = regs.h.ah;
X#   endif
X	/* Get shift status.
X	 */
X#   ifdef TOS
X	shift = Kbshift(-1);
X#   else
X	regs.h.ah = GETKEYFLAGS;
X	int86(KEYBRD_BIOS, &regs, &regs);
X	shift = regs.h.al;
X#   endif
X#  endif /* OS2 */
X
X	/* Translate keypad keys */
X	if (iskeypad(scan)) {
X		kpad = flags.num_pad ? numpad : keypad;
X		if (shift & SHIFT)
X			ch = kpad[scan - KEYPADLO].shift;
X		else
X			ch = kpad[scan - KEYPADLO].normal;
X	}
X	/* Translate unassigned Alt-letters */
X	if ((shift & ALT) && !ch) {
X		if (inmap(scan))
X			ch = scanmap[scan - SCANLO];
X		return (isprint(ch) ? M(ch) : ch);
X	}
X	return ch;
X}
X
Xstatic char
XDOSgetch() {
X# ifdef TOS
X	return (Crawcin() & 0x007f);
X# else
X#  ifdef OS2
X	KBDKEYINFO CharData;
X	USHORT IOWait = 0;
X	HKBD KbdHandle = 0;
X
X	KbdCharIn(&CharData,IOWait,KbdHandle);
X	if (CharData.chChar == 0) {	/* an extended code -- not yet supported */
X		KbdCharIn(&CharData,IOWait,KbdHandle);	   /* eat the next character */
X		CharData.chChar = 0;		/* and return a 0 */
X	}
X	return (CharData.chChar);
X#  else
X	union REGS regs;
X	char ch;
X	struct pad (*kpad)[PADKEYS];
X
X	regs.h.ah = DIRECT_INPUT;
X	intdos(&regs, &regs);
X	ch = regs.h.al;
X
X	/*
X	 * The extended codes for Alt-shifted letters, and unshifted keypad
X	 * and function keys, correspond to the scan codes.  So we can still
X	 * translate the unshifted cursor keys and Alt-letters.  -3.
X	 */
X	if (ch == 0) {		/* an extended key */
X		regs.h.ah = DIRECT_INPUT;
X		intdos(&regs, &regs);	/* get the extended key code */
X		ch = regs.h.al;
X
X		if (iskeypad(ch)) {	/* unshifted keypad keys */
X			kpad = (void *)(flags.num_pad ? numpad : keypad);
X			ch = (*kpad)[ch - KEYPADLO].normal;
X		} else if (inmap(ch)) { /* Alt-letters */
X			ch = scanmap[ch - SCANLO];
X			if (isprint(ch)) ch = M(ch);
X		} else ch = 0;		/* munch it */
X	}
X	return (ch);
X#  endif /* OS2 */
X# endif /* TOS */
X}
X
X
X#  ifndef TOS
X
X#   ifdef __TURBOC__
X#define switchar()	(char)getswitchar()
X#   else
X#    ifndef OS2
Xstatic char
Xswitchar()
X{
X	union REGS regs;
X
X	regs.x.ax = GETSWITCHAR;
X	intdos(&regs, &regs);
X	return regs.h.dl;
X}
X#    endif /* OS2 */
X#   endif /* __TURBOC__ */
X# endif  /* TOS */
X
Xstatic const char *COMSPEC = 
X# ifdef TOS
X"SHELL";
X# else
X"COMSPEC";
X# endif
X
X#define getcomspec() getenv(COMSPEC)
X
X# ifdef SHELL
Xint
Xdosh() {
X	extern char orgdir[];
X	char *comspec;
X
X	if (comspec = getcomspec()) {
X#  if defined(DGK) && !defined(TOS)	/* TOS has a variety of shells */
X		settty("To return to NetHack, enter \"exit\" at the DOS prompt.\n");
X#  else
X		settty((char *)0);
X#  endif /* DGK */
X		chdirx(orgdir, 0);
X		if (spawnl(P_WAIT, comspec, comspec, NULL) < 0) {
X			Printf("\nCan't spawn \"%s\"!\n", comspec);
X			flags.toplin = 0;
X			more();
X		}
X#ifdef TOS
X/* Some shells (e.g. Gulam) turn the cursor off when they exit */
X		if (flags.IBMBIOS)
X			(void)Cursconf(1, -1);
X#endif
X		gettty(); /* ctrl-P might get turned back on (TH) */
X		chdirx(hackdir, 0);
X		start_screen();
X		docrt();
X	} else
X#  ifdef OS2
X		pline("Can't execute CMD.EXE");
X#  else
X#   ifdef TOS
X		pline("Can't find SHELL.");
X#   else
X		pline("Can't find COMSPEC.");
X#   endif
X#  endif /* OS2 */
X	return 0;
X}
X# endif /* SHELL */
X
X#ifndef TOS
X
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X#   ifdef OS2
X	struct {
X		ULONG  idFileSystem;
X		ULONG  cSectorUnit;
X		ULONG  cUnit;
X		ULONG  cUnitAvail;
X		USHORT cbSector;
X	} FSInfoBuf;
X	USHORT DriveNumber, FSInfoLevel = 1, res;
X
X	if (path[0] && path[1] == ':')
X		DriveNumber = (toupper(path[0]) - 'A') + 1;
X	else
X		DriveNumber = 0;
X	res = DosQFSInfo(DriveNumber,FSInfoLevel,(PBYTE)&FSInfoBuf,sizeof(FSInfoBuf));
X	if (res)
X		return -1L;		/* error */
X	else
X		return ((long) FSInfoBuf.cSectorUnit * FSInfoBuf.cUnitAvail *
X			       FSInfoBuf.cbSector);
X#   else /* OS2 */
X	union REGS regs;
X
X	regs.h.ah = FREESPACE;
X	if (path[0] && path[1] == ':')
X		regs.h.dl = (toupper(path[0]) - 'A') + 1;
X	else
X		regs.h.dl = 0;
X	intdos(&regs, &regs);
X	if (regs.x.ax == 0xFFFF)
X		return -1L;		/* bad drive number */
X	else
X		return ((long) regs.x.bx * regs.x.cx * regs.x.ax);
X#   endif /* OS2 */
X}
X
X#   ifdef OS2
XFILEFINDBUF ResultBuf;
XHDIR DirHandle;
X#   endif
X
X/* Functions to get filenames using wildcards
X */
Xstatic int
Xfindfirst(path)
Xchar *path;
X{
X#   ifdef OS2
X	USHORT res, SearchCount = 1;
X
X	DirHandle = 1;
X	res = DosFindFirst((PSZ)path,&DirHandle,0,&ResultBuf,sizeof(FILEFINDBUF),&SearchCount,0L);
X	return(!res);
X#   else
X	union REGS regs;
X	struct SREGS sregs;
X
X	regs.h.ah = FINDFIRST;
X	regs.x.cx = 0;		/* attribute: normal files */
X	regs.x.dx = FP_OFF(path);
X	sregs.ds = FP_SEG(path);
X	intdosx(&regs, &regs, &sregs);
X	return !regs.x.cflag;
X#   endif /* OS2 */
X}
X
Xstatic int
Xfindnext() {
X#   ifdef OS2
X	USHORT res, SearchCount = 1;
X
X	res = DosFindNext(DirHandle,&ResultBuf,sizeof(FILEFINDBUF),&SearchCount);
X	return(!res);
X#   else
X	union REGS regs;
X
X	regs.h.ah = FINDNEXT;
X	intdos(&regs, &regs);
X	return !regs.x.cflag;
X#   endif /* OS2 */
X}
X
X#   ifndef OS2
X/* Get disk transfer area, Turbo C already has getdta */
Xstatic char *
Xgetdta() {
X	union REGS regs;
X	struct SREGS sregs;
X	char *ret;
X
X	regs.h.ah = GETDTA;
X	intdosx(&regs, &regs, &sregs);
X#    ifdef MK_FP
X	ret = MK_FP(sregs.es, regs.x.bx);
X#    else
X	FP_OFF(ret) = regs.x.bx;
X	FP_SEG(ret) = sregs.es;
X#    endif
X	return ret;
X}
X#   endif /* OS2 */
X
X#  else /* TOS */
X
Xlong
Xfreediskspace(path)
Xchar *path;
X{
X	int drive = 0;
X	struct {
X		long freal; /*free allocation units*/
X		long total; /*total number of allocation units*/
X		long bps;   /*bytes per sector*/
X		long pspal; /*physical sectors per allocation unit*/
X	} freespace;
X	if (path[0] && path[1] == ':')
X		drive = (toupper(path[0]) - 'A') + 1;
X	if (Dfree(&freespace,drive)<0) return -1;
X	return freespace.freal*freespace.bps*freespace.pspal;
X}
X
Xstatic int
Xfindfirst(path)
Xchar *path;
X{
X	return (Fsfirst(path, 0) == 0);
X}
X
Xstatic int findnext() {
X	return (Fsnext() == 0);
X}
X
Xstatic char *
Xgetdta() {
X	return (char *) Fgetdta();
X}
X
X#  endif /* TOS */
X
Xlong
Xfilesize(file)
Xchar *file;
X{
X#  ifndef OS2
X	char *dta;
X#  endif
X
X	if (findfirst(file)) {
X#  ifdef OS2
X		return  (* (long *) (ResultBuf.cbFileAlloc));
X#  else
X		dta = getdta();
X		return  (* (long *) (dta + 26));
X#  endif
X	} else
X		return -1L;
X}
X
Xvoid
Xeraseall(path, files)
Xconst char *path, *files;
X{
X#  ifndef OS2
X	char *dta;
X#  endif
X	char buf[PATHLEN];
X
X#  ifndef OS2
X	dta = getdta();
X#  endif
X	Sprintf(buf, "%s%s", path, files);
X	if (findfirst(buf))
X		do {
X			Sprintf(buf, "%s%s", path,
X#  ifdef OS2
X				ResultBuf.achName
X#  else
X				dta + 30
X#  endif
X				);
X			(void) unlink(buf);
X		} while (findnext());
X	return;
X}
X
X/* Rewritten for version 3.3 to be faster
X */
Xvoid
Xcopybones(mode)
Xint mode;
X{
X	char from[PATHLEN], to[PATHLEN], last[13];
X	char *frompath, *topath;
X#  ifndef OS2
X	char *dta;
X#  endif
X#  ifndef TOS
X	int status;
X	char copy[8], *comspec;
X	extern saveprompt;
X#  endif
X
X	if (!ramdisk)
X		return;
X
X	/* Find the name of the last file to be transferred
X	 */
X	frompath = (mode != TOPERM) ? permbones : levels;
X#  ifndef OS2
X	dta = getdta();
X#  endif
X	last[0] = '\0';
X	Sprintf(from, "%s%s", frompath, allbones);
X	topath = (mode == TOPERM) ? permbones : levels;
X#  ifdef TOS
X	eraseall(topath, allbones);
X#  endif
X	if (findfirst(from))
X		do {
X#  ifdef TOS
X			Sprintf(from, "%s%s", frompath, dta+30); 
X			Sprintf(to, "%s%s", topath, dta+30);
X			if (_copyfile(from, to))
X				goto error_copying;
X#  endif
X			Strcpy(last,
X#  ifdef OS2
X				ResultBuf.achName
X#  else
X				dta + 30
X#  endif
X				);
X		} while (findnext());
X#  ifdef TOS
X	else
X		return;
X#  else
X	if (last[0]) {
X		Sprintf(copy, "%cC copy",
X#   ifdef OS2
X			'/'
X#   else
X			switchar()
X#   endif
X			);
X
X		/* Remove any bones files in `to' directory.
X		 */
X		eraseall(topath, allbones);
X
X		/* Copy `from' to `to' */
X		Sprintf(to, "%s%s", topath, allbones);
X		comspec = getcomspec();
X		status =spawnl(P_WAIT, comspec, comspec, copy, from,
X			to, "> nul", NULL);
X	} else
X		return;
X#  endif /* TOS */
X
X	/* See if the last file got there.  If so, remove the ramdisk bones
X	 * files.
X	 */
X	Sprintf(to, "%s%s", topath, last);
X	if (findfirst(to)) {
X		if (mode == TOPERM)
X			eraseall(frompath, allbones);
X		return;
X	}
X
Xerror_copying:
X	/* Last file didn't get there.
X	 */
X	Sprintf(to, "%s%s", topath, allbones);
X	msmsg("Can't copy \"%s\" to \"%s\" -- ", from, to);
X#  ifndef TOS
X	if (status < 0)
X	    msmsg("can't spawn \"%s\"!", comspec);
X	else
X#  endif
X	    msmsg((freediskspace(topath) < filesize(from)) ?
X			"insufficient disk space." : "bad path(s)?");
X	if (mode == TOPERM) {
X		msmsg("Bones will be left in \"%s\"\n",
X			*levels ? levels : hackdir);
X	} else {
X		/* Remove all bones files on the RAMdisk */
X		eraseall(levels, allbones);
X		playwoRAMdisk();
X	}
X	return;
X}
X
X#if 0 /* defined(MSDOS) && !defined(TOS) && !defined(OS2) */
Xboolean
Xremoveable_drive(drive)
Xchar drive;
X/* check whether current drive is a fixed disk,
X   so we don't ask the player to insert one */
X{
X	union REGS regs;
X	char *fat_id;
X
X	regs.h.ah = FATINFO;
X	intdos(&regs, &regs);
X	/* also returns size info, as
X	   AL (sectors/cluster) * CX (bytes/sector) * DX (clusters/disk) */
X#   ifdef MK_FP
X	fat_id = MK_FP(sregs.ds, regs.x.bx);
X#   else
X	FP_OFF(fat_id) = regs.x.bx;
X	FP_SEG(fat_id) = sregs.ds;
X#   endif
X	return (*fat_id != 0xF8);
X}
X#endif /* 0 */
X
Xvoid
XplaywoRAMdisk() {
X	msmsg("Do you wish to play without a RAMdisk? ");
X
X	/* Set ramdisk false *before* exit-ing (because msexit calls
X	 * copybones)
X	 */
X	ramdisk = FALSE;
X	if (yn() != 'y') {
X		settty("Be seeing you...\n");
X		exit(0);
X	}
X	set_lock_and_bones();
X	return;
X}
X
Xint
XsaveDiskPrompt(start)
Xint start;
X{
X	extern saveprompt;
X	char buf[BUFSIZ], *bp;
X	int fd;
X
X	if (saveprompt) {
X		/* Don't prompt if you can find the save file */
X		if ((fd = open(SAVEF, 0)) >= 0) {
X			(void) close(fd);
X			return 1;
X		}
X		remember_topl();
X		home();
X		cl_end();
X		msmsg("If save file is on a save disk, insert that disk now.\n");
X		cl_end();
X		msmsg("File name (default \"%s\"%s) ? ", SAVEF,
X			start ? "" : ", <Esc> cancels save");
X		getlin(buf);
X		home();
X		cl_end();
X		curs(1, 2);
X		cl_end();
X		if (!start && *buf == '\033')
X			return 0;
X
X		/* Strip any whitespace. Also, if nothing was entered except
X		 * whitespace, do not change the value of SAVEF.
X		 */
X		for (bp = buf; *bp; bp++)
X			if (!isspace(*bp)) {
X				strncpy(SAVEF, bp, PATHLEN);
X				break;
X			}
X	}
X	return 1;
X}
X
X/* Return 1 if the record file was found */
Xstatic boolean
Xrecord_exists() {
X	int fd;
X#  ifdef OS2_CODEVIEW
X	char tmp[PATHLEN];
X
X	Strcpy(tmp,hackdir);
X	append_slash(tmp);
X	Strcat(tmp,RECORD);
X	if ((fd = open(tmp, 0)) >= 0) {
X#  else
X	if ((fd = open(RECORD, 0)) >= 0) {
X#  endif
X		(void) close(fd);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X#  ifdef TOS
X#define comspec_exists() 1
X#  else
X/* Return 1 if the comspec was found */
Xstatic boolean
Xcomspec_exists() {
X	int fd;
X	char *comspec;
X
X	if (comspec = getcomspec())
X		if ((fd = open(comspec, 0)) >= 0) {
X			(void) close(fd);
X			return TRUE;
X		}
X	return FALSE;
X}
X#  endif
X
X/* Prompt for game disk, then check for record file.
X */
Xvoid
XgameDiskPrompt() {
X	extern int saveprompt;
X
X	if (saveprompt) {
X		if (record_exists() && comspec_exists())
X			return;
X		(void) putchar('\n');
X		getreturn("when the game disk has been inserted");
X	}
X	if (comspec_exists() && record_exists())
X		return;
X
X	if (!comspec_exists())
X		msmsg("\n\nWARNING: can't find command processor \"%s\"!\n", getcomspec());
X        if (!record_exists())
X		msmsg("\n\nWARNING: can't find record file \"%s\"!\n", RECORD);
X	msmsg("If the game disk is not in, insert it now.\n");
X	getreturn("to continue");
X	return;
X}
X
X# endif /* DGK */
X
X/* Read configuration */
Xvoid
Xread_config_file() {
X# ifdef DGK
X	char	tmp_ramdisk[PATHLEN];
X	extern	int saveprompt;
X# else
X#define fopenp fopen
X# endif
X	char	tmp_levels[PATHLEN];
X	char	buf[BUFSZ], *bufp;
X	FILE	*fp;
X	extern	char plname[];
X
X# ifdef DGK
X	tmp_ramdisk[0] = 0;
X# endif
X	tmp_levels[0] = 0;
X	if ((fp = fopenp(configfile, "r")) == (FILE *)0) {
X		msmsg("Warning: no configuration file!\n");
X		getreturn("to continue");
X		return;
X	}
X	while (fgets(buf, BUFSZ, fp)) {
X		if (*buf == '#')
X			continue;
X
X		/* remove trailing whitespace
X		 */
X		bufp = index(buf, '\n');
X		while (bufp > buf && isspace(*bufp))
X			bufp--;
X		if (bufp == buf)
X			continue;		/* skip all-blank lines */
X		else
X			*(bufp + 1) = 0;	/* 0 terminate line */
X
X		/* find the '=' */
X		if (!(bufp = strchr(buf, '='))) {
X			msmsg("Bad option line: \"%s\"\n", buf);
X			getreturn("to continue");
X			continue;
X		}
X		
X		/* skip  whitespace between '=' and value */
X		while (isspace(*++bufp))
X			;
X
X		/* Go through possible variables */
X		if (!strncmp(buf, "HACKDIR", 4)) {
X			strncpy(hackdir, bufp, PATHLEN);
X		
X# ifdef DGK
X		} else if (!strncmp(buf, "RAMDISK", 3)) {
X			strncpy(tmp_ramdisk, bufp, PATHLEN);
X# endif
X
X		} else if (!strncmp(buf, "LEVELS", 4)) {
X			strncpy(tmp_levels, bufp, PATHLEN);
X
X		} else if (!strncmp(buf, "OPTIONS", 4)) {
X			parseoptions(bufp, TRUE);
X			if (plname[0])		/* If a name was given */
X				plnamesuffix();	/* set the character class */
X
X		} else if (!strncmp(buf, "SAVE", 4)) {
X# ifdef DGK
X			char *ptr;
X			if (ptr = index(bufp, ';')) {
X				*ptr = '\0';
X				if (*(ptr+1) == 'n' || *(ptr+1) == 'N')
X					saveprompt = FALSE;
X			}
X# endif /* DGK */
X			(void) strncpy(SAVEF, bufp, PATHLEN);
X			(void) strncpy(SAVEP, bufp, PATHLEN);
X			append_slash(SAVEF);
X			append_slash(SAVEP);
X		} else if (!strncmp(buf, "GRAPHICS", 4)) {
X			unsigned int translate[MAXPCHARS+1];
X			int lth;
X#ifdef OVERLAY
X			/* THIS is what I call a stupid hack, but MSC cannot survive
X			   the overlays without it (TH) */
X			lth = sscanf(bufp,
X	"%d%d%d%d%d%d%d%d%d%d%d%d",
X				&translate[0], &translate[1], &translate[2],
X				&translate[3], &translate[4], &translate[5],
X				&translate[6], &translate[7], &translate[8],
X				&translate[9], &translate[10], &translate[11]);
X			lth += sscanf(bufp,
X	"%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%d%d%d%d%d%d%d%d%d%d%d%d",
X				&translate[12], &translate[13], &translate[14],
X				&translate[15], &translate[16], &translate[17],
X				&translate[18], &translate[19], &translate[20],
X				&translate[21], &translate[22], &translate[23]);
X			lth += sscanf(bufp,
X	"%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%*d%d%d%d%d%d%d%d%d%d%d%d",
X				&translate[24], &translate[25], &translate[26],
X				&translate[27], &translate[28], &translate[29],
X				&translate[30], &translate[31], &translate[32],
X				&translate[33], &translate[34]);
X#else
X		     lth = sscanf(bufp,
X	"%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X				&translate[0], &translate[1], &translate[2],
X				&translate[3], &translate[4], &translate[5],
X				&translate[6], &translate[7], &translate[8],
X				&translate[9], &translate[10], &translate[11],
X				&translate[12], &translate[13], &translate[14],
X				&translate[15], &translate[16], &translate[17],
X				&translate[18], &translate[19], &translate[20],
X				&translate[21], &translate[22], &translate[23],
X				&translate[24], &translate[25], &translate[26],
X				&translate[27], &translate[28], &translate[29],
X				&translate[30], &translate[31], &translate[32],
X				&translate[33], &translate[34]);
X#endif /* OVERLAY */
X			if (lth <= 0) {
X				msmsg ("Syntax error in GRAPHICS\n");
X				getreturn("to continue");
X			}
X			assign_graphics(translate, lth);
X		} else {
X			msmsg("Bad option line: \"%s\"\n", buf);
X			getreturn("to continue");
X		}
X	}
X	(void) fclose(fp);
X
X# ifdef DGK
X	Strcpy(permbones, tmp_levels);
X	if (tmp_ramdisk[0]) {
X		Strcpy(levels, tmp_ramdisk);
X		if (strcmp(permbones, levels))		/* if not identical */
X			ramdisk = TRUE;
X	} else
X# endif /* DGK */
X		Strcpy(levels, tmp_levels);
X	Strcpy(bones, levels);
X	return;
X}
X
X# ifdef DGK
X/* Set names for bones[] and lock[]
X */
Xvoid
Xset_lock_and_bones() {
X	if (!ramdisk) {
X		Strcpy(levels, permbones);
X		Strcpy(bones, permbones);
X	}
X	append_slash(permbones);
X	append_slash(levels);
X	append_slash(bones);
X	Strcat(bones, allbones);
X	Strcpy(lock, levels);
X	Strcat(lock, alllevels);
X	return;
X}
X# endif /* DGK */
X
X/* Add a backslash to any name not ending in /, \ or :   There must
X * be room for the \
X */
Xvoid
Xappend_slash(name)
Xchar *name;
X{
X	char *ptr;
X
X	if (!*name)
X		return;
X	ptr = name + (strlen(name) - 1);
X	if (*ptr != '\\' && *ptr != '/' && *ptr != ':') {
X		*++ptr = '\\';
X		*++ptr = '\0';
X	}
X	return;
X}
X
Xvoid
Xgetreturn(str)
Xconst char *str;
X{
X# ifdef TOS
X	msmsg("Hit <Return> %s.", str);
X# else
X	msmsg("Hit <Enter> %s.", str);
X# endif
X	while (Getchar() != '\n') ;
X	return;
X}
X
Xvoid
Xmsmsg VA_DECL(const char *, fmt)
X	VA_START(fmt);
X	VA_INIT(fmt, const char *);
X	Vprintf(fmt, VA_ARGS);
X	flushout();
X	VA_END();
X	return;
X}
X
X/* Chdrive() changes the default drive.
X */
X# ifndef __TURBOC__
X#  ifndef OS2
X#define SELECTDISK	0x0E
X#  endif
Xvoid
Xchdrive(str)
Xchar *str;
X{
X	char *ptr;
X#  ifndef TOS
X#   ifndef OS2
X	union REGS inregs;
X#   endif
X#  endif
X	char drive;
X
X	if ((ptr = index(str, ':')) != NULL) {
X		drive = toupper(*(ptr - 1));
X#  ifdef TOS
X		(void)Dsetdrv(drive - 'A');
X#  else
X#   ifdef OS2
X		DosSelectDisk((USHORT)(drive - 'A' + 1));
X#   else
X		inregs.h.ah = SELECTDISK;
X		inregs.h.dl = drive - 'A';
X		intdos(&inregs, &inregs);
X#   endif
X#  endif
X	}
X	return;
X}
X# else
Xextern int setdisk(int);
X
Xvoid
Xchdrive(str)
Xchar *str;
X{
X	if (str[1] == ':')
X		(void)setdisk((int)(toupper(str[0]) - 'A'));
X	return;
X}
X# endif
X
X# ifndef TOS
X/* Use the IOCTL DOS function call to change stdin and stdout to raw
X * mode.  For stdin, this prevents MSDOS from trapping ^P, thus
X * freeing us of ^P toggling 'echo to printer'.
X * Thanks to Mark Zbikowski (markz@microsoft.UUCP).
X */
X
X#  ifndef OS2
X#define DEVICE		0x80
X#define RAW		0x20
X#define IOCTL		0x44
X#define STDIN		fileno(stdin)
X#define STDOUT		fileno(stdout)
X#define GETBITS		0
X#define SETBITS		1
X#  endif
X
Xstatic unsigned	int old_stdin, old_stdout;
X
Xvoid
Xdisable_ctrlP() {
X#  ifdef OS2
X	KBDINFO KbdInfo;
X	HKBD KbdHandle = 0;
X#  endif
X
X#  ifdef DGK
X	if (!flags.rawio) return;
X#  endif
X#  ifdef OS2
X	KbdInfo.cb = sizeof(KbdInfo);
X	KbdGetStatus(&KbdInfo,KbdHandle);
X	KbdInfo.fsMask &= 0xFFF7; /* ASCII off */
X	KbdInfo.fsMask |= 0x0004; /* BINARY on */
X	KbdSetStatus(&KbdInfo,KbdHandle);
X#  else
X	old_stdin = ioctl(STDIN, GETBITS, 0);
X	old_stdout = ioctl(STDOUT, GETBITS, 0);
X	if (old_stdin & DEVICE)
X		ioctl(STDIN, SETBITS, old_stdin | RAW);
X	if (old_stdout & DEVICE)
X		ioctl(STDOUT, SETBITS, old_stdout | RAW);
X#  endif /* OS2 */
X	return;
X}
X
Xvoid
Xenable_ctrlP() {
X#  ifdef OS2
X	KBDINFO KbdInfo;
X	HKBD KbdHandle = 0;
X#  endif
X
X#  ifdef DGK
X	if (!flags.rawio) return;
X#  endif
X#  ifdef OS2
X	KbdInfo.cb = sizeof(KbdInfo);
X	KbdGetStatus(&KbdInfo,KbdHandle);
X	KbdInfo.fsMask &= 0xFFFB; /* BINARY off */
X	KbdInfo.fsMask |= 0x0008; /* ASCII on */
X	KbdSetStatus(&KbdInfo,KbdHandle);
X#  else
X	if (old_stdin)
X		(void) ioctl(STDIN, SETBITS, old_stdin);
X	if (old_stdout)
X		(void) ioctl(STDOUT, SETBITS, old_stdout);
X#  endif
X	return;
X}
X
X#  ifndef OS2
Xstatic unsigned int
Xioctl(handle, mode, setvalue)
Xint handle, mode;
Xunsigned setvalue;
X{
X	union REGS regs;
X
X	regs.h.ah = IOCTL;
X	regs.h.al = mode;
X	regs.x.bx = handle;
X	regs.h.dl = setvalue;
X	regs.h.dh = 0;			/* Zero out dh */
X	intdos(&regs, &regs);
X	return (regs.x.dx);
X}
X#  endif /* OS2 */
X# endif /* TOS */
X
X# ifdef DGK
X/* Follow the PATH, trying to fopen the file.
X */
X#  ifdef TOS
X#define PATHSEP	','
X#  else
X#define PATHSEP	';'
X#  endif
X
XFILE *
Xfopenp(name, mode)
Xconst char *name, *mode;
X{
X	char buf[BUFSIZ], *bp, *pp, lastch = 0;
X	FILE *fp;
X
X	/* Try the default directory first.  Then look along PATH.
X	 */
X	Strcpy(buf, name);
X	if (fp = fopen(buf, mode))
X		return fp;
X	else {
X		pp = getenv("PATH");
X		while (pp && *pp) {
X			bp = buf;
X			while (*pp && *pp != PATHSEP)
X				lastch = *bp++ = *pp++;
X			if (lastch != '\\' && lastch != '/')
X				*bp++ = '\\';
X			Strcpy(bp, name);
X			if (fp = fopen(buf, mode))
X				return fp;
X			if (*pp)
X				pp++;
X		}
X	}
X#  ifdef OS2_CODEVIEW /* one more try for hackdir */
X	Strcpy(buf,hackdir);
X	append_slash(buf);
X	Strcat(buf,name);
X	if(fp = fopen(buf,mode))
X		return fp;
X#  endif
X	return (FILE *)0;
X}
X# endif /* DGK */
X
X/* Chdir back to original directory
X */
X#undef exit
X# ifdef TOS
Xextern boolean run_from_desktop;	/* set in pcmain.c */
X# endif
X
Xvoid exit(int);
Xvoid
Xmsexit(code)
Xint code;
X{
X# ifdef CHDIR
X	extern char orgdir[];
X# endif
X
X	flushout();
X# ifndef TOS
X	enable_ctrlP();		/* in case this wasn't done */
X# endif
X# ifdef DGK
X	if (ramdisk) copybones(TOPERM);
X# endif
X# ifdef CHDIR
X	chdir(orgdir);		/* chdir, not chdirx */
X	chdrive(orgdir);
X# endif
X# ifdef TOS
X	if (run_from_desktop)
X	    getreturn("to continue"); /* so the user can read the score list */
X#  ifdef TEXTCOLOR
X	if (flags.IBMBIOS && flags.use_color)
X		restore_colors();
X#  endif
X# endif
X	exit(code);
X	return;
X}
X
X#  ifdef DGK		/* for flags.IBMBIOS */
Xvoid
Xget_scr_size()
X{
X#   ifdef OS2
X	VIOMODEINFO ModeInfo;
X	HVIO VideoHandle = 0;
X
X	ModeInfo.cb = sizeof(ModeInfo);
X
X	(void) VioGetMode(&ModeInfo,VideoHandle);
X
X	CO = ModeInfo.col;
X	LI = ModeInfo.row;
X#   else
X#    ifndef TOS
X	union REGS regs;
X
X	if (!flags.IBMBIOS) {		/* assume standard screen size */
X		CO = 80;
X		LI = 24;
X		return;
X	}
X
X	regs.x.ax = FONTINFO;
X	regs.x.bx = 0;			/* current ROM BIOS font */
X	regs.h.dl = 24;			/* default row count */
X					/* in case no EGA/MCGA/VGA */
X	int86(VIDEO_BIOS, &regs, &regs); /* Get Font Information */
X
X	/* MDA/CGA/PCjr ignore INT 10h, Function 11h, but since we
X	 * cleverly loaded up DL with the default, everything's fine.
X	 *
X	 * Otherwise, DL now contains rows - 1.  Also, CX contains the
X	 * points (bytes per character) and ES:BP points to the font
X	 * table.  -3.
X	 */
X
X	regs.h.ah = GETMODE;
X	int86(VIDEO_BIOS, &regs, &regs); /* Get Video Mode */
X
X	/* This goes back all the way to the original PC.  Completely
X	 * safe.  AH contains # of columns, AL contains display mode,
X	 * and BH contains the active display page.
X	 */
X
X	LI = regs.h.dl + 1;
X	CO = regs.h.ah;
X#    else  /* TOS */
X	init_aline();
X	LI = (*((WORD  *)(_a_line + -42L))) + 1;
X	CO = (*((WORD  *)(_a_line + -44L))) + 1;
X#    endif /* TOS */
X#   endif /* OS2 */
X}
X
X#   ifndef TOS
Xvoid
Xgotoxy(x,y)
Xint x,y;
X{
X#    ifdef OS2
X	HVIO VideoHandle = 0;
X
X	x--; y--;			/* (0,0) is upper right corner */
X
X	(void) VioSetCurPos(x, y, VideoHandle);
X#    else
X	union REGS regs;
X
X	x--; y--;			/* (0,0) is upper right corner */
X
X	regs.h.ah = SETCURPOS;
X	regs.h.bh = 0;			/* display page */
X	regs.h.dh = y;			/* row */
X	regs.h.dl = x;			/* column */
X	int86(VIDEO_BIOS, &regs, &regs); /* Set Cursor Position */
X
X	/* This, too, goes back all the way to the original PC.  If
X	 * we ever get so fancy as to swap display pages (i doubt it),
X	 * then we'll need to set BH appropriately.  This function
X	 * returns nothing.  -3.
X	 */
X#    endif /* OS2 */
X}
X#   endif /* TOS */
X#  endif /* DGK */
X
X#endif /* MSDOS */
X
X
X#ifdef TOS
X# define BIGBUF  8192
X
Xint
X_copyfile(from, to)
Xchar *from, *to;
X{
X	int fromfd, tofd, r;
X	char *buf;
X
X	if ((fromfd = open(from, O_RDONLY|O_BINARY, 0)) < 0)
X		return -1;
X	if ((tofd = open(to, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, FCMASK)) < 0)
X		return -1;
X	if (!(buf = (char *)malloc((size_t)BIGBUF)))
X		return -1;
X	while ( (r = read(fromfd, buf, BIGBUF)) > 0)
X		write(tofd, buf, r);
X	close(fromfd);
X	close(tofd);
X	free(buf);
X	return 0;	/* successful */
X}
X
Xint kbhit()
X{
X	return Cconis();
X}
X
Xstatic void
Xinit_aline()
X{
X# ifdef __GNUC__
X	asm(" .word 0xa000; movel d0, __a_line");
X# else
X	asm(" .dc.w 0xa000");	/* tweak as necessary for your compiler */
X	asm(" move.l d0, __a_line");
X# endif
X}
X
X# ifdef TEXTCOLOR
Xstatic unsigned orig_color[4] = {-1, -1, -1, -1};
Xstatic unsigned new_color[4] = { 0x0, 0x730, 0x047, 0x555 };
Xstatic int numcolors = 2;
X
Xvoid set_colors()
X{
X	int i;
X	char *s;
X	static char newhe[] = "\033q\033b\017\033c0";
X
X	init_aline();
X	numcolors = 1 << (((unsigned char *) _a_line)[1]);
X	if (numcolors == 2) {			/* mono */
X		flags.use_color = FALSE;
X		return;
X	}
X	else if (numcolors == 4) {
X		for (i = 0; i < 4; i++)
X			orig_color[i] = Setcolor(i, new_color[i]);
X	}
X	else {
X		orig_color[0] = Setcolor(0, new_color[0]);
X		orig_color[1] = Setcolor(15, 0x777);
X		hilites[0] = "";
X		for (i = 1; i < 16; i++) {
X			s = (char *) alloc(sizeof("\033b0"));
X			sprintf(s, "\033b%c", '0'+i);
X			hilites[i] = s;
X		}
X		HE = newhe;
X	}
X}
X
Xvoid restore_colors()
X{
X	int i;
X
X	if (numcolors == 2)
X		return;
X	else if (numcolors == 4)
X		for (i = 0; i < 4; i++)
X			(void) Setcolor(i, orig_color[i]);
X	else {
X		(void) Setcolor(0, orig_color[0]);
X		(void) Setcolor(15, orig_color[1]);
X	}
X}
X# endif /* TEXTCOLOR */
X#endif /* TOS */
END_OF_FILE
if test 29447 -ne `wc -c <'others/msdos.c'`; then
    echo shar: \"'others/msdos.c'\" unpacked with wrong size!
fi
# end of 'others/msdos.c'
if test -f 'others/ovlmgr.uu' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'others/ovlmgr.uu'\" to \"'others/ovlmgr.uu.orig'\"
  mv -f 'others/ovlmgr.uu' 'others/ovlmgr.uu.orig'
fi
echo shar: Extracting \"'others/ovlmgr.uu'\" \(5497 characters\)
sed "s/^X//" >'others/ovlmgr.uu' <<'END_OF_FILE'
Xbegin 660 ovlmgr.obj
XM@ P "F]V;&UG<BYA<VUDEA4   904U!314<&3U9,5$),!$-/1$6%F H     
XM "P  @$!+I@*       0  ,! 4F8!P!HHPX$ 0%"C$8 !R0D24Y43D\ "20D
XM3U9,0D%310 *)"1-4$=33D]63  +)"1-4$=33D)!4T4 !B0D34%)3@ &)"1#
XM1U-.  8D)$-/5DP T9 0   #"20D3U9,24Y)5' & '&(!   H@'1H!(  @  
XM                  !,H"@  P            #_______________\     
XM                0: &  ,D!   +YP( ,0   ,#)@1HHF8  Z8% 0    )-
XM6@$    "   !     @   0    (   $    "   !     @   0    (   $ 
XM   "   !     @   0    (   $    "   !     @   0    (   $    "
XM  !YH  $ \(%  T*3F]T(&5N;W5G:"!M96UO<GD@=&\@<G5N('1H:7,@<')O
XM9W)A;2X@5&EM92!T;R!G;R!T;R!T:&4@<W1O<F4N#0H') T*66]U<B!D;V<@
XM96%T<R!A;&P@>6]U<B!R96UA:6YI;F<@;65M;W)Y(2!9;W4@9&EE+@T*!R0-
XM"E1H92!.>6UP:"!S=&]L92!Y;W5R("Y%6$4@9FEL92$@66]U(&1I92X-"@<D
XM#0HD4%-14E9751X&C-@%$  NHP  CAX  +[__T:#/ !U^H/&!+  M#V+ULTA
XM<PBP!;H  .D  "ZC  "X   NHP  NP )M$C-(7,#Z0  CL"T2+O__\TAM$C-
XM(7,#Z0  +J,  +@  ([8BPX  "Z)#@  BPX  "Z)#@  *]ES ^D  %.T2<TA
XM<P/I   S[3/_,_;H   NH0  +@,&  ".P#/ )J,  ":C   FHP  )J(  "ZA
XM  #1X-'@T>#1X-'@+HL6   +TG0.T>K1ZM'JT>I"+2   \(FHP  +BL&   N
XM@SX   !T"SO'<@>+^":+-@  )HDN   N RX  (O5BLZ*\C+M,M+1XM'1L "T
XM0LTA+J$  $@N.P8  '0#Z0  5BZA  ".P"Z+-@  +@,V   FQ@8    FB38"
XM ";'!@0    FB3X(  /X+HD^  ".QB;&!@   ";'!@(    FHP0 7ELFB1X(
XM "ZC   NQP8     +L<&     +@  "ZC  "+^"['!?__@\<&+J$  "Z)!2Z)
XM/@  CL FQ@8   =&.]YS"+ %N@  Z0  N   CMBT-:   "ZB  #-(2Z)'@  
XM+HP&  "T-; AS2$NB1X  "Z,!@  M"4NH   C,N.V[H  ,TAM"6P(8S+CMNZ
XM  #-(2Z+#@  N   CL",R([8NP  O@  OP  )HH$,N0#!@  B04FBP<K!@  
XMB44"@\<$@\,"1N+B!Q]=7UY:65M8Z@     NB1X  "Z,!@  6P=05B:+1P$N
XMHP  ,N0FB@>#PP,NBS8  "Z,1 (NB5P$B]C1X]'C@<,  "Z.!RZ+1P(NC$0&
XM+H,&   &+HLV  !&+HDV   FB38  "Z+-@  ='LFB38  ";V!@   71W)@,&
XM   NHP  +HL>   NC@8  %Y8G2[_'@  G"Z,!@  +HD>   NBQX  "Z.1_HN
XM_W?\+O]W_E$NBPX  $$NB0X  ":)#@  +HL.  !T+2:)#@  )O8&   !="@N
XM@RX   8NBQX  "Z.!@  6<]&+HDV  #I  #H  #KA$$NB0X  .O+Z   Z]-0
XM4U%25E=5'@;H   F]@8   1U"B:A  #H  #K!)#H   FHP  !0$ )IS& L2^
XM  ,#'@#$P@ ! 2P Q-T  P,_!H3@  ,#2 [$Y  # Q  R.<F @+$ZP # Q@ 
XMA/<  P,2"(4)  ,#$@C%#0 # Q( R1 F!P?%%B8&!L4;  ,#%@#%'R8'!\4D
XM  ,#% "%*P # Q((A34  P,2"(4^  ,#) [%0@ # Q( Q4<  P/ !<5/  ("
XM! #%4P " @8 Q5<  @(( ,5;! ("Q5\  P.J!<5N  ,#J 7%A  " @P Q8D 
XM P.N!<6.  ,#P 7%G  " @P Q:$  @(* ,6F  ,#J@7%O@ # Q0 Q<0  P/ 
XM!87)  ,#_P;%S@ # Q@ Q=4  P,2 ,7:  ,#% #%^  # QH QA8  P,< ,8;
XM! ,#QB(  P," ,8G  ,#)@3&*P # R0$QCD  P,2 ,9!  ,#) 3&2 0" L93
XM  ,#PP6&5@ # T@.REDF 0'&8"8! <9D  ,#P@7&:P # P@ QG   P,* ,9[
XM  ,## #&@  # PX QH8  P/"!<:-  ,#HPC&F@ # _@*QJ$  P,6 ,JD)@0$
XMQJTF! 3&L"8# \:S  ,#) #&O  # Q( QL4  P,8 ,[=)@4%QN0  P,@ ,;I
XM  ,#(@#&]0 # P0 QP(  P,D!,<4  ,#) #')  # R0$QRH$ P/', 0# \<U
XM  ("! #'.@ # P( QT$  @(& ,=&! ("QTX  @(( ,=2  ,#!@#'5P # R  
XMQUP  P,B ,=D  ,#! #':@ # R( QV\  P,@ ,=T  ,#) 3'A@0# \>,! ,#
XMQY$  @($ ,>6  ,# @#'G0 " @8 QZ($ @+'J@ # R0$Q[   P,@ ,>U  ,#
XM(@#'O0 # P( A\   P, "8?#  ,#E@G'RP # P( A]   P.6"8?>  ,#P@K'
XMXP0" L?J  ("# "'[0 # Z$,A_,  P,Q#,?W  (" @!6H/\# [X)CM@FBQ8 
XM (K.BO(R[3+2T>+1T;1"L  NBQX  ,TA<B@STB:+#@  T>'1X='AT>&T/\TA
XM<A/H   ')H .   !'UU?7EI96UC#L 6Z  #I  "+#@8 C-@#!@@ )J,  (OX
XM+BL^  "+-A@ XRJMB]BM+@,&   #QX[ )HL'+@,&   N.P8  '()+CL&  !S
XM @/')HD'XM;#4U%25E=5'BZ.'@  ,\"+T(OHB]@NBPX  /:'   !="GVAP  
XM G4B+HLV   NBSX  "NW   ;OP  .]=R!G4*.\9S!HO&B]>+ZX/#$.++"^UU
XM"+ %N@  Z0  T>W1[='MT>V,V /%'UU?7EI96\,&+HX&   NBPX  #/;)H"G
XM  #[@\,0XO4NBQX  (/K!NL,D"Z.'X .   $@^L&+H,__W7O!\. _$MT%8#\
XM3'0%+O\N  !86%BP +H  .D   K =>Q04U%25E=5!AXNH0  ZQV.V"X[!@  
XM<A'V!@   70*C@8& ": )@  _J$"  O ==\NH0  +@,&  ".P";'!@@  @ F
XMQP8"    )L8&    +HL6   NCAX  +0EL"'-(2Z+%@  +HX>  "T)2Z@  #-
XM(2Z.!@  +HL>  "#PP*T2LTAB^S_=A:='P==7UY:65M8S2%04U%25E=5!AZ+
XM[)R/1A;H  "T-; AS2$NB1X  "Z,!@  M"6P(8S+CMNZ  #-(;0U+J   ,TA
XM+HD>   NC 8  +0E+J   (S+CMNZ  #-(1\'75]>6EE;6,\&M$HNC@8  +O_
XM_\TAM$HNC@8  %/-(2ZA   N P8  ([ 6"XK!@  )J,(  ?#)HL>   NH0  
XMZU>0CM@[V',4B],F Q8  (/" 3O"<S_H  #K#) #!@@ .]AS,>@  (S8.]AR
XM*(O3)@,6  "#P@$#!@@ .\)R%HS8B\LKR'0#Z   )HL.  "#P0'K+9"A @ +
XMP'0"ZZ2P!;H  .D  (O(@\$!Z   .]%S#.@  .@  #D." !R].L!D : #@  
XM 8S8 \&.P*$( "O!/0$ <C6)#@@ )J,( *$" ":C @",!@( )HP>!  FQ@8 
XM   >)J$"  O = :.V(P&! ",P([8Z   'P>,!@8 C-C#!HS8 \&.P*$( "O!
XMB0X( ":C" "A @ FHP( C 8" ":,'@0 Q@8    F@ X   $FH0( "\!T"!Z.
XMV(P&!  ?Z   C,".V >,!@8 C-C#+J$  #/2ZQB0CMCV!@   74+.0X( '(%
XMBQ8( ,.A @ +P'7EP_8&   != P&C@8& ": )@  _@?K$)".V( F  #^H0  
XMCMCK 9 &@"8  /ZA!  +P'0RCL F]@:WG ,"Q 4  @(* ,0:  ,#$ #$)0 "
XM @P A#8  P,."L0\! ("Q$L  P,_!H1.  ,#2 [$7  " @@ Q&,  P,8 ,1R
XM  ,#'@#$?@ # QX Q(,  P,8 ,2*  ,#&@#$H  # Q( Q*T  P,4 ,2Q! ("
XMQ+@$ @+$P 0# \3%  ,# @#$R0 " @0 Q,T  @(& ,3K  ,#" :$[@ # T@.
XMQ0@  P,2 ,4-  ,#% #%% 0" L4?  ,#) 3%+ 0" L5'  ,## #%3P # VT&
XMA5(  P-(#L5C  ,#' #%;  # Q( Q7X$ @+%B@ # Q( Q8\  P,4 ,6J  ,#
XM# #%KP # PX Q;H  P,( ,6_  ,#"@#%Q0 # \(%Q<P  P,2 ,71  ,#% "%
XM^P # P,,Q@8  P,, ,8+  ,##@#&%@ # _@*QAX  P/"!<8E  ,#" #&*@ #
XM PH QC   P/"!<8W  ,#HPC&2P # Q( QE<  P,2 ,9>  ,#$@#&8P # Q0 
XMQFL  P,4 ,9V  (" @#&>@ # QP QHH  @(, (:4  ,#@@V&H@ # X(-QJ\ 
XM @(, (;%  ,##PW&R@ " @P QMX  P,(!H;A  ,#2 Z&Z0 # UT-AO   P-4
XM"H;S  ,#F V'1@ # Z<-AY$  P.G#<>A  ,#' #'TP0" L?>! ("Q^(  @("
XM &6@[@ #N0T   %U*"8#!@@ C-H[T'4=H0@ )@$&" "A @ FHP( "\!T!H[8
XMC 8$ (S CMBA @ +P'0PCL F]@8   %U)HS8 P8( (S".\)U&B:A"  !!@@ 
XM)J$" *,"  O = >.P":,'@0 @"8  /X'PU&,R([8N@  +HL>  "Y' "T/\TA
XM<@8[P74"6<.P!;H  .L!D%",R([8M G-(2Z+%@  @_K_= \>+HX>  "T)2Z@
XM  #-(1\NBQ8  (/Z_W0-'BZ.'@  M"6P(<TA'RZA   ]__]T!H[ M$G-(2Z+
XM'@  @_O_= 2T/LTA6+1,S2%FG$< Q'$  P.F!<1V  ,#$ #$B@ # S\&Q)L 
XM P,( ,2F  ,#"@#$K  # \(%Q+0  P,, ,2_  ,##@#$R@ # Q( Q-H  P,0
X' *^* @  = ,#
X 
Xend
END_OF_FILE
if test 5497 -ne `wc -c <'others/ovlmgr.uu'`; then
    echo shar: \"'others/ovlmgr.uu'\" unpacked with wrong size!
fi
# end of 'others/ovlmgr.uu'
echo shar: End of archive 28 \(of 30\).
cp /dev/null ark28isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
