Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!wuarchive!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i022:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7v
Message-ID: <5236@tekred.CNA.TEK.COM>
Date: 24 Feb 90 01:05:43 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2310
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 22
Archive-name: NetHack3/Patch7v
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 22 (of 30)."
# Contents:  include/mondata.h patch7.18
# Wrapped by billr@saab on Wed Feb 21 10:04:43 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/mondata.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'include/mondata.h'\" to \"'include/mondata.h.orig'\"
  mv -f 'include/mondata.h' 'include/mondata.h.orig'
fi
echo shar: Extracting \"'include/mondata.h'\" \(4813 characters\)
sed "s/^X//" >'include/mondata.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)mondata.h	3.0	89/11/21
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef MONDATA_H
X#define MONDATA_H
X
X# ifndef STUPID_CPP	/* otherwise these macros are functions in mondata.c */
X
X#define verysmall(ptr)		((ptr)->msize < MZ_SMALL)
X#define bigmonst(ptr)		((ptr)->msize >= MZ_LARGE)
X
X#define is_flyer(ptr)		(((ptr)->mflags1 & M1_FLY) != 0L)
X#define is_floater(ptr) 	((ptr)->mlet == S_EYE)
X#define is_swimmer(ptr) 	(((ptr)->mflags1 & M1_SWIM) != 0L)
X#define passes_walls(ptr)	(((ptr)->mflags1 & M1_WALLWALK) != 0L)
X#define amorphous(ptr)		(((ptr)->mflags1 & M1_AMORPHOUS) != 0L)
X#define noncorporeal(ptr)	((ptr)->mlet == S_GHOST)
X#define tunnels(ptr)		(((ptr)->mflags1 & M1_TUNNEL) != 0L)
X#define needspick(ptr)		(((ptr)->mflags1 & M1_NEEDPICK) != 0L)
X#define hides_under(ptr)	(((ptr)->mflags1 & M1_CONCEAL) != 0L)
X#define is_hider(ptr)		(((ptr)->mflags1 & M1_HIDE) != 0L)
X#define haseyes(ptr)		(((ptr)->mflags1 & M1_NOEYES) == 0L)
X#define nohands(ptr)		(((ptr)->mflags1 & M1_NOHANDS) != 0L)
X#define nolimbs(ptr)		(((ptr)->mflags1 & M1_NOLIMBS) == M1_NOLIMBS)
X#  ifdef POLYSELF
X#define polyok(ptr)		(((ptr)->mflags1 & M1_NOPOLY) == 0L)
X#  endif
X#define is_whirly(ptr)		((ptr)->mlet == S_VORTEX || (ptr) == &mons[PM_AIR_ELEMENTAL])
X#define humanoid(ptr)		(((ptr)->mflags1 & M1_HUMANOID) != 0L)
X#define is_animal(ptr)		(((ptr)->mflags1 & M1_ANIMAL) != 0L)
X#define slithy(ptr)		(((ptr)->mflags1 & M1_SLITHY) != 0L)
X#define thick_skinned(ptr)	(((ptr)->mflags1 & M1_THICK_HIDE) != 0L)
X#define resists_fire(ptr)	(((ptr)->mflags1 & M1_FIRE_RES) != 0L)
X#define resists_cold(ptr)	(((ptr)->mflags1 & M1_COLD_RES) != 0L)
X#define resists_disint(ptr)	((ptr) == &mons[PM_BLACK_DRAGON] || (ptr) == &mons[PM_BABY_BLACK_DRAGON])
X#define resists_elec(ptr)	(((ptr)->mflags1 & M1_ELEC_RES) != 0L)
X#define resists_acid(ptr)	(((ptr)->mflags1 & M1_ACID) != 0L)
X#define acidic(ptr)		(((ptr)->mflags1 & M1_ACID) != 0L)
X#define resists_poison(ptr)	(((ptr)->mflags1 & (M1_POIS | M1_POIS_RES)) != 0L)
X#define poisonous(ptr)		(((ptr)->mflags1 & M1_POIS) != 0L)
X#define regenerates(ptr)	(((ptr)->mflags1 & M1_REGEN) != 0L)
X#define perceives(ptr)		(((ptr)->mflags1 & M1_SEE_INVIS) != 0L)
X#define can_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT) != 0L)
X#define control_teleport(ptr)	(((ptr)->mflags1 & M1_TPORT_CONTROL) != 0L)
X#define is_armed(ptr)		attacktype(ptr, AT_WEAP)
X#define likes_gold(ptr) 	(((ptr)->mflags1 & M1_GREEDY) != 0L)
X#define likes_gems(ptr) 	(((ptr)->mflags1 & M1_JEWELS) != 0L)
X#define likes_objs(ptr) 	(((ptr)->mflags1 & M1_COLLECT) != 0L || \
X					is_armed(ptr))
X#define likes_magic(ptr)	(((ptr)->mflags1 & M1_MAGIC) != 0L)
X#define is_undead(ptr)		(((ptr)->mflags2 & M2_UNDEAD) != 0L)
X#define resists_sleep(ptr)	(((ptr)->mflags1 & M1_SLEE_RES) != 0L || is_undead(ptr))
X#define is_were(ptr)		(((ptr)->mflags2 & M2_WERE) != 0L)
X#define is_elf(ptr)		(((ptr)->mflags2 & M2_ELF) != 0L)
X#define is_dwarf(ptr)		(((ptr)->mflags2 & M2_DWARF) != 0L)
X#define is_giant(ptr)		(((ptr)->mflags2 & M2_GIANT) != 0L)
X#  ifdef GOLEMS
X#define is_golem(ptr)		((ptr)->mlet == S_GOLEM)
X#  endif
X#define is_domestic(ptr)	(((ptr)->mflags2 & M2_DOMESTIC) != 0L)
X#define is_orc(ptr)		(((ptr)->mflags2 & M2_ORC) != 0L)
X#define is_human(ptr)		(((ptr)->mflags2 & M2_HUMAN) != 0L)
X#define is_demon(ptr)		(((ptr)->mflags2 & M2_DEMON) != 0L)
X#define is_mercenary(ptr)	(((ptr)->mflags2 & M2_MERC) != 0L)
X#define is_wanderer(ptr)	(((ptr)->mflags2 & M2_WANDER) != 0L)
X#define always_hostile(ptr)	(((ptr)->mflags2 & M2_HOSTILE) != 0L)
X#define always_peaceful(ptr)	(((ptr)->mflags2 & M2_PEACEFUL) != 0L)
X#define extra_nasty(ptr)	(((ptr)->mflags2 & M2_NASTY) != 0L)
X#define strongmonst(ptr)	(((ptr)->mflags2 & M2_STRONG) != 0L)
X#  ifdef POLYSELF
X#define can_breathe(ptr)	attacktype(ptr, AT_BREA)
X#define cantwield(ptr)		(nohands(ptr) || verysmall(ptr))
X#define cantweararm(ptr)	(breakarm(ptr) || sliparm(ptr))
X#  endif /* POLYSELF */
X#define carnivorous(ptr)	(((ptr)->mflags2 & M2_CARNIVORE) != 0L)
X#define herbivorous(ptr)	(((ptr)->mflags2 & M2_HERBIVORE) != 0L)
X#define metallivorous(ptr)	(((ptr)->mflags2 & M2_METALLIVORE) != 0L)
X#define lays_eggs(ptr)		(((ptr)->mflags2 & M2_EGGS) != 0L)
X#define throws_rocks(ptr)	(((ptr)->mflags2 & M2_ROCKTHROW) != 0L)
X#define type_is_pname(ptr)	(((ptr)->mflags2 & M2_PNAME) != 0L)
X#define is_lord(ptr)		(((ptr)->mflags2 & M2_LORD) != 0L)
X#define is_prince(ptr)		(((ptr)->mflags2 & M2_PRINCE) != 0L)
X#  ifdef INFERNO
X#define is_ndemon(ptr)		(is_demon(ptr) && \
X			(((ptr)->mflags2 & (M2_LORD | M2_PRINCE)) == 0L))
X#  else
X#define is_ndemon(ptr)		(ptr == &mons[PM_DEMON])
X#  endif
X#define is_dlord(ptr)		(is_demon(ptr) && is_lord(ptr))
X#define is_dprince(ptr)		(is_demon(ptr) && is_prince(ptr))
X
X# endif /* STUPID_CPP */
X
X#endif /* MONDATA_H */
END_OF_FILE
if test 4813 -ne `wc -c <'include/mondata.h'`; then
    echo shar: \"'include/mondata.h'\" unpacked with wrong size!
fi
# end of 'include/mondata.h'
if test -f 'patch7.18' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.18'\" to \"'patch7.18.orig'\"
  mv -f 'patch7.18' 'patch7.18.orig'
fi
echo shar: Extracting \"'patch7.18'\" \(52317 characters\)
sed "s/^X//" >'patch7.18' <<'END_OF_FILE'
X*** src/Old/mthrowu.c	Mon Feb 19 20:37:10 1990
X--- src/mthrowu.c	Wed Feb 14 18:38:25 1990
X***************
X*** 1,18 ****
X! /*	SCCS Id: @(#)mthrowu.c	3.0	88/04/13
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X  
X! static int movedist();
X  
X  #define URETREATING(x,y) (movedist(u.ux,u.uy,x,y) > movedist(u.ux0,u.uy0,x,y))
X  
X! boolean lined_up();
X  
X  schar	tbx = 0, tby = 0;	/* used for direction of throw, buzz, etc. */
X  
X! const char *breathwep[] = {	"fragments",
X  				"fire",
X  				"sleep gas",
X  				"frost",
X--- 1,26 ----
X! /*	SCCS Id: @(#)mthrowu.c	3.0	89/11/22
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X  
X! OSTATIC int FDECL(movedist,(int,int,int,int));
X! static void FDECL(drop_throw,(struct obj *,BOOLEAN_P,int,int));
X! OSTATIC void FDECL(m_throw,(int,int,int,int,int,struct obj *));
X  
X  #define URETREATING(x,y) (movedist(u.ux,u.uy,x,y) > movedist(u.ux0,u.uy0,x,y))
X  
X! boolean FDECL(lined_up, (struct monst *));
X  
X+ #ifndef OVLB
X+ 
X+ OSTATIC const char *breathwep[];
X+ 
X+ #else /* OVLB */
X+ 
X  schar	tbx = 0, tby = 0;	/* used for direction of throw, buzz, etc. */
X  
X! XSTATIC const char *breathwep[] = {	"fragments",
X  				"fire",
X  				"sleep gas",
X  				"frost",
X***************
X*** 26,43 ****
X  thitu(tlev, dam, obj, name)	/* u is hit by sth, but not a monster */
X  	register int tlev, dam;
X  	struct obj *obj;
X! 	register char *name;
X  {
X! 	char *oname = an(name);
X! 	boolean acidic = (obj && obj->otyp == ACID_VENOM);
X  
X  	if(u.uac + tlev <= rnd(20)) {
X  		if(Blind || !flags.verbose) pline("It misses.");
X! 		else You("are almost hit by %s!", oname);
X  		return(0);
X  	} else {
X  		if(Blind || !flags.verbose) You("are hit!");
X! 		else You("are hit by %s!", oname);
X  #ifdef POLYSELF
X  		if (obj && obj->otyp == SILVER_ARROW && (u.ulycn != -1 ||
X  				is_demon(uasmon) || u.usym == S_VAMPIRE ||
X--- 34,51 ----
X  thitu(tlev, dam, obj, name)	/* u is hit by sth, but not a monster */
X  	register int tlev, dam;
X  	struct obj *obj;
X! 	register const char *name;
X  {
X! 	const char *onm = an(name);
X! 	boolean is_acid = (obj && obj->otyp == ACID_VENOM);
X  
X  	if(u.uac + tlev <= rnd(20)) {
X  		if(Blind || !flags.verbose) pline("It misses.");
X! 		else You("are almost hit by %s!", onm);
X  		return(0);
X  	} else {
X  		if(Blind || !flags.verbose) You("are hit!");
X! 		else You("are hit by %s!", onm);
X  #ifdef POLYSELF
X  		if (obj && obj->otyp == SILVER_ARROW && (u.ulycn != -1 ||
X  				is_demon(uasmon) || u.usym == S_VAMPIRE ||
X***************
X*** 46,57 ****
X  			pline("The %sarrow sears your flesh!",
X  				Blind ? "" : "silver ");
X  		}
X! 		if (acidic && resists_acid(uasmon))
X  			pline("It doesn't seem to hurt you.");
X  		else {
X  #endif
X! 			if (acidic) pline("It burns!");
X! 			losehp(dam, name);
X  #ifdef POLYSELF
X  		}
X  #endif
X--- 54,65 ----
X  			pline("The %sarrow sears your flesh!",
X  				Blind ? "" : "silver ");
X  		}
X! 		if (is_acid && resists_acid(uasmon))
X  			pline("It doesn't seem to hurt you.");
X  		else {
X  #endif
X! 			if (is_acid) pline("It burns!");
X! 			losehp(dam, name, KILLED_BY_AN);
X  #ifdef POLYSELF
X  		}
X  #endif
X***************
X*** 85,91 ****
X  	} else free((genericptr_t)obj);
X  }
X  
X! static void
X  m_throw(x, y, dx, dy, range, obj)
X  	register int x,y,dx,dy,range;		/* direction and range */
X  	register struct obj *obj;
X--- 93,99 ----
X  	} else free((genericptr_t)obj);
X  }
X  
X! XSTATIC void
X  m_throw(x, y, dx, dy, range, obj)
X  	register int x,y,dx,dy,range;		/* direction and range */
X  	register struct obj *obj;
X***************
X*** 174,180 ****
X  			}
X  			mtmp->mhp -= damage;
X  			if(mtmp->mhp < 1) {
X! 			    pline("%s is killed!", vis ? Monnam(mtmp) : "It");
X  			    mondied(mtmp);
X  			}
X  
X--- 182,191 ----
X  			}
X  			mtmp->mhp -= damage;
X  			if(mtmp->mhp < 1) {
X! 			    pline("%s is %s!", vis ? Monnam(mtmp) : "It",
X! 			       (is_demon(mtmp->data) || 
X! 					is_undead(mtmp->data) || !vis) ?
X! 				 "destroyed" : "killed");
X  			    mondied(mtmp);
X  			}
X  
X***************
X*** 214,220 ****
X  			if (hitu && obj->opoisoned)
X  			    /* it's safe to call xname twice because it's the
X  			       same object both times... */
X! 			    poisoned(xname(singleobj), A_STR, xname(singleobj));
X  			if(hitu && (obj->otyp == CREAM_PIE ||
X  				     obj->otyp == BLINDING_VENOM)) {
X  			    blindinc = rnd(25);
X--- 225,231 ----
X  			if (hitu && obj->opoisoned)
X  			    /* it's safe to call xname twice because it's the
X  			       same object both times... */
X! 			    poisoned(xname(singleobj), A_STR, xname(singleobj), 10);
X  			if(hitu && (obj->otyp == CREAM_PIE ||
X  				     obj->otyp == BLINDING_VENOM)) {
X  			    blindinc = rnd(25);
X***************
X*** 228,233 ****
X--- 239,245 ----
X  					makeplural(body_part(EYE)));
X  			    }
X  			}
X+ 			stop_occupation();
X  			if (hitu || !range) {
X  			    drop_throw(singleobj, hitu, u.ux, u.uy);
X  			    break;
X***************
X*** 285,290 ****
X--- 297,305 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /* Always returns 0??? -SAC */
X  int
X  thrwmu(mtmp)	/* monster throws item at you */
X***************
X*** 308,314 ****
X  		   !rn2(BOLT_LIM-movedist(x,mtmp->mux,y,mtmp->muy)))
X  		{
X  		    int savequan = otmp->quan;
X! 		    char *verb = "throws";
X  
X  		    if (otmp->otyp == ARROW
X  #ifdef TOLKIEN
X--- 323,329 ----
X  		   !rn2(BOLT_LIM-movedist(x,mtmp->mux,y,mtmp->muy)))
X  		{
X  		    int savequan = otmp->quan;
X! 		    const char *verb = "throws";
X  
X  		    if (otmp->otyp == ARROW
X  #ifdef TOLKIEN
X***************
X*** 331,339 ****
X  	return 0;
X  }
X  
X  int
X! spitmu(mtmp)			/* monster spits substance at you */
X  register struct monst *mtmp;
X  {
X  	register struct obj *otmp;
X  
X--- 346,358 ----
X  	return 0;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X! spitmu(mtmp, mattk)		/* monster spits substance at you */
X  register struct monst *mtmp;
X+ register struct attack *mattk;
X  {
X  	register struct obj *otmp;
X  
X***************
X*** 344,355 ****
X  	    return 0;
X  	}
X  	if(lined_up(mtmp)) {
X! 		otmp = mksobj(mtmp->data==&mons[PM_COBRA] ?
X! 			BLINDING_VENOM : ACID_VENOM, FALSE);
X! 		/* really incorrect; should check the attack type; this might
X! 		 * fail if someone introduces another monster with a venom
X! 		 * attack...
X! 		 */
X  		if(!rn2(BOLT_LIM-movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy))) {
X  		    if (canseemon(mtmp))
X  			pline("%s spits venom!", Monnam(mtmp));
X--- 363,380 ----
X  	    return 0;
X  	}
X  	if(lined_up(mtmp)) {
X! 		switch (mattk->adtyp) {
X! 		    case AD_BLND:
X! 		    case AD_DRST:
X! 			otmp = mksobj(BLINDING_VENOM, FALSE);
X! 			break;
X! 		    default:
X! 			impossible("bad attack type in spitmu");
X! 				/* fall through */
X! 		    case AD_ACID:
X! 			otmp = mksobj(ACID_VENOM, FALSE);
X! 			break;
X! 		}
X  		if(!rn2(BOLT_LIM-movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy))) {
X  		    if (canseemon(mtmp))
X  			pline("%s spits venom!", Monnam(mtmp));
X***************
X*** 362,367 ****
X--- 387,395 ----
X  	return 0;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  int
X  breamu(mtmp, mattk)			/* monster breathes at you (ranged) */
X  	register struct monst *mtmp;
X***************
X*** 412,421 ****
X  		x = bx; y = by;
X  		while(x != ax || y != ay) {
X  
X! 		    if (!ACCESSIBLE(levl[x][y].typ) ||
X! 			  (IS_DOOR(levl[x][y].typ) && 
X! 				(levl[x][y].doormask & (D_LOCKED | D_CLOSED)))) 
X! 			return FALSE;
X  		    x += sgn(tbx), y += sgn(tby);
X  		}
X  		return TRUE;
X--- 440,446 ----
X  		x = bx; y = by;
X  		while(x != ax || y != ay) {
X  
X! 		    if(!accessible(x, y)) return FALSE;
X  		    x += sgn(tbx), y += sgn(tby);
X  		}
X  		return TRUE;
X***************
X*** 430,435 ****
X--- 455,463 ----
X  	return(linedup(mtmp->mux,mtmp->muy,mtmp->mx,mtmp->my));
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  /* Check if a monster is carrying a particular item.
X   */
X  struct obj *
X***************
X*** 445,452 ****
X  	return((struct obj *) 0);
X  }
X  
X! static int
X  movedist(x0, x1, y0, y1)
X  {
X  	register int absdx, absdy;
X  
X--- 473,484 ----
X  	return((struct obj *) 0);
X  }
X  
X! #endif /* OVL0 */
X! #ifdef OVL1
X! 
X! XSTATIC int
X  movedist(x0, x1, y0, y1)
X+ int x0, x1, y0, y1;
X  {
X  	register int absdx, absdy;
X  
X***************
X*** 455,457 ****
X--- 487,491 ----
X  
X  	return (max(absdx,absdy));
X  }
X+ 
X+ #endif /* OVL1 */
X*** src/Old/music.c	Mon Feb 19 20:37:41 1990
X--- src/music.c	Mon Feb 19 10:18:01 1990
X***************
X*** 30,36 ****
X--- 30,46 ----
X  #include "hack.h"
X  
X  #ifdef MUSIC
X+ #include <ctype.h>
X  
X+ static void FDECL(awaken_monsters,(int));
X+ static void FDECL(put_monsters_to_sleep,(int));
X+ static void FDECL(charm_snakes,(int));
X+ static void FDECL(calm_nymphs,(int));
X+ static void NDECL(awaken_soldiers);
X+ static void FDECL(charm_monsters,(int));
X+ static void FDECL(do_earthquake,(int));
X+ static int FDECL(do_improvisation,(struct obj *));
X+ 
X  /*
X   * Wake every monster in range...
X   */
X***************
X*** 48,54 ****
X  			  mtmp->mflee = 1;
X  		} else if (dist(mtmp->mx, mtmp->my) < distance) {
X  			mtmp->msleep = 0;
X! 			mtmp->mfroz = 0;
X  		}
X  		mtmp = mtmp->nmon;
X  	}
X--- 58,65 ----
X  			  mtmp->mflee = 1;
X  		} else if (dist(mtmp->mx, mtmp->my) < distance) {
X  			mtmp->msleep = 0;
X! 			mtmp->mcanmove = 1;
X! 			mtmp->mfrozen = 0;
X  		}
X  		mtmp = mtmp->nmon;
X  	}
X***************
X*** 66,73 ****
X  
X  	while(mtmp) {
X  		  if (dist(mtmp->mx, mtmp->my) < distance)
X! 		    if(!mtmp->mfroz && !resist(mtmp, WAND_SYM, 0, NOTELL))
X! 		      mtmp->mfroz = 1;
X  		mtmp = mtmp->nmon;
X  	}
X  }
X--- 77,84 ----
X  
X  	while(mtmp) {
X  		  if (dist(mtmp->mx, mtmp->my) < distance)
X! 		    if(mtmp->mcanmove && !resist(mtmp, WAND_SYM, 0, NOTELL))
X! 		      mtmp->mcanmove = mtmp->mfrozen = 0;
X  		mtmp = mtmp->nmon;
X  	}
X  }
X***************
X*** 122,129 ****
X  	register struct monst *mtmp = fmon;
X  
X  	while(mtmp) {
X! 		if (IS_SOLDIER(mtmp->data))
X! 			mtmp->mpeaceful = mtmp->msleep = mtmp->mfroz = 0;
X  		mtmp = mtmp->nmon;
X  	}
X  #endif /* ARMY /**/
X--- 133,142 ----
X  	register struct monst *mtmp = fmon;
X  
X  	while(mtmp) {
X! 		if (IS_SOLDIER(mtmp->data)) {
X! 			mtmp->mpeaceful = mtmp->msleep = 0;
X! 			mtmp->mcanmove = 1;
X! 		}
X  		mtmp = mtmp->nmon;
X  	}
X  #endif /* ARMY /**/
X***************
X*** 219,225 ****
X  					int saved_conf = u.umconf;
X  
X  					if(!cansee(x,y))
X! 					    pline("It has died!");
X  					else {
X  					    You("destroy %s!",
X  					    mtmp->mtame ?
X--- 232,238 ----
X  					int saved_conf = u.umconf;
X  
X  					if(!cansee(x,y))
X! 					    pline("It is destroyed!");
X  					else {
X  					    You("destroy %s!",
X  					    mtmp->mtame ?
X***************
X*** 242,248 ****
X  					    You("fall into a chasm!");
X  					    u.utrap = rn1(6,2);
X  					    u.utraptype = TT_PIT;
X! 					    losehp(rnd(6),"fall into a chasm");
X  					    selftouch("Falling, you");
X  				    }
X  			    } else
X--- 255,262 ----
X  					    You("fall into a chasm!");
X  					    u.utrap = rn1(6,2);
X  					    u.utraptype = TT_PIT;
X! 					    losehp(rnd(6),"fell into a chasm",
X! 						NO_KILLER_PREFIX);
X  					    selftouch("Falling, you");
X  				    }
X  			    } else
X***************
X*** 302,308 ****
X  			} else {
X  				if (!u.dx && !u.dy && !u.dz) {
X  					if((damage = zapyourself(instr)))
X! 					  losehp(damage,"self-inflicted injury");
X  					makeknown(instr->otyp);
X  					return(2);
X  				}
X--- 316,324 ----
X  			} else {
X  				if (!u.dx && !u.dy && !u.dz) {
X  					if((damage = zapyourself(instr)))
X! 					  losehp(damage,
X! 		self_pronoun("using a magical horn on %sself", "him"),
X! 					  NO_KILLER_PREFIX);
X  					makeknown(instr->otyp);
X  					return(2);
X  				}
X***************
X*** 368,374 ****
X  	pline("What tune are you playing? [what 5 notes] ");
X  	getlin(buf);
X  	for(s=buf;*s;s++)
X! 	    *s = (*s >='a' && *s<='z') ? 'A' + *s - 'a' : *s;
X  	You("extract a strange sound from the %s!",xname(instr));
X  	/* Check if there was the Stronghold drawbridge near
X  	 * and if the tune conforms to what we're waiting for.
X--- 384,390 ----
X  	pline("What tune are you playing? [what 5 notes] ");
X  	getlin(buf);
X  	for(s=buf;*s;s++)
X! 		if (islower(*s)) *s=toupper(*s);
X  	You("extract a strange sound from the %s!",xname(instr));
X  	/* Check if there was the Stronghold drawbridge near
X  	 * and if the tune conforms to what we're waiting for.
X*** src/Old/o_init.c	Mon Feb 19 20:38:04 1990
X--- src/o_init.c	Thu Feb  1 18:45:03 1990
X***************
X*** 4,9 ****
X--- 4,13 ----
X  
X  #include	"hack.h"		/* for typedefs */
X  
X+ static void NDECL(setgemprobs);
X+ static void FDECL(shuffle,(int,int,BOOLEAN_P));
X+ static boolean FDECL(interesting_to_discover,(int));
X+ 
X  /* note that NROFOBJECTS is the number of legal objects, which does not count
X   * the strange object and null object that take up positions 0 and NROFOBJECTS+1
X   * in the objects array
X***************
X*** 70,76 ****
X  	register boolean domaterial;
X  {
X  	register int i, j;
X! 	char *desc;
X  #ifdef TEXTCOLOR
X  	int color;
X  #endif /* TEXTCOLOR */
X--- 74,80 ----
X  	register boolean domaterial;
X  {
X  	register int i, j;
X! 	const char *desc;
X  #ifdef TEXTCOLOR
X  	int color;
X  #endif /* TEXTCOLOR */
X***************
X*** 120,126 ****
X  		bases[i] = 0;
X  	for(i = 0; i != TOTAL_OBJS; i++)
X  		disco[i] = i;
X! 
X  	/* init base; if probs given check that they add up to 1000,
X  	   otherwise compute probs; shuffle descriptions */
X  	end = TOTAL_OBJS;
X--- 124,132 ----
X  		bases[i] = 0;
X  	for(i = 0; i != TOTAL_OBJS; i++)
X  		disco[i] = i;
X! #ifdef NAMED_ITEMS
X! 	init_exists();	/* zero out the "artifact exists" list */
X! #endif
X  	/* init base; if probs given check that they add up to 1000,
X  	   otherwise compute probs; shuffle descriptions */
X  	end = TOTAL_OBJS;
X***************
X*** 238,244 ****
X  #ifdef MACOS
X  	for (i = 0 ; i < TOTAL_OBJS; i++) {
X  		descr[i] = objects[i].oc_descr;
X! 		objects[i].oc_descr = (char *)switches[i];
X  	}
X  #endif
X  	bwrite(fd, (genericptr_t)objects, sizeof(struct objclass) * TOTAL_OBJS);
X--- 244,250 ----
X  #ifdef MACOS
X  	for (i = 0 ; i < TOTAL_OBJS; i++) {
X  		descr[i] = objects[i].oc_descr;
X! 		objects[i].oc_descr = (const char *)switches[i];
X  	}
X  #endif
X  	bwrite(fd, (genericptr_t)objects, sizeof(struct objclass) * TOTAL_OBJS);
X***************
X*** 295,301 ****
X  		objects[i].oc_descr = d[switches[i]].descr;
X  	}
X  #else
X! # if !defined(MSDOS) && !defined(M_XENIX)
X  	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X  # else
X  	differ = (long)&objects[0] - (long)then;
X--- 301,307 ----
X  		objects[i].oc_descr = d[switches[i]].descr;
X  	}
X  #else
X! # if !defined(MSDOS) && !defined(M_XENIX) && !defined(HPUX)
X  	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X  # else
X  	differ = (long)&objects[0] - (long)then;
X***************
X*** 308,314 ****
X  			objects[i].oc_name += differ;
X  # else
X  			objects[i].oc_name =
X! 			    (char *)((long)(objects[i].oc_name) + differ);
X  # endif
X  		}
X  		if (objects[i].oc_descr) {
X--- 314,320 ----
X  			objects[i].oc_name += differ;
X  # else
X  			objects[i].oc_name =
X! 			    (const char *)((long)(objects[i].oc_name) + differ);
X  # endif
X  		}
X  		if (objects[i].oc_descr) {
X***************
X*** 316,322 ****
X  			objects[i].oc_descr += differ;
X  # else
X  			objects[i].oc_descr =
X! 			    (char *)((long)(objects[i].oc_descr) + differ);
X  # endif
X  		}
X  #endif /* MACOS */
X--- 322,328 ----
X  			objects[i].oc_descr += differ;
X  # else
X  			objects[i].oc_descr =
X! 			    (const char *)((long)(objects[i].oc_descr) + differ);
X  # endif
X  		}
X  #endif /* MACOS */
X*** src/Old/objects.c	Mon Feb 19 20:38:30 1990
X--- src/objects.c	Wed Jan 17 23:02:38 1990
X***************
X*** 6,12 ****
X   * function declarations for all of nethack
X   */
X  #define EXTERN_H
X- /* #define MAKEDEFS_C	1	/* for Mac compilers with 32K data limit */
X  #include "config.h"
X  #include "obj.h"
X  #include "objclass.h"
X--- 6,11 ----
X***************
X*** 376,382 ****
X  #else
X  	{ "pick-axe", NULL, NULL, 1,0,1,1,METAL, 0, TOOL_SYM, 20,
X  						0, 10, 50, 6, 3, 0, C(HI_METAL)},
X! 	{ "unicorn horn", NULL, NULL, 1,0,1,0,0, 0, TOOL_SYM, 0,
X  						0, 4, 100, 12, 12, 0, C(WHITE)},
X  	{ "blinding venom", "splash of venom", NULL,
X  		0,1,0,0,0, 0, VENOM_SYM, 500, 0, 0, 0, 0, 0, 0, C(HI_ORGANIC)},
X--- 375,381 ----
X  #else
X  	{ "pick-axe", NULL, NULL, 1,0,1,1,METAL, 0, TOOL_SYM, 20,
X  						0, 10, 50, 6, 3, 0, C(HI_METAL)},
X! 	{ "unicorn horn", NULL, NULL, 1,0,1,1,0, 0, TOOL_SYM, 0,
X  						0, 4, 100, 12, 12, 0, C(WHITE)},
X  	{ "blinding venom", "splash of venom", NULL,
X  		0,1,0,0,0, 0, VENOM_SYM, 500, 0, 0, 0, 0, 0, 0, C(HI_ORGANIC)},
X***************
X*** 437,443 ****
X  ARMOR("plate mail", NULL,
X  			1, 1, 0, 44, 5, 9, 600, 3, 2, METAL, HI_METAL),
X  ARMOR("crystal plate mail", NULL,
X! 			1, 1, 0, 10, 5, 9, 820, 3, 2, 0, WHITE|BRIGHT),
X  #ifdef SHIRT
X  ARMOR("bronze plate mail", NULL,
X  			1, 1, 0, 25, 5, 9, 400, 4, 0, COPPER, HI_COPPER),
X--- 436,442 ----
X  ARMOR("plate mail", NULL,
X  			1, 1, 0, 44, 5, 9, 600, 3, 2, METAL, HI_METAL),
X  ARMOR("crystal plate mail", NULL,
X! 			1, 1, 0, 10, 5, 9, 820, 3, 2, GLASS, WHITE|BRIGHT),
X  #ifdef SHIRT
X  ARMOR("bronze plate mail", NULL,
X  			1, 1, 0, 25, 5, 9, 400, 4, 0, COPPER, HI_COPPER),
X*** src/Old/objnam.c	Mon Feb 19 20:40:32 1990
X--- src/objnam.c	Sat Feb 17 21:15:08 1990
X***************
X*** 9,26 ****
X  #define	PREFIX	50
X  #define SCHAR_MAX 127
X  
X  /*	We want the player to be able to learn what key goes in what lock.  */
X! const char *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X! 			    "octagonal", "hexagonal", "cylindrical",
X! 			    "irregular", "conical", "wedge-shaped" },
X! 	   *lockstr[N_LOX] = { "round", "square", "triangular", "oval",
X! 			    "octagonal", "hexagonal", "wide",
X! 			    "notched", "large round", "large square" };
X  
X  static int FDECL(rnd_class, (int,int));
X  
X! static int
X! named_key(s) register char *s; {
X  	char tc[BUFSZ];
X  	register int i;
X  
X--- 9,51 ----
X  #define	PREFIX	50
X  #define SCHAR_MAX 127
X  
X+ #ifndef OVLB
X+ 
X+ OSTATIC const char *keystr[N_LOX], *lockstr[N_LOX];
X+ 
X+ #else /* OVLB */
X  /*	We want the player to be able to learn what key goes in what lock.  */
X! XSTATIC const char *keystr[N_LOX] = { "round", "square", "triangular", "oval",
X! 			              "octagonal", "hexagonal", "cylindrical",
X! 			              "irregular", "conical", "wedge-shaped" },
X! 	          *lockstr[N_LOX] = { "round", "square", "triangular", "oval",
X! 			              "octagonal", "hexagonal", "wide",
X! 			              "notched", "large round", "large square" };
X! #endif /* OVLB */
X  
X  static int FDECL(rnd_class, (int,int));
X+ OSTATIC int FDECL(named_key,(const char *));
X+ OSTATIC int FDECL(named_box,(const char *));
X+ OSTATIC char *FDECL(strprepend,(char *,const char *));
X+ static char *FDECL(sitoa,(int));
X  
X! static struct Jitem {
X! 	int item;
X! 	const char *name;
X! } Japanese_items[] = {
X! 	{ SHORT_SWORD, "wakizashi" },
X! 	{ BROADSWORD, "ninja-to" },
X! 	{ GLAIVE, "naginata" },
X! 	/* { BOW, "yumi" }, */
X! 	{ LOCK_PICK, "osaku" },
X! 	{0, "" }
X! };
X! OSTATIC const char *FDECL(Japanese_item_name,(int));
X! 
X! #ifdef OVL1
X! 
X! XSTATIC int
X! named_key(s) register const char *s; {
X  	char tc[BUFSZ];
X  	register int i;
X  
X***************
X*** 32,40 ****
X  	return(0);
X  }
X  
X! static int
X  named_box(s)
X! register char *s;
X  {
X  	char tc[BUFSZ];
X  	register int i;
X--- 57,65 ----
X  	return(0);
X  }
X  
X! XSTATIC int
X  named_box(s)
X! register const char *s;
X  {
X  	char tc[BUFSZ];
X  	register int i;
X***************
X*** 47,54 ****
X  	return(0);
X  }
X  
X! static char *
X! strprepend(s,pref) register char *s, *pref; {
X  register int i = strlen(pref);
X  	if(i > PREFIX) {
X  		pline("WARNING: prefix too short.");
X--- 72,81 ----
X  	return(0);
X  }
X  
X! XSTATIC char *
X! strprepend(s,pref)
X! register char *s;
X! register const char *pref; {
X  register int i = strlen(pref);
X  	if(i > PREFIX) {
X  		pline("WARNING: prefix too short.");
X***************
X*** 70,75 ****
X--- 97,105 ----
X  	return(buf);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  char *
X  typename(otyp)
X  register int otyp;
X***************
X*** 80,89 ****
X  static char buf[BUFSZ];
X  #endif
X  register struct objclass *ocl = &objects[otyp];
X! register char *actualn = ocl->oc_name;
X! register char *dn = ocl->oc_descr;
X! register char *un = ocl->oc_uname;
X  register int nn = ocl->oc_name_known;
X  	switch(ocl->oc_olet) {
X  	case POTION_SYM:
X  		Strcpy(buf, "potion");
X--- 110,122 ----
X  static char buf[BUFSZ];
X  #endif
X  register struct objclass *ocl = &objects[otyp];
X! register const char *actualn = ocl->oc_name;
X! register const char *dn = ocl->oc_descr;
X! register const char *un = ocl->oc_uname;
X  register int nn = ocl->oc_name_known;
X+ 
X+ 	if (pl_character[0] == 'S' && Japanese_item_name(otyp))
X+ 		actualn = Japanese_item_name(otyp);
X  	switch(ocl->oc_olet) {
X  	case POTION_SYM:
X  		Strcpy(buf, "potion");
X***************
X*** 165,170 ****
X--- 198,206 ----
X  	return str;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  char *
X  xname(obj)
X  register struct obj *obj;
X***************
X*** 176,184 ****
X  #endif
X  register char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
X  register int nn = objects[obj->otyp].oc_name_known;
X! register char *actualn = objects[obj->otyp].oc_name;
X! register char *dn = objects[obj->otyp].oc_descr;
X! register char *un = objects[obj->otyp].oc_uname;
X  
X  	buf[0] = 0;
X  	if(!Blind) obj->dknown=1;
X--- 212,223 ----
X  #endif
X  register char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
X  register int nn = objects[obj->otyp].oc_name_known;
X! register const char *actualn = objects[obj->otyp].oc_name;
X! register const char *dn = objects[obj->otyp].oc_descr;
X! register const char *un = objects[obj->otyp].oc_uname;
X! 
X! 	if (pl_character[0] == 'S' && Japanese_item_name((int)obj->otyp))
X! 		actualn = Japanese_item_name((int)obj->otyp);
X  
X  	buf[0] = 0;
X  	if(!Blind) obj->dknown=1;
X***************
X*** 202,212 ****
X  			Strcpy(buf, "poisoned ");
X  	    case VENOM_SYM:
X  	    case TOOL_SYM:
X! 		if(nn)	Strcat(buf, actualn);
X! 		else	Strcat(buf, dn);
X  		if(obj->otyp == FIGURINE)
X! 			Sprintf(eos(buf), " of %s",
X! 				an(mons[obj->corpsenm].mname));
X  		break;
X  	    case ARMOR_SYM:
X  		if(obj->otyp==DRAGON_SCALE_MAIL) {
X--- 241,263 ----
X  			Strcpy(buf, "poisoned ");
X  	    case VENOM_SYM:
X  	    case TOOL_SYM:
X! 		if(un) {
X! 			/* un must come first here.  If it does not, they could
X! 			 * tell objects apart by seeing which ones refuse to
X! 			 * accept names.
X! 			 */
X! 			Sprintf(buf, "%s called %s",
X! 				nn ? actualn : dn, un);
X! 		} else if(nn)
X! 			Strcat(buf, actualn);
X! 		else
X! 			Strcat(buf, dn);
X! 		/* If we use an() here we'd have to remember never to use */
X! 		/* it whenever calling doname() or xname(). */
X  		if(obj->otyp == FIGURINE)
X! 		    Sprintf(eos(buf), " of a%s %s",
X! 			index(vowels,*(mons[obj->corpsenm].mname)) ? "n" : "",
X! 			mons[obj->corpsenm].mname);
X  		break;
X  	    case ARMOR_SYM:
X  		if(obj->otyp==DRAGON_SCALE_MAIL) {
X***************
X*** 266,272 ****
X  		break;
X  	    case ROCK_SYM:
X  		if(obj->otyp == STATUE)
X! 		    Sprintf(buf, "%s of %s", actualn, an(mons[obj->corpsenm].mname));
X  		else Strcpy(buf, actualn);
X  		break;
X  	    case BALL_SYM:
X--- 317,325 ----
X  		break;
X  	    case ROCK_SYM:
X  		if(obj->otyp == STATUE)
X! 		    Sprintf(buf, "%s of a%s %s", actualn,
X! 			index(vowels,*(mons[obj->corpsenm].mname)) ? "n" : "",
X! 			mons[obj->corpsenm].mname);
X  		else Strcpy(buf, actualn);
X  		break;
X  	    case BALL_SYM:
X***************
X*** 351,358 ****
X  			break;
X  		}
X  		if(!nn) {
X! 			char *rock=(obj->otyp==LOADSTONE||obj->otyp==LUCKSTONE)
X! 				? "stone" : "gem";
X  			if(un)	Sprintf(buf,"%s called %s", rock, un);
X  			else	Sprintf(buf, "%s %s", dn, rock);
X  			break;
X--- 404,411 ----
X  			break;
X  		}
X  		if(!nn) {
X! 			const char *rock=
X! 	(obj->otyp==LOADSTONE||obj->otyp==LUCKSTONE) ? "stone" : "gem";
X  			if(un)	Sprintf(buf,"%s called %s", rock, un);
X  			else	Sprintf(buf, "%s %s", dn, rock);
X  			break;
X***************
X*** 374,379 ****
X--- 427,435 ----
X  	return(buf);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  char *
X  doname(obj)
X  register struct obj *obj;
X***************
X*** 544,549 ****
X--- 600,608 ----
X  	return(bp);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  /*
X   * Used if only one of a collection of objects is named (e.g. in eat.c).
X   */
X***************
X*** 572,578 ****
X  
X  char *
X  an(str)
X! register char *str;
X  {
X  	static char buf[BUFSZ];
X  
X--- 631,637 ----
X  
X  char *
X  an(str)
X! register const char *str;
X  {
X  	static char buf[BUFSZ];
X  
X***************
X*** 592,608 ****
X  
X  char *
X  An(str)
X! register char *str;
X  {
X! 	str = an(str);
X! 	if (*str == 'a') *str = 'A';
X! 	return str;
X  }
X  
X  char *
X! aobjnam(otmp,verb) register struct obj *otmp; register char *verb; {
X! register char *bp = xname(otmp);
X! char prefix[PREFIX];
X  	if(otmp->quan != 1) {
X  		Sprintf(prefix, "%u ", otmp->quan);
X  		bp = strprepend(bp, prefix);
X--- 651,673 ----
X  
X  char *
X  An(str)
X! const char *str;
X  {
X! 	register char *tmp;
X! 
X! 	tmp = an(str);
X! 	if (*tmp == 'a') *tmp = 'A';
X! 	return tmp;
X  }
X  
X  char *
X! aobjnam(otmp,verb)
X! register struct obj *otmp;
X! register const char *verb;
X! {
X! 	register char *bp = xname(otmp);
X! 	char prefix[PREFIX];
X! 
X  	if(otmp->quan != 1) {
X  		Sprintf(prefix, "%u ", otmp->quan);
X  		bp = strprepend(bp, prefix);
X***************
X*** 656,661 ****
X--- 721,729 ----
X  		if('A' <= *p && *p <= 'Z') *p += 'a'-'A';
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /* Plural routine; chiefly used for user-defined fruits.  We have to try to
X   * account for everything reasonable the player has; something unreasonable
X   * can still break the code.  However, it's still a lot more accurate than
X***************
X*** 666,682 ****
X   */
X  char *
X  makeplural(oldstr)
X! char *oldstr;
X  {
X  	register char *spot;
X  	static char str[BUFSZ];
X! 	static char *excess;
X  	int len;
X  
X  	while (*oldstr==' ') oldstr++;
X  	if (!oldstr || !*oldstr) {
X  		impossible("plural of null?");
X! 		return("s");
X  	}
X  	Strcpy(str, oldstr);
X  
X--- 734,751 ----
X   */
X  char *
X  makeplural(oldstr)
X! const char *oldstr;
X  {
X  	register char *spot;
X  	static char str[BUFSZ];
X! 	const char *excess;
X  	int len;
X  
X  	while (*oldstr==' ') oldstr++;
X  	if (!oldstr || !*oldstr) {
X  		impossible("plural of null?");
X! 		Strcpy(str, "s");
X! 		return str;
X  	}
X  	Strcpy(str, oldstr);
X  
X***************
X*** 853,863 ****
X  	return str;
X  }
X  
X! /* wishable subranges of objects */
X! static const struct o_range {
X! 	char *name, osym;
X  	int  f_o_range, l_o_range;
X! } o_ranges[] = {
X  	{ "bag",	TOOL_SYM,   SACK,	    BAG_OF_TRICKS },
X  	{ "gloves",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X  	{ "gauntlets",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X--- 922,942 ----
X  	return str;
X  }
X  
X! #endif /* OVL0 */
X! 
X! struct o_range {
X! 	const char *name, osym;
X  	int  f_o_range, l_o_range;
X! };
X! 
X! #ifndef OVLB
X! 
X! OSTATIC const struct o_range o_ranges[];
X! 
X! #else /* OVLB */
X! 
X! /* wishable subranges of objects */
X! XSTATIC const struct o_range o_ranges[] = {
X  	{ "bag",	TOOL_SYM,   SACK,	    BAG_OF_TRICKS },
X  	{ "gloves",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X  	{ "gauntlets",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X***************
X*** 873,891 ****
X  	{ "sword",	WEAPON_SYM, SHORT_SWORD,    KATANA }
X  };
X  
X- 
X  /*
X   * Singularize a string the user typed in; this helps reduce the complexity
X!  * of readobjnam.
X   */
X  
X! static
X! void
X! singularize(bp)
X! char *bp;
X  {
X! 	char *p;
X  
X  	/* find "cloves of garlic", "worthless pieces of blue glass" */
X  	for(p = bp; *p; p++) 
X  	    if(!strncmp(p, "s of ", 5)){
X--- 952,978 ----
X  	{ "sword",	WEAPON_SYM, SHORT_SWORD,    KATANA }
X  };
X  
X  /*
X   * Singularize a string the user typed in; this helps reduce the complexity
X!  * of readobjnam, and is also used in pager.c to singularize the string
X!  * for which help is sought.
X   */
X  
X! char *
X! makesingular(oldstr)
X! const char *oldstr;
X  {
X! 	char *p, *bp;
X! 	static char str[BUFSZ];
X! 
X! 	if (!oldstr || !*oldstr) {
X! 		impossible("singular of null?");
X! 		str[0] = 0; return str;
X! 	}
X! 	Strcpy(str, oldstr);
X! 	bp = str;
X  
X+ 	while (*bp == ' ') bp++;
X  	/* find "cloves of garlic", "worthless pieces of blue glass" */
X  	for(p = bp; *p; p++) 
X  	    if(!strncmp(p, "s of ", 5)){
X***************
X*** 892,898 ****
X  		/* but don't singularize "gauntlets" */
X  		if(strncmp(p-8, "gauntlet", 8))
X  			while(*p = p[1]) p++;
X! 		return;
X  	    }
X  
X  	/* remove -s or -es (boxes) or -ies (rubies) */
X--- 979,985 ----
X  		/* but don't singularize "gauntlets" */
X  		if(strncmp(p-8, "gauntlet", 8))
X  			while(*p = p[1]) p++;
X! 		return bp;
X  	    }
X  
X  	/* remove -s or -es (boxes) or -ies (rubies) */
X***************
X*** 904,942 ****
X  				   !strcmp(p-4, "pies"))
X  					goto mins;
X  				Strcpy(p-3, "y");
X! 				return;
X  			}
X  
X  			/* note: cloves / knives from clove / knife */
X  			if(!strcmp(p-6, "knives")) {
X  				Strcpy(p-3, "fe");
X! 				return;
X  			}
X  
X  			if(!strcmp(p-6, "staves")) {
X  				Strcpy(p-3, "ff");
X! 				return;
X  			}
X  
X  			/* note: nurses, axes but boxes */
X  			if(!strcmp(p-5, "boxes")) {
X  				p[-2] = 0;
X! 				return;
X  			}
X  		}
X  		/* but don't singularize boots or gloves */
X  		else if(!strcmp(p-5, "boots") ||
X  			!strcmp(p-6, "gloves"))
X! 				return;
X  	mins:
X  		p[-1] = 0;
X  	} else {
X  		if(!strcmp(p-5, "teeth")) {
X  			Strcpy(p-5, "tooth");
X! 			return;
X  		}
X  		/* here we cannot find the plural suffix */
X  	}
X  }
X  
X  /* Return something wished for.  If not an object, return &zeroobj; if an error
X--- 991,1030 ----
X  				   !strcmp(p-4, "pies"))
X  					goto mins;
X  				Strcpy(p-3, "y");
X! 				return bp;
X  			}
X  
X  			/* note: cloves / knives from clove / knife */
X  			if(!strcmp(p-6, "knives")) {
X  				Strcpy(p-3, "fe");
X! 				return bp;
X  			}
X  
X  			if(!strcmp(p-6, "staves")) {
X  				Strcpy(p-3, "ff");
X! 				return bp;
X  			}
X  
X  			/* note: nurses, axes but boxes */
X  			if(!strcmp(p-5, "boxes")) {
X  				p[-2] = 0;
X! 				return bp;
X  			}
X  		}
X  		/* but don't singularize boots or gloves */
X  		else if(!strcmp(p-5, "boots") ||
X  			!strcmp(p-6, "gloves"))
X! 				return bp;
X  	mins:
X  		p[-1] = 0;
X  	} else {
X  		if(!strcmp(p-5, "teeth")) {
X  			Strcpy(p-5, "tooth");
X! 			return bp;
X  		}
X  		/* here we cannot find the plural suffix */
X  	}
X+ 	return bp;
X  }
X  
X  /* Return something wished for.  If not an object, return &zeroobj; if an error
X***************
X*** 964,970 ****
X  	 */
X  #endif
X  	char let;
X! 	char *un, *dn, *an;
X  	char *name=0;
X  #ifdef WIZARD
X  	int fake=0;
X--- 1052,1058 ----
X  	 */
X  #endif
X  	char let;
X! 	char *un, *dn, *actualn;
X  	char *name=0;
X  #ifdef WIZARD
X  	int fake=0;
X***************
X*** 978,984 ****
X  #define SPINACH 2
X  	contents = UNDEFINED;
X  	let = 0;
X! 	an = dn = un = 0;
X  	
X  	for(;;) {
X  		if (!bp) goto any;
X--- 1066,1072 ----
X  #define SPINACH 2
X  	contents = UNDEFINED;
X  	let = 0;
X! 	actualn = dn = un = 0;
X  	
X  	for(;;) {
X  		if (!bp) goto any;
X***************
X*** 1135,1142 ****
X  	}
X  
X  	/* first change to singular if necessary */
X! 	if(cnt != 1)
X! 		singularize(bp);
X  
X  sing:
X  	/* Maybe we need a special strcmp() which ignores capitalization and
X--- 1223,1230 ----
X  	}
X  
X  	/* first change to singular if necessary */
X! 	if(cnt != 1 && *bp)
X! 		Strcpy(bp, makesingular(bp));
X  
X  sing:
X  	/* Maybe we need a special strcmp() which ignores capitalization and
X***************
X*** 1174,1185 ****
X  	   !strcmp(bp, "leather armor") || /* Prevent falling to 'armor'. */
X  	   !strcmp(bp, "studded leather armor")) {
X  		let = ARMOR_SYM;
X! 		an = bp;
X  		goto srch;
X  	}
X  	if(!strcmp(bp, "food ration")){
X  		let = FOOD_SYM;
X! 		an = bp;
X  		goto srch;
X  	}
X  	if((iskey = named_key(bp)) > 0) {
X--- 1262,1273 ----
X  	   !strcmp(bp, "leather armor") || /* Prevent falling to 'armor'. */
X  	   !strcmp(bp, "studded leather armor")) {
X  		let = ARMOR_SYM;
X! 		actualn = bp;
X  		goto srch;
X  	}
X  	if(!strcmp(bp, "food ration")){
X  		let = FOOD_SYM;
X! 		actualn = bp;
X  		goto srch;
X  	}
X  	if((iskey = named_key(bp)) > 0) {
X***************
X*** 1213,1222 ****
X  			let = wrpsym[i];
X  			if(let != AMULET_SYM) {
X  			    bp += j;
X! 			    if(!strncmp(bp, " of ", 4)) an = bp+4;
X  			    /* else if(*bp) ?? */
X  			} else
X! 			    an = bp;
X  			goto srch;
X  		}
X  		if(!strcmp(p-j, wrp[i])){
X--- 1301,1310 ----
X  			let = wrpsym[i];
X  			if(let != AMULET_SYM) {
X  			    bp += j;
X! 			    if(!strncmp(bp, " of ", 4)) actualn = bp+4;
X  			    /* else if(*bp) ?? */
X  			} else
X! 			    actualn = bp;
X  			goto srch;
X  		}
X  		if(!strcmp(p-j, wrp[i])){
X***************
X*** 1231,1237 ****
X  	if(!strcmp(p-6, " stone")){
X  		p[-6] = 0;
X  		let = GEM_SYM;
X! 		dn = an = bp;
X  		goto srch;
X  	}
X  	if(!strcmp(p-10, "gold piece") || !strcmp(p-7, "zorkmid") ||
X--- 1319,1325 ----
X  	if(!strcmp(p-6, " stone")){
X  		p[-6] = 0;
X  		let = GEM_SYM;
X! 		dn = actualn = bp;
X  		goto srch;
X  	}
X  	if(!strcmp(p-10, "gold piece") || !strcmp(p-7, "zorkmid") ||
X***************
X*** 1278,1292 ****
X  		goto typfnd;
X  	    }
X  
X! 	an = bp;
X! 	if (!dn) dn = an; /* ex. "black cap" */
X  srch:
X  	i = 1;
X  	if(let) i = bases[letindex(let)];
X  	while(i <= NROFOBJECTS && (!let || objects[i].oc_olet == let)){
X! 		register char *zn;
X  
X! 		if(an && (zn = objects[i].oc_name) && !strcmp(an, zn)) {
X  			typ = i;
X  			goto typfnd;
X  		}
X--- 1366,1380 ----
X  		goto typfnd;
X  	    }
X  
X! 	actualn = bp;
X! 	if (!dn) dn = actualn; /* ex. "black cap" */
X  srch:
X  	i = 1;
X  	if(let) i = bases[letindex(let)];
X  	while(i <= NROFOBJECTS && (!let || objects[i].oc_olet == let)){
X! 		register const char *zn;
X  
X! 		if(actualn && (zn = objects[i].oc_name) && !strcmp(actualn, zn)) {
X  			typ = i;
X  			goto typfnd;
X  		}
X***************
X*** 1300,1305 ****
X--- 1388,1403 ----
X  		}
X  		i++;
X  	}
X+ 	if (actualn) {
X+ 		struct Jitem *j = Japanese_items;
X+ 		while(j->item) {
X+ 			if (actualn && !strcmp(actualn, j->name)) {
X+ 				typ = j->item;
X+ 				goto typfnd;
X+ 			}
X+ 			j++;
X+ 		}
X+ 	}
X  #ifdef TUTTI_FRUTTI
X  	for(f=ffruit; f; f = f->nextf) {
X  		char *f1 = f->fname, *f2 = makeplural(f->fname);
X***************
X*** 1351,1357 ****
X  		wizard ||
X  #endif
X  		 (cnt <= 20 &&
X! 		  (let == WEAPON_SYM && typ <= SHURIKEN) || (typ == ROCK))))
X  			otmp->quan = cnt;
X  
X  	if (spesgn == 0) spe = otmp->spe;
X--- 1449,1455 ----
X  		wizard ||
X  #endif
X  		 (cnt <= 20 &&
X! 		  ((let == WEAPON_SYM && typ <= SHURIKEN) || (typ == ROCK)))))
X  			otmp->quan = cnt;
X  
X  	if (spesgn == 0) spe = otmp->spe;
X***************
X*** 1362,1368 ****
X  			typ == UNICORN_HORN ||
X  			(let==RING_SYM && objects[typ].oc_charged)) {
X  		if(spe > rnd(5) && spe > otmp->spe) spe = 0;
X! 		if(spe > 2 && u.uluck < 0) spesgn = -1;
X  	} else {
X  		if (let == WAND_SYM) {
X  			if (spe > 1 && spesgn == -1) spe = 1;
X--- 1460,1466 ----
X  			typ == UNICORN_HORN ||
X  			(let==RING_SYM && objects[typ].oc_charged)) {
X  		if(spe > rnd(5) && spe > otmp->spe) spe = 0;
X! 		if(spe > 2 && Luck < 0) spesgn = -1;
X  	} else {
X  		if (let == WAND_SYM) {
X  			if (spe > 1 && spesgn == -1) spe = 1;
X***************
X*** 1461,1482 ****
X  		curse(otmp);
X  	} else if (uncursed) {
X  		otmp->blessed = 0;
X! 		otmp->cursed = (u.uluck < 0);
X  	} else if (blessed) {
X! 		otmp->blessed = (u.uluck >= 0);
X! 		otmp->cursed = (u.uluck < 0);
X  	} else if (spesgn < 0) {
X  		curse(otmp);
X  	}
X  
X  	/* prevent wishing abuse */
X! 	if (otmp->otyp == WAN_WISHING || otmp->otyp == MAGIC_LAMP)
X  		otmp->recharged = 1;
X  
X  	/* set poisoned */
X  	if (ispoisoned) {
X  	    if (let == WEAPON_SYM && typ <= SHURIKEN)
X! 		otmp->opoisoned = (u.uluck >= 0);
X  #ifdef WIZARD
X  	    else if (Is_box(otmp))
X  		otmp->otrapped = 1;
X--- 1559,1596 ----
X  		curse(otmp);
X  	} else if (uncursed) {
X  		otmp->blessed = 0;
X! 		otmp->cursed = (Luck < 0
X! #ifdef WIZARD
X! 					 && !wizard
X! #endif
X! 							);
X  	} else if (blessed) {
X! 		otmp->blessed = (Luck >= 0
X! #ifdef WIZARD
X! 					 || wizard
X! #endif
X! 							);
X! 		otmp->cursed = (Luck < 0
X! #ifdef WIZARD
X! 					 && !wizard
X! #endif
X! 							);
X  	} else if (spesgn < 0) {
X  		curse(otmp);
X  	}
X  
X  	/* prevent wishing abuse */
X! 	if (
X! #ifdef WIZARD
X! 		!wizard &&
X! #endif
X! 		(otmp->otyp == WAN_WISHING || otmp->otyp == MAGIC_LAMP))
X  		otmp->recharged = 1;
X  
X  	/* set poisoned */
X  	if (ispoisoned) {
X  	    if (let == WEAPON_SYM && typ <= SHURIKEN)
X! 		otmp->opoisoned = (Luck >= 0);
X  #ifdef WIZARD
X  	    else if (Is_box(otmp))
X  		otmp->otrapped = 1;
X***************
X*** 1514,1516 ****
X--- 1628,1645 ----
X  			return i;
X  	return 0;
X  }
X+ 
X+ XSTATIC const char *
X+ Japanese_item_name(i)
X+ int i;
X+ {
X+ 	struct Jitem *j = Japanese_items;
X+ 
X+ 	while(j->item) {
X+ 		if (i == j->item)
X+ 			return j->name;
X+ 		j++;
X+ 	}
X+ 	return (const char *)0;
X+ }
X+ #endif /* OVLB */
X*** src/Old/options.c	Mon Feb 19 20:41:34 1990
X--- src/options.c	Thu Feb  1 20:16:30 1990
X***************
X*** 1,12 ****
X  /*	SCCS Id: @(#)options.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X- 
X  #include "hack.h"
X  static boolean set_order;
X  
X! static void FDECL(nmcpy, (char *, char *, int));
X! static int FDECL(next_opt, (char *));
X  
X  void
X  initoptions()
X--- 1,11 ----
X  /*	SCCS Id: @(#)options.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  #include "hack.h"
X  static boolean set_order;
X  
X! static void FDECL(nmcpy, (char *, const char *, int));
X! void FDECL(escapes,(const char *, char *));
X  
X  void
X  initoptions()
X***************
X*** 16,23 ****
X  	flags.time = flags.nonews = flags.notombstone = flags.end_own =
X  	flags.standout = flags.nonull = flags.ignintr = FALSE;
X  	flags.no_rest_on_space = flags.invlet_constant = TRUE;
X! 	flags.end_top = 5;
X! 	flags.end_around = 4;
X  	flags.female = FALSE;			/* players are usually male */
X  	flags.sortpack = TRUE;
X  	flags.soundok = TRUE;
X--- 15,22 ----
X  	flags.time = flags.nonews = flags.notombstone = flags.end_own =
X  	flags.standout = flags.nonull = flags.ignintr = FALSE;
X  	flags.no_rest_on_space = flags.invlet_constant = TRUE;
X! 	flags.end_top = 3;
X! 	flags.end_around = 2;
X  	flags.female = FALSE;			/* players are usually male */
X  	flags.sortpack = TRUE;
X  	flags.soundok = TRUE;
X***************
X*** 25,34 ****
X  	flags.confirm = TRUE;
X  	flags.safe_dog = TRUE;
X  	flags.silent = 	flags.pickup = TRUE;
X- #ifdef MACOS
X- 	flags.standout = TRUE;
X- 	flags.end_around = 3;	/* Mac display routines don't scroll */
X- #endif
X  #ifdef TUTTI_FRUTTI
X  	nmcpy(pl_fruit, objects[SLIME_MOLD].oc_name, PL_FSIZ);
X  #endif
X--- 24,29 ----
X***************
X*** 49,54 ****
X--- 44,56 ----
X  #endif
X  	read_config_file();
X  #endif /* MSDOS */
X+ #ifdef MACOS
X+ 	flags.standout = TRUE;
X+ 	flags.end_around = 2;	/* Mac display routines don't scroll */
X+ 	flags.end_top = 4;
X+ 	read_config_file();
X+ 	
X+ #endif
X  	if(opts = getenv("NETHACKOPTIONS"))
X  		parseoptions(opts,TRUE);
X  #ifdef TUTTI_FRUTTI
X***************
X*** 60,79 ****
X  }
X  
X  static void
X! nmcpy(dest, source, maxlen)
X! 	char	*dest, *source;
X  	int	maxlen;
X  {
X- 	char	*cs, *cd;
X  	int	count;
X  
X- 	cd = dest;
X- 	cs = source;
X  	for(count = 1; count < maxlen; count++) {
X! 		if(*cs == ',' || *cs == '\0') break; /*exit on \0 terminator*/
X! 		*cd++ = *cs++;
X  	}
X! 	*cd = 0;
X  }
X  
X  /*
X--- 62,79 ----
X  }
X  
X  static void
X! nmcpy(dest, src, maxlen)
X! 	char	*dest;
X! 	const char *src;
X  	int	maxlen;
X  {
X  	int	count;
X  
X  	for(count = 1; count < maxlen; count++) {
X! 		if(*src == ',' || *src == '\0') break; /*exit on \0 terminator*/
X! 		*dest++ = *src++;
X  	}
X! 	*dest = 0;
X  }
X  
X  /*
X***************
X*** 85,91 ****
X   */
X  void
X  escapes(cp, tp)
X! char	*cp, *tp;
X  {
X      while (*cp)
X      {
X--- 85,92 ----
X   */
X  void
X  escapes(cp, tp)
X! const char	*cp;
X! char *tp;
X  {
X      while (*cp)
X      {
X***************
X*** 97,103 ****
X  	}
X  	if (*cp == '\\' && index("0123456789xXoO", cp[1]))
X  	{
X! 	    char *dp, *hex = "00112233445566778899aAbBcCdDeEfF";
X  	    int dcount = 0;
X  
X  	    cp++;
X--- 98,104 ----
X  	}
X  	if (*cp == '\\' && index("0123456789xXoO", cp[1]))
X  	{
X! 	    const char *dp, *hex = "00112233445566778899aAbBcCdDeEfF";
X  	    int dcount = 0;
X  
X  	    cp++;
X***************
X*** 157,162 ****
X--- 158,164 ----
X  register char *opts;
X  boolean from_env;
X  {
X+ #ifndef MACOS
X  	register char *op;
X  	unsigned num;
X  	boolean negated;
X***************
X*** 476,481 ****
X--- 478,486 ----
X  		return;
X  	}
X  #ifdef MSDOS
X+ # ifdef AMIGA_WBENCH
X+ 	if(ami_wbench_badopt(opts))
X+ # endif
X  	Printf("Bad syntax in OPTIONS in %s: %s.", configfile, opts);
X  #else
X  	Printf("Bad syntax in NETHACKOPTIONS: %s.", opts);
X***************
X*** 485,495 ****
X--- 490,797 ----
X  	);
X  #endif
X  	getret();
X+ #endif /* MACOS */
X  }
X  
X  int
X  doset()
X  {
X+ #ifdef MACOS
X+ #define	OPTIONS			"Nethack prefs"
X+ #define OK_BUTTON 1
X+ #define SAVE_BUTTON 2
X+ #define CANCEL_BUTTON 3
X+ #define MIN_CHECKBOX 4
X+ #define EXPLORE_BOX 4
X+ #define FEM_BOX 5
X+ #define NEWS_BOX 6
X+ #define FIXINV_BOX 7
X+ #define TOMB_BOX 8
X+ #define TIME_BOX 9
X+ #define VERBOSE_BOX 10
X+ #define SILENT_BOX 11
X+ #define AUTOZOOM_BOX 12
X+ #define INVERSE_BOX 13
X+ #define SORT_BOX 14
X+ #define COLOR_BOX 15
X+ #define PICKUP_BOX 16
X+ #define CONFIRM_BOX 17
X+ #define SAFE_BOX 18
X+ #define REST_SPACE_BOX 19
X+ #define MAX_CHECKBOX 19
X+ #define PLAYER_NAME 20
X+ #define CAT_NAME 21
X+ #define DOG_NAME 22
X+ #define FRUIT_NAME 23
X+ #define PACKORDER 24
X+ #define END_TOP 26
X+ #define END_AROUND 27
X+ #define FRUIT_TEXT 35
X+ #define PACK_TEXT 34
X+ #define ITEMTEXT(item,text) {GetDItem(optionDlg,item,&type,&ItemHndl,&box); \
X+ 					         (void)CtoPstr(text); \
X+ 					         SetIText(ItemHndl,text);\
X+ 					         (void)PtoCstr(text);}
X+ #define HIDEITEM(item) {GetDItem(optionDlg,item,&type,&ItemHndl,&box); \
X+ 				        HideControl(ItemHndl);\
X+ 				        SetDItem(optionDlg,item,type+128,ItemHndl,&box);}
X+ #define HIDETEXT(item) {GetDItem(optionDlg,item,&type,&ItemHndl,&box);\
X+ 						SetDItem(optionDlg,item,128+statText,ItemHndl,&box);\
X+ 						SetIText(ItemHndl,"\0");}
X+ #define SHOWITEM(item) {GetDItem(optionDlg,item,&type,&ItemHndl,&box);\
X+ 						SetDItem(optionDlg,item,type-128,ItemHndl,&box);\
X+ 						ShowControl(ItemHndl);}
X+ #define GETTEXT(item,maxsize) {GetDItem(optionDlg,item,&type,&ItemHndl,&box);\
X+ 					GetIText (ItemHndl, &tmp_name);\
X+ 					tmp_name[tmp_name[0]+1] = 0;\
X+ 					if (tmp_name[0] > maxsize)\
X+ 						tmp_name[0] = maxsize;}
X+ 	static boolean *flag_ptrs[20] = {0, 0, 0, 0, &flags.explore,
X+ 			&flags.female, &flags.nonews,&flags.invlet_constant,
X+ 			&flags.notombstone, &flags.time, &flags.verbose,
X+ 			&flags.silent, 0, &flags.standout, &flags.sortpack,
X+ #ifdef TEXTCOLOR
X+ 			&flags.use_color,
X+ #else
X+ 			0,
X+ #endif
X+ 			&flags.pickup, &flags.confirm,
X+ 			&flags.safe_dog, &flags.no_rest_on_space};
X+ 	extern short macflags;
X+ 	short dlgItem, type;
X+ 	Rect box;
X+ 	extern WindowPtr	HackWindow;
X+ 	Handle ItemHndl;
X+ 	unsigned num;
X+ 	char *op;
X+ 	char tmp_name[256];
X+ 	char savename[PL_NSIZ];
X+ 	char savedog[63];
X+ 	char savecat[63];
X+ 	char savefruit[PL_FSIZ];
X+ 	char saveorder[20];
X+ 	DialogRecord	dlgR;
X+ 	DialogPtr optionDlg;
X+ 	DialogTHndl	th, centreDlgBox();
X+ 	boolean done = FALSE;
X+     short savemacflags = macflags;
X+ 	struct flag saveflags;
X+ 	register char	*sp, *tmp;
X+ 
X+ 	SetCursor(&ARROW_CURSOR);
X+ 
X+ 	BlockMove(&flags, &saveflags, sizeof(struct flag));
X+ 	
X+ 	th = centreDlgBox(130, FALSE);
X+ 
X+ 	optionDlg = GetNewDialog(130, (Ptr)&dlgR, (WindowPtr)-1);
X+ /* set initial values of text items */
X+ 	nmcpy(savename,plname,sizeof(plname)-1);
X+ 	ITEMTEXT(PLAYER_NAME,plname);
X+ 	if(*dogname){
X+ 		nmcpy(savedog,dogname,62);
X+ 		ITEMTEXT(DOG_NAME,dogname);
X+ 	}
X+ 	if(*catname){
X+ 		nmcpy(savecat,catname,62);
X+ 		ITEMTEXT(CAT_NAME,catname);
X+ 	}
X+ #ifdef TUTTI_FRUTTI
X+ 	if(*pl_fruit){
X+ 		nmcpy(savefruit,pl_fruit,PL_FSIZ);
X+ 		ITEMTEXT(FRUIT_NAME,pl_fruit);
X+ 	}
X+ #else
X+ 	HIDETEXT(FRUIT_NAME);
X+ 	HIDETEXT(FRUIT_TEXT);
X+ #endif
X+ 	nmcpy(saveorder,inv_order,strlen(inv_order)+1);
X+ 	ITEMTEXT(PACKORDER,inv_order);
X+ /* set initial values of record items */
X+ 	Sprintf(tmp_name,"%u",flags.end_top);
X+ 	ITEMTEXT(END_TOP,tmp_name);
X+ 	Sprintf(tmp_name,"%u",flags.end_around);
X+ 	ITEMTEXT(END_AROUND,tmp_name);
X+ /* set initial values of checkboxes */
X+ 	for(dlgItem = MIN_CHECKBOX; dlgItem <= MAX_CHECKBOX; dlgItem++) {
X+ 		GetDItem(optionDlg, dlgItem, &type, &ItemHndl, &box);
X+ 		switch (dlgItem){
X+ 			case NEWS_BOX:
X+ #ifndef NEWS
X+ 				HIDEITEM(NEWS_BOX);
X+ 				break;
X+ #endif
X+ 			case TOMB_BOX:
X+ 			case REST_SPACE_BOX:
X+ 				SetCtlValue(ItemHndl,!(*(flag_ptrs[dlgItem])));
X+ 				break;
X+ 			case AUTOZOOM_BOX:
X+ 				SetCtlValue(ItemHndl,macflags & fZoomOnContextSwitch);
X+ 				break;
X+ #ifndef TEXTCOLOR
X+ 			case COLOR_BOX:
X+ 				HIDEITEM(COLOR_BOX);
X+ 				break;
X+ #endif
X+ 			default:
X+ 				SetCtlValue(ItemHndl,*(flag_ptrs[dlgItem]));
X+ 		}
X+ 	}
X+ 	SelIText(optionDlg, PLAYER_NAME, 0, 32767);
X+ 	
X+ 	ShowWindow(optionDlg);
X+ 	GetDItem(optionDlg, OK, &type, &ItemHndl, &box);
X+ 	SetPort (optionDlg);
X+ 	PenSize(3, 3);
X+ 	InsetRect (&box, -4, -4);
X+ 	FrameRoundRect (&box, 16, 16);
X+ 	
X+ 	while(!done) {
X+ 		ModalDialog((ProcPtr)0, &dlgItem);
X+ 		GetDItem(optionDlg, dlgItem, &type, &ItemHndl, &box);
X+ 		if (dlgItem >= MIN_CHECKBOX && dlgItem <= MAX_CHECKBOX) {
X+ 			SetCtlValue(ItemHndl, ! GetCtlValue (ItemHndl));
X+ 			if (dlgItem != AUTOZOOM_BOX)
X+ 				*(flag_ptrs[dlgItem]) = !*(flag_ptrs[dlgItem]);
X+ 			else
X+ 				macflags ^= fZoomOnContextSwitch;
X+ 		}
X+ 		else switch(dlgItem){
X+ 			case SAVE_BUTTON:
X+ 				GETTEXT(PLAYER_NAME,PL_NSIZ-1);
X+ 				strncpy(plname, tmp_name, tmp_name[0]+1);
X+ 				(void)PtoCstr (plname);
X+ 			
X+ 				GETTEXT(DOG_NAME,62);
X+ 				strncpy(dogname, tmp_name, tmp_name[0]+1);
X+ 				(void)PtoCstr (dogname);
X+ 			
X+ 				GETTEXT(CAT_NAME,62);
X+ 				strncpy(catname, tmp_name, tmp_name[0]+1);
X+ 				(void)PtoCstr (catname);
X+ 
X+ #ifdef TUTTI_FRUTTI
X+ 				GETTEXT(FRUIT_NAME,PL_FSIZ-1);
X+ 				strncpy(pl_fruit, tmp_name, tmp_name[0]+1);
X+ 				(void)PtoCstr (pl_fruit);
X+ #endif
X+ 
X+ 				GETTEXT(PACKORDER,19);
X+ 				op = tmp_name+1;
X+ 				/* Missing characters in new order are filled in at the end 
X+ 				 * from inv_order.
X+ 				 */
X+ 				for (sp = op; *sp; sp++)
X+ 					if ((!index(inv_order, *sp))||(index(sp+1, *sp))){
X+ 						for(tmp = sp; *tmp;tmp++)
X+ 							tmp[0]=tmp[1];
X+ 						sp--;
X+ 					}			/* bad or duplicate char in order - remove it*/
X+ 				tmp = (char *) alloc((unsigned)(strlen(inv_order)+1));
X+ 				Strcpy(tmp, op);
X+ 				for (sp = inv_order, num = strlen(tmp); *sp; sp++)
X+ 					if (!index(tmp, *sp)) {
X+ 						tmp[num++] = *sp;
X+ 						tmp[num] = 0;
X+ 					}
X+ 				Strcpy(inv_order, tmp);
X+ 				free((genericptr_t)tmp);
X+ 
X+ 				GETTEXT(END_TOP,5);
X+ 				op = tmp_name+1;
X+ 				while(*op) {
X+ 					num = 1;
X+ 					if(digit(*op)) {
X+ 						num = atoi(op);
X+ 						while(digit(*op)) op++;
X+ 					} else op++;
X+ 				}
X+ 				flags.end_top=num;
X+ 				GETTEXT(END_AROUND,5);
X+ 				op = tmp_name+1;
X+ 				while(*op) {
X+ 					num = 1;
X+ 					if(digit(*op)) {
X+ 						num = atoi(op);
X+ 						while(digit(*op)) op++;
X+ 					} else op++;
X+ 				}
X+ 				flags.end_around = num;
X+ 				write_opts();
X+ 				nmcpy(dogname,savedog,62);
X+ 				nmcpy(catname,savecat,62);
X+ 				nmcpy(plname,savename,sizeof(plname)-1);
X+ #ifdef TUTTI_FRUTTI
X+ 				nmcpy(pl_fruit,savefruit,PL_FSIZ-1);
X+ #endif
X+ 				nmcpy(inv_order,saveorder,strlen(inv_order)+1);
X+ 			case CANCEL_BUTTON:
X+ 				flags = saveflags;
X+ 				macflags = savemacflags;
X+ 				done = TRUE;
X+ 				break;
X+ 			case OK_BUTTON:
X+ 				GETTEXT(END_TOP,5);
X+ 				op = tmp_name+1;
X+ 				while(*op) {
X+ 					num = 1;
X+ 					if(digit(*op)) {
X+ 						num = atoi(op);
X+ 						while(digit(*op)) op++;
X+ 					} else op++;
X+ 				}
X+ 				flags.end_top=num;
X+ 				GETTEXT(END_AROUND,5);
X+ 				op = tmp_name+1;
X+ 				while(*op) {
X+ 					num = 1;
X+ 					if(digit(*op)) {
X+ 						num = atoi(op);
X+ 						while(digit(*op)) op++;
X+ 					} else op++;
X+ 				}
X+ 				flags.end_around = num;
X+ #ifdef TUTTI_FRUTTI
X+ 				GETTEXT(FRUIT_NAME,PL_FSIZ-1);
X+ 				(void)PtoCstr (tmp_name);
X+ 				(void)fruitadd(tmp_name);
X+ 				nmcpy(pl_fruit,tmp_name,PL_FSIZ-1);
X+ #endif
X+ 				nmcpy(dogname,savedog,62);
X+ 				nmcpy(catname,savecat,62);
X+ 				nmcpy(plname,savename,sizeof(plname)-1);
X+ 				GETTEXT(PACKORDER,19);
X+ 				op = tmp_name+1;
X+ 				/* Missing characters in new order are filled in at the end 
X+ 				 * from inv_order.
X+ 				 */
X+ 				for (sp = op; *sp; sp++)
X+ 					if ((!index(inv_order, *sp))||(index(sp+1, *sp))){
X+ 						for (tmp = sp; *tmp;tmp++)
X+ 							tmp[0]=tmp[1];
X+ 						sp--;
X+ 					}			/* bad or duplicate char in order - remove it*/
X+ 				tmp = (char *) alloc((unsigned)(strlen(inv_order)+1));
X+ 				Strcpy(tmp, op);
X+ 				for (sp = inv_order, num = strlen(tmp); *sp; sp++)
X+ 					if (!index(tmp, *sp)) {
X+ 						tmp[num++] = *sp;
X+ 						tmp[num] = 0;
X+ 					}
X+ 				Strcpy(inv_order, tmp);
X+ 				free((genericptr_t)tmp);
X+ 				flags.female = saveflags.female;
X+ 				flags.explore = saveflags.explore;
X+ 				done = TRUE;
X+ 				break;
X+ 			default:;
X+ 		}
X+ 	} 
X+ 	HideWindow(optionDlg);
X+ 	DisposDialog (optionDlg);
X+ 	SetPort (HackWindow);
X+ 	return 0; 
X+ #else
X  	char buf[BUFSZ];
X  
X  	pline("What options do you want to set? ");
X***************
X*** 536,542 ****
X  #ifdef TUTTI_FRUTTI
X  	    Sprintf(eos(buf), "fruit:%s,", pl_fruit);
X  #endif
X! 	    if(flags.end_top != 5 || flags.end_around != 4 || flags.end_own){
X  		Sprintf(eos(buf), "endgame: %u top scores/%u around me",
X  			flags.end_top, flags.end_around);
X  		if(flags.end_own) Strcat(buf, "/own scores");
X--- 838,844 ----
X  #ifdef TUTTI_FRUTTI
X  	    Sprintf(eos(buf), "fruit:%s,", pl_fruit);
X  #endif
X! 	    if(flags.end_top != 3 || flags.end_around != 2 || flags.end_own){
X  		Sprintf(eos(buf), "endgame: %u top scores/%u around me",
X  			flags.end_top, flags.end_around);
X  		if(flags.end_own) Strcat(buf, "/own scores");
X***************
X*** 551,556 ****
X--- 853,859 ----
X  	}
X  
X  	return 0;
X+ #endif /* MACOS */
X  }
X  
X  int
X***************
X*** 637,642 ****
X--- 940,946 ----
X  	set_pager(1);
X  	return;
X  quit:
X+ 	(void) next_opt("\033");
X  	set_pager(2);
X  	return;
X  }
X***************
X*** 643,660 ****
X  
X  /*
X   * prints the next boolean option, on the same line if possible, on a new
X!  * line if not
X   */
X! static int
X  next_opt(str)
X! 	char *str;
X  {
X! 	static char buf[80];
X  	static int i = 0;
X  	int r = 0;
X  
X  	i += strlen(str);
X! 	if (i > (CO - 2) || !*str) {
X  		r = page_line(buf);
X  		buf[0] = 0;
X  		i = strlen(str);
X--- 947,968 ----
X  
X  /*
X   * prints the next boolean option, on the same line if possible, on a new
X!  * line if not. End with next_opt(""). Note that next_opt("\033") may be
X!  * used to abort.
X   */
X! int
X  next_opt(str)
X! const char *str;
X  {
X! 	static char buf[121];
X  	static int i = 0;
X  	int r = 0;
X  
X+ 	if (*str == '\033') {
X+ 		i = 0; buf[0] = 0; return 0;
X+ 	}
X  	i += strlen(str);
X! 	if (i > min(CO - 2, 120) || !*str) {
X  		r = page_line(buf);
X  		buf[0] = 0;
X  		i = strlen(str);
X***************
X*** 677,683 ****
X--- 985,995 ----
X  {
X  	register int i,j;
X  	register struct fruit *f;
X+ #ifdef __GNULINT__
X+ 	struct fruit *lastf = 0;
X+ #else
X  	struct fruit *lastf;
X+ #endif
X  	int highest_fruit_id = 0;
X  	char buf[PL_FSIZ];
X  	boolean user_specified = (str == pl_fruit);
X*** src/Old/track.c	Mon Feb 19 19:03:41 1990
X--- src/track.c	Fri Feb 16 19:14:36 1990
X***************
X*** 7,21 ****
X  
X  #define	UTSZ	50
X  
X! coord utrack[UTSZ];
X! int utcnt = 0;
X! int utpnt = 0;
X  
X  void
X  initrack(){
X  	utcnt = utpnt = 0;
X  }
X  
X  /* add to track */
X  void
X  settrack(){
X--- 7,24 ----
X  
X  #define	UTSZ	50
X  
X! VSTATIC int utcnt, utpnt;
X! VSTATIC coord utrack[UTSZ];
X  
X+ #ifdef OVLB
X  void
X  initrack(){
X  	utcnt = utpnt = 0;
X  }
X+ #endif /* OVLB */
X  
X+ #ifdef OVL1
X+ 
X  /* add to track */
X  void
X  settrack(){
X***************
X*** 26,31 ****
X--- 29,37 ----
X  	utpnt++;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  coord *
X  gettrack(x, y)
X  register int x, y;
X***************
X*** 42,44 ****
X--- 48,52 ----
X  	}
X  	return (coord *)0;
X  }
X+ 
X+ #endif /* OVL0 */
X
END_OF_FILE
if test 52317 -ne `wc -c <'patch7.18'`; then
    echo shar: \"'patch7.18'\" unpacked with wrong size!
fi
# end of 'patch7.18'
echo shar: End of archive 22 \(of 30\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
