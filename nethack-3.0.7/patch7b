Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!wuarchive!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i002:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7b
Message-ID: <5216@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:28:07 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2259
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 2
Archive-name: NetHack3/Patch7b
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 30)."
# Contents:  patch7.06
# Wrapped by billr@saab on Wed Feb 21 10:04:23 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.06' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.06'\" to \"'patch7.06.orig'\"
  mv -f 'patch7.06' 'patch7.06.orig'
fi
echo shar: Extracting \"'patch7.06'\" \(57309 characters\)
sed "s/^X//" >'patch7.06' <<'END_OF_FILE'
X*** src/Old/potion.c	Mon Feb 19 18:51:51 1990
X--- src/potion.c	Sun Feb 18 11:46:24 1990
X***************
X*** 4,14 ****
X--- 4,27 ----
X  
X  #include "hack.h"
X  
X+ #ifdef OVLB
X  static int nothing, unkn;
X+ #endif /* OVLB */
X+ 
X  #ifdef WORM
X+ 
X+ extern boolean notonhead;
X+ 
X+ #ifdef OVLB
X+ 
X  boolean notonhead = FALSE;
X+ 
X+ #endif /* OVLB */
X+ 
X  #endif
X  
X+ #ifdef OVLB
X+ 
X  static const char beverages[] = { POTION_SYM, 0 };
X  
X  void
X***************
X*** 128,136 ****
X  		if (!Blind && talk) pline("Everything looks SO boring now.");
X  		for (mtmp=fmon; mtmp; mtmp=mtmp->nmon)
X  		  if (showmon(mtmp))
X! 		    atl(mtmp->mx, mtmp->my, (!mtmp->mappearance ||
X  					     Protection_from_shape_changers)
X! 			? mtmp->data->mlet : mtmp->mappearance);
X  		flags.botl = 1;
X  	}
X  	if (xtime && !old ) {
X--- 141,149 ----
X  		if (!Blind && talk) pline("Everything looks SO boring now.");
X  		for (mtmp=fmon; mtmp; mtmp=mtmp->nmon)
X  		  if (showmon(mtmp))
X! 		    atl(mtmp->mx, mtmp->my, (!mtmp->m_ap_type ||
X  					     Protection_from_shape_changers)
X! 			? mtmp->data->mlet : (char) mimic_appearance(mtmp));
X  		flags.botl = 1;
X  	}
X  	if (xtime && !old ) {
X***************
X*** 159,164 ****
X--- 172,181 ----
X  dodrink() {
X  	register struct obj *otmp;
X  
X+ 	if (Strangled) {
X+ 		pline("If you can't breathe air, how can you drink liquid?");
X+ 		return 0;
X+ 	}
X  #ifdef FOUNTAINS
X  	/* Is there a fountain to drink from here? */
X          if (IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X***************
X*** 271,277 ****
X  				u.ualigntyp == U_CHAOTIC) {
X  		    if(otmp->blessed) {
X  			pline("This burns like acid!");
X! 			losehp(d(2,6), "potion of holy water");
X  		    } else if(otmp->cursed) {
X  			You("feel quite proud of yourself.");
X  			healup(d(2,6),0,0,0);
X--- 288,301 ----
X  				u.ualigntyp == U_CHAOTIC) {
X  		    if(otmp->blessed) {
X  			pline("This burns like acid!");
X! 			if (u.ulycn != -1) {
X! 				Your("affinity to %s disappears!",
X! 				     makeplural(mons[u.ulycn].mname));
X! 				if(uasmon == &mons[u.ulycn] && !Polymorph_control)
X! 					rehumanize();
X! 				u.ulycn = -1;
X! 			}
X! 			losehp(d(2,6), "potion of holy water", KILLED_BY_AN);
X  		    } else if(otmp->cursed) {
X  			You("feel quite proud of yourself.");
X  			healup(d(2,6),0,0,0);
X***************
X*** 293,299 ****
X  		    } else {
X  			if(u.ualigntyp == U_LAWFUL) {
X  			    pline("This burns like acid!");
X! 			    losehp(d(2,6), "potion of unholy water");
X  			} else
X  			    You("feel full of dread.");
X  		    }
X--- 317,324 ----
X  		    } else {
X  			if(u.ualigntyp == U_LAWFUL) {
X  			    pline("This burns like acid!");
X! 			    losehp(d(2,6), "potion of unholy water",
X! 				KILLED_BY_AN);
X  			} else
X  			    You("feel full of dread.");
X  		    }
X***************
X*** 304,310 ****
X  		      Hallucination ? "furniture polish" : "liquid fire");
X  		if (!otmp->blessed) make_confused(HConfusion + d(3,8),FALSE);
X  		/* the whiskey makes us feel better */
X! 		if(u.uhp < u.uhpmax) losehp(-1, "bottle of whiskey");
X  		lesshungry(10 * (2 + bcsign(otmp)));
X  		if(otmp->cursed) {
X  			You("pass out.");
X--- 329,335 ----
X  		      Hallucination ? "furniture polish" : "liquid fire");
X  		if (!otmp->blessed) make_confused(HConfusion + d(3,8),FALSE);
X  		/* the whiskey makes us feel better */
X! 		if(u.uhp < u.uhpmax) losehp(-1, "", 0); /* can't kill you */
X  		lesshungry(10 * (2 + bcsign(otmp)));
X  		if(otmp->cursed) {
X  			You("pass out.");
X***************
X*** 340,349 ****
X--- 365,382 ----
X  		       You("feel rather airy."), unkn++;
X  		}
X  		if (otmp->blessed && !(HInvis & INTRINSIC)) {
X+ #ifndef MACOS
X  			pline("Do you want the invisibility to be permanent? ");
X  			nothing = 0;
X  			if (yn()=='n') HInvis += rn1(15,31);
X  			else HInvis |= INTRINSIC;
X+ #else
X+ 			nothing = 0;
X+ 			if (UseMacAlertText(128,
X+ 				"Do you want the invisibility to be permanent ?")
X+ 				== 2) HInvis += rn1(15,31);
X+ 			else HInvis |= INTRINSIC;
X+ #endif
X  		} else HInvis += rn1(15,31);
X  		if(otmp->cursed) {
X  		    pline("For some reason, you feel your presence is known.");
X***************
X*** 411,417 ****
X  		pline("(But in fact it was mildly stale orange juice.)");
X  #endif
X  			if (pl_character[0] != 'H')
X! 				losehp(1, "mildly contaminated potion");
X  		} else {
X  		    if(Poison_resistance)
X  #ifdef TUTTI_FRUTTI
X--- 444,451 ----
X  		pline("(But in fact it was mildly stale orange juice.)");
X  #endif
X  			if (pl_character[0] != 'H')
X! 				losehp(1, "mildly contaminated potion",
X! 					KILLED_BY_AN);
X  		} else {
X  		    if(Poison_resistance)
X  #ifdef TUTTI_FRUTTI
X***************
X*** 427,433 ****
X  			adjattrib(typ,Poison_resistance ? -1 : -rn1(4,3), TRUE);
X  			if(!Poison_resistance)
X  				losehp(rnd(10)+5*!!(otmp->cursed),
X! 				       "contaminated potion");
X  		    }
X  		}
X  		if(Hallucination) {
X--- 461,467 ----
X  			adjattrib(typ,Poison_resistance ? -1 : -rn1(4,3), TRUE);
X  			if(!Poison_resistance)
X  				losehp(rnd(10)+5*!!(otmp->cursed),
X! 				       "contaminated potion", KILLED_BY_AN);
X  		    }
X  		}
X  		if(Hallucination) {
X***************
X*** 526,532 ****
X  					You("hit your %s on the ceiling.",
X  						body_part(HEAD));
X  					losehp(uarmh ? 1 : rnd(10),
X! 						"collision with the ceiling");
X  				} else (void) doup();
X  			}
X  		} else
X--- 560,567 ----
X  					You("hit your %s on the ceiling.",
X  						body_part(HEAD));
X  					losehp(uarmh ? 1 : rnd(10),
X! 						"colliding with the ceiling",
X! 						KILLED_BY);
X  				} else (void) doup();
X  			}
X  		} else
X***************
X*** 591,597 ****
X  void
X  strange_feeling(obj,txt)
X  register struct obj *obj;
X! register char *txt;
X  {
X  	if(flags.beginner)
X  		You("have a %s feeling for a moment, then it passes.",
X--- 626,632 ----
X  void
X  strange_feeling(obj,txt)
X  register struct obj *obj;
X! register const char *txt;
X  {
X  	if(flags.beginner)
X  		You("have a %s feeling for a moment, then it passes.",
X***************
X*** 617,623 ****
X  register struct monst *mon;
X  register struct obj *obj;
X  {
X! 	register char *botlnam = bottlenames[rn2(SIZE(bottlenames))];
X  	boolean uclose, isyou = (mon == &youmonst);
X  
X  	if(isyou) {
X--- 652,658 ----
X  register struct monst *mon;
X  register struct obj *obj;
X  {
X! 	register const char *botlnam = bottlenames[rn2(SIZE(bottlenames))];
X  	boolean uclose, isyou = (mon == &youmonst);
X  
X  	if(isyou) {
X***************
X*** 624,630 ****
X  		uclose = TRUE;
X  		pline("The %s crashes on your %s and breaks into shivers.",
X  			botlnam, body_part(HEAD));
X! 		losehp(rnd(2), "thrown potion");
X  	} else {
X  		uclose = (dist(mon->mx,mon->my) < 3);
X  		if(Blind) pline("Crash!");
X--- 659,665 ----
X  		uclose = TRUE;
X  		pline("The %s crashes on your %s and breaks into shivers.",
X  			botlnam, body_part(HEAD));
X! 		losehp(rnd(2), "thrown potion", KILLED_BY_AN);
X  	} else {
X  		uclose = (dist(mon->mx,mon->my) < 3);
X  		if(Blind) pline("Crash!");
X***************
X*** 675,684 ****
X  		pmon(mon);
X  		break;
X  	case POT_PARALYSIS:
X! 		mon->mfroz = 1;
X  		break;
X  	case POT_SPEED:
X! 		mon->mspeed = MFAST;
X  		break;
X  	case POT_BLINDNESS:
X  		{
X--- 710,726 ----
X  		pmon(mon);
X  		break;
X  	case POT_PARALYSIS:
X! 		if (mon->mcanmove) {
X! 			mon->mcanmove = 0;
X! 			/* really should be rnd(5) for consistency with players
X! 			 * breathing potions, but...
X! 			 */
X! 			mon->mfrozen = rnd(25);
X! 		}
X  		break;
X  	case POT_SPEED:
X! 		if (mon->mspeed == MSLOW) mon->mspeed = 0;
X! 		else mon->mspeed = MFAST;
X  		break;
X  	case POT_BLINDNESS:
X  		{
X***************
X*** 685,690 ****
X--- 727,733 ----
X  		    register int btmp = 64 + rn2(32) +
X  					rn2(32) * !resist(mon, POTION_SYM, 0, NOTELL);
X  		    mon->mblinded |= btmp;
X+ 		    mon->mcansee = 0;
X  		}
X  		break;
X  	case POT_WATER:
X***************
X*** 857,863 ****
X  dodip()
X  {
X  	register struct obj *potion, *obj;
X! 	char *tmp;
X  	uchar here;
X  
X  	if(!(obj = getobj("#", "dip")))
X--- 900,906 ----
X  dodip()
X  {
X  	register struct obj *potion, *obj;
X! 	const char *tmp;
X  	uchar here;
X  
X  	if(!(obj = getobj("#", "dip")))
X***************
X*** 919,925 ****
X  			if (obj->blessed) {
X  				if (!Blind)
X  				    Your("%s %s.", aobjnam(obj, "glow"),
X! 					  Hallucination ? hcolor() : "brown");
X  				obj->blessed=0;
X  				obj->bknown=1;
X  				goto poof;
X--- 962,968 ----
X  			if (obj->blessed) {
X  				if (!Blind)
X  				    Your("%s %s.", aobjnam(obj, "glow"),
X! 				     Hallucination ? hcolor() : (const char *)"brown");
X  				obj->blessed=0;
X  				obj->bknown=1;
X  				goto poof;
X***************
X*** 1014,1020 ****
X  	if(obj->otyp == UNICORN_HORN && neutralizes(obj, potion)) {
X  		pline("The potion clears.");
X  		potion->otyp = POT_WATER;
X! 		potion->blessed = potion->cursed = 0;
X  		return(1);
X  	}
X  
X--- 1057,1064 ----
X  	if(obj->otyp == UNICORN_HORN && neutralizes(obj, potion)) {
X  		pline("The potion clears.");
X  		potion->otyp = POT_WATER;
X! 		potion->blessed = 0;
X! 		potion->cursed = 0;
X  		return(1);
X  	}
X  
X***************
X*** 1087,1094 ****
X  		    at(mtmp->mx, mtmp->my,
X  		       (uchar)(Hallucination ? rndmonsym() : mtmp->data->mlet),
X  		       AT_MON);
X! 			if (otmp && otmp->cursed && (mtmp->msleep || mtmp->mfroz)) {
X! 				mtmp->msleep = mtmp->mfroz = 0;
X  				woken = TRUE;
X  			}
X  		}
X--- 1131,1139 ----
X  		    at(mtmp->mx, mtmp->my,
X  		       (uchar)(Hallucination ? rndmonsym() : mtmp->data->mlet),
X  		       AT_MON);
X! 			if (otmp && otmp->cursed && (mtmp->msleep || !mtmp->mcanmove)) {
X! 				mtmp->msleep = mtmp->mfrozen = 0;
X! 				mtmp->mcanmove = 1;
X  				woken = TRUE;
X  			}
X  		}
X***************
X*** 1102,1107 ****
X--- 1147,1155 ----
X  	return(0);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /* object_detect is also used in the crystal ball routine */
X  /* returns 1 if nothing was detected		*/
X  /* returns 0 if something was detected		*/
X***************
X*** 1111,1155 ****
X  {
X  	register struct obj	*objs;
X  	register struct monst	*mtmp;
X  
X  	if(!fobj) {
X! 		if (otmp)
X! 			strange_feeling(otmp, "You feel a pull downward.");
X! 		return(1);
X! 	} else {
X! 		int mfound=FALSE;
X! 
X! 		for(objs = fobj; objs; objs = objs->nobj)
X! 			if(objs->ox != u.ux || objs->oy != u.uy)
X! 				goto outobjmap;
X! 		You("sense the presence of objects nearby.");
X! 		return(0);
X! 	outobjmap:
X! 		cls();
X! 		for(objs = fobj; objs; objs = objs->nobj)
X  at(objs->ox, objs->oy, (uchar)(Hallucination ? rndobjsym() : objs->olet), AT_OBJ);
X! 		/* monster possessions added by GAN 12/16/86 */
X! 		for(mtmp = fmon ; mtmp ; mtmp = mtmp->nmon)
X! 			if(mtmp->minvent)
X! 				for(objs = mtmp->minvent;objs;objs = objs->nobj)
X! 				    at(mtmp->mx, mtmp->my, (uchar)objs->olet, AT_OBJ);
X! 		if (otmp && otmp->cursed) {
X! 			for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X! 				if (mtmp->mimic) {
X! 					mnexto(mtmp);
X! 					mfound = TRUE;
X! 				}
X  			}
X  		}
X- 		prme();
X- 		You("sense the presence of objects.");
X- 		if (mfound) pline("Objects sense the presence of you.");
X- 		more();
X- 		docrt();
X  	}
X  	return(0);
X  }
X  
X  /* the detections are pulled out so they can	*/
X  /* also be used in the crystal ball routine	*/
X  /* returns 1 if nothing was detected		*/
X--- 1159,1214 ----
X  {
X  	register struct obj	*objs;
X  	register struct monst	*mtmp;
X+ 	boolean mfound=FALSE;
X  
X  	if(!fobj) {
X! 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X! 			if (mtmp->minvent) {
X! 				/* OK, it's used for 2 different things */
X! 				mfound = TRUE;
X! 				break;
X! 			}
X! 		}
X! 		if (!mfound) {
X! 			if (otmp)
X! 			    strange_feeling(otmp, "You feel a pull downward.");
X! 			return(1);
X! 		}
X! 	}
X! 	mfound = FALSE;
X! 	for(objs = fobj; objs; objs = objs->nobj)
X! 		if(objs->ox != u.ux || objs->oy != u.uy)
X! 			goto outobjmap;
X! 	You("sense the presence of objects nearby.");
X! 	return(0);
X! outobjmap:
X! 	cls();
X! 	for(objs = fobj; objs; objs = objs->nobj)
X  at(objs->ox, objs->oy, (uchar)(Hallucination ? rndobjsym() : objs->olet), AT_OBJ);
X! 	/* monster possessions added by GAN 12/16/86 */
X! 	for(mtmp = fmon ; mtmp ; mtmp = mtmp->nmon)
X! 		if(mtmp->minvent)
X! 			for(objs = mtmp->minvent;objs;objs = objs->nobj)
X! 			    at(mtmp->mx, mtmp->my, (uchar)objs->olet, AT_OBJ);
X! 	if (otmp && otmp->cursed) {
X! 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X! 			if (mtmp->mimic) {
X! 				mnexto(mtmp);
X! 				mfound = TRUE;
X  			}
X  		}
X  	}
X+ 	prme();
X+ 	You("sense the presence of objects.");
X+ 	if (mfound) pline("Objects sense the presence of you.");
X+ 	more();
X+ 	docrt();
X  	return(0);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  /* the detections are pulled out so they can	*/
X  /* also be used in the crystal ball routine	*/
X  /* returns 1 if nothing was detected		*/
X***************
X*** 1220,1222 ****
X--- 1279,1283 ----
X  	docrt();
X  	return(0);
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/pray.c	Mon Feb 19 18:52:47 1990
X--- src/pray.c	Wed Feb  7 18:37:36 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pray.c	3.0	89/01/10
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* Copyright (c) Benson I. Margulies, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X--- 1,4 ----
X! /*	SCCS Id: @(#)pray.c	3.0	89/11/20
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* Copyright (c) Benson I. Margulies, Mike Stephenson, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X***************
X*** 6,18 ****
X  #include "hack.h"
X  
X  #ifdef THEOLOGY
X  
X  #define ALIGNLIM 	(5L + (moves/200L))
X  
X  struct ghods {
X- 
X  	char	classlet;
X! 	char	*law, *balance, *chaos;
X  }  gods[] = {
X  
X  'A', /* Central American */	"Quetzalcotl", "Camaxtli", "Huhetotl",
X--- 6,23 ----
X  #include "hack.h"
X  
X  #ifdef THEOLOGY
X+ static int NDECL(in_trouble);
X+ static void FDECL(fix_worst_trouble,(int));
X+ static void NDECL(angrygods);
X+ static void NDECL(pleased);
X+ static void NDECL(gods_upset);
X+ static void FDECL(consume_offering,(struct obj *));
X  
X  #define ALIGNLIM 	(5L + (moves/200L))
X  
X  struct ghods {
X  	char	classlet;
X! 	const char *law, *balance, *chaos;
X  }  gods[] = {
X  
X  'A', /* Central American */	"Quetzalcotl", "Camaxtli", "Huhetotl",
X***************
X*** 159,165 ****
X  {
X  	int i;
X  	struct obj *otmp = (struct obj *)0;
X! 	char *what = NULL;
X  
X  	u.ublesscnt += rnz(100);
X  	switch (trouble) {
X--- 164,170 ----
X  {
X  	int i;
X  	struct obj *otmp = (struct obj *)0;
X! 	const char *what = NULL;
X  
X  	u.ublesscnt += rnz(100);
X  	switch (trouble) {
X***************
X*** 187,193 ****
X  			pline("%s glow surrounds you.",
X  			      An(Hallucination ? hcolor() : golden));
X  		    } else You("feel much better.");
X! 		    u.uhp = u.uhpmax += 5;
X  		    flags.botl = 1;
X  		    break;
X  	    case TROUBLE_STUCK_IN_WALL:
X--- 192,201 ----
X  			pline("%s glow surrounds you.",
X  			      An(Hallucination ? hcolor() : golden));
X  		    } else You("feel much better.");
X! 		    if (u.uhpmax < u.ulevel * 5 + 11)
X! 			u.uhp = u.uhpmax += rnd(5);
X! 		    else
X! 			u.uhp = u.uhpmax;
X  		    flags.botl = 1;
X  		    break;
X  	    case TROUBLE_STUCK_IN_WALL:
X***************
X*** 207,217 ****
X  			what = rightglow;
X  		    }
X  		    goto decurse;
X- 		    break;
X  	    case TROUBLE_CURSED_BLINDFOLD:
X  		    otmp = ublindf;
X  		    goto decurse;
X- 		    break;
X  	    case TROUBLE_PUNISHED:
X  		    Your("chain disappears.");
X  		    unpunish();
X--- 215,223 ----
X***************
X*** 261,268 ****
X  		    otmp->bknown = 1;
X  		    if (!Blind)
X  			    Your("%s %s.",
X! 				   what ? what : aobjnam (otmp, "softly glow"),
X! 				   Hallucination ? hcolor() : amber);
X  		    break;
X  	    case TROUBLE_HALLUCINATION:
X  		    pline ("Looks like you are back in Kansas.");
X--- 267,274 ----
X  		    otmp->bknown = 1;
X  		    if (!Blind)
X  			    Your("%s %s.",
X! 			       what ? what : (const char *)aobjnam (otmp, "softly glow"),
X! 				Hallucination ? hcolor() : amber);
X  		    break;
X  	    case TROUBLE_HALLUCINATION:
X  		    pline ("Looks like you are back in Kansas.");
X***************
X*** 269,275 ****
X  		    make_hallucinated(0L,FALSE);
X  		    break;
X  	    case TROUBLE_BLIND:
X! 		    pline ("Your %s feel better.", makeplural(body_part(EYE)));
X  		    make_blinded(0L,FALSE);
X  		    break;
X  	    case TROUBLE_POISONED:
X--- 275,281 ----
X  		    make_hallucinated(0L,FALSE);
X  		    break;
X  	    case TROUBLE_BLIND:
X! 		    Your("%s feel better.", makeplural(body_part(EYE)));
X  		    make_blinded(0L,FALSE);
X  		    break;
X  	    case TROUBLE_POISONED:
X***************
X*** 304,310 ****
X  
X  	/* changed from tmp = u.ugangr + abs (u.uluck) -- rph */
X  	tmp =  3*u.ugangr +
X! 	       (u.uluck > 0 || u.ualign > 3 ? -u.uluck/3 : -u.uluck);
X  	if (tmp < 0) tmp = 0; /* possible if bad alignment but good luck */
X  	tmp =  (tmp > 15 ? 15 : tmp);  /* lets be a little reasonable */
X  	switch (tmp ? rn2(tmp): 0) {
X--- 310,316 ----
X  
X  	/* changed from tmp = u.ugangr + abs (u.uluck) -- rph */
X  	tmp =  3*u.ugangr +
X! 	       (Luck > 0 || u.ualign > 3 ? -Luck/3 : -Luck);
X  	if (tmp < 0) tmp = 0; /* possible if bad alignment but good luck */
X  	tmp =  (tmp > 15 ? 15 : tmp);  /* lets be a little reasonable */
X  	switch (tmp ? rn2(tmp): 0) {
X***************
X*** 323,339 ****
X  			break;
X  	    case 2:
X  	    case 3:
X  # ifdef POLYSELF
X! 			pline("A voice booms out:  \"Thou %s, %s.\"",
X  			      ugod_is_angry() ? "hast strayed from the path" :
X  					        "art arrogant",
X  			      u.usym == S_HUMAN ? "mortal" : "creature");
X  # else
X! 			pline("A voice booms out:  \"Thou %s, mortal.\"",
X  			      ugod_is_angry() ? "hast strayed from the path" :
X  					        "art arrogant");
X  # endif
X! 			pline("\"Thou must relearn thy lessons!\"");
X  			adjattrib(A_WIS, -1, FALSE);
X  			if (u.ulevel > 1) {
X  			    losexp();
X--- 329,346 ----
X  			break;
X  	    case 2:
X  	    case 3:
X+ 			pline("A voice thunders:");
X  # ifdef POLYSELF
X! 			pline("\"Thou %s, %s.\"",
X  			      ugod_is_angry() ? "hast strayed from the path" :
X  					        "art arrogant",
X  			      u.usym == S_HUMAN ? "mortal" : "creature");
X  # else
X! 			pline("\"Thou %s, mortal.\"",
X  			      ugod_is_angry() ? "hast strayed from the path" :
X  					        "art arrogant");
X  # endif
X! 			verbalize("Thou must relearn thy lessons!");
X  			adjattrib(A_WIS, -1, FALSE);
X  			if (u.ulevel > 1) {
X  			    losexp();
X***************
X*** 355,366 ****
X  			rndcurse();
X  			break;
X  	    case 7:
X! 	    case 8:	pline("A voice booms out:  \"Thou durst call upon me?\"");
X  # ifdef POLYSELF
X  			pline("\"Then die, %s!\"",
X  			      u.usym == S_HUMAN ? "mortal" : "creature");
X  # else
X! 			pline("\"Then die, mortal!\"");
X  # endif
X  			(void) makemon(&mons[ndemon()], u.ux, u.uy);
X  			break;
X--- 362,374 ----
X  			rndcurse();
X  			break;
X  	    case 7:
X! 	    case 8:	pline("A voice booms out:");
X! 			verbalize("Thou durst call upon me?");
X  # ifdef POLYSELF
X  			pline("\"Then die, %s!\"",
X  			      u.usym == S_HUMAN ? "mortal" : "creature");
X  # else
X! 			verbalize("Then die, mortal!");
X  # endif
X  			(void) makemon(&mons[ndemon()], u.ux, u.uy);
X  			break;
X***************
X*** 389,399 ****
X  ohno:
X  				if (Disint_resistance) {
X  	You("bask in the disintegration beam for a minute...");
X! 	pline("A voice rings out:  \"I believe it not!\"");
X  					break;
X  				}
X  			}
X  			You("fry to a crisp.");
X  			killer = "holy wrath";
X  			done(DIED);
X  			break;
X--- 397,409 ----
X  ohno:
X  				if (Disint_resistance) {
X  	You("bask in the disintegration beam for a minute...");
X! 					pline("A voice rings out:");
X! 					verbalize("I believe it not!");
X  					break;
X  				}
X  			}
X  			You("fry to a crisp.");
X+ 			killer_format = KILLED_BY_AN;
X  			killer = "holy wrath";
X  			done(DIED);
X  			break;
X***************
X*** 438,448 ****
X  	if (!trouble) pat_on_head = 1;
X  	else {
X  #ifdef ALTARS
X! 	    int action = rn1(on_altar() ? 3 + on_shrine() : 2, u.uluck+1);
X  
X  	    if (!on_altar()) action = max(action,2);
X  #else
X! 	    int action = rn1(4,u.uluck+1);
X  #endif
X  
X  	    switch(min(action,5)) {
X--- 448,458 ----
X  	if (!trouble) pat_on_head = 1;
X  	else {
X  #ifdef ALTARS
X! 	    int action = rn1(on_altar() ? 3 + on_shrine() : 2, Luck+1);
X  
X  	    if (!on_altar()) action = max(action,2);
X  #else
X! 	    int action = rn1(4,Luck+1);
X  #endif
X  
X  	    switch(min(action,5)) {
X***************
X*** 461,467 ****
X  	}
X  
X      if(pat_on_head)
X! 	switch(rn2((u.uluck + 6)>>1))  {
X  
X  	    case 0:	break;
X  	    case 1:
X--- 471,477 ----
X  	}
X  
X      if(pat_on_head)
X! 	switch(rn2((Luck + 6)>>1))  {
X  
X  	    case 0:	break;
X  	    case 1:
X***************
X*** 486,495 ****
X  			break;
X  	    case 3:
X  #if defined(STRONGHOLD) && defined(MUSIC)
X! 			/* takes 2 hints to get the music to enter the Stronghold */
X  			if (flags.soundok) {
X  			    if(music_heard < 1) {
X! 				pline("A voice booms out:  \"Hark, mortal!\"");
X  				verbalize("To enter the castle, thou must play the right tune!");
X  				music_heard++;
X  				break;
X--- 496,511 ----
X  			break;
X  	    case 3:
X  #if defined(STRONGHOLD) && defined(MUSIC)
X! 			/* takes 2 hints to get the music to enter the stronghold */
X  			if (flags.soundok) {
X  			    if(music_heard < 1) {
X! 				pline("A voice rings out:");
X! # ifdef POLYSELF
X! 				pline("\"Hark, %s!\"",
X! 				    u.usym == S_HUMAN ? "mortal" : "creature");
X! # else
X! 				verbalize("Hark, mortal!");
X! # endif
X  				verbalize("To enter the castle, thou must play the right tune!");
X  				music_heard++;
X  				break;
X***************
X*** 532,539 ****
X  		}
X  	    case 5:
X  		{
X! 			char *msg="\"and thus I grant thee the gift of %s!\"";
X! 			pline("A voice booms out:  \"Thou hast pleased me with thy progress,\"");
X  			if (!(HTelepat & INTRINSIC))  {
X  				HTelepat |= INTRINSIC;
X  				pline(msg, "Telepathy");
X--- 548,556 ----
X  		}
X  	    case 5:
X  		{
X! 			const char *msg="\"and thus I grant thee the gift of %s!\"";
X! 			pline("A voice booms out:");
X! 			verbalize("Thou hast pleased me with thy progress,");
X  			if (!(HTelepat & INTRINSIC))  {
X  				HTelepat |= INTRINSIC;
X  				pline(msg, "Telepathy");
X***************
X*** 550,559 ****
X  			    } else u.ublessed++;
X  			    pline(msg, "my protection");
X  			}
X! 			pline ("\"Use it wisely in my name!\"");
X  			break;
X  		}
X  	    case 7:
X  #ifdef ELBERETH
X  			if (u.ualign > 3 && !u.uhand_of_elbereth) {
X  			    u.uhand_of_elbereth = TRUE;
X--- 567,577 ----
X  			    } else u.ublessed++;
X  			    pline(msg, "my protection");
X  			}
X! 			verbalize("Use it wisely in my name!");
X  			break;
X  		}
X  	    case 7:
X+ 	    case 8:
X  #ifdef ELBERETH
X  			if (u.ualign > 3 && !u.uhand_of_elbereth) {
X  			    u.uhand_of_elbereth = TRUE;
X***************
X*** 561,569 ****
X  			    HFire_resistance |= INTRINSIC;
X  			    HCold_resistance |= INTRINSIC;
X  			    HPoison_resistance |= INTRINSIC;
X  			    if (u.ualigntyp != U_CHAOTIC) {
X! 			        pline("A voice booms out:  \"I crown thee...\"");
X! 				pline("\"The Hand of Elbereth!\"");
X  #ifdef NAMED_ITEMS
X  				if(uwep && (uwep->otyp == LONG_SWORD)) {
X  					bless(uwep);
X--- 579,587 ----
X  			    HFire_resistance |= INTRINSIC;
X  			    HCold_resistance |= INTRINSIC;
X  			    HPoison_resistance |= INTRINSIC;
X+ 			    pline("A voice booms out:");
X  			    if (u.ualigntyp != U_CHAOTIC) {
X! 				verbalize("I crown thee...      The Hand of Elbereth!");
X  #ifdef NAMED_ITEMS
X  				if(uwep && (uwep->otyp == LONG_SWORD)) {
X  					bless(uwep);
X***************
X*** 575,581 ****
X  			    } else {
X  				register struct obj *obj;
X  #ifdef NAMED_ITEMS
X! 				pline("A voice booms out:  \"Thou art chosen to steal souls for Arioch!\"");
X  				/* This does the same damage as Excalibur.
X  				 * Disadvantages: doesn't do bonuses to undead;
X  				 * doesn't aid searching.
X--- 593,600 ----
X  			    } else {
X  				register struct obj *obj;
X  #ifdef NAMED_ITEMS
X! 				const char *Stormbringer = "Stormbringer";
X! 
X  				/* This does the same damage as Excalibur.
X  				 * Disadvantages: doesn't do bonuses to undead;
X  				 * doesn't aid searching.
X***************
X*** 585,612 ****
X  				 * +5 weapon and turn it into a Stormbringer.
X  				 * Advantage: they don't need to already have a
X  				 * sword of the right type to get it...
X  				 */
X  				if (Blind)
X  				    pline("Something appears at your %s.",
X  					makeplural(body_part(FOOT)));
X  				else
X  				    pline("%s sword appears at your %s!",
X! 					An(Hallucination ? hcolor() : black),
X  					makeplural(body_part(FOOT)));
X- 				obj = mksobj(BROADSWORD, FALSE);
X- 				obj = oname(obj, "Stormbringer", 0);
X  				obj->rustfree = 1;
X  				obj->cursed = 0;
X- 				obj->blessed = 1;
X  			/* Why bless it?  Why not.  After all, chaotic gods
X  			 * will bless regular weapons.  And blessed really
X  			 * means given sanctified to a deity, which is certainly
X  			 * sensible even for Stormbringer and a chaotic deity...
X  			 */
X! 				obj->spe = 1;
X  				dropy(obj);
X  #else
X! 				pline("Thou shalt become the servant of Arioch!");
X  #endif
X  			    }
X  			    break;
X--- 604,646 ----
X  				 * +5 weapon and turn it into a Stormbringer.
X  				 * Advantage: they don't need to already have a
X  				 * sword of the right type to get it...
X+ 				 * However, if Stormbringer already exists in
X+ 				 * the game, an ordinary good broadsword is
X+ 				 * given and the messages are a bit different.
X  				 */
X+ 				obj = mksobj(BROADSWORD, FALSE);
X+ 				if (exist_artifact(obj, Stormbringer))
X+ 					verbalize("Thou art chosen to take lives for Arioch!");
X+ 				else
X+ 					verbalize("Thou art chosen to steal souls for Arioch!");
X  				if (Blind)
X  				    pline("Something appears at your %s.",
X  					makeplural(body_part(FOOT)));
X  				else
X  				    pline("%s sword appears at your %s!",
X! 					An(exist_artifact(obj, Stormbringer) ?
X! 					   (const char *)"wide" :
X! 					   Hallucination ? hcolor() : black),
X  					makeplural(body_part(FOOT)));
X  				obj->rustfree = 1;
X  				obj->cursed = 0;
X  			/* Why bless it?  Why not.  After all, chaotic gods
X  			 * will bless regular weapons.  And blessed really
X  			 * means given sanctified to a deity, which is certainly
X  			 * sensible even for Stormbringer and a chaotic deity...
X  			 */
X! 				obj->blessed = 1;
X! 
X! 				/* if not "Stormbringer", make it a bit better otherwise */
X! 				if (exist_artifact(obj, Stormbringer))
X! 				    obj->spe = 3;
X! 				else
X! 				    obj->spe = 1;
X! 				/* existence of "Stormbringer" is checked in oname() */
X! 				obj = oname(obj, Stormbringer, 0);
X  				dropy(obj);
X  #else
X! 				verbalize("Thou shalt become the servant of Arioch!");
X  #endif
X  			    }
X  			    break;
X***************
X*** 616,624 ****
X  	    case 6:	pline ("An object appears at your %s!",
X  				makeplural(body_part(FOOT)));
X  #ifdef SPELLS
X! 			(void) mkobj_at(SPBOOK_SYM, u.ux, u.uy);
X  #else
X! 			(void) mkobj_at(SCROLL_SYM, u.ux, u.uy);
X  #endif
X  			break;
X  
X--- 650,658 ----
X  	    case 6:	pline ("An object appears at your %s!",
X  				makeplural(body_part(FOOT)));
X  #ifdef SPELLS
X! 			bless(mkobj_at(SPBOOK_SYM, u.ux, u.uy));
X  #else
X! 			bless(mkobj_at(SCROLL_SYM, u.ux, u.uy));
X  #endif
X  			break;
X  
X***************
X*** 645,657 ****
X  #else
X  	if (u.ugangr++)	angrygods();
X  	else {			/* exactly one warning */
X! #ifdef ALTARS
X! 		pline("The voice of %s booms out:  \"Thou hast angered me.\"",
X  				on_altar() ? a_gname() : u_gname());
X! #else
X! 		pline("A voice booms out:  \"Thou hast angered me.\"");
X! #endif
X! 		pline("\"Disturb me again at thine own risk!\"");
X  	}
X  #endif
X  }
X--- 679,692 ----
X  #else
X  	if (u.ugangr++)	angrygods();
X  	else {			/* exactly one warning */
X! # ifdef ALTARS
X! 		pline("The voice of %s booms out:",
X  				on_altar() ? a_gname() : u_gname());
X! # else
X! 		pline("A voice booms out:");
X! # endif
X! 		verbalize("Thou hast angered me.");
X! 		verbalize("Disturb me again at thine own peril!");
X  	}
X  #endif
X  }
X***************
X*** 665,674 ****
X  register struct obj *otmp;
X  {
X  	if (Hallucination)
X!     pline ("Your sacrifice sprouts wings and a propeller and roars away!");
X  	else if (Blind && u.ualigntyp == U_LAWFUL)
X! 		pline("Your sacrifice disappears!");
X! 	else pline ("Your sacrifice is consumed in a %s!",
X  		    u.ualigntyp == U_LAWFUL ? "flash of light" : "burst of flame");
X  	if (carried(otmp)) useup(otmp);
X  	else useupf(otmp);
X--- 700,709 ----
X  register struct obj *otmp;
X  {
X  	if (Hallucination)
X! 		Your("sacrifice sprouts wings and a propeller and roars away!");
X  	else if (Blind && u.ualigntyp == U_LAWFUL)
X! 		Your("sacrifice disappears!");
X! 	else Your("sacrifice is consumed in a %s!",
X  		    u.ualigntyp == U_LAWFUL ? "flash of light" : "burst of flame");
X  	if (carried(otmp)) useup(otmp);
X  	else useupf(otmp);
X***************
X*** 679,686 ****
X  {
X  	register struct obj *otmp;
X  	int value = 0;
X- 
X  #ifdef ALTARS
X  	if (!on_altar()) {
X  		You("are not standing on an altar.");
X  		return 0;
X--- 714,724 ----
X  {
X  	register struct obj *otmp;
X  	int value = 0;
X  #ifdef ALTARS
X+ 	/* Note: normal altar aligns are 0, 1, 2; this is -1, 0, 1 so it */
X+ 	/* can be compared with u.ualigntyp */
X+ 	int altaralign = (levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1;
X+ 
X  	if (!on_altar()) {
X  		You("are not standing on an altar.");
X  		return 0;
X***************
X*** 726,732 ****
X  			if (u.ualigntyp != U_CHAOTIC)
X  		    pline("You'll regret this infamous offense!");
X  #ifdef ALTARS
X! 		if (levl[u.ux][u.uy].altarmask & ~A_SHRINE) {
X  			/* curse the lawful/neutral altar */
X  			pline("The altar is stained with human blood.");
X  			levl[u.ux][u.uy].altarmask = A_CHAOS;
X--- 764,770 ----
X  			if (u.ualigntyp != U_CHAOTIC)
X  		    pline("You'll regret this infamous offense!");
X  #ifdef ALTARS
X! 		if (altaralign != U_CHAOTIC) {
X  			/* curse the lawful/neutral altar */
X  			pline("The altar is stained with human blood.");
X  			levl[u.ux][u.uy].altarmask = A_CHAOS;
X***************
X*** 735,741 ****
X  			register struct monst *dmon;
X      /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X  #ifdef THEOLOGY
X! 			if (levl[u.ux][u.uy].altarmask & A_SHRINE)
X  				pline("The blood covers the altar!");
X  			else {
X  #endif
X--- 773,779 ----
X  			register struct monst *dmon;
X      /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X  #ifdef THEOLOGY
X! 			if (altaralign == U_CHAOTIC)
X  				pline("The blood covers the altar!");
X  			else {
X  #endif
X***************
X*** 776,788 ****
X  		if (mtmp == &mons[PM_BLACK_UNICORN]) unicalign = -1;
X  		else if (mtmp == &mons[PM_GRAY_UNICORN]) unicalign = 0;
X  		else if (mtmp == &mons[PM_WHITE_UNICORN]) unicalign = 1;
X! 		if (unicalign == u.ualigntyp) {
X  		    pline("Such an action is an insult to %s!", (unicalign== -1)
X  				? "chaos" : unicalign ? "law" : "neutrality");
X  		    adjattrib(A_WIS, -1, TRUE);
X  		    value = -5;
X! 		} else if ((unicalign == -u.ualigntyp) ||
X! 						(!u.ualigntyp && unicalign)) {
X  		    if (u.ualign < ALIGNLIM)
X  			You("feel stridently %s!", (u.ualigntyp== U_CHAOTIC) ?
X  			    "chaotic" : u.ualigntyp ? "lawful" : "neutral");
X--- 814,831 ----
X  		if (mtmp == &mons[PM_BLACK_UNICORN]) unicalign = -1;
X  		else if (mtmp == &mons[PM_GRAY_UNICORN]) unicalign = 0;
X  		else if (mtmp == &mons[PM_WHITE_UNICORN]) unicalign = 1;
X! #ifdef __GNULINT__
X! 		else { impossible("Bad unicorn type??"); unicalign = 0; }
X! #endif
X! 		/* If same as altar, always a very bad action. */
X! 		if (unicalign == altaralign) {
X  		    pline("Such an action is an insult to %s!", (unicalign== -1)
X  				? "chaos" : unicalign ? "law" : "neutrality");
X  		    adjattrib(A_WIS, -1, TRUE);
X  		    value = -5;
X! 		} else if (u.ualigntyp == altaralign) {
X! 		/* If different from altar, and altar is same as yours, */
X! 		/* get maximum alignment */
X  		    if (u.ualign < ALIGNLIM)
X  			You("feel stridently %s!", (u.ualigntyp== U_CHAOTIC) ?
X  			    "chaotic" : u.ualigntyp ? "lawful" : "neutral");
X***************
X*** 789,795 ****
X  		    else You("feel you are thoroughly on the right path.");
X  		    u.ualign = ALIGNLIM;
X  		    value += 3;
X! 		}
X  	    }
X  	}
X  #ifdef ENDGAME
X--- 832,843 ----
X  		    else You("feel you are thoroughly on the right path.");
X  		    u.ualign = ALIGNLIM;
X  		    value += 3;
X! 		} else if (unicalign == u.ualigntyp) {
X! 		/* If sacrificing unicorn of your alignment to altar not of */
X! 		/* your alignment, your god gets angry and it's a conversion */
X! 		    u.ualign = -1;
X! 		    value = 1;
X! 		} else value += 3;
X  	    }
X  	}
X  #ifdef ENDGAME
X***************
X*** 824,831 ****
X  		    if(carried(otmp)) useup(otmp);    /* well, it's gone now */
X  		    else useupf(otmp);
X  		    You("offer the Amulet to %s...", a_gname());
X! 		    if (u.ualigntyp !=
X! 			    (levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1) {
X  			/* And the opposing team picks him up and
X  			       carries him off on their shoulders */
X  		       pline("%s accepts your gift, and gains dominion over %s...",
X--- 872,878 ----
X  		    if(carried(otmp)) useup(otmp);    /* well, it's gone now */
X  		    else useupf(otmp);
X  		    You("offer the Amulet to %s...", a_gname());
X! 		    if (u.ualigntyp != altaralign) {
X  			/* And the opposing team picks him up and
X  			       carries him off on their shoulders */
X  		       pline("%s accepts your gift, and gains dominion over %s...",
X***************
X*** 833,844 ****
X  			pline("%s is enraged...", u_gname());
X  			pline("Fortunately, %s permits you to live...", a_gname());
X  			pline("A cloud of %s smoke surrounds you...",
X! 				Hallucination ? hcolor() : "orange");
X  			done(ESCAPED);
X  		    } else {	    /* super big win */
X  	    pline("An invisible choir sings, and you are bathed in radiance...");
X! 	    pline("\"Congratulations, mortal!  In return for thy service,");
X! 			pline("I grant thee the gift of Immortality!\"");
X  			You("ascend to the status of Demigod...");
X  			done(ASCENDED);
X  		    }
X--- 880,892 ----
X  			pline("%s is enraged...", u_gname());
X  			pline("Fortunately, %s permits you to live...", a_gname());
X  			pline("A cloud of %s smoke surrounds you...",
X! 			    Hallucination ? hcolor() : (const char *)"orange");
X  			done(ESCAPED);
X  		    } else {	    /* super big win */
X  	    pline("An invisible choir sings, and you are bathed in radiance...");
X! 			verbalize("Congratulations, mortal!");
X! 			more();
X! verbalize("In return for thy service, I grant thee the gift of Immortality!");
X  			You("ascend to the status of Demigod...");
X  			done(ASCENDED);
X  		    }
X***************
X*** 872,878 ****
X  	    boolean consumed = FALSE;
X  #ifdef ALTARS
X  	    /* Sacrificing at an altar of a different alignment */
X! 	    if (u.ualigntyp != (levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1) {
X  		/* Is this a conversion ? */
X  		if(ugod_is_angry()) {
X  		    if(u.ualignbase[0] == u.ualignbase[1]) {
X--- 920,926 ----
X  	    boolean consumed = FALSE;
X  #ifdef ALTARS
X  	    /* Sacrificing at an altar of a different alignment */
X! 	    if (u.ualigntyp != altaralign) {
X  		/* Is this a conversion ? */
X  		if(ugod_is_angry()) {
X  		    if(u.ualignbase[0] == u.ualignbase[1]) {
X***************
X*** 883,893 ****
X  			You("have a sudden sense of a new direction.");
X  			/* The player wears a helm of opposite alignment? */
X  			if (uarmh && uarmh->otyp == HELM_OF_OPPOSITE_ALIGNMENT)
X! 			    u.ualignbase[0] =
X! 				(levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1;
X  			else
X! 			    u.ualigntyp = u.ualignbase[0] =
X! 				(levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1;
X  			flags.botl = 1;
X  			/* Beware, Conversion is costly */
X  			change_luck(-3);
X--- 931,939 ----
X  			You("have a sudden sense of a new direction.");
X  			/* The player wears a helm of opposite alignment? */
X  			if (uarmh && uarmh->otyp == HELM_OF_OPPOSITE_ALIGNMENT)
X! 			    u.ualignbase[0] = altaralign;
X  			else
X! 			    u.ualigntyp = u.ualignbase[0] = altaralign;
X  			flags.botl = 1;
X  			/* Beware, Conversion is costly */
X  			change_luck(-3);
X***************
X*** 894,902 ****
X  			u.ublesscnt += 300;
X  			adjalign((int)(u.ualignbase[1] * (ALIGNLIM / 2)));
X  		    } else {
X! 			pline("%s rejects your sacrifice!",a_gname());
X! 			pline("The voice of %s booms:  \"Suffer, infidel!\"",
X! 					u_gname());
X  			adjalign(-5);
X  			u.ugangr += 3;
X  			adjattrib(A_WIS, -2, TRUE);
X--- 940,948 ----
X  			u.ublesscnt += 300;
X  			adjalign((int)(u.ualignbase[1] * (ALIGNLIM / 2)));
X  		    } else {
X! 			pline("%s rejects your sacrifice!", a_gname());
X! 			pline("The voice of %s booms:", u_gname());
X! 			verbalize("Suffer, infidel!");
X  			adjalign(-5);
X  			u.ugangr += 3;
X  			adjattrib(A_WIS, -2, TRUE);
X***************
X*** 921,927 ****
X  			    pline("The newly consecrated altar glows %s.",
X  				Hallucination ? hcolor() :
X  				u.ualigntyp == U_LAWFUL ? white :
X! 				u.ualigntyp ? black : "gray");
X  		    } else {
X  			pline("Unluckily, you feel the power of %s decrease.",
X  					u_gname());
X--- 967,973 ----
X  			    pline("The newly consecrated altar glows %s.",
X  				Hallucination ? hcolor() :
X  				u.ualigntyp == U_LAWFUL ? white :
X! 				u.ualigntyp ? black : (const char *)"gray");
X  		    } else {
X  			pline("Unluckily, you feel the power of %s decrease.",
X  					u_gname());
X***************
X*** 983,988 ****
X--- 1029,1036 ----
X  		if(!rn2(10)) {
X  			otmp = mk_aligned_artifact((unsigned)(levl[u.ux][u.uy].altarmask & ~A_SHRINE));
X  			if(otmp) {
X+ 			    if (otmp->spe < 0) otmp->spe = 0;
X+ 			    if (otmp->cursed) otmp->cursed = 0;
X  			    dropy(otmp);
X  			    pline("An object appears at your %s!",
X  				  makeplural(body_part(FOOT)));
X***************
X*** 993,999 ****
X  		change_luck((value * LUCKMAX) / (MAXVALUE * 2));
X  		if (u.uluck != saved_luck) {
X  		    if (Blind)
X! 			You("think you stepped on something.");
X  		    else You(Hallucination ?
X  		"see crabgrass at your %s.  A funny thing in a dungeon." :
X  		"glimpse a four-leaf clover at your %s.",
X--- 1041,1048 ----
X  		change_luck((value * LUCKMAX) / (MAXVALUE * 2));
X  		if (u.uluck != saved_luck) {
X  		    if (Blind)
X! 			You("think something brushed your %s.",
X! 			    body_part(FOOT));
X  		    else You(Hallucination ?
X  		"see crabgrass at your %s.  A funny thing in a dungeon." :
X  		"glimpse a four-leaf clover at your %s.",
X***************
X*** 1027,1038 ****
X  #ifdef POLYSELF
X  	if (is_undead(uasmon)) {
X  		if (aligntyp == 1 || (aligntyp == 0 && !rn2(10))) {
X! 			pline(aligntyp == 1 ?
X! 			      "\"Vile creature, thou durst call upon me?\"" :
X! 			      "\"Walk no more, perversion of nature!\"");
X  			You("feel like you are falling apart.");
X  			rehumanize();
X! 			losehp(rnd(20), "residual undead turning effect");
X  			return(1);
X  		}
X  	}
X--- 1076,1088 ----
X  #ifdef POLYSELF
X  	if (is_undead(uasmon)) {
X  		if (aligntyp == 1 || (aligntyp == 0 && !rn2(10))) {
X! 			verbalize(aligntyp == 1 ?
X! 			      "Vile creature, thou durst call upon me?" :
X! 			      "Walk no more, perversion of nature!");
X  			You("feel like you are falling apart.");
X  			rehumanize();
X! 			losehp(rnd(20), "residual undead turning effect",
X! 				KILLED_BY_AN);
X  			return(1);
X  		}
X  	}
X***************
X*** 1070,1076 ****
X  		u.ublesscnt += rnz(250);
X  		change_luck(-3);
X  		gods_upset();
X! 	} else if ((int)u.uluck < 0 || u.ugangr || align < 0)
X  		angrygods();			/* naughty */
X  	else	if (align >= 0) pleased();	/* nice */
X  	nomovemsg = "You finish your prayer.";
X--- 1120,1126 ----
X  		u.ublesscnt += rnz(250);
X  		change_luck(-3);
X  		gods_upset();
X! 	} else if ((int)Luck < 0 || u.ugangr || align < 0)
X  		angrygods();			/* naughty */
X  	else	if (align >= 0) pleased();	/* nice */
X  	nomovemsg = "You finish your prayer.";
X***************
X*** 1118,1124 ****
X  #  endif
X  		) {
X  
X! 		pline("For some reason, the gods seem not to listen to you.");
X  		aggravate();
X  		return(0);
X  	}
X--- 1168,1174 ----
X  #  endif
X  		) {
X  
X! 		pline("For some reason, the gods seem to ignore you.");
X  		aggravate();
X  		return(0);
X  	}
X***************
X*** 1144,1150 ****
X  
X  		    if(Confusion) {
X  			pline("Unfortunately, your voice falters.");
X! 			mtmp->mflee = mtmp->mfroz = mtmp->msleep = 0;
X  		    } else if (! resist(mtmp, '\0', 0, TELL))
X  			switch (mtmp->data->mlet) {
X  			    /* this is intentional, lichs are tougher
X--- 1194,1201 ----
X  
X  		    if(Confusion) {
X  			pline("Unfortunately, your voice falters.");
X! 			mtmp->mflee = mtmp->mfrozen = mtmp->msleep = 0;
X! 			mtmp->mcanmove = 1;
X  		    } else if (! resist(mtmp, '\0', 0, TELL))
X  			switch (mtmp->data->mlet) {
X  			    /* this is intentional, lichs are tougher
X***************
X*** 1177,1189 ****
X  }
X  
X  #ifdef ALTARS
X! char *
X  a_gname()
X  {
X  	return(a_gname_at(u.ux, u.uy));
X  }
X  
X! char *
X  a_gname_at(x,y)     /* returns the name of an altar's deity */
X  xchar x, y;
X  {
X--- 1228,1240 ----
X  }
X  
X  #ifdef ALTARS
X! const char *
X  a_gname()
X  {
X  	return(a_gname_at(u.ux, u.uy));
X  }
X  
X! const char *
X  a_gname_at(x,y)     /* returns the name of an altar's deity */
X  xchar x, y;
X  {
X***************
X*** 1223,1234 ****
X  altar_wrath(x, y)
X  register int x, y;
X  {
X!     	if(!strcmp(a_gname_at(x,y), u_gname())) {
X! 	    pline("%s's voice booms:  \"How darest thou desecrate my altar!\"", 
X! 					a_gname_at(x,y));
X  	    adjattrib(A_WIS, -1, FALSE);
X  	} else {
X! 	    pline("A voice whispers in your ear:  \"Thou shalt pay, infidel!\"");
X  	    change_luck(-1);
X  	}
X  }
X--- 1274,1286 ----
X  altar_wrath(x, y)
X  register int x, y;
X  {
X! 	if(!strcmp(a_gname_at(x,y), u_gname())) {
X! 	    pline("The voice of %s booms:", a_gname_at(x,y));
X! 	    verbalize("How darest thou desecrate my altar!");
X  	    adjattrib(A_WIS, -1, FALSE);
X  	} else {
X! 	    pline("A voice whispers in your ear:");
X! 	    verbalize("Thou shalt pay, infidel!");
X  	    change_luck(-1);
X  	}
X  }
X***************
X*** 1236,1242 ****
X  #endif /* ALTARS */
X  
X  #ifdef THEOLOGY
X! char *
X  u_gname() {  /* returns the name of the player's deity */
X  	register struct ghods *aghod;
X  
X--- 1288,1294 ----
X  #endif /* ALTARS */
X  
X  #ifdef THEOLOGY
X! const char *
X  u_gname() {  /* returns the name of the player's deity */
X  	register struct ghods *aghod;
X  
X*** src/Old/pri.c	Mon Feb 19 18:53:47 1990
X--- src/pri.c	Sun Feb 18 16:31:50 1990
X***************
X*** 2,9 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include "hack.h"
X  #include <ctype.h>  /* for isalpha() */
X  #if defined(ALTARS) && defined(THEOLOGY)
X--- 2,9 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  #include <ctype.h>  /* for isalpha() */
X  #if defined(ALTARS) && defined(THEOLOGY)
X***************
X*** 11,21 ****
X  #endif
X  #include "termcap.h"
X  
X! static void FDECL(hilite, (int,int,UCHAR_P, UCHAR_P));
X! static void FDECL(cornbot, (int));
X! static boolean FDECL(ismnst, (CHAR_P));
X  #ifdef TEXTCOLOR
X! static uchar FDECL(mimic_color, (UCHAR_P));
X  #endif
X  
X  #ifndef ASCIIGRAPH
X--- 11,20 ----
X  #endif
X  #include "termcap.h"
X  
X! OSTATIC void FDECL(hilite, (int,int,UCHAR_P, UCHAR_P));
X! OSTATIC void FDECL(cornbot, (int));
X  #ifdef TEXTCOLOR
X! OSTATIC uchar FDECL(mimic_color, (struct monst *));
X  #endif
X  
X  #ifndef ASCIIGRAPH
X***************
X*** 23,41 ****
X  #endif
X  
X  #ifndef g_putch
X  static boolean GFlag = FALSE; /* graphic flag */
X  #endif
X  
X  /* 100 suffices for bot(); must be larger than COLNO */
X  #define MAXCO 100
X! static char oldbot1[MAXCO], newbot1[MAXCO];
X! static char oldbot2[MAXCO], newbot2[MAXCO];
X  static const char *dispst = "*0#@#0#*0#@#0#*0#@#0#*0#@#0#*0#@#0#*";
X! static int mrank_sz = 0;  /* loaded by max_rank_sz (called in u_init) */
X  
X! #ifdef CLIPPING
X! #define curs(x, y) win_curs((x), (y)-2)
X! #endif
X  
X  void
X  swallowed(first)
X--- 22,61 ----
X  #endif
X  
X  #ifndef g_putch
X+ #ifdef OVL0
X  static boolean GFlag = FALSE; /* graphic flag */
X+ #endif /* OVL0 */
X  #endif
X  
X  /* 100 suffices for bot(); must be larger than COLNO */
X  #define MAXCO 100
X! VSTATIC char oldbot1[MAXCO], newbot1[MAXCO];
X! VSTATIC char oldbot2[MAXCO], newbot2[MAXCO];
X! #ifdef OVL2
X  static const char *dispst = "*0#@#0#*0#@#0#*0#@#0#*0#@#0#*0#@#0#*";
X! #endif /* OVL2 */
X! #ifndef OVLB
X! OSTATIC int mrank_sz;
X! #else /* OVLB */
X! XSTATIC int mrank_sz = 0;  /* loaded by max_rank_sz (called in u_init) */
X! #endif /* OVLB */
X! 
X! #ifdef CLIPPING
X! #define curs(x, y) (void) win_curs((x), (y)-2)
X! #endif
X! 
X! #ifdef OVL0
X! 
X! char *
X! eos(s)
X! register char *s;
X! {
X! 	while(*s) s++;
X! 	return(s);
X! }
X  
X! #endif /* OVL0 */
X! #ifdef OVLB
X  
X  void
X  swallowed(first)
X***************
X*** 135,145 ****
X  			u.udispl = 0;
X  			levl[u.udisx][u.udisy].scrsym = news0(u.udisx, u.udisy);
X  		}
X! 		doredraw();
X  	}
X  }
X  #endif /* CLIPPING */
X  
X  /*
X   *  Allow for a different implementation than this...
X   */
X--- 155,168 ----
X  			u.udispl = 0;
X  			levl[u.udisx][u.udisy].scrsym = news0(u.udisx, u.udisy);
X  		}
X! 		(void) doredraw();
X  	}
X  }
X  #endif /* CLIPPING */
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /*
X   *  Allow for a different implementation than this...
X   */
X***************
X*** 224,229 ****
X--- 247,255 ----
X  #endif
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  prme(){
X  	if(!Invisible
X***************
X*** 236,246 ****
X  	}
X  }
X  
X  void
X  shieldeff(x, y)		/* produce a magical shield effect at x,y */
X  	register xchar x, y;
X  {
X! 	register char *ch;
X  	register struct monst *mtmp = 0;
X  
X  	if((x != u.ux) || (y != u.uy)) {
X--- 262,275 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  void
X  shieldeff(x, y)		/* produce a magical shield effect at x,y */
X  	register xchar x, y;
X  {
X! 	register const char *ch;
X  	register struct monst *mtmp = 0;
X  
X  	if((x != u.ux) || (y != u.uy)) {
X***************
X*** 276,281 ****
X--- 305,313 ----
X  	return;
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  int
X  doredraw()
X  {
X***************
X*** 283,288 ****
X--- 315,323 ----
X  	return 0;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  docrt()
X  {
X***************
X*** 318,324 ****
X  		mtmp->mdispl = 0;
X  	seemons();	/* force new positions to be shown */
X  
X! #if ((defined(DGK) && !defined(TEXTCOLOR)) || defined(MACOS)) & !defined(CLIPPING)
X  # ifdef MACOS
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	if (!t->inColor)
X--- 353,359 ----
X  		mtmp->mdispl = 0;
X  	seemons();	/* force new positions to be shown */
X  
X! #if ((defined(DGK) && !defined(TEXTCOLOR)) || defined(MACOS)) && !defined(CLIPPING)
X  # ifdef MACOS
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	if (!t->inColor)
X***************
X*** 329,339 ****
X  		for(y = 0; y < ROWNO; y++) {
X  			char buf[COLNO+1];
X  			int start, end;
X! # if defined(OLD_TOS) || defined(LSC) || defined(AZTEC)
X  			setmem(buf, COLNO, ' ');
X  # else
X  			memset(buf, ' ', COLNO);
X! # endif /* OLD_TOS */
X  			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X  				if((room = &levl[x][y])->new) {
X  					room->new = 0;
X--- 364,374 ----
X  		for(y = 0; y < ROWNO; y++) {
X  			char buf[COLNO+1];
X  			int start, end;
X! # if defined(LSC) || defined(AZTEC) || defined(AZTEC_C)
X  			setmem(buf, COLNO, ' ');
X  # else
X  			memset(buf, ' ', COLNO);
X! # endif
X  			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X  				if((room = &levl[x][y])->new) {
X  					room->new = 0;
X***************
X*** 391,397 ****
X  	bot();
X  }
X  
X! static void
X  cornbot(lth)
X  register int lth;
X  {
X--- 426,435 ----
X  	bot();
X  }
X  
X! #endif /* OVL0 */
X! #ifdef OVLB
X! 
X! XSTATIC void
X  cornbot(lth)
X  register int lth;
X  {
X***************
X*** 400,405 ****
X--- 438,446 ----
X  	flags.botl = 1;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  docorner(xmin, ymax)
X  register int xmin, ymax;
X***************
X*** 467,472 ****
X--- 508,516 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  void
X  seeglds()
X  {
X***************
X*** 532,537 ****
X--- 576,584 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  void
X  seemons()
X  {
X***************
X*** 564,577 ****
X  	    if (Hallucination)
X  	    atl(mon->mx,mon->my,
X  		(char) ((!mon->mimic || Protection_from_shape_changers) ?
X! 		rndmonsym() : (mon->mappearance == CLOSED_DOOR_SYM) ?
X! 		CLOSED_DOOR_SYM : rndobjsym()));
X  	    else
X  
X  		atl(mon->mx,mon->my,
X! 		    (!mon->mappearance ||
X  		     Protection_from_shape_changers) ?
X! 		     mon->data->mlet : mon->mappearance);
X  		mon->mdispl = 1;
X  		mon->mdx = mon->mx;
X  		mon->mdy = mon->my;
X--- 611,624 ----
X  	    if (Hallucination)
X  	    atl(mon->mx,mon->my,
X  		(char) ((!mon->mimic || Protection_from_shape_changers) ?
X! 		rndmonsym() : (mon->m_ap_type == M_AP_FURNITURE) ?
X! 		showsyms[mon->mappearance] : rndobjsym()));
X  	    else
X  
X  		atl(mon->mx,mon->my,
X! 		    (!mon->m_ap_type ||
X  		     Protection_from_shape_changers) ?
X! 		     mon->data->mlet : (char) mimic_appearance(mon));
X  		mon->mdispl = 1;
X  		mon->mdx = mon->mx;
X  		mon->mdy = mon->my;
X***************
X*** 584,589 ****
X--- 631,639 ----
X  #endif
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  void
X  unpmon(mon)
X  register struct monst *mon;
X***************
X*** 594,599 ****
X--- 644,652 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  void
X  nscr() {
X  	register int x, y;
X***************
X*** 618,623 ****
X--- 671,679 ----
X  	scrly = ROWNO;
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  /* Make sure that there are 18 entries in the rank arrays. */
X  /* 0 and even entries are male ranks, odd entries are female. */
X  
X***************
X*** 873,879 ****
X  	"Elentari", 	/* Star-queen (Q.) */ /* Elbereth (S.) */
X  };
X  
X! static const char **
X  rank_array() {
X  	register const char **ranks;
X  
X--- 929,941 ----
X  	"Elentari", 	/* Star-queen (Q.) */ /* Elbereth (S.) */
X  };
X  
X! #endif /* OVL1 */
X! 
X! OSTATIC const char **NDECL(rank_array);
X! 
X! #ifdef OVL1
X! 
X! XSTATIC const char **
X  rank_array() {
X  	register const char **ranks;
X  
X***************
X*** 895,901 ****
X  	return(ranks);
X  }
X  
X! static char *
X  rank() {
X  	register int place;
X  	register const char **ranks = rank_array();
X--- 957,969 ----
X  	return(ranks);
X  }
X  
X! #endif /* OVL1 */
X! 
X! OSTATIC const char *rank();
X! 
X! #ifdef OVL1
X! 
X! XSTATIC const char *
X  rank() {
X  	register int place;
X  	register const char **ranks = rank_array();
X***************
X*** 915,920 ****
X--- 983,991 ----
X  	return(pl_character);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  max_rank_sz() {
X  	register int i, maxr = 0;
X***************
X*** 928,933 ****
X--- 999,1007 ----
X  	else mrank_sz = strlen(pl_character);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  static void
X  fillbot(row,oldbot,newbot)
X  int row;
X***************
X*** 1094,1100 ****
X  	}
X  	if(Confusion)	   Sprintf(eos(newbot2), " Conf");
X  	if(Sick)	   Sprintf(eos(newbot2), " Sick");
X! 	if(Blinded)	   Sprintf(eos(newbot2), " Blind");
X  	if(Stunned)	   Sprintf(eos(newbot2), " Stun");
X  	if(Hallucination)  Sprintf(eos(newbot2), " Hallu");
X  #ifdef CLIPPING
X--- 1168,1174 ----
X  	}
X  	if(Confusion)	   Sprintf(eos(newbot2), " Conf");
X  	if(Sick)	   Sprintf(eos(newbot2), " Sick");
X! 	if(Blind)	   Sprintf(eos(newbot2), " Blind");
X  	if(Stunned)	   Sprintf(eos(newbot2), " Stun");
X  	if(Hallucination)  Sprintf(eos(newbot2), " Hallu");
X  #ifdef CLIPPING
X***************
X*** 1113,1118 ****
X--- 1187,1194 ----
X  	flags.botl = flags.botlx = 0;
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X  
X  void
X  mstatusline(mtmp)
X***************
X*** 1171,1176 ****
X--- 1247,1255 ----
X  	flags.botlx = 1;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  char
X  rndmonsym()
X  {
X***************
X*** 1177,1183 ****
X  	return(mons[rn2(NUMMONS - 1)].mlet);
X  }
X  
X! static const char objsyms[] = {
X  	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X--- 1256,1267 ----
X  	return(mons[rn2(NUMMONS - 1)].mlet);
X  }
X  
X! /*
X!  * we don't use objsyms here because (someday) objsyms may be
X!  * user programmable
X!  */
X! 
X! static const char rndobs[] = {
X  	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X***************
X*** 1187,1193 ****
X  char
X  rndobjsym()
X  {
X! 	return objsyms[rn2(SIZE(objsyms))];
X  }
X  
X  static const char *hcolors[] = {
X--- 1271,1277 ----
X  char
X  rndobjsym()
X  {
X! 	return rndobs[rn2(SIZE(rndobs))];
X  }
X  
X  static const char *hcolors[] = {
X***************
X*** 1209,1220 ****
X  	return hcolors[rn2(SIZE(hcolors))];
X  }
X  
X  /*ARGSUSED*/
X! static void
X  hilite(x, y, let, typ)
X  int x, y;
X  uchar let, typ;
X  {
X  	if (let == ' '
X  #if !defined(MSDOS) && !defined(MACOS)
X  	    || !flags.standout
X--- 1293,1310 ----
X  	return hcolors[rn2(SIZE(hcolors))];
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL0
X+ 
X  /*ARGSUSED*/
X! XSTATIC void
X  hilite(x, y, let, typ)
X  int x, y;
X  uchar let, typ;
X  {
X+ #ifdef TEXTCOLOR
X+ 	boolean colorit;
X+ #endif
X  	if (let == ' '
X  #if !defined(MSDOS) && !defined(MACOS)
X  	    || !flags.standout
X***************
X*** 1233,1244 ****
X  			 || let == S_MIMIC_DEF)
X  			/* is an object */
X  			typ = AT_OBJ;
X! 		else if (ismnst((char) let))
X  			/* is a monster */
X  			typ = AT_MON;
X  	}
X  #ifdef TEXTCOLOR
X! 	if (flags.use_color) {
X  	    switch (typ) {
X  		case AT_MON:
X  		    switch (let) {
X--- 1323,1341 ----
X  			 || let == S_MIMIC_DEF)
X  			/* is an object */
X  			typ = AT_OBJ;
X! 		else if (vism_at(x, y))
X  			/* is a monster */
X  			typ = AT_MON;
X  	}
X  #ifdef TEXTCOLOR
X! # ifdef REINCARNATION
X! 	colorit = flags.use_color && dlevel != rogue_level;
X! # else
X! 	colorit = flags.use_color;
X! # endif
X! 	if (colorit) {
X! 	    struct monst *mtmp;
X! 
X  	    switch (typ) {
X  		case AT_MON:
X  		    switch (let) {
X***************
X*** 1246,1255 ****
X  			    typ = HI_OBJ;
X  			    break;
X  		        default:
X! 			    if (u.ux == x && u.uy == y)
X  				typ = uasmon->mcolor;
X! 			    else if (level.monsters[x][y])
X! 			        typ = level.monsters[x][y]->data->mcolor;
X  			    else
X  				typ = 0;
X  		    }
X--- 1343,1354 ----
X  			    typ = HI_OBJ;
X  			    break;
X  		        default:
X! 			    if (u.ux == x && u.uy == y && u.usym == let)
X  				typ = uasmon->mcolor;
X! 			    else if (mtmp = m_at(x, y))
X! 			        typ = mtmp->m_ap_type ?
X! 					mimic_color(mtmp) :
X! 					mtmp->data->mcolor;
X  			    else
X  				typ = 0;
X  		    }
X***************
X*** 1266,1274 ****
X  			    typ = mons[otmp->corpsenm].mcolor;
X  			else
X  			    typ = objects[level.objects[x][y]->otyp].oc_color;
X! 		    }
X! 		    else
X! 			typ = mimic_color(let);
X  		    }
X  		    break;
X  		case AT_MAP:
X--- 1365,1372 ----
X  			    typ = mons[otmp->corpsenm].mcolor;
X  			else
X  			    typ = objects[level.objects[x][y]->otyp].oc_color;
X! 		     } else
X! 			typ = mimic_color(m_at(x, y));
X  		    }
X  		    break;
X  		case AT_MAP:
X***************
X*** 1295,1347 ****
X  		    break;
X  		}
X  	}
X! 	if (typ && flags.use_color)
X! 		xputs(hilites[typ]);
X  	else
X  #endif
X  	if (typ == AT_MON) revbeg();
X! 
X  	g_putch(let);
X  
X  #ifdef TEXTCOLOR
X! 	if (typ && flags.use_color) xputs(HE); else
X  #endif
X  	if (typ == AT_MON) m_end();
X  }
X  
X! static boolean
X! ismnst(let)
X! char let;
X! {
X! 	register int ct;
X! 	register struct permonst *ptr;
X! 
X! 	if (let & 0x80) return 0;
X! 	if (isalpha(let)) return 1; /* for speed */
X  
X! 	for (ct = 0 ; ct < NUMMONS; ct++) {
X! 		ptr = &mons[ct];
X! 		if(ptr->mlet == let) return 1;
X  	}
X! #ifdef WORM
X! 	if (let == S_WORM_TAIL) return 1;
X! #endif
X! 	return 0;
X  }
X  
X  #ifdef TEXTCOLOR
X  /* pick an appropriate color for a mimic imitating an object */
X  
X! static uchar
X! mimic_color(let)
X! uchar let;
X  {
X! 	int i;
X! 
X! 	for(i = 0; i < NROFOBJECTS; i++) {
X! 		if (objects[i].oc_olet == let)
X! 			return objects[i].oc_color;
X  	}
X- 	return HI_OBJ;
X  }
X  #endif
X--- 1393,1476 ----
X  		    break;
X  		}
X  	}
X! 	if (typ && colorit)
X! 		xputs(hilites[Hallucination ? rn2(MAXCOLORS) : typ]);
X  	else
X  #endif
X+ #ifdef REINCARNATION
X+ 	if (typ == AT_MON && dlevel != rogue_level) revbeg();
X+ #else
X  	if (typ == AT_MON) revbeg();
X! #endif
X  	g_putch(let);
X  
X  #ifdef TEXTCOLOR
X! 	if (typ && colorit) xputs(HE); else
X  #endif
X+ #ifdef REINCARNATION
X+ 	if (typ == AT_MON && dlevel != rogue_level) m_end();
X+ #else
X  	if (typ == AT_MON) m_end();
X+ #endif
X  }
X  
X! #endif /* OVL0 */
X! #ifdef OVL2
X! 
X! /*
X!  * find the appropriate symbol for printing a mimic
X!  */
X  
X! uchar
X! mimic_appearance(mon)
X! struct monst *mon;
X! {
X! 	switch(mon->m_ap_type) {
X! 	case M_AP_NOTHING:
X! 		return mon->data->mlet;
X! 	case M_AP_FURNITURE:
X! 		return showsyms[mon->mappearance];
X! 	case M_AP_OBJECT:
X! 		return objects[mon->mappearance].oc_olet;
X! 	case M_AP_MONSTER:
X! 		return mons[mon->mappearance].mlet;
X! 	case M_AP_GOLD:
X! 		return GOLD_SYM;
X! 	default:
X! 		impossible("Monster mimicking %d", mon->m_ap_type);
X! 		return 0;
X  	}
X! /*NOTREACHED*/
X  }
X  
X  #ifdef TEXTCOLOR
X  /* pick an appropriate color for a mimic imitating an object */
X  
X! XSTATIC uchar
X! mimic_color(mtmp)
X! struct monst *mtmp;
X  {
X! 	if (!mtmp)
X! 		return 0;
X! 	switch (mtmp->m_ap_type) {
X! 	case M_AP_NOTHING:
X! 		return mtmp->data->mcolor;
X! 	case M_AP_FURNITURE:
X! # ifdef FOUNTAINS
X! 		if (mtmp->mappearance == S_fountain && hilites[BLUE] != HI)
X! 			return BLUE;
X! # endif
X! 		return 0;
X! 	case M_AP_OBJECT:
X! 		return objects[mtmp->mappearance].oc_color;
X! 	case M_AP_MONSTER:
X! 		return mons[mtmp->mappearance].mcolor;
X! 	case M_AP_GOLD:
X! 		return HI_GOLD;
X! 	default:
X! 		return 0;
X  	}
X  }
X  #endif
X+ 
X+ #endif /* OVL2 */
X
END_OF_FILE
if test 57309 -ne `wc -c <'patch7.06'`; then
    echo shar: \"'patch7.06'\" unpacked with wrong size!
fi
# end of 'patch7.06'
echo shar: End of archive 2 \(of 30\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
