Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!brutus.cs.uiuc.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i008:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7h
Message-ID: <5222@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:34:39 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2354
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 8
Archive-name: NetHack3/Patch7h
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 30)."
# Contents:  patch7.04
# Wrapped by billr@saab on Wed Feb 21 10:04:29 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.04' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.04'\" to \"'patch7.04.orig'\"
  mv -f 'patch7.04' 'patch7.04.orig'
fi
echo shar: Extracting \"'patch7.04'\" \(56054 characters\)
sed "s/^X//" >'patch7.04' <<'END_OF_FILE'
X*** src/Old/end.c	Mon Feb 19 18:02:33 1990
X--- src/end.c	Mon Feb 19 13:40:25 1990
X***************
X*** 2,10 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X- #define NEED_VARARGS
X  
X  #include "hack.h"
X  #ifndef NO_SIGNAL
X--- 2,10 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X+ #define NEED_VARARGS	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  
X  #include "hack.h"
X  #ifndef NO_SIGNAL
X***************
X*** 13,19 ****
X  
X  #include "eshk.h"
X  
X! void end_box_display();
X  
X  static const char *deaths[] = {		/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X--- 13,20 ----
X  
X  #include "eshk.h"
X  
X! void NDECL(end_box_display);
X! static int NDECL(done_intr);
X  
X  static const char *deaths[] = {		/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X***************
X*** 49,56 ****
X--- 50,62 ----
X  int
X  done2()
X  {
X+ #ifdef MACOS
X+ 	if(!flags.silent) SysBeep(1);
X+ 	if(UseMacAlert(128) != 1) {
X+ #else
X  	pline("Really quit? ");
X  	if(yn() == 'n') {
X+ #endif
X  #ifndef NO_SIGNAL
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X***************
X*** 61,80 ****
X  		multi = 0;
X  		return 0;
X  	}
X! #if defined(WIZARD) && (defined(UNIX) || defined(VMS))
X  	if(wizard) {
X! #ifdef VMS
X  	    pline("Enter debugger? ");
X! #else
X  	    pline("Dump core? ");
X! #endif
X  	    if(yn() == 'y') {
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  		settty(NULL);
X! #ifdef SYSV
X  		(void)
X! #endif
X  		    abort();
X  	    }
X  	}
X  #endif
X--- 67,95 ----
X  		multi = 0;
X  		return 0;
X  	}
X! #if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE))
X  	if(wizard) {
X! # ifdef VMS
X  	    pline("Enter debugger? ");
X! # else
X! #  ifdef LATTICE
X! 	    pline("Create SnapShot? ");
X! #  else
X  	    pline("Dump core? ");
X! #  endif
X! # endif
X! /* KL - do I need to change the next 3 lines? */
X  	    if(yn() == 'y') {
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  		settty(NULL);
X! #ifdef AMIGA
X! 		Abort(0);
X! #else
X! # ifdef SYSV
X  		(void)
X! # endif
X  		    abort();
X+ #endif
X  	    }
X  	}
X  #endif
X***************
X*** 90,99 ****
X  	done_stopprint++;
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X! #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, SIG_IGN);
X! #endif
X! #endif /* TOS /* */
X  	return 0;
X  }
X  
X--- 105,114 ----
X  	done_stopprint++;
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X! # if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, SIG_IGN);
X! # endif
X! #endif /* NO_SIGNAL /* */
X  	return 0;
X  }
X  
X***************
X*** 116,123 ****
X  
X  	You("die...");
X  	buf[0] = '\0';
X! 	if (mtmp->iswiz)
X  		Strcat(buf, "the ");
X  	if (mtmp->minvis)
X  		Strcat(buf, "invisible ");
X  	if (Hallucination)
X--- 131,140 ----
X  
X  	You("die...");
X  	buf[0] = '\0';
X! 	if (mtmp->iswiz) {
X  		Strcat(buf, "the ");
X+ 		killer_format = KILLED_BY;
X+ 	}
X  	if (mtmp->minvis)
X  		Strcat(buf, "invisible ");
X  	if (Hallucination)
X***************
X*** 125,136 ****
X  
X  	if(mtmp->data->mlet == S_GHOST) {
X  		register char *gn = (char *) mtmp->mextra;
X! 		if (!Hallucination && !mtmp->minvis && *gn)
X  			Strcat(buf, "the ");
X  		Sprintf(eos(buf), (*gn ? "ghost of %s" : "ghost%s"), gn);
X  	} else if(mtmp->isshk) {
X  		Sprintf(eos(buf), "%s %s, the shopkeeper",
X  			(ESHK(mtmp)->ismale ? "Mr." : "Ms."), shkname(mtmp));
X  	} else Strcat(buf, mtmp->data->mname);
X  	if (mtmp->mnamelth) Sprintf(eos(buf), " called %s", NAME(mtmp));
X  	killer = buf;
X--- 142,156 ----
X  
X  	if(mtmp->data->mlet == S_GHOST) {
X  		register char *gn = (char *) mtmp->mextra;
X! 		if (!Hallucination && !mtmp->minvis && *gn) {
X  			Strcat(buf, "the ");
X+ 			killer_format = KILLED_BY;
X+ 		}
X  		Sprintf(eos(buf), (*gn ? "ghost of %s" : "ghost%s"), gn);
X  	} else if(mtmp->isshk) {
X  		Sprintf(eos(buf), "%s %s, the shopkeeper",
X  			(ESHK(mtmp)->ismale ? "Mr." : "Ms."), shkname(mtmp));
X+ 		killer_format = KILLED_BY;
X  	} else Strcat(buf, mtmp->data->mname);
X  	if (mtmp->mnamelth) Sprintf(eos(buf), " called %s", NAME(mtmp));
X  	killer = buf;
X***************
X*** 155,174 ****
X  extern boolean hu;	/* from save.c */
X  
X  void
X! panic VA_DECL(char *, str)
X  	VA_START(str);
X  	VA_INIT(str, char *);
X- #ifdef MACOS
X- 	puts(str);
X- 	more();
X- #endif
X  
X  	if(panicking++)
X! #ifdef SYSV
X  	    (void)
X! #endif
X  		abort();    /* avoid loops - this should never happen*/
X  				    /* was exit(1) */
X  	home(); cls();
X  	(void) puts(" Suddenly, the dungeon collapses.");
X  #if defined(WIZARD) && !defined(MSDOS)
X--- 175,194 ----
X  extern boolean hu;	/* from save.c */
X  
X  void
X! panic VA_DECL(const char *, str)
X  	VA_START(str);
X  	VA_INIT(str, char *);
X  
X  	if(panicking++)
X! #ifdef AMIGA
X! 	    Abort(0);
X! #else
X! # ifdef SYSV
X  	    (void)
X! # endif
X  		abort();    /* avoid loops - this should never happen*/
X  				    /* was exit(1) */
X+ #endif
X  	home(); cls();
X  	(void) puts(" Suddenly, the dungeon collapses.");
X  #if defined(WIZARD) && !defined(MSDOS)
X***************
X*** 195,208 ****
X  #else
X  	(void) fputs(" ERROR:  ", stdout);
X  #endif
X  	Vprintf(str,VA_ARGS);
X  	more();				/* contains a fflush() */
X! #if defined(WIZARD) && (defined(UNIX) || defined(VMS))
X  	if (wizard)
X! # ifdef SYSV
X  		(void)
X! # endif
X  		    abort();	/* generate core dump */
X  #endif
X  	VA_END();
X  	done(PANICKED);
X--- 215,240 ----
X  #else
X  	(void) fputs(" ERROR:  ", stdout);
X  #endif
X+ #ifdef LATTICE
X+ 	{
X+ 	char pbuf[100];
X+ 	vsprintf(pbuf,str,VA_ARGS);
X+ 	(void)puts(pbuf);
X+ 	}
X+ #else
X  	Vprintf(str,VA_ARGS);
X+ #endif
X  	more();				/* contains a fflush() */
X! #if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE))
X  	if (wizard)
X! # ifdef AMIGA
X! 		Abort(0);
X! # else
X! #  ifdef SYSV
X  		(void)
X! #  endif
X  		    abort();	/* generate core dump */
X+ # endif
X  #endif
X  	VA_END();
X  	done(PANICKED);
X***************
X*** 213,231 ****
X  done(how)
X  int how;
X  {
X  	struct permonst *upmon;
X! 	char buf[BUFSZ], buf2[BUFSZ], buf3[BUFSZ];
X! 	/* buf: used if killer gets changed
X  	 * buf2: same as player name, except it is capitalized
X- 	 * buf3: used to copy killer in case it comes from something like
X- 		xname(), which would otherwise get overwritten when we call
X- 		xname() when listing possessions
X  	 */
X  	char	c;
X  	boolean taken;
X! 
X! 	Strcpy(buf3, (!killer || how >= PANICKED ? deaths[how] : killer));
X! 	killer = buf3;
X  #ifdef WIZARD
X  	if (wizard && how == TRICKED) {
X  		You("are a very tricky wizard, it seems.");
X--- 245,272 ----
X  done(how)
X  int how;
X  {
X+ #ifdef MACOS
X+ 	int see_c;
X+ 	char mac_buf[80];
X+ #endif
X  	struct permonst *upmon;
X! 	char kilbuf[BUFSZ], buf2[BUFSZ];
X! 	/* kilbuf: used to copy killer in case it comes from something like
X! 	 *	xname(), which would otherwise get overwritten when we call
X! 	 *	xname() when listing possessions
X  	 * buf2: same as player name, except it is capitalized
X  	 */
X  	char	c;
X  	boolean taken;
X! #ifdef ENDGAME
X! 	if (how == ASCENDED)
X! 		killer_format = NO_KILLER_PREFIX;
X! #endif
X! 	/* Avoid killed by "a" burning or "a" starvation */
X! 	if (!killer && (how == STARVING || how == BURNING))
X! 		killer_format = KILLED_BY;
X! 	Strcpy(kilbuf, (!killer || how >= PANICKED ? deaths[how] : killer));
X! 	killer = kilbuf;
X  #ifdef WIZARD
X  	if (wizard && how == TRICKED) {
X  		You("are a very tricky wizard, it seems.");
X***************
X*** 280,289 ****
X  die:
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
X! #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X! #endif
X  #endif /* NO_SIGNAL /* */
X  	upmon = player_mon();
X  	if(u.ugrave_arise > -1) /* create no corpse */ ;
X--- 321,330 ----
X  die:
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
X! # if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X! # endif
X  #endif /* NO_SIGNAL /* */
X  	upmon = player_mon();
X  	if(u.ugrave_arise > -1) /* create no corpse */ ;
X***************
X*** 297,307 ****
X  		(void) mk_named_object(CORPSE, upmon, u.ux, u.uy, plname,
X  							strlen(plname));
X  
X! 	if(how == QUIT && u.uhp < 1) {
X! 		how = DIED;
X! 		Strcpy(buf, "quit while already on Charon's boat");
X! 		killer = buf;
X  	}
X  	taken = paybill();
X  	paygd();
X  	clearlocks();
X--- 338,352 ----
X  		(void) mk_named_object(CORPSE, upmon, u.ux, u.uy, plname,
X  							strlen(plname));
X  
X! 	if (how == QUIT) {
X! 		killer_format = NO_KILLER_PREFIX;
X! 		if (u.uhp < 1) {
X! 			how = DIED;
X! /* note that killer is pointing at kilbuf */
X! 			Strcpy(kilbuf, "quit while already on Charon's boat");
X! 		}
X  	}
X+ 	if (how == ESCAPED) killer_format = NO_KILLER_PREFIX;
X  	taken = paybill();
X  	paygd();
X  	clearlocks();
X***************
X*** 308,320 ****
X  	if(flags.toplin == 1) more();
X  
X  	if(invent) {
X  	    if(taken)
X  		pline("Do you want to see what you had when you %s? ",
X  			(how == QUIT) ? "quit" : "died");
X  	    else
X  		pline("Do you want your possessions identified? ");
X- 	    /* New dump format by maartenj@cs.vu.nl */
X  	    if ((c = yn_function(ynqchars,'y')) == 'y') {
X  		struct obj *obj;
X  
X  		for(obj = invent; obj && !done_stopprint; obj = obj->nobj) {
X--- 353,381 ----
X  	if(flags.toplin == 1) more();
X  
X  	if(invent) {
X+ #ifndef MACOS
X  	    if(taken)
X  		pline("Do you want to see what you had when you %s? ",
X  			(how == QUIT) ? "quit" : "died");
X  	    else
X  		pline("Do you want your possessions identified? ");
X  	    if ((c = yn_function(ynqchars,'y')) == 'y') {
X+ #else
X+ 		{
X+ 			extern short macflags;
X+ 		
X+ 			/* stop user from using menus, etc. */
X+ 			macflags &= ~(fDoNonKeyEvt | fDoUpdate);
X+ 		}
X+ 	    if(taken)
X+ 		sprintf(mac_buf, "Do you want to see what you had when you %s? ",
X+ 			(how == QUIT) ? "quit" : "died");
X+ 	    else
X+ 		sprintf(mac_buf, "Do you want your possessions identified? ");
X+ 		if(!flags.silent) SysBeep(1);
X+ 	    if ((c = "qqynq"[UseMacAlertText(129,mac_buf)+1]) == 'y') {
X+ #endif
X+ 	    /* New dump format by maartenj@cs.vu.nl */
X  		struct obj *obj;
X  
X  		for(obj = invent; obj && !done_stopprint; obj = obj->nobj) {
X***************
X*** 339,361 ****
X  	    }
X  	}
X  
X  	if(how < GENOCIDED) {
X  #ifdef WIZARD
X  	    if(wizard) {
X  		pline("Save bones? ");
X  		if(yn() == 'y') savebones();
X  	    }  else
X  #endif
X! 		savebones();
X  	    if(!flags.notombstone) outrip();
X  	}
X! 	if(how == STONING) {
X! 		Strcpy(buf, "turned to stone by ");
X! 		Strcat(buf, killer);
X! 		/* No a or an; topten.c will do that. */
X! 		killer = buf;
X! 	}
X! 	if(u.uhave_amulet) Strcat(killer, " (with the Amulet)");
X  	settty(NULL);	/* does a clear_screen() */
X  	Strcpy(buf2, plname);
X  	if('a' <= buf2[0] && buf2[0] <= 'z') buf2[0] += 'A'-'a';
X--- 400,437 ----
X  	    }
X  	}
X  
X+ 	if (!done_stopprint) {
X+ #ifdef MACOS
X+ 		c = "qqynq"[UseMacAlertText(129, "Do you want to see your instrinsics ?")+1];
X+ #else
X+ 	    pline("Do you want to see your intrinsics? ");
X+ 	    c = yn_function(ynqchars, 'y');
X+ #endif
X+ 	    if (c == 'y') enlightenment();
X+ 	    if (c == 'q') done_stopprint++;
X+ 	}
X+ 
X  	if(how < GENOCIDED) {
X  #ifdef WIZARD
X  	    if(wizard) {
X+ #ifdef MACOS
X+ 		if(!flags.silent) SysBeep(20);
X+ 		if(UseMacAlertText(128, "Save bones ?") == 1) savebones();
X+ #else
X  		pline("Save bones? ");
X  		if(yn() == 'y') savebones();
X+ #endif
X  	    }  else
X  #endif
X! 		if (how != PANICKED && how !=TRICKED)
X! 			savebones();
X  	    if(!flags.notombstone) outrip();
X  	}
X! 
X! /* changing kilbuf really changes killer. we do it this way because
X!    killer is declared a (const char *)
X! */
X! 	if(u.uhave_amulet) Strcat(kilbuf, " (with the Amulet)");
X  	settty(NULL);	/* does a clear_screen() */
X  	Strcpy(buf2, plname);
X  	if('a' <= buf2[0] && buf2[0] <= 'z') buf2[0] += 'A'-'a';
X***************
X*** 362,369 ****
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   how != ASCENDED ? pl_character :
X! 		   flags.female ? "Demigoddess" : "Demigod");
X  #else
X  		   pl_character);
X  #endif
X--- 438,446 ----
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   how != ASCENDED ? (const char *)pl_character :
X! 		   flags.female ? (const char *)"Demigoddess" : 
X! 			(const char *)"Demigod");
X  #else
X  		   pl_character);
X  #endif
X***************
X*** 467,484 ****
X  	if(!done_stopprint)
X    Printf("You were level %u with a maximum of %d hit points when you %s.\n",
X  	    u.ulevel, u.uhpmax, ends[how]);
X! 	if(how == ESCAPED && !done_stopprint){
X! 		getret();	/* all those pieces of colored glass ... */
X! 		cls();
X! 	}
X! #if (defined(WIZARD) || defined(EXPLORE_MODE)) && !defined(LOGFILE)
X  	if(wizard || discover)
X  		Printf("\nSince you were in %s mode, the score list \
X  will not be checked.\n", wizard ? "wizard" : "discover");
X  	else
X  #endif
X! 		topten();
X  /* "So when I die, the first thing I will see in Heaven is a score list?" */
X  	if(done_stopprint) Printf("\n\n");
X  #if defined(APOLLO) || defined(MACOS)
X  	getret();
X--- 544,565 ----
X  	if(!done_stopprint)
X    Printf("You were level %u with a maximum of %d hit points when you %s.\n",
X  	    u.ulevel, u.uhpmax, ends[how]);
X! #if (defined(WIZARD) || defined(EXPLORE_MODE))
X! # ifndef LOGFILE
X  	if(wizard || discover)
X  		Printf("\nSince you were in %s mode, the score list \
X  will not be checked.\n", wizard ? "wizard" : "discover");
X  	else
X+ # endif
X  #endif
X! 	{
X! 		if (!done_stopprint) {
X! 			getret();
X! 			cls();
X! 		}
X  /* "So when I die, the first thing I will see in Heaven is a score list?" */
X+ 		topten(how);
X+ 	}
X  	if(done_stopprint) Printf("\n\n");
X  #if defined(APOLLO) || defined(MACOS)
X  	getret();
X***************
X*** 488,499 ****
X  
X  void
X  clearlocks(){
X! #if defined(DGK) && !defined(OLD_TOS)
X  	eraseall(levels, alllevels);
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! # if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS)) || defined(VMS) || defined(MACOS)
X  	register int x;
X  #  if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X--- 569,580 ----
X  
X  void
X  clearlocks(){
X! #if defined(DGK)
X  	eraseall(levels, alllevels);
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! # if defined(UNIX) || defined(MSDOS) || defined(VMS) || defined(MACOS)
X  	register int x;
X  #  if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X*** src/Old/engrave.c	Mon Feb 19 18:03:09 1990
X--- src/engrave.c	Wed Feb 14 18:38:01 1990
X***************
X*** 4,10 ****
X  
X  #include	"hack.h"
X  
X! struct engr {
X  	struct engr *nxt_engr;
X  	char *engr_txt;
X  	xchar engr_x, engr_y;
X--- 4,10 ----
X  
X  #include	"hack.h"
X  
X! VSTATIC struct engr {
X  	struct engr *nxt_engr;
X  	char *engr_txt;
X  	xchar engr_x, engr_y;
X***************
X*** 18,25 ****
X  #define POLY	5	/* temporary type - for polymorphing engraving */
X  } *head_engr;
X  
X! static void FDECL(del_engr, (struct engr *));
X  
X  /* random engravings */
X  const char *random_engr[] =
X  			 {"Elbereth", "ad ae?ar um",
X--- 18,27 ----
X  #define POLY	5	/* temporary type - for polymorphing engraving */
X  } *head_engr;
X  
X! OSTATIC void FDECL(del_engr, (struct engr *));
X! OSTATIC struct engr * FDECL(engr_at,(XCHAR_P,XCHAR_P));
X  
X+ #ifdef OVLB
X  /* random engravings */
X  const char *random_engr[] =
X  			 {"Elbereth", "ad ae?ar um",
X***************
X*** 32,38 ****
X  			 "Y?u won?t get i? up ?he ste?s",
X  			 "A.S. ->"};
X  
X! static struct engr *
X  engr_at(x,y) register xchar x,y; {
X  register struct engr *ep = head_engr;
X  	while(ep) {
X--- 34,43 ----
X  			 "Y?u won?t get i? up ?he ste?s",
X  			 "A.S. ->"};
X  
X! #endif /* OVLB */
X! #ifdef OVL0
X! 
X! XSTATIC struct engr *
X  engr_at(x,y) register xchar x,y; {
X  register struct engr *ep = head_engr;
X  	while(ep) {
X***************
X*** 46,52 ****
X  #ifdef ELBERETH
X  int
X  sengr_at(s,x,y)
X! 	register char *s;
X  	register xchar x,y;
X  {
X  	register struct engr *ep = engr_at(x,y);
X--- 51,57 ----
X  #ifdef ELBERETH
X  int
X  sengr_at(s,x,y)
X! 	register const char *s;
X  	register xchar x,y;
X  {
X  	register struct engr *ep = engr_at(x,y);
X***************
X*** 68,73 ****
X--- 73,81 ----
X  }
X  #endif
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X  void
X  u_wipe_engr(cnt)
X  register int cnt;
X***************
X*** 76,81 ****
X--- 84,92 ----
X  		wipe_engr_at(u.ux, u.uy, cnt);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL1
X+ 
X  void
X  wipe_engr_at(x,y,cnt) register xchar x,y,cnt; {
X  register struct engr *ep = engr_at(x,y);
X***************
X*** 104,109 ****
X--- 115,123 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL2
X+ 
X  void
X  read_engr_at(x,y) register int x,y; {
X  register struct engr *ep = engr_at(x,y);
X***************
X*** 136,145 ****
X  	}
X  }
X  
X  void
X  make_engr_at(x,y,s)
X  register int x,y;
X! register char *s;
X  {
X  	register struct engr *ep;
X  
X--- 150,162 ----
X  	}
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  void
X  make_engr_at(x,y,s)
X  register int x,y;
X! register const char *s;
X  {
X  	register struct engr *ep;
X  
X***************
X*** 163,169 ****
X   */
X  int
X  freehand(){
X- 
X  	return(!uwep ||
X  	   !uwep->cursed ||
X  	   (!bimanual(uwep) && (!uarms || !uarms->cursed)));
X--- 180,185 ----
X***************
X*** 188,193 ****
X--- 204,210 ----
X  register char *sp, *sptmp;
X  register struct engr *ep, *oep = engr_at(u.ux,u.uy);
X  char buf[BUFSZ];
X+ boolean jello = FALSE;
X  xchar type, polytype = 0;
X  int spct;		/* number of leading spaces */
X  register struct obj *otmp;
X***************
X*** 194,201 ****
X  	multi = 0;
X  
X  	if(u.uswallow) {
X! 		pline("What would you write?  \"Jonah was here\"?");
X! 		return(0);
X  	}
X  
X  	/* one may write with finger, weapon or wand */
X--- 211,225 ----
X  	multi = 0;
X  
X  	if(u.uswallow) {
X! 		if (is_animal(u.ustuck->data)) {
X! 			pline("What would you write?  \"Jonah was here\"?");
X! 			return(0);
X! 		} else
X! 			if (is_whirly(u.ustuck->data)) {
X! 				You("can't reach the ground.");
X! 				return(0);
X! 			} else 
X! 				jello = TRUE;
X  	}
X  
X  	/* one may write with finger, weapon or wand */
X***************
X*** 225,230 ****
X--- 249,262 ----
X  	if(otmp != &zeroobj && index(too_large,otmp->olet)) {
X  		You("can't engrave with such a large object!");
X  		return(1);
X+        }
X+ 
X+ 	if (jello) {
X+ 		You("tickle %s with your %s.", mon_nam(u.ustuck), 
X+ 		    (otmp == &zeroobj) ? makeplural(body_part(FINGER)) :
X+ 			xname(otmp));
X+ 		Your("message dissolves...");
X+ 		return(0);
X  	}
X  
X  	if(otmp != &zeroobj && index(paper,otmp->olet)) {
X***************
X*** 452,458 ****
X  			nomovemsg = "You finish writing.";
X  			if(type != MARK)
X  			nomovemsg = "You finish engraving.";
X! 			if(otmp->olet != WAND_SYM && otmp->otyp != ATHAME)  {
X  				if(otmp->olet == WEAPON_SYM)
X  					Your("%s dull.",
X  					       aobjnam(otmp, "get"));
X--- 484,491 ----
X  			nomovemsg = "You finish writing.";
X  			if(type != MARK)
X  			nomovemsg = "You finish engraving.";
X! 			if(otmp->olet != WAND_SYM && (otmp->otyp != ATHAME
X! 					|| otmp->cursed))  {
X  				if(otmp->olet == WEAPON_SYM)
X  					Your("%s dull.",
X  					       aobjnam(otmp, "get"));
X***************
X*** 535,540 ****
X--- 568,576 ----
X  save_engravings(fd) int fd; {
X  register struct engr *ep = head_engr;
X  register struct engr *ep2;
X+ #ifdef __GNULINT__
X+ static long nulls[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
X+ #endif
X  	while(ep) {
X  	    ep2 = ep->nxt_engr;
X  	    if(ep->engr_lth && ep->engr_txt[0]){
X***************
X*** 541,554 ****
X  		bwrite(fd, (genericptr_t)&(ep->engr_lth), sizeof(ep->engr_lth));
X  		bwrite(fd, (genericptr_t)ep, sizeof(struct engr) + ep->engr_lth);
X  	    }
X! #if defined(DGK) && !defined(OLD_TOS)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) ep);
X  	    ep = ep2;
X  	}
X  	bwrite(fd, (genericptr_t)nul, sizeof(unsigned));
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if (!count_only)
X  #endif
X  		head_engr = 0;
X--- 577,596 ----
X  		bwrite(fd, (genericptr_t)&(ep->engr_lth), sizeof(ep->engr_lth));
X  		bwrite(fd, (genericptr_t)ep, sizeof(struct engr) + ep->engr_lth);
X  	    }
X! #if defined(DGK)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) ep);
X  	    ep = ep2;
X  	}
X+ 
X+ #ifdef __GNULINT__
X+ 	bwrite(fd, (genericptr_t)nulls, sizeof(unsigned));
X+ #else
X  	bwrite(fd, (genericptr_t)nul, sizeof(unsigned));
X! #endif
X! 
X! #if defined(DGK)
X  	if (!count_only)
X  #endif
X  		head_engr = 0;
X***************
X*** 570,576 ****
X  	}
X  }
X  
X! static void
X  del_engr(ep) register struct engr *ep; {
X  register struct engr *ept;
X  	if(ep == head_engr)
X--- 612,618 ----
X  	}
X  }
X  
X! XSTATIC void
X  del_engr(ep) register struct engr *ep; {
X  register struct engr *ept;
X  	if(ep == head_engr)
X***************
X*** 588,590 ****
X--- 630,634 ----
X  	}
X  	free((genericptr_t) ep);
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/exper.c	Mon Feb 19 18:03:38 1990
X--- src/exper.c	Wed Nov 29 19:29:16 1989
X***************
X*** 117,123 ****
X  
X  	if(u.ulevel > 1) {
X  		pline("Goodbye level %u.", u.ulevel--);
X! 		adjabil(-1);	/* remove intrinsic abilities */
X  	} else
X  		u.uhp = -1;
X  	num = newhp();
X--- 117,124 ----
X  
X  	if(u.ulevel > 1) {
X  		pline("Goodbye level %u.", u.ulevel--);
X! 		/* remove intrinsic abilities */
X! 		adjabil((int)u.ulevel+1, (int)u.ulevel);
X  	} else
X  		u.uhp = -1;
X  	num = newhp();
X***************
X*** 151,157 ****
X  		if (u.uexp >= newuexp(u.ulevel)) u.uexp = newuexp(u.ulevel) - 1;
X  		pline("Welcome to experience level %u.", u.ulevel);
X  		set_uasmon();	/* set up for the new level. */
X! 		adjabil(1);	/* give new intrinsic abilities */
X  		tmp = newhp();
X  		u.uhpmax += tmp;
X  		u.uhp += tmp;
X--- 152,159 ----
X  		if (u.uexp >= newuexp(u.ulevel)) u.uexp = newuexp(u.ulevel) - 1;
X  		pline("Welcome to experience level %u.", u.ulevel);
X  		set_uasmon();	/* set up for the new level. */
X! 		/* give new intrinsics */
X! 		adjabil((int)u.ulevel-1, (int)u.ulevel);
X  		tmp = newhp();
X  		u.uhpmax += tmp;
X  		u.uhp += tmp;
X***************
X*** 180,186 ****
X  	if(u.ulevel < MAXULEV) {
X  		u.uexp = newuexp(u.ulevel);
X  		pline("Welcome to experience level %u.", ++u.ulevel);
X! 		adjabil(1);
X  	}
X  	flags.botl = 1;
X  }
X--- 182,188 ----
X  	if(u.ulevel < MAXULEV) {
X  		u.uexp = newuexp(u.ulevel);
X  		pline("Welcome to experience level %u.", ++u.ulevel);
X! 		adjabil((int)u.ulevel-1, (int)u.ulevel);
X  	}
X  	flags.botl = 1;
X  }
X*** src/Old/extralev.c	Mon Feb 19 18:03:58 1990
X--- src/extralev.c	Thu Jan 25 22:04:06 1990
X***************
X*** 2,9 ****
X  /*	Copyright 1988, 1989 by Ken Arromdee				*/
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include "hack.h"
X  
X  #ifdef REINCARNATION
X--- 2,9 ----
X  /*	Copyright 1988, 1989 by Ken Arromdee				*/
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  
X  #ifdef REINCARNATION
X***************
X*** 21,26 ****
X--- 21,29 ----
X  #define RIGHT 8
X  
X  static struct rogueroom r[3][3];
X+ static void FDECL(roguejoin,(int,int,int,int,int));
X+ static void FDECL(roguecorr,(int,int,int));
X+ static void FDECL(miniwalk,(int,int));
X  
X  static
X  void
X*** src/Old/fountain.c	Mon Feb 19 18:04:25 1990
X--- src/fountain.c	Wed Feb  7 18:37:42 1990
X***************
X*** 6,11 ****
X--- 6,16 ----
X  #include "hack.h"
X  
X  #ifdef FOUNTAINS
X+ static void NDECL(dowatersnakes);
X+ static void NDECL(dowaterdemon);
X+ static void NDECL(dowaternymph);
X+ static void FDECL(dogushforth,(int));	
X+ static void NDECL(dofindgem);
X  
X  static
X  void
X***************
X*** 12,18 ****
X  dowatersnakes() /* Fountain of snakes! */ {
X  	register int num = rnd(6);
X  	if (!(mons[PM_WATER_MOCCASIN].geno & G_GENOD)) {
X! 		pline("An endless stream of snakes pours forth!");
X  		while(num-- > 0) (void) makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy);
X  	} else
X  		pline("The fountain bubbles furiously for a moment, then calms.");
X--- 17,26 ----
X  dowatersnakes() /* Fountain of snakes! */ {
X  	register int num = rnd(6);
X  	if (!(mons[PM_WATER_MOCCASIN].geno & G_GENOD)) {
X! 		if (!Blind)
X! 			pline("An endless stream of snakes pours forth!");
X! 		else
X! 			You("hear something hissing!");
X  		while(num-- > 0) (void) makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy);
X  	} else
X  		pline("The fountain bubbles furiously for a moment, then calms.");
X***************
X*** 24,34 ****
X  register struct monst *mtmp;
X  
X  	if((mtmp = makemon(&mons[PM_WATER_DEMON],u.ux,u.uy))) {
X! 	    You("have unleashed %s!", defmonnam(mtmp));
X  
X  	/* Give those on low levels a (slightly) better chance of survival */
X  	    if ( rnd(100) > (80 + dlevel)) {
X! 		pline("Grateful for his release, he grants you a wish!");
X  		makewish();
X  		mongone(mtmp);
X  	    }
X--- 32,46 ----
X  register struct monst *mtmp;
X  
X  	if((mtmp = makemon(&mons[PM_WATER_DEMON],u.ux,u.uy))) {
X! 	    if (!Blind)
X! 	    	You("have unleashed %s!", defmonnam(mtmp));
X! 	    else
X! 		You("feel the presence of evil.");
X  
X  	/* Give those on low levels a (slightly) better chance of survival */
X  	    if ( rnd(100) > (80 + dlevel)) {
X! 		pline("Grateful for %s release, %s grants you a wish!",
X! 			Blind ? "its" : "his", Blind ? "it" : "he" );
X  		makewish();
X  		mongone(mtmp);
X  	    }
X***************
X*** 40,50 ****
X  dowaternymph() /* Water Nymph */ {
X  	register struct monst *mtmp;
X  	if((mtmp = makemon(&mons[PM_WATER_NYMPH],u.ux,u.uy))) {
X! 
X! 		You("have attracted %s!", defmonnam(mtmp));
X  		mtmp->msleep = 0;
X  	} else
X! 		pline("A large bubble rises to the surface and pops.");
X  }
X  
X  
X--- 52,67 ----
X  dowaternymph() /* Water Nymph */ {
X  	register struct monst *mtmp;
X  	if((mtmp = makemon(&mons[PM_WATER_NYMPH],u.ux,u.uy))) {
X! 		if (!Blind)
X! 		   You("have attracted %s!", defmonnam(mtmp));
X! 		else
X! 		   You("hear a seductive voice.");
X  		mtmp->msleep = 0;
X  	} else
X! 		if (!Blind)
X! 		   pline("A large bubble rises to the surface and pops.");
X! 		else
X! 		   You("hear a loud pop.");
X  }
X  
X  
X***************
X*** 106,112 ****
X  void
X  dryup(){
X  	if (!rn2(3) && IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X! 		pline("The fountain dries up!");
X  		levl[u.ux][u.uy].typ = ROOM;
X  		levl[u.ux][u.uy].looted = 0;
X  		if(Invisible) newsym(u.ux, u.uy);
X--- 123,129 ----
X  void
X  dryup(){
X  	if (!rn2(3) && IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X! 		if (!Blind) pline("The fountain dries up!");
X  		levl[u.ux][u.uy].typ = ROOM;
X  		levl[u.ux][u.uy].looted = 0;
X  		if(Invisible) newsym(u.ux, u.uy);
X***************
X*** 154,164 ****
X  #else
X  	   pline("Perhaps it is runoff from the nearby orange farm.");
X  #endif
X! 			   losehp(rnd(4),"unrefrigerated sip of juice");
X  			   break;
X  			}
X  			losestr(rn1(4,3));
X! 			losehp(rnd(10),"contaminated water");
X  			break;
X  	
X  		case 22: /* Fountain of snakes! */
X--- 171,182 ----
X  #else
X  	   pline("Perhaps it is runoff from the nearby orange farm.");
X  #endif
X! 			   losehp(rnd(4),"unrefrigerated sip of juice",
X! 				KILLED_BY_AN);
X  			   break;
X  			}
X  			losestr(rn1(4,3));
X! 			losehp(rnd(10),"contaminated water", KILLED_BY);
X  			break;
X  	
X  		case 22: /* Fountain of snakes! */
X***************
X*** 237,243 ****
X  	}
X  
X  	if (obj->otyp == LONG_SWORD && u.ulevel >= 5 && !rn2(6)
X! #ifndef NAMED_ITEMS
X  	    && !strcmp(ONAME(obj), "Excalibur")
X  #endif
X  	   ) {
X--- 255,263 ----
X  	}
X  
X  	if (obj->otyp == LONG_SWORD && u.ulevel >= 5 && !rn2(6)
X! #ifdef NAMED_ITEMS
X! 	    && !is_artifact(obj) && !exist_artifact(obj, "Excalibur")
X! #else
X  	    && !strcmp(ONAME(obj), "Excalibur")
X  #endif
X  	   ) {
X***************
X*** 314,319 ****
X--- 334,340 ----
X  		 * by.	Just like a shopping mall!  Chris Woodbury  */
X  
X  			mkgold((long)(rnd((MAXLEVEL-dlevel)*2)+5), u.ux, u.uy);
X+ 			if (!Blind)
X  		pline("Far below you, you see coins glistening in the water.");
X  			break;
X  	}
X***************
X*** 339,345 ****
X  		case 2: You("take a sip of scalding hot water.");
X  			if (Fire_resistance)
X  				pline("It seems quite tasty.");
X! 			else losehp(rnd(6), "sip of boiling water");
X  			break;
X  		case 3: if (mons[PM_SEWER_RAT].geno & G_GENOD)
X  				pline("The sink seems quite dirty.");
X--- 360,366 ----
X  		case 2: You("take a sip of scalding hot water.");
X  			if (Fire_resistance)
X  				pline("It seems quite tasty.");
X! 			else losehp(rnd(6), "sipping boiling water", KILLED_BY);
X  			break;
X  		case 3: if (mons[PM_SEWER_RAT].geno & G_GENOD)
X  				pline("The sink seems quite dirty.");
X*** src/Old/hack.c	Mon Feb 19 18:05:17 1990
X--- src/hack.c	Fri Feb 16 22:10:43 1990
X***************
X*** 4,12 ****
X  #include "hack.h"
X  
X  #if defined(UNIX) && !defined(LINT)
X! static	const char	SCCS_Id[] = "@(#)hack.c	3.0\t89/11/03";
X  #endif
X  
X  /* called on movement:
X  	1. when throwing ball+chain far away
X  	2. when teleporting
X--- 4,21 ----
X  #include "hack.h"
X  
X  #if defined(UNIX) && !defined(LINT)
X! static	const char	SCCS_Id[] = "@(#)hack.c	3.0\t89/11/20";
X  #endif
X  
X+ OSTATIC int NDECL(moverock);
X+ #ifdef SINKS
X+ OSTATIC void NDECL(dosinkfall);
X+ #endif
X+ static boolean FDECL(is_edge,(XCHAR_P,XCHAR_P));
X+ static boolean FDECL(bad_rock,(XCHAR_P,XCHAR_P));
X+ 
X+ #ifdef OVLB
X+ 
X  /* called on movement:
X  	1. when throwing ball+chain far away
X  	2. when teleporting
X***************
X*** 24,30 ****
X  	    for(y = u.uy-1; y < u.uy+2; y++) {
X  		if(!isok(x, y)) continue;
X  		lev = &levl[x][y];
X! 		if(!lev->lit && IS_FLOOR(lev->typ)){
X  			lev->scrsym = STONE_SYM;
X  			lev->new = 1;
X  			on_scr(x,y);
X--- 33,39 ----
X  	    for(y = u.uy-1; y < u.uy+2; y++) {
X  		if(!isok(x, y)) continue;
X  		lev = &levl[x][y];
X! 		if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			lev->scrsym = STONE_SYM;
X  			lev->new = 1;
X  			on_scr(x,y);
X***************
X*** 42,49 ****
X  	in mhitu.c:  seeoff(1)	- swallowed
X  	in mthrow.c: seeoff(0)	- hit by a cream pie.
X  	in potion.c: seeoff(0)	- quaffing or sniffing a potion of blindness
X! 	in spell.c:  seeoff(0)	- due to a cursed spellbook
X! 	in trap.c:   seeoff(1)	- fall through trapdoor
X   */
X  void
X  seeoff(mode)
X--- 51,58 ----
X  	in mhitu.c:  seeoff(1)	- swallowed
X  	in mthrow.c: seeoff(0)	- hit by a cream pie.
X  	in potion.c: seeoff(0)	- quaffing or sniffing a potion of blindness
X! 	in spell.c:  seeoff(0)	- due to a cursed spell book
X! 	in trap.c:   seeoff(1)	- fall through trap door
X   */
X  void
X  seeoff(mode)
X***************
X*** 67,73 ****
X  			lev = &levl[x][y];
X  			if(MON_AT(x, y))
X  			    unpmon(m_at(x,y));
X! 			if(!lev->lit && IS_FLOOR(lev->typ)) {
X  			    lev->seen = 0;
X  			    atl(x, y, (char)STONE_SYM);
X  			}
X--- 76,82 ----
X  			lev = &levl[x][y];
X  			if(MON_AT(x, y))
X  			    unpmon(m_at(x,y));
X! 			if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			    lev->seen = 0;
X  			    atl(x, y, (char)STONE_SYM);
X  			}
X***************
X*** 75,81 ****
X  	    }
X  }
X  
X! static int
X  moverock() {
X  	register xchar rx, ry;
X  	register struct obj *otmp;
X--- 84,93 ----
X  	    }
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL2
X! 
X! XSTATIC int
X  moverock() {
X  	register xchar rx, ry;
X  	register struct obj *otmp;
X***************
X*** 143,150 ****
X  				rloco(otmp);
X  				continue;
X  			    }
X! 			if(levl[rx][ry].typ == DOOR &&
X! 				(levl[rx][ry].doormask & (D_LOCKED | D_CLOSED)))
X  				goto nopushmsg;
X  			if(is_pool(rx,ry)) {
X  #ifdef STRONGHOLD
X--- 155,161 ----
X  				rloco(otmp);
X  				continue;
X  			    }
X! 			if(closed_door(rx, ry))
X  				goto nopushmsg;
X  			if(is_pool(rx,ry)) {
X  #ifdef STRONGHOLD
X***************
X*** 209,229 ****
X  	return (0);
X  }
X  
X  void
X  movobj(obj, ox, oy)
X  register struct obj *obj;
X  register xchar ox, oy;
X  {
X! 	/* Some dirty programming to get display right */
X! 	freeobj(obj);
X! 	unpobj(obj);
X! 	obj->nobj = fobj;
X! 	fobj = obj;
X! 	move_object(obj, ox, oy);
X  }
X  
X  #ifdef SINKS
X! static
X  void
X  dosinkfall() {
X  	register struct obj *obj;
X--- 220,241 ----
X  	return (0);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  void
X  movobj(obj, ox, oy)
X  register struct obj *obj;
X  register xchar ox, oy;
X  {
X! 	remove_object(obj);
X! 	newsym(obj->ox, obj->oy);
X! 	place_object(obj, ox, oy);
X! 	newsym(ox, oy);
X  }
X  
X  #ifdef SINKS
X! XSTATIC
X  void
X  dosinkfall() {
X  	register struct obj *obj;
X***************
X*** 234,244 ****
X  	} else {
X  # endif
X  		You("crash to the floor!");
X! 		losehp((rn1(10, 20 - (int)ACURR(A_CON))),"fall onto a sink");
X  		for(obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X  		    if(obj->olet == WEAPON_SYM) {
X  			You("fell on %s.",doname(obj));
X! 			losehp(rn2(3),"fall onto a sink");
X  		    }
X  # ifdef POLYSELF
X  	}
X--- 246,257 ----
X  	} else {
X  # endif
X  		You("crash to the floor!");
X! 		losehp((rn1(10, 20 - (int)ACURR(A_CON))),
X! 			"fell onto a sink", NO_KILLER_PREFIX);
X  		for(obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X  		    if(obj->olet == WEAPON_SYM) {
X  			You("fell on %s.",doname(obj));
X! 			losehp(rn2(3),"fell onto a sink", NO_KILLER_PREFIX);
X  		    }
X  # ifdef POLYSELF
X  	}
X***************
X*** 264,269 ****
X--- 277,285 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  static boolean
X  is_edge(x,y)
X  register xchar x,y;
X***************
X*** 279,284 ****
X--- 295,303 ----
X  	       (y == rooms[roomno].ly - 1) || (y == rooms[roomno].hy + 1));
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  boolean
X  may_dig(x,y)
X  register xchar x,y;
X***************
X*** 287,292 ****
X--- 306,314 ----
X  return (!(IS_STWALL(levl[x][y].typ) && (levl[x][y].diggable & W_NONDIGGABLE)));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  static boolean
X  bad_rock(x,y)
X  register xchar x,y;
X***************
X*** 348,354 ****
X  		if(u.ustuck && (x != u.ustuck->mx ||
X  				y != u.ustuck->my)) {
X  			if(dist(u.ustuck->mx, u.ustuck->my) > 2) {
X! 				/* perhaps it fled (or was teleported or ... ) */
X  				u.ustuck = 0;
X  			} else {
X  #ifdef POLYSELF
X--- 370,376 ----
X  		if(u.ustuck && (x != u.ustuck->mx ||
X  				y != u.ustuck->my)) {
X  			if(dist(u.ustuck->mx, u.ustuck->my) > 2) {
X! 			/* perhaps it fled (or was teleported or ... ) */
X  				u.ustuck = 0;
X  			} else {
X  #ifdef POLYSELF
X***************
X*** 376,382 ****
X  			/* Don't attack if you're running */
X  			if (flags.run && !mtmp->mimic &&
X  				    (Blind ? Telepat :
X! 					    (!mtmp->minvis || See_invisible))) {
X  				nomul(0);
X  				flags.move = 0;
X  				return;
X--- 398,404 ----
X  			/* Don't attack if you're running */
X  			if (flags.run && !mtmp->mimic &&
X  				    (Blind ? Telepat :
X! 					 (!mtmp->minvis || See_invisible))) {
X  				nomul(0);
X  				flags.move = 0;
X  				return;
X***************
X*** 434,471 ****
X  		    return;
X  	    }
X  #endif
X! 	    if(IS_DOOR(tmpr->typ) && (tmpr->doormask & (D_LOCKED | D_CLOSED))
X  #ifdef POLYSELF
X! 	       && !amorphous(uasmon)
X  #endif
X- 	      ){
X  		    flags.move = 0;
X  		    if(x == u.ux || y == u.uy) {
X  		        if (Blind || Stunned || ACURR(A_DEX) < 10 || Fumbling)
X  			    pline("Ouch!  You bump into a door.");
X! 		        else pline("That door is closed.");
X  		    }
X  		    nomul(0);
X  		    return;
X  	    }
X  #ifdef POLYSELF
X  	}
X  #endif
X  	ust = &levl[u.ux][u.uy];
X  	if(bad_rock(x,y) ||
X  	   (u.dx && u.dy
X  #ifdef POLYSELF
X! 		    && !passes_walls(uasmon)
X  #endif
X  #ifdef REINCARNATION
X! 		    && (((IS_DOOR(tmpr->typ) && ((tmpr->doormask & ~D_BROKEN)
X! 				|| dlevel == rogue_level)) ||
X! 		        ((IS_DOOR(ust->typ) && ((ust->doormask & ~D_BROKEN)
X! 				|| dlevel == rogue_level))))))) {
X  #else
X! 		    && (((IS_DOOR(tmpr->typ) && (tmpr->doormask & ~D_BROKEN)) ||
X! 		      ((IS_DOOR(ust->typ) && (ust->doormask & ~D_BROKEN))))))){
X  #endif
X  		flags.move = 0;
X  		nomul(0);
X  		return;
X--- 456,505 ----
X  		    return;
X  	    }
X  #endif
X! 	    if(closed_door(x, y)) {
X  #ifdef POLYSELF
X! 		if(amorphous(uasmon))
X! 		    You("ooze under the door.");
X! 		else {
X  #endif
X  		    flags.move = 0;
X  		    if(x == u.ux || y == u.uy) {
X  		        if (Blind || Stunned || ACURR(A_DEX) < 10 || Fumbling)
X  			    pline("Ouch!  You bump into a door.");
X! 		         else pline("That door is closed.");
X  		    }
X  		    nomul(0);
X  		    return;
X+ #ifdef POLYSELF
X+ 		}
X+ #endif
X  	    }
X  #ifdef POLYSELF
X  	}
X  #endif
X  	ust = &levl[u.ux][u.uy];
X+ 
X  	if(bad_rock(x,y) ||
X  	   (u.dx && u.dy
X  #ifdef POLYSELF
X! 		 && !passes_walls(uasmon)
X  #endif
X+ 		 && ( (IS_DOOR(ust->typ) && block_entry(x, y)) ||
X  #ifdef REINCARNATION
X! 			(IS_DOOR(tmpr->typ) &&
X! 			 ((tmpr->doormask & ~D_BROKEN) 
X! 			   || dlevel == rogue_level || block_door(x, y))
X!                         )  
X! 		     || (IS_DOOR(ust->typ) &&
X! 			 ((ust->doormask & ~D_BROKEN) || dlevel == rogue_level)
X!                         )
X  #else
X! 			(IS_DOOR(tmpr->typ) &&
X! 			 ((tmpr->doormask & ~D_BROKEN) || block_door(x, y))) ||
X! 			(IS_DOOR(ust->typ) && (ust->doormask & ~D_BROKEN))
X  #endif
X+ 		    )
X+ 	   )) {
X  		flags.move = 0;
X  		nomul(0);
X  		return;
X***************
X*** 507,514 ****
X  		}
X  
X  		movobj(uball, uchain->ox, uchain->oy);
X! 		unpobj(uball);		/* BAH %% */
X! 		move_object(uchain, u.ux, u.uy);
X  		nomul(-2);
X  		nomovemsg = "";
X  	nodrag:	;
X--- 541,547 ----
X  		}
X  
X  		movobj(uball, uchain->ox, uchain->oy);
X! 		movobj(uchain, u.ux, u.uy);
X  		nomul(-2);
X  		nomovemsg = "";
X  	nodrag:	;
X***************
X*** 515,521 ****
X  	}
X  #ifdef POLYSELF
X  	if (tunnels(uasmon) && !needspick(uasmon) && IS_ROCK(tmpr->typ)) {
X! 		static char *digtxt;
X  
X  		if(dig_pos.x != x || dig_pos.y != y
X  		    || dig_level != dlevel || dig_down) {
X--- 548,554 ----
X  	}
X  #ifdef POLYSELF
X  	if (tunnels(uasmon) && !needspick(uasmon) && IS_ROCK(tmpr->typ)) {
X! 		static const char *digtxt;
X  
X  		if(dig_pos.x != x || dig_pos.y != y
X  		    || dig_level != dlevel || dig_down) {
X***************
X*** 649,654 ****
X--- 682,690 ----
X  	spoteffects();
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL2
X+ 
X  void
X  spoteffects()
X  {
X***************
X*** 676,681 ****
X--- 712,720 ----
X  
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  int
X  dopickup() {
X  	/* uswallow case added by GAN 01/29/87 */
X***************
X*** 684,690 ****
X  		    You("pick up %s's tongue.", mon_nam(u.ustuck));
X  		    pline("But it's kind of slimy, so you drop it.");
X  		} else
X! 		    pline("You don't %s anything in here to pick up.",
X  			  Blind ? "feel" : "see");
X  		return(1);
X  	}
X--- 723,729 ----
X  		    You("pick up %s's tongue.", mon_nam(u.ustuck));
X  		    pline("But it's kind of slimy, so you drop it.");
X  		} else
X! 		    You("don't %s anything in here to pick up.",
X  			  Blind ? "feel" : "see");
X  		return(1);
X  	}
X***************
X*** 700,705 ****
X--- 739,747 ----
X  	return(1);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  /* stop running if we see something interesting */
X  /* turn around a corner if that is the only way we can proceed */
X  /* do not turn left or right twice */
X***************
X*** 707,715 ****
X  lookaround() {
X  	register int x, y, i, x0, y0, m0, i0 = 9, corrct = 0, noturn = 0;
X  	register struct monst *mtmp;
X! #ifdef LINT
X  	/* suppress "used before set" message */
X! 	x0 = y0 = 0;
X  #endif
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X--- 749,757 ----
X  lookaround() {
X  	register int x, y, i, x0, y0, m0, i0 = 9, corrct = 0, noturn = 0;
X  	register struct monst *mtmp;
X! #if defined(LINT) || defined(__GNULINT__)
X  	/* suppress "used before set" message */
X! 	x0 = y0 = m0 = 0;
X  #endif
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X***************
X*** 823,829 ****
X  		if(MON_AT(x, y) && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X! 		   !mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
X  		   (!mtmp->minvis || See_invisible) &&
X  		   !onscary(u.ux, u.uy, mtmp))
X  			return(1);
X--- 865,871 ----
X  		if(MON_AT(x, y) && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X! 		   mtmp->mcanmove && !mtmp->msleep &&  /* aplvax!jcn */
X  		   (!mtmp->minvis || See_invisible) &&
X  		   !onscary(u.ux, u.uy, mtmp))
X  			return(1);
X***************
X*** 831,836 ****
X--- 873,881 ----
X  	return(0);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL0
X+ 
X  int
X  cansee(x,y)
X  xchar x,y;
X***************
X*** 847,852 ****
X--- 892,900 ----
X  	return(0);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  int
X  sgn(a)
X  	register int a;
X***************
X*** 854,859 ****
X--- 902,910 ----
X  	return((a > 0) ? 1 : (a == 0) ? 0 : -1);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL2
X+ 
X  void
X  getcorners(lx1,hx1,ly1,hy1,lx2,hx2,ly2,hy2)
X  xchar *lx1,*hx1,*ly1,*hy1,*lx2,*hx2,*ly2,*hy2;
X***************
X*** 901,906 ****
X--- 952,960 ----
X  	}
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL1
X+ 
X  void
X  setsee() {
X  	register int x, y;
X***************
X*** 937,942 ****
X--- 991,999 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL2
X+ 
X  void
X  nomul(nval)
X  	register int nval;
X***************
X*** 946,955 ****
X  	flags.mv = flags.run = 0;
X  }
X  
X  void
X! losehp(n, knam)
X! 	register int n;
X! 	register const char *knam;
X  {
X  #ifdef POLYSELF
X  	if (u.mtimedone) {
X--- 1003,1016 ----
X  	flags.mv = flags.run = 0;
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL1
X+ 
X  void
X! losehp(n, knam, k_format)
X! register int n;
X! register const char *knam;
X! boolean k_format;
X  {
X  #ifdef POLYSELF
X  	if (u.mtimedone) {
X***************
X*** 965,971 ****
X  		u.uhpmax = u.uhp;	/* perhaps n was negative */
X  	flags.botl = 1;
X  	if(u.uhp < 1) {
X! 		killer = (char *)knam;	/* the thing that killed you */
X  		You("die...");
X  		done(DIED);
X  	} else if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50 && n > 0){
X--- 1026,1033 ----
X  		u.uhpmax = u.uhp;	/* perhaps n was negative */
X  	flags.botl = 1;
X  	if(u.uhp < 1) {
X! 		killer_format = k_format;
X! 		killer = knam;		/* the thing that killed you */
X  		You("die...");
X  		done(DIED);
X  	} else if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50 && n > 0){
X***************
X*** 1052,1057 ****
X--- 1114,1122 ----
X  	return(wt - weight_cap());
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  inv_cnt() {
X  	register struct obj *otmp = invent;
X***************
X*** 1115,1117 ****
X--- 1180,1184 ----
X  	objects[x].oc_name_known = 1;
X  }
X  #endif /* STUPID_CPP */
X+ 
X+ #endif /* OVLB */
X*** src/Old/invent.c	Mon Feb 19 18:06:12 1990
X--- src/invent.c	Mon Feb 19 10:18:41 1990
X***************
X*** 11,20 ****
X  
X  #define	NOINVSYM	'#'
X  
X! static boolean mergable();
X  
X  int lastinvnr = 51;	/* 0 ... 51 */
X- static char *xprname();
X  
X  char inv_order[] = {
X  	AMULET_SYM, WEAPON_SYM, ARMOR_SYM, FOOD_SYM, SCROLL_SYM,
X--- 11,34 ----
X  
X  #define	NOINVSYM	'#'
X  
X! static boolean FDECL(mergable,(struct obj *,struct obj *));
X! OSTATIC void FDECL(assigninvlet,(struct obj *));
X! static int FDECL(merged,(struct obj *,struct obj *,int));
X! OSTATIC struct obj *FDECL(mkgoldobj,(long));
X! #ifndef OVERLAY
X! static int FDECL(ckunpaid,(struct obj *));
X! #else
X! int FDECL(ckunpaid,(struct obj *));
X! #endif
X! static boolean NDECL(wearing_armor);
X! static boolean FDECL(is_worn,(struct obj *));
X! static char FDECL(obj_to_let,(struct obj *));
X! 
X! OSTATIC char *FDECL(xprname,(struct obj *,CHAR_P,BOOLEAN_P));
X  
X+ #ifdef OVLB
X+ 
X  int lastinvnr = 51;	/* 0 ... 51 */
X  
X  char inv_order[] = {
X  	AMULET_SYM, WEAPON_SYM, ARMOR_SYM, FOOD_SYM, SCROLL_SYM,
X***************
X*** 24,30 ****
X  	POTION_SYM, RING_SYM, WAND_SYM, TOOL_SYM, GEM_SYM,
X  	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X  
X! static void
X  assigninvlet(otmp)
X  register struct obj *otmp;
X  {
X--- 38,44 ----
X  	POTION_SYM, RING_SYM, WAND_SYM, TOOL_SYM, GEM_SYM,
X  	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X  
X! XSTATIC void
X  assigninvlet(otmp)
X  register struct obj *otmp;
X  {
X***************
X*** 51,56 ****
X--- 65,73 ----
X  	lastinvnr = i;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /* merge obj with otmp and delete obj if types agree */
X  static int
X  merged(otmp, obj, lose)
X***************
X*** 67,72 ****
X--- 84,91 ----
X  			/ (otmp->quan + obj->quan);
X  		otmp->quan += obj->quan;
X  		otmp->owt += obj->owt;
X+ 		if(!otmp->onamelth && obj->onamelth)
X+ 			(void)oname(otmp, ONAME(obj), 1);
X  		if(lose) freeobj(obj);
X  		obfree(obj,otmp);	/* free(obj), bill->otmp */
X  		return(1);
X***************
X*** 130,140 ****
X  		 * for correct calculation */
X  		if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X  		else u.moreluck = -LUCKADD;
X- 		flags.botl = 1;
X  	}
X  	return(obj);
X  }
X  
X  void
X  useup(obj)
X  register struct obj *obj;
X--- 149,161 ----
X  		 * for correct calculation */
X  		if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X  		else u.moreluck = -LUCKADD;
X  	}
X  	return(obj);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  useup(obj)
X  register struct obj *obj;
X***************
X*** 146,151 ****
X--- 167,173 ----
X  		obj->quan--;
X  		obj->owt = weight(obj);
X  	} else {
X+ 		if(obj->otyp == CORPSE) food_disappears(obj);
X  		setnotworn(obj);
X  		freeinv(obj);
X  		delete_contents(obj);
X***************
X*** 188,193 ****
X--- 210,217 ----
X  #ifdef WALKIES
X  	if(obj->otyp == LEASH && obj->leashmon != 0) o_unleash(obj);
X  #endif
X+ 	if(obj->otyp == CORPSE) food_disappears(obj);
X+ 
X  	freeobj(obj);
X  	unpobj(obj);
X  
X***************
X*** 248,253 ****
X--- 272,280 ----
X  #endif
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  struct obj *
X  sobj_at(n,x,y)
X  register int n, x, y;
X***************
X*** 260,265 ****
X--- 287,295 ----
X  	return((struct obj *)0);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  int
X  carried(obj)
X  register struct obj *obj;
X***************
X*** 331,337 ****
X  }
X  
X  /* make dummy object structure containing gold - for temporary use only */
X! static
X  struct obj *
X  mkgoldobj(q)
X  register long q;
X--- 361,367 ----
X  }
X  
X  /* make dummy object structure containing gold - for temporary use only */
X! XSTATIC
X  struct obj *
X  mkgoldobj(q)
X  register long q;
X***************
X*** 341,346 ****
X--- 371,379 ----
X  	otmp = newobj(0);
X  	/* should set o_id etc. but otmp will be freed soon */
X  	otmp->olet = GOLD_SYM;
X+ #ifdef POLYSELF
X+ 	otmp->ox = 0; /* necessary for eating gold */
X+ #endif
X  	u.ugold -= q;
X  	OGOLD(otmp) = q;
X  	flags.botl = 1;
X***************
X*** 347,352 ****
X--- 380,388 ----
X  	return(otmp);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /*
X   * getobj returns:
X   *	struct obj *xxx:	object to do something with.
X***************
X*** 378,383 ****
X--- 414,424 ----
X  	if(*let == '0') let++, allowcnt = 1;
X  	if(*let == GOLD_SYM) let++,
X  		usegold = TRUE, allowgold = (u.ugold ? TRUE : FALSE);
X+ #ifdef POLYSELF
X+ 	/* Equivalent of an "ugly check" for gold */
X+ 	if (usegold && !strcmp(word, "eat") && !metallivorous(uasmon))
X+ 		usegold = allowgold = FALSE;
X+ #endif
X  	if(*let == '#') let++, allowall = TRUE;
X  	if(*let == '-') let++, allownone = TRUE;
X  	if(allownone) *bp++ = '-';
X***************
X*** 410,417 ****
X  		/* Second ugly check; unlike the first it won't trigger an
X  		 * "else" in "you don't have anything else to ___".
X  		 */
X! 		if ((!strcmp(word, "wear") &&
X  		    (otmp->olet == TOOL_SYM && otmp->otyp != BLINDFOLD))
X  		|| (!strcmp(word, "can") &&
X  		    (otmp->otyp != CORPSE))
X  		|| (!strcmp(word, "write with") &&
X--- 451,461 ----
X  		/* Second ugly check; unlike the first it won't trigger an
X  		 * "else" in "you don't have anything else to ___".
X  		 */
X! 		else if ((!strcmp(word, "wear") &&
X  		    (otmp->olet == TOOL_SYM && otmp->otyp != BLINDFOLD))
X+ #ifdef POLYSELF
X+ 		|| (!strcmp(word, "eat") && !is_edible(otmp))
X+ #endif
X  		|| (!strcmp(word, "can") &&
X  		    (otmp->otyp != CORPSE))
X  		|| (!strcmp(word, "write with") &&
X***************
X*** 508,514 ****
X  			allowcnt = 1;
X  			if(cnt == 0 && prezero) return((struct obj *)0);
X  			if(cnt > 1) {
X! 			    pline("You can only throw one item at a time.");
X  			    continue;
X  			}
X  		}
X--- 552,558 ----
X  			allowcnt = 1;
X  			if(cnt == 0 && prezero) return((struct obj *)0);
X  			if(cnt > 1) {
X! 			    You("can only throw one item at a time.");
X  			    continue;
X  			}
X  		}
X***************
X*** 552,557 ****
X--- 596,602 ----
X  		if(cnt == 0) return (struct obj *)0;
X  		if(cnt != otmp->quan) {
X  			register struct obj *obj;
X+ 			
X  #ifdef LINT	/*splitobj for (long )cnt > 30000 && sizeof(int) == 2*/
X  			obj = (struct obj *)0;
X  #else
X***************
X*** 561,566 ****
X--- 606,620 ----
X  			else
X  				obj = splitobj(otmp, (int) cnt);
X  #endif
X+ 		/* Very ugly kludge necessary to prevent someone from trying
X+ 		 * to drop one of several loadstones and having the loadstone
X+ 		 * now be separate.  If putting items in containers is ever
X+ 		 * changed to allow putting in counts of individual items, a
X+ 		 * similar kludge will be needed.
X+ 		 */
X+ 			if (!strcmp(word, "drop") && obj->otyp == LOADSTONE
X+ 					&& obj->cursed)
X+ 				otmp->corpsenm = obj->invlet;
X  			if(otmp == uwep) setuwep(obj);
X  		}
X  	}
X***************
X*** 567,572 ****
X--- 621,629 ----
X  	return(otmp);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifndef OVERLAY
X  static 
X  #endif
X***************
X*** 600,607 ****
X  /* Takeoff (A). Return the number of times fn was called successfully */
X  int
X  ggetobj(word, fn, mx)
X! register char *word;
X! register int (*fn)(), mx;
X  {
X  	char buf[BUFSZ];
X  	register char *ip;
X--- 657,664 ----
X  /* Takeoff (A). Return the number of times fn was called successfully */
X  int
X  ggetobj(word, fn, mx)
X! register const char *word;
X! register int FDECL((*fn),(struct obj *)), mx;
X  {
X  	char buf[BUFSZ];
X  	register char *ip;
X***************
X*** 609,615 ****
X  	register int oletct = 0, iletct = 0;
X  	register boolean allflag = FALSE;
X  	char olets[20], ilets[20];
X! 	int (*ckfn)() = (int (*)()) 0;
X  	xchar allowgold = (u.ugold && !strcmp(word, "drop")) ? 1 : 0; /* BAH */
X  	register boolean takeoff = !strcmp(word, "take off");
X  
X--- 666,672 ----
X  	register int oletct = 0, iletct = 0;
X  	register boolean allflag = FALSE;
X  	char olets[20], ilets[20];
X! 	int FDECL((*ckfn),(struct obj *)) = (int (*)()) 0;
X  	xchar allowgold = (u.ugold && !strcmp(word, "drop")) ? 1 : 0; /* BAH */
X  	register boolean takeoff = !strcmp(word, "take off");
X  
X***************
X*** 708,715 ****
X  askchain(objchn, ininv, olets, allflag, fn, ckfn, mx, word)
X  register struct obj *objchn;
X  register int ininv, allflag, mx;
X! register char *olets, *word;
X! register int (*fn)(), (*ckfn)();
X  {
X  	register struct obj *otmp, *otmp2;
X  	register char sym, ilet;
X--- 765,772 ----
X  askchain(objchn, ininv, olets, allflag, fn, ckfn, mx, word)
X  register struct obj *objchn;
X  register int ininv, allflag, mx;
X! register const char *olets, *word;
X! register int FDECL((*fn),(struct obj *)), FDECL((*ckfn),(struct obj *));
X  {
X  	register struct obj *otmp, *otmp2;
X  	register char sym, ilet;
X***************
X*** 732,742 ****
X  		if(takeoff && !is_worn(otmp)) continue;
X  		if(ckfn && !(*ckfn)(otmp)) continue;
X  		if(!allflag) {
X! 			if(ininv) {
X! 			    if (nodot)
X! 				 pline(xprname(otmp, ilet, FALSE));
X! 			    else pline(xprname(otmp, ilet, TRUE));
X! 			}
X  			else
X  			    pline(doname(otmp));
X  			addtopl("? ");
X--- 789,797 ----
X  		if(takeoff && !is_worn(otmp)) continue;
X  		if(ckfn && !(*ckfn)(otmp)) continue;
X  		if(!allflag) {
X! 			if(ininv)
X! 			    pline("%s", xprname(otmp, ilet,
X! 							nodot ? FALSE : TRUE));
X  			else
X  			    pline(doname(otmp));
X  			addtopl("? ");
X***************
X*** 788,794 ****
X  	pline(xprname(obj, obj_to_let(obj), TRUE));
X  }
X  
X! static char *
X  xprname(obj,let,dot)
X  register struct obj *obj;
X  register char let;
X--- 843,852 ----
X  	pline(xprname(obj, obj_to_let(obj), TRUE));
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL1
X! 
X! XSTATIC char *
X  xprname(obj,let,dot)
X  register struct obj *obj;
X  register char let;
X***************
X*** 807,812 ****
X--- 865,873 ----
X  	return(li);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  ddoinv()
X  {
X***************
X*** 814,824 ****
X  	return 0;
X  }
X  
X  /* called with 0 or "": all objects in inventory */
X  /* otherwise: all objects with (serial) letter in lets */
X  void
X  doinv(lets)
X! register char *lets;
X  {
X  	register struct obj *otmp;
X  	register char ilet;
X--- 875,888 ----
X  	return 0;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /* called with 0 or "": all objects in inventory */
X  /* otherwise: all objects with (serial) letter in lets */
X  void
X  doinv(lets)
X! register const char *lets;
X  {
X  	register struct obj *otmp;
X  	register char ilet;
X***************
X*** 879,884 ****
X--- 943,951 ----
X  	cornline(2, any);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  dotypeinv()				/* free after Robert Viduya */
X  /* Changed to one type only, so he doesn't have to type cr */
X***************
X*** 965,971 ****
X  dolook() {
X      	register struct obj *otmp, *otmp0;
X      	register struct gold *gold;
X!     	char *verb = Blind ? "feel" : "see";
X      	int ct = 0;
X      	int fd = 0;
X  
X--- 1032,1038 ----
X  dolook() {
X      	register struct obj *otmp, *otmp0;
X      	register struct gold *gold;
X!     	const char *verb = Blind ? "feel" : "see";
X      	int ct = 0;
X      	int fd = 0;
X  
X***************
X*** 1012,1018 ****
X  #endif
X  #ifdef ALTARS
X      	if(IS_ALTAR(levl[u.ux][u.uy].typ))  {
X! 		char *al;
X  
X  		fd++;
X  		switch (levl[u.ux][u.uy].altarmask & ~A_SHRINE) {
X--- 1079,1085 ----
X  #endif
X  #ifdef ALTARS
X      	if(IS_ALTAR(levl[u.ux][u.uy].typ))  {
X! 		const char *al;
X  
X  		fd++;
X  		switch (levl[u.ux][u.uy].altarmask & ~A_SHRINE) {
X***************
X*** 1073,1078 ****
X--- 1140,1146 ----
X  		    (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE)) {
X  			pline("Touching the dead cockatrice is a fatal mistake...");
X  			You("turn to stone...");
X+ 			killer_format = KILLED_BY_AN;
X  			killer = "cockatrice corpse";
X  			done(STONING);
X  		}
X***************
X*** 1098,1103 ****
X--- 1166,1174 ----
X      	return(!!Blind);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  stackobj(obj)
X  register struct obj *obj;
X***************
X*** 1122,1144 ****
X  	   obj->otrapped != otmp->otrapped)
X  	    return(FALSE);
X  
X! 	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X! 	else if(obj->olet == FOOD_SYM && (obj->oeaten != otmp->oeaten ||
X  		obj->orotten != otmp->orotten))
X  		return(FALSE);
X  
X! 	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X! 		return( (obj->corpsenm == otmp->corpsenm) &&
X! 			(!ONAME(obj) || !strcmp(ONAME(obj), ONAME(otmp))) );
X  
X! 	else if(obj->known == otmp->known || 
X  		!objects[otmp->otyp].oc_uses_known) {
X  		return(objects[obj->otyp].oc_merge);
X  	} else return(FALSE);
X  }
X  
X  int
X  doprgold(){
X  	if(!u.ugold)
X--- 1193,1232 ----
X  	   obj->otrapped != otmp->otrapped)
X  	    return(FALSE);
X  
X! 	if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X! 	if(obj->olet == FOOD_SYM && (obj->oeaten != otmp->oeaten ||
X  		obj->orotten != otmp->orotten))
X  		return(FALSE);
X  
X! 	if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN) {
X! 		if((obj->corpsenm != otmp->corpsenm) ||
X! 			(ONAME(obj) && strcmp(ONAME(obj), ONAME(otmp))))
X! 				return FALSE;
X! 	}
X! 
X! /* if they have names, make sure they're the same */
X! 	if ( (obj->onamelth != otmp->onamelth &&
X! 		((obj->onamelth && otmp->onamelth) || obj->otyp == CORPSE)
X! 	     ) ||
X! 	    (obj->onamelth && 
X! 		    strncmp(ONAME(obj), ONAME(otmp), (int)obj->onamelth)))
X! 		return FALSE;
X! 
X! #ifdef NAMED_ITEMS
X! 	if(is_artifact(obj) != is_artifact(otmp)) return FALSE;
X! #endif
X  
X! 	if(obj->known == otmp->known || 
X  		!objects[otmp->otyp].oc_uses_known) {
X  		return(objects[obj->otyp].oc_merge);
X  	} else return(FALSE);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  doprgold(){
X  	if(!u.ugold)
X***************
X*** 1305,1307 ****
X--- 1393,1397 ----
X  		obj->invlet = (i < 26) ? ('a'+i) : ('A'+i-26);
X  	lastinvnr = i;
X  }
X+ 
X+ #endif /* OVLB */
X
END_OF_FILE
if test 56054 -ne `wc -c <'patch7.04'`; then
    echo shar: \"'patch7.04'\" unpacked with wrong size!
fi
# end of 'patch7.04'
echo shar: End of archive 8 \(of 30\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
