Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!wuarchive!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i017:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7q
Message-ID: <5231@tekred.CNA.TEK.COM>
Date: 24 Feb 90 01:00:09 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2193
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 17
Archive-name: NetHack3/Patch7q
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 30)."
# Contents:  patch7.07
# Wrapped by billr@saab on Wed Feb 21 10:04:38 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.07' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.07'\" to \"'patch7.07.orig'\"
  mv -f 'patch7.07' 'patch7.07.orig'
fi
echo shar: Extracting \"'patch7.07'\" \(53513 characters\)
sed "s/^X//" >'patch7.07' <<'END_OF_FILE'
X*** src/Old/priest.c	Mon Feb 19 18:54:33 1990
X--- src/priest.c	Wed Feb  7 19:57:01 1990
X***************
X*** 3,15 ****
X  /* Copyright (c) Izchak Miller, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include "hack.h"
X  #include "mfndpos.h"
X  #include "eshk.h"
X  #include "epri.h"
X  
X  /* used for the insides of shk_move and pri_move */
X  int
X  move_special(mtmp,monroom,appr,uondoor,avoid,omx,omy,gx,gy)
X--- 3,24 ----
X  /* Copyright (c) Izchak Miller, Steve Linhart, 1989. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  #include "mfndpos.h"
X  #include "eshk.h"
X  #include "epri.h"
X  
X+ static boolean FDECL(histemple_at,(struct monst *,int,int));
X+ static int FDECL(t_alignment,(struct mkroom *));
X+ static boolean FDECL(is_shrined,(struct mkroom *));
X+ static boolean FDECL(t_coaligned,(struct mkroom *));
X+ struct monst *FDECL(findpriest,(struct mkroom *));
X+ static boolean FDECL(p_inhistemple,(struct mkroom *));
X+ 
X+ #ifdef OVLB
X+ 
X  /* used for the insides of shk_move and pri_move */
X  int
X  move_special(mtmp,monroom,appr,uondoor,avoid,omx,omy,gx,gy)
X***************
X*** 42,47 ****
X--- 51,61 ----
X  	if (tunnels(mtmp->data) &&
X  		    (!needspick(mtmp->data) || m_carrying(mtmp, PICK_AXE)))
X  		allowflags |= ALLOW_DIG;
X+ 	if (!nohands(mtmp->data) && !verysmall(mtmp->data)) {
X+ 		allowflags |= OPENDOOR;
X+ 		if (m_carrying(mtmp, SKELETON_KEY)) allowflags |= BUSTDOOR;
X+ 	}
X+ 	if (is_giant(mtmp->data)) allowflags |= BUSTDOOR;
X  	cnt = mfndpos(mtmp, poss, info, allowflags);
X  	if (allowflags & ALLOW_DIG) if(!mdig_tunnel(mtmp)) return(-2);
X  
X***************
X*** 100,107 ****
X--- 114,125 ----
X  	return(0);
X  }
X  
X+ #endif /* OVLB */
X+ 
X  #if defined(ALTARS) && defined(THEOLOGY)
X  
X+ #ifdef OVL0
X+ 
X  struct mkroom *
X  in_temple(x, y)
X  register int x, y;
X***************
X*** 113,118 ****
X--- 131,139 ----
X  	return(&rooms[roomno]);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  static boolean
X  histemple_at(priest, x, y)
X  register struct monst *priest;
X***************
X*** 308,318 ****
X--- 329,344 ----
X  struct mkroom *troom;
X  {
X  	register struct monst *mtmp;
X+ 	extern struct monst *fdmon; /* from mon.c */
X  
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	    if(mtmp->ispriest && histemple_at(mtmp,mtmp->mx,mtmp->my)
X  			&& &rooms[EPRI(mtmp)->shroom] == troom)
X  		return(mtmp);
X+ 	for(mtmp = fdmon; mtmp; mtmp = mtmp->nmon)
X+ 	    if(mtmp->ispriest && histemple_at(mtmp,mtmp->mx,mtmp->my)
X+ 			&& &rooms[EPRI(mtmp)->shroom] == troom)
X+ 		return(mtmp);
X  	return (struct monst *)0;
X  }
X  
X***************
X*** 383,392 ****
X  
X  	/* priests don't chat unless peaceful and in their own temple */
X  	if(!histemple_at(priest,priest->mx,priest->my) || priest->mtame ||
X! 		 !priest->mpeaceful || priest->mfroz || priest->msleep) {
X!             if(priest->mfroz || priest->msleep) {
X  	        kludge("%s breaks out of his reverie!", Monnam(priest));
X!                 priest->mfroz = priest->msleep = 0;
X  	    }
X  	    /* The following is now impossible according to monst.c, */
X  	    /* but it should stay just in case we change the latter. */
X--- 409,419 ----
X  
X  	/* priests don't chat unless peaceful and in their own temple */
X  	if(!histemple_at(priest,priest->mx,priest->my) || priest->mtame ||
X! 		 !priest->mpeaceful || !priest->mcanmove || priest->msleep) {
X!             if(!priest->mcanmove || priest->msleep) {
X  	        kludge("%s breaks out of his reverie!", Monnam(priest));
X!                 priest->mfrozen = priest->msleep = 0;
X! 		priest->mcanmove = 1;
X  	    }
X  	    /* The following is now impossible according to monst.c, */
X  	    /* but it should stay just in case we change the latter. */
X***************
X*** 547,550 ****
X--- 574,580 ----
X  	if(!(priest = findpriest(in_temple(u.ux, u.uy)))) return;
X  	wakeup(priest);
X  }
X+ 
X+ #endif /* OVLB */
X  #endif /* ALTARS && THEOLOGY */
X+ 
X*** src/Old/prisym.c	Mon Feb 19 18:54:59 1990
X--- src/prisym.c	Mon Feb  5 18:09:58 1990
X***************
X*** 8,16 ****
X  #include "wseg.h"
X  #include "lev.h"
X  
X! static void FDECL(pwseg, (struct wseg *));
X  #endif
X  
X  void
X  atl(x,y,ch)
X  register int x, y;
X--- 8,18 ----
X  #include "wseg.h"
X  #include "lev.h"
X  
X! OSTATIC void FDECL(pwseg, (struct wseg *));
X  #endif
X  
X+ #ifdef OVL0
X+ 
X  void
X  atl(x,y,ch)
X  register int x, y;
X***************
X*** 44,49 ****
X--- 46,54 ----
X  	if(y > scrhy) scrhy = y;
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X  /* call: (x,y) - display
X  	(-1,0) - close (leave last symbol)
X  	(-1,-1)- close (undo last symbol)
X***************
X*** 161,166 ****
X--- 166,174 ----
X  	}
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL1
X+ 
X  void
X  curs_on_u()
X  {
X***************
X*** 196,201 ****
X--- 204,212 ----
X  	levl[u.ux][u.uy].seen = 1;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  /* print a position that is visible for @ */
X  void
X  prl(x,y)
X***************
X*** 423,428 ****
X--- 434,442 ----
X  	atl(x,y,(char)news0(x,y));
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  /* used with wand of digging (or pick-axe): fill scrsym and force display */
X  /* also when a POOL evaporates */
X  void
X***************
X*** 442,447 ****
X--- 456,464 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  nosee(x,y)
X  register int x, y;
X***************
X*** 450,456 ****
X  
X  	if(!isok(x,y)) return;
X  	room = &levl[x][y];
X! 	if(IS_FLOOR(levl[x][y].typ)
X  	   && !room->lit && !Blind) {
X  		room->scrsym = STONE_SYM;	/* was ' ' -- OIS */
X  		room->new = 1;
X--- 467,473 ----
X  
X  	if(!isok(x,y)) return;
X  	room = &levl[x][y];
X! 	if(levl[x][y].scrsym == ROOM_SYM
X  	   && !room->lit && !Blind) {
X  		room->scrsym = STONE_SYM;	/* was ' ' -- OIS */
X  		room->new = 1;
X***************
X*** 515,520 ****
X--- 532,540 ----
X  	return(0);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifdef NEWSCR
X  void
X  pobj(obj)
X***************
X*** 553,559 ****
X  }
X  
X  #ifdef WORM
X! static void
X  pwseg(wtmp)
X  register struct wseg *wtmp;
X  {
X--- 573,579 ----
X  }
X  
X  #ifdef WORM
X! XSTATIC void
X  pwseg(wtmp)
X  register struct wseg *wtmp;
X  {
X***************
X*** 590,601 ****
X  	return(typ == DOOR);
X  }
X  
X- boolean IS_FLOOR(typ)
X- unsigned typ;
X- {
X- 	return(typ == ROOM);
X- }
X- 
X  boolean ACCESSIBLE(typ)
X  unsigned typ;
X  {
X--- 610,615 ----
X***************
X*** 662,664 ****
X--- 676,680 ----
X  	return(typ >= STAIRS && typ <= ALTAR);
X  }
X  #endif /* STUPID_CPP */
X+ 
X+ #endif /* OVLB */
X*** src/Old/read.c	Mon Feb 19 18:55:26 1990
X--- src/read.c	Mon Feb  5 18:10:02 1990
X***************
X*** 4,9 ****
X--- 4,11 ----
X  
X  #include "hack.h"
X  
X+ #ifdef OVLB
X+ 
X  boolean	known;
X  
X  static const char readable[] = { '#', SCROLL_SYM,
X***************
X*** 12,19 ****
X  #endif
X  	0 };
X  
X  static void FDECL(explode, (struct obj *));
X! static void do_class_genocide();
X  
X  int
X  doread() {
X--- 14,31 ----
X  #endif
X  	0 };
X  
X+ #endif /* OVLB */
X+ 
X  static void FDECL(explode, (struct obj *));
X! static void NDECL(do_class_genocide);
X! static void FDECL(stripspe,(struct obj *));
X! static void FDECL(p_glow1,(struct obj *));
X! static void FDECL(p_glow2,(struct obj *,const char *));
X! static void FDECL(recharge,(struct obj *,int));
X! static void FDECL(forget,(BOOLEAN_P));
X! OSTATIC void FDECL(show_map_spot,(int,int));
X! 
X! #ifdef OVLB
X  
X  int
X  doread() {
X***************
X*** 118,129 ****
X  static void
X  p_glow2(otmp,color)
X  register struct obj	*otmp;
X! register char *color;
X  {
X  	Your("%s %s%s for a moment.",
X  		xname(otmp),
X  		Blind ? "vibrates" : "glows ",
X! 		Blind ? "" : Hallucination ? hcolor() : color);
X  }
X  
X  /*
X--- 130,141 ----
X  static void
X  p_glow2(otmp,color)
X  register struct obj	*otmp;
X! register const char *color;
X  {
X  	Your("%s %s%s for a moment.",
X  		xname(otmp),
X  		Blind ? "vibrates" : "glows ",
X! 		Blind ? (const char *)"" : Hallucination ? hcolor() : color);
X  }
X  
X  /*
X***************
X*** 137,166 ****
X  int curse_bless;
X  {
X  	register int n;
X! 	boolean cursed, blessed;
X  
X! 	cursed = curse_bless < 0;
X! 	blessed = curse_bless > 0;
X  
X  	if (obj->olet != WAND_SYM) {
X  	    switch(obj->otyp) {
X  	    case MAGIC_MARKER:
X! 		if (cursed) stripspe(obj);
X! 		else if (blessed) {
X  		    n = obj->spe;
X  		    if (n < 50) obj->spe = 50;
X  		    if (n >= 50 && n < 75) obj->spe = 75;
X  		    if (n >= 75) obj->spe += 10;
X  		    p_glow2(obj,blue);
X  		} else {
X  		    if (obj->spe < 50) obj->spe = 50;
X  		    else obj->spe++;
X  		    p_glow2(obj,white);
X  		}
X  		break;
X  	    case LAMP:
X! 		if (cursed) stripspe(obj);
X! 		else if (blessed) {
X  		    n = rn2(11);
X  		    if (obj->spe < n) obj->spe = n;
X  		    else obj->spe += rnd(3);
X--- 149,186 ----
X  int curse_bless;
X  {
X  	register int n;
X! 	boolean is_cursed, is_blessed;
X  
X! 	is_cursed = curse_bless < 0;
X! 	is_blessed = curse_bless > 0;
X  
X  	if (obj->olet != WAND_SYM) {
X  	    switch(obj->otyp) {
X  	    case MAGIC_MARKER:
X! 		if (is_cursed) stripspe(obj);
X! 		else if (obj->recharged) {
X! 		    if (obj->spe < 3)
X! 			Your("marker seems permanently dried out.");
X! 		    else
X! 			pline(nothing_happens);
X! 		}
X! 		else if (is_blessed) {
X  		    n = obj->spe;
X  		    if (n < 50) obj->spe = 50;
X  		    if (n >= 50 && n < 75) obj->spe = 75;
X  		    if (n >= 75) obj->spe += 10;
X  		    p_glow2(obj,blue);
X+ 		    obj->recharged = 1;
X  		} else {
X  		    if (obj->spe < 50) obj->spe = 50;
X  		    else obj->spe++;
X  		    p_glow2(obj,white);
X+ 		    obj->recharged = 1;
X  		}
X  		break;
X  	    case LAMP:
X! 		if (is_cursed) stripspe(obj);
X! 		else if (is_blessed) {
X  		    n = rn2(11);
X  		    if (obj->spe < n) obj->spe = n;
X  		    else obj->spe += rnd(3);
X***************
X*** 171,178 ****
X  		}
X  		break;
X  	    case MAGIC_LAMP:
X! 		if (cursed) stripspe(obj);
X! 		else if (blessed > 0) {
X  		    if (obj->spe == 1 || obj->recharged)
X  			pline(nothing_happens);
X  		    else {
X--- 191,198 ----
X  		}
X  		break;
X  	    case MAGIC_LAMP:
X! 		if (is_cursed) stripspe(obj);
X! 		else if (is_blessed > 0) {
X  		    if (obj->spe == 1 || obj->recharged)
X  			pline(nothing_happens);
X  		    else {
X***************
X*** 194,201 ****
X  		}
X  		break;
X  	    case CRYSTAL_BALL:
X! 		if (cursed) stripspe(obj);
X! 		else if (blessed) {
X  		    obj->spe = 6;
X  		    p_glow2(obj,blue);
X  		} else {
X--- 214,221 ----
X  		}
X  		break;
X  	    case CRYSTAL_BALL:
X! 		if (is_cursed) stripspe(obj);
X! 		else if (is_blessed) {
X  		    obj->spe = 6;
X  		    p_glow2(obj,blue);
X  		} else {
X***************
X*** 206,213 ****
X  		}
X  		break;
X  	    case BAG_OF_TRICKS:
X! 		if (cursed) stripspe(obj);
X! 		else if (blessed) {
X  		    if (obj->spe <= 10)
X  			obj->spe += (5 + rnd(10));
X  		    else obj->spe += (5 + rnd(5));
X--- 226,233 ----
X  		}
X  		break;
X  	    case BAG_OF_TRICKS:
X! 		if (is_cursed) stripspe(obj);
X! 		else if (is_blessed) {
X  		    if (obj->spe <= 10)
X  			obj->spe += (5 + rnd(10));
X  		    else obj->spe += (5 + rnd(5));
X***************
X*** 228,235 ****
X  		    explode(obj);
X  		    return;
X  		}
X! 		if (cursed) stripspe(obj);
X! 		else if (blessed) {
X  		    if (obj->spe != 3) {
X  			obj->spe = 3;
X  			p_glow2(obj,blue);
X--- 248,255 ----
X  		    explode(obj);
X  		    return;
X  		}
X! 		if (is_cursed) stripspe(obj);
X! 		else if (is_blessed) {
X  		    if (obj->spe != 3) {
X  			obj->spe = 3;
X  			p_glow2(obj,blue);
X***************
X*** 246,253 ****
X  		obj->recharged = 1; /* another recharging disallowed */
X  	    }
X  	    else {
X! 		if (cursed) stripspe(obj);
X! 		else if (blessed) {
X  		    if (objects[obj->otyp].bits & NODIR) {
X  			n = rn1(5,11);
X  			if (obj->spe < n) obj->spe = n;
X--- 266,273 ----
X  		obj->recharged = 1; /* another recharging disallowed */
X  	    }
X  	    else {
X! 		if (is_cursed) stripspe(obj);
X! 		else if (is_blessed) {
X  		    if (objects[obj->otyp].bits & NODIR) {
X  			n = rn1(5,11);
X  			if (obj->spe < n) obj->spe = n;
X***************
X*** 331,337 ****
X  				xname(otmp),
X  				sobj->cursed ? "mottled" : "shimmering",
X  				Hallucination ? hcolor() :
X! 				  sobj->cursed ? black : "gold",
X  				sobj->cursed ? "glow" :
X  				  (is_shield(otmp) ? "layer" : "shield"));
X  			if(!(sobj->cursed))
X--- 351,357 ----
X  				xname(otmp),
X  				sobj->cursed ? "mottled" : "shimmering",
X  				Hallucination ? hcolor() :
X! 				  sobj->cursed ? black : (const char *)"gold",
X  				sobj->cursed ? "glow" :
X  				  (is_shield(otmp) ? "layer" : "shield"));
X  			if(!(sobj->cursed))
X***************
X*** 347,353 ****
X  		Your("%s violently %s%s for a while, then evaporates.",
X  			    xname(otmp),
X  			    Blind ? "vibrates" : "glows ",
X! 			    Blind ? "" : Hallucination ? hcolor() : silver);
X  			if(is_cloak(otmp)) (void) Cloak_off();
X  			if(is_boots(otmp)) (void) Boots_off();
X  			if(is_helmet(otmp)) (void) Helmet_off();
X--- 367,373 ----
X  		Your("%s violently %s%s for a while, then evaporates.",
X  			    xname(otmp),
X  			    Blind ? "vibrates" : "glows ",
X! 			    Blind ? nul : Hallucination ? hcolor() : silver);
X  			if(is_cloak(otmp)) (void) Cloak_off();
X  			if(is_boots(otmp)) (void) Boots_off();
X  			if(is_helmet(otmp)) (void) Helmet_off();
X***************
X*** 361,367 ****
X  		Your("%s %s%s for a %s.",
X  			xname(otmp),
X  			Blind ? "vibrates" : "glows ",
X! 			Blind ? "" : Hallucination ? hcolor() :
X  			  sobj->cursed ? black : silver,
X  			  (s*s>1) ? "while" : "moment");
X  		otmp->cursed = sobj->cursed;
X--- 381,387 ----
X  		Your("%s %s%s for a %s.",
X  			xname(otmp),
X  			Blind ? "vibrates" : "glows ",
X! 			Blind ? nul : Hallucination ? hcolor() :
X  			  sobj->cursed ? black : silver,
X  			  (s*s>1) ? "while" : "moment");
X  		otmp->cursed = sobj->cursed;
X***************
X*** 407,427 ****
X  			Your("%s begin to %s%s.",
X  			    makeplural(body_part(HAND)),
X  			    Blind ? "tingle" : "glow ",
X! 			    Blind ? "" : Hallucination ? hcolor() : purple);
X  			make_confused(HConfusion + rnd(100),FALSE);
X  		    } else {
X  			pline("A %s%s surrounds your %s.",
X! 			    Blind ? "" : Hallucination ? hcolor() : red,
X  			    Blind ? "faint buzz" : " glow",
X  			    body_part(HEAD));
X  			make_confused(0L,TRUE);
X  		    }
X  		} else {
X! 			Your("%s%s %s.",
X  			makeplural(body_part(HAND)),
X  			Blind ? "" : " begin to glow",
X! 			Blind ? "tingle" : Hallucination ? hcolor() : red);
X! 			u.umconf = 1;
X  		}
X  		break;
X  	case SCR_SCARE_MONSTER:
X--- 427,461 ----
X  			Your("%s begin to %s%s.",
X  			    makeplural(body_part(HAND)),
X  			    Blind ? "tingle" : "glow ",
X! 			    Blind ? nul : Hallucination ? hcolor() : purple);
X  			make_confused(HConfusion + rnd(100),FALSE);
X  		    } else {
X  			pline("A %s%s surrounds your %s.",
X! 			    Blind ? nul : Hallucination ? hcolor() : red,
X  			    Blind ? "faint buzz" : " glow",
X  			    body_part(HEAD));
X  			make_confused(0L,TRUE);
X  		    }
X  		} else {
X! 		    if (!sobj->blessed) {
X! 			Your("%s%s %s%s.",
X  			makeplural(body_part(HAND)),
X  			Blind ? "" : " begin to glow",
X! 			Blind ? (const char *)"tingle" : Hallucination ? hcolor() : red,
X! 			u.umconf ? " even more" : "");
X! 			u.umconf++;
X! 		    } else {
X! 			if (Blind)
X! 			    Your("%s tingle %s sharply.",
X! 				makeplural(body_part(HAND)),
X! 				u.umconf ? "even more" : "very");
X! 			else
X! 			    Your("%s glow a%s brilliant %s.",
X! 				makeplural(body_part(HAND)),
X! 				u.umconf ? "n even more" : "",
X! 				Hallucination ? hcolor() : red);
X! 			u.umconf += (1 + rnd(8));
X! 		    }
X  		}
X  		break;
X  	case SCR_SCARE_MONSTER:
X***************
X*** 433,441 ****
X  
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  		    if(cansee(mtmp->mx,mtmp->my)) {
X! 			if(confused || sobj->cursed)
X! 			    mtmp->mflee = mtmp->mfroz = mtmp->msleep = 0;
X! 			else
X  			    if (! resist(mtmp, sobj->olet, 0, NOTELL))
X  				mtmp->mflee = 1;
X  			if(!mtmp->mtame) ct++;	/* pets don't laugh at you */
X--- 467,476 ----
X  
X  		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  		    if(cansee(mtmp->mx,mtmp->my)) {
X! 			if(confused || sobj->cursed) {
X! 			    mtmp->mflee = mtmp->mfrozen = mtmp->msleep = 0;
X! 			    mtmp->mcanmove = 1;
X! 			} else
X  			    if (! resist(mtmp, sobj->olet, 0, NOTELL))
X  				mtmp->mflee = 1;
X  			if(!mtmp->mtame) ct++;	/* pets don't laugh at you */
X***************
X*** 512,519 ****
X  	    }
X  /*	    break;	/*NOTREACHED*/
X  	case SCR_ENCHANT_WEAPON:
X! 		if(uwep && (uwep->olet == WEAPON_SYM || uwep->otyp == PICK_AXE)
X! 							&& confused) {
X  		/* olet check added 10/25/86 GAN */
X                          uwep->rustfree = !(sobj->cursed);
X  			if(Blind)
X--- 547,554 ----
X  	    }
X  /*	    break;	/*NOTREACHED*/
X  	case SCR_ENCHANT_WEAPON:
X! 		if(uwep && (uwep->olet == WEAPON_SYM || uwep->otyp == PICK_AXE
X! 			|| uwep->otyp == UNICORN_HORN) && confused) {
X  		/* olet check added 10/25/86 GAN */
X                          uwep->rustfree = !(sobj->cursed);
X  			if(Blind)
X***************
X*** 523,529 ****
X  				aobjnam(uwep, "are"),
X  				sobj->cursed ? "mottled" : "shimmering",
X  				Hallucination ? hcolor() :
X! 				  sobj->cursed ? purple : "gold",
X  				sobj->cursed ? "glow" : "shield");
X  		} else return !chwepon(sobj, bcsign(sobj)*2+1);
X  		break;
X--- 558,564 ----
X  				aobjnam(uwep, "are"),
X  				sobj->cursed ? "mottled" : "shimmering",
X  				Hallucination ? hcolor() :
X! 				  sobj->cursed ? purple : (const char *)"gold",
X  				sobj->cursed ? "glow" : "shield");
X  		} else return !chwepon(sobj, bcsign(sobj)*2+1);
X  		break;
X***************
X*** 571,578 ****
X--- 606,619 ----
X  
X  			if (sobj->blessed && !Teleport_control) {
X  				known = TRUE;
X+ #ifndef MACOS
X  				pline("Do you wish to teleport? ");
X  				if (yn()=='n') break;
X+ #else
X+ 				if(!flags.silent) SysBeep(1);
X+ 				if(UseMacAlertText(128, "Do you wish to teleport ?") == 2)
X+ 					break;
X+ #endif
X  			}
X  			tele();
X  			if(uroom != inroom(u.ux, u.uy)) known = TRUE;
X***************
X*** 589,594 ****
X--- 630,640 ----
X  		if (food_detect(sobj))
X  			return(1);	/* nothing detected */
X  		break;
X+ #ifdef SPELLS
X+ 	case SPE_IDENTIFY:
X+ 		cval = rn2(5);
X+ 		goto id;
X+ #endif
X  	case SCR_IDENTIFY:
X  		/* known = TRUE; */
X  		if(confused)
X***************
X*** 602,608 ****
X  		useup(sobj);
X  		makeknown(SCR_IDENTIFY);
X  #ifdef SPELLS
X! 	case SPE_IDENTIFY:
X  #endif
X  		if(!confused)
X  		    while(invent && !ggetobj("identify", identify, cval));
X--- 648,654 ----
X  		useup(sobj);
X  		makeknown(SCR_IDENTIFY);
X  #ifdef SPELLS
X! 	id:
X  #endif
X  		if(!confused)
X  		    while(invent && !ggetobj("identify", identify, cval));
X***************
X*** 665,671 ****
X  		    } else {
X  			pline("The scroll catches fire and you burn your %s.",
X  				makeplural(body_part(HAND)));
X! 			losehp(1, "scroll of fire");
X  		    }
X  		    return(1);
X  		}
X--- 711,717 ----
X  		    } else {
X  			pline("The scroll catches fire and you burn your %s.",
X  				makeplural(body_part(HAND)));
X! 			losehp(1, "scroll of fire", KILLED_BY_AN);
X  		    }
X  		    return(1);
X  		}
X***************
X*** 676,682 ****
X  			You("are uninjured.");
X  		} else {
X  			u.uhpmax -= num;
X! 			losehp(num, "scroll of fire");
X  		}
X  		destroy_item(SCROLL_SYM, AD_FIRE);
X  #ifdef SPELLS
X--- 722,728 ----
X  			You("are uninjured.");
X  		} else {
X  			u.uhpmax -= num;
X! 			losehp(num, "scroll of fire", KILLED_BY_AN);
X  		}
X  		destroy_item(SCROLL_SYM, AD_FIRE);
X  #ifdef SPELLS
X***************
X*** 689,697 ****
X  		    if(dist(mtmp->mx,mtmp->my) < 3) {
X  			if (resists_fire(mtmp->data)) continue;
X  			if (u.uswallow) {
X! 			    if (mtmp != u.ustuck) continue;
X! 			    pline("%s gets heartburn.", Monnam(u.ustuck));
X! 			    num *= 2;
X  			}
X  			mtmp->mhp -= num;		/* No saving throw! */
X  			if(resists_cold(mtmp->data))
X--- 735,748 ----
X  		    if(dist(mtmp->mx,mtmp->my) < 3) {
X  			if (resists_fire(mtmp->data)) continue;
X  			if (u.uswallow) {
X! 				if (mtmp != u.ustuck) continue;
X! 				if (is_animal(u.ustuck->data))
X! 					pline("%s gets heartburn.", 
X! 					      Monnam(u.ustuck));
X! 				else
X! 					You("toast %s slightly.", 
X! 					    Monnam(u.ustuck)); 
X! 				num *= 2;
X  			}
X  			mtmp->mhp -= num;		/* No saving throw! */
X  			if(resists_cold(mtmp->data))
X***************
X*** 724,730 ****
X  {
X      Your("%s vibrates violently, and explodes!",xname(obj));
X      bell();
X!     losehp(rn2(2*(u.uhpmax+1)/3),"exploding wand");
X      useup(obj);
X  }
X  
X--- 775,781 ----
X  {
X      Your("%s vibrates violently, and explodes!",xname(obj));
X      bell();
X!     losehp(rn2(2*(u.uhpmax+1)/3),"exploding wand", KILLED_BY_AN);
X      useup(obj);
X  }
X  
X***************
X*** 745,751 ****
X  			pline("It suddenly becomes dark in here.");
X  	} else {
X  		if(u.uswallow){
X! 			pline("%s's stomach is lit.", Monnam(u.ustuck));
X  			return;
X  		}
X  		if(is_maze_lev){
X--- 796,809 ----
X  			pline("It suddenly becomes dark in here.");
X  	} else {
X  		if(u.uswallow){
X! 			if (is_animal(u.ustuck->data))
X! 				pline("%s's stomach is lit.", Monnam(u.ustuck));
X! 			else
X! 				if (is_whirly(u.ustuck->data))
X! 					pline("%s shines briefly.", 
X! 					      Monnam(u.ustuck));
X! 				else
X! 					pline("%s glistens.", Monnam(u.ustuck));
X  			return;
X  		}
X  		if(is_maze_lev){
X***************
X*** 829,834 ****
X--- 887,893 ----
X  			    pline("Wiped out all %s.", n);
X  			    if (&mons[i] == player_mon()) {
X  				u.uhp = -1;
X+ 				killer_format = KILLED_BY_AN;
X  				killer = "scroll of genocide";
X  #ifdef POLYSELF
X  				if (u.umonnum >= 0)
X***************
X*** 935,940 ****
X--- 994,1000 ----
X  	    pline("Wiped out all %s.", makeplural(buf));
X  	    if(killplayer) {
X  		u.uhp = -1;
X+ 		killer_format = KILLED_BY_AN;
X  		killer = "genocide spell";
X  #ifdef POLYSELF
X  	/* A polymorphed character will die as soon as he is rehumanized. */
X***************
X*** 961,967 ****
X  	}
X  }
X  
X! static void
X  show_map_spot(x, y)
X  register int x, y;
X  {
X--- 1021,1030 ----
X  	}
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL0
X! 
X! XSTATIC void
X  show_map_spot(x, y)
X  register int x, y;
X  {
X***************
X*** 998,1003 ****
X--- 1061,1069 ----
X  		show_map_spot(zx, zy);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  do_vicinity_map() {
X  	register int zx, zy;
X***************
X*** 1065,1071 ****
X  		return(1);
X  	} else if(!ct) {
X  		known = TRUE;
X! 		You("%s %s close nearby.", sobj ? "smell" : "sense",
X  			confused ? "something" : "food");
X  	} else {
X  		known = TRUE;
X--- 1131,1137 ----
X  		return(1);
X  	} else if(!ct) {
X  		known = TRUE;
X! 		You("%s %s nearby.", sobj ? "smell" : "sense",
X  			confused ? "something" : "food");
X  	} else {
X  		known = TRUE;
X***************
X*** 1136,1149 ****
X  create_particular()
X  {
X  	char buf[BUFSZ];
X! 	int which;
X  
X  	do {
X  	    pline("Create what kind of monster? [type the name] ");
X  	    getlin(buf);
X! 	} while(strlen(buf) < 1);
X! 	which = name_to_mon(buf);
X! 	if (which != -1) {
X  	    if (!(mons[which].geno & G_GENOD) && cant_create(&which) &&
X  								!Blind) {
X  		if (mons[which].geno & G_GENOD)
X--- 1202,1218 ----
X  create_particular()
X  {
X  	char buf[BUFSZ];
X! 	int which, tries = 0;
X  
X  	do {
X  	    pline("Create what kind of monster? [type the name] ");
X  	    getlin(buf);
X! 	    which = name_to_mon(buf);
X! 	    if (which < 0) pline("I've never heard of such monsters.");
X! 	    else break;
X! 	} while (++tries < 5);
X! 	if (tries == 5) pline(thats_enough_tries);
X! 	else {
X  	    if (!(mons[which].geno & G_GENOD) && cant_create(&which) &&
X  								!Blind) {
X  		if (mons[which].geno & G_GENOD)
X***************
X*** 1157,1159 ****
X--- 1226,1230 ----
X  	return FALSE;
X  }
X  #endif /* WIZARD || EXPLORE_MODE */
X+ 
X+ #endif /* OVLB */
X*** src/Old/restore.c	Mon Feb 19 18:56:14 1990
X--- src/restore.c	Fri Feb 16 19:06:29 1990
X***************
X*** 99,105 ****
X  	register struct fruit *oldf;
X  #endif
X  	int xl;
X! #ifdef LINT
X  	/* suppress "used before set" warning from lint */
X  	otmp2 = 0;
X  #endif
X--- 99,105 ----
X  	register struct fruit *oldf;
X  #endif
X  	int xl;
X! #if defined(LINT) || defined(__GNULINT__)
X  	/* suppress "used before set" warning from lint */
X  	otmp2 = 0;
X  #endif
X***************
X*** 148,160 ****
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4)
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X  #endif
X  
X! #ifdef LINT
X  	/* suppress "used before set" warning from lint */
X  	mtmp2 = 0;
X  #endif
X--- 148,160 ----
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX)
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X  #endif
X  
X! #if defined(LINT) || defined(__GNULINT__)
X  	/* suppress "used before set" warning from lint */
X  	mtmp2 = 0;
X  #endif
X***************
X*** 167,173 ****
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4)
X  		/* ANSI type for differ is ptrdiff_t --
X  		 * long may be wrong for segmented architecture --
X  		 * may be better to cast pointers to (struct permonst *)
X--- 167,173 ----
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4) && !defined(HPUX)
X  		/* ANSI type for differ is ptrdiff_t --
X  		 * long may be wrong for segmented architecture --
X  		 * may be better to cast pointers to (struct permonst *)
X***************
X*** 241,246 ****
X--- 241,249 ----
X  	    if(tmp != getuid()) {		/* strange ... */
X  		(void) close(fd);
X  		(void) unlink(SAVEF);
X+ #ifdef AMIGA_WBENCH
X+ 		ami_wbench_unlink(SAVEF);
X+ #endif
X  		(void) puts("Saved game was not yours.");
X  		restoring = FALSE;
X  		return(0);
X***************
X*** 286,293 ****
X  #endif
X  	mread(fd, (genericptr_t) &is_maze_lev, sizeof is_maze_lev);
X  	mread(fd, (genericptr_t) &u, sizeof(struct you));
X  #ifdef SPELLS
X! 	mread(fd, (genericptr_t) spl_book, sizeof(struct spell) * (MAXSPELL + 1));
X  #endif
X  	if(u.ustuck)
X  		mread(fd, (genericptr_t) &mid, sizeof mid);
X--- 289,311 ----
X  #endif
X  	mread(fd, (genericptr_t) &is_maze_lev, sizeof is_maze_lev);
X  	mread(fd, (genericptr_t) &u, sizeof(struct you));
X+ 	if(u.uhp <= 0) {
X+ 	    (void) close(fd);
X+ 	    (void) unlink(SAVEF);
X+ #ifdef AMIGA_WBENCH
X+ 	    ami_wbench_unlink(SAVEF);
X+ #endif
X+ 	    (void) puts("You were not healthy enough to survive restoration.");
X+ 	    restoring = FALSE;
X+ 	    return(0);
X+ 	}
X  #ifdef SPELLS
X! 	mread(fd, (genericptr_t) spl_book, 
X! 				sizeof(struct spell) * (MAXSPELL + 1));
X! #endif
X! #ifdef NAMED_ITEMS
X! 	mread(fd, (genericptr_t) artiexist, 
X! 			(unsigned int)(sizeof(boolean) * artifact_num));
X  #endif
X  	if(u.ustuck)
X  		mread(fd, (genericptr_t) &mid, sizeof mid);
X***************
X*** 349,358 ****
X  			
X  			if (er = Create(&fileName, 0, CREATOR, LEVEL_TYPE))
X  				SysBeep(1);
X! 			else {
X! 				msmsg(".");
X! 				nfd = open(lock, O_WRONLY | O_BINARY);
X! 			}
X  			(void)SetVol(0L, oldVolume);
X  		}
X  # else
X--- 367,374 ----
X  			
X  			if (er = Create(&fileName, 0, CREATOR, LEVEL_TYPE))
X  				SysBeep(1);
X! 			msmsg(".");
X! 			nfd = open(lock, O_WRONLY | O_BINARY);
X  			(void)SetVol(0L, oldVolume);
X  		}
X  # else
X***************
X*** 360,366 ****
X  # endif /* MACOS */
X  #endif
X  		if (nfd < 0)	panic("Cannot open temp file %s!\n", lock);
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!savelev(nfd, ltmp, COUNT | WRITE)) {
X  
X  			/* The savelev can't proceed because the size required
X--- 376,382 ----
X  # endif /* MACOS */
X  #endif
X  		if (nfd < 0)	panic("Cannot open temp file %s!\n", lock);
X! #if defined(DGK)
X  		if (!savelev(nfd, ltmp, COUNT | WRITE)) {
X  
X  			/* The savelev can't proceed because the size required
X***************
X*** 423,428 ****
X--- 439,447 ----
X  				)
X  #endif
X  		(void) unlink(SAVEF);
X+ #ifdef AMIGA_WBENCH
X+ 		ami_wbench_unlink(SAVEF);
X+ #endif
X  #ifdef REINCARNATION
X  	/* this can't be done earlier because we need to check the initial
X  	 * showsyms against the one saved in each of the non-rogue levels */
X***************
X*** 489,495 ****
X  	short tlev;
X  #endif
X  
X! #if defined(MSDOS) && !defined(TOS)
X  	setmode(fd, O_BINARY);	    /* is this required for TOS??? NO --ERS */
X  #endif
X  #ifdef TUTTI_FRUTTI
X--- 508,514 ----
X  	short tlev;
X  #endif
X  
X! #if defined(MSDOS) && !defined(TOS) && !defined(LATTICE) && !defined(AZTEC_C)
X  	setmode(fd, O_BINARY);	    /* is this required for TOS??? NO --ERS */
X  #endif
X  #ifdef TUTTI_FRUTTI
X***************
X*** 558,572 ****
X  	mread(fd, (genericptr_t) levl, sizeof(levl));
X  #endif
X  	mread(fd, (genericptr_t) osymbol, sizeof(osymbol));
X- 	if (memcmp((genericptr_t) osymbol,
X- 		   (genericptr_t) showsyms, sizeof (showsyms))
X  #ifdef REINCARNATION
X! 		&& dlvl != rogue_level
X! 		/* rogue level always uses default syms, and showsyms will still
X! 		 * have its initial value from environment when restoring a
X! 		 * game */
X  #endif
X- 	    ) {
X  		for (x = 0; x < COLNO; x++)
X  			for (y = 0; y < ROWNO; y++) {
X  				osym = levl[x][y].scrsym;
X--- 577,598 ----
X  	mread(fd, (genericptr_t) levl, sizeof(levl));
X  #endif
X  	mread(fd, (genericptr_t) osymbol, sizeof(osymbol));
X  #ifdef REINCARNATION
X! 	if (memcmp((genericptr_t) osymbol, ((dlevel==rogue_level)
X! 			? (genericptr_t)savesyms : (genericptr_t)showsyms),
X! 			sizeof (osymbol))
X! 		&& dlvl != rogue_level) {
X! 		/* rogue level always uses default syms.  Although showsyms
X! 		 * will be properly initialized from environment when restoring
X! 		 * a game, this routine is called upon saving as well as
X! 		 * restoring; when saving on the Rogue level, showsyms will
X! 		 * be wrong, so use savesyms (which is always right, both on
X! 		 * saving and restoring).
X! 		 */
X! #else
X! 	if (memcmp((genericptr_t) osymbol,
X! 		   (genericptr_t) showsyms, sizeof (showsyms))) {
X  #endif
X  		for (x = 0; x < COLNO; x++)
X  			for (y = 0; y < ROWNO; y++) {
X  				osym = levl[x][y].scrsym;
X***************
X*** 768,773 ****
X--- 794,807 ----
X  		if (!ghostly) {
X  			nhp = mtmp->mhp +
X  				(regenerates(mtmp->data) ? tmoves : tmoves/20);
X+ 			if(!mtmp->mcansee && mtmp->mblinded) {
X+ 				if (mtmp->mblinded < tmoves) mtmp->mblinded = 0;
X+ 				else mtmp->mblinded -= tmoves;
X+ 			}
X+ 			if(!mtmp->mcanmove && mtmp->mfrozen) {
X+ 				if (mtmp->mfrozen < tmoves) mtmp->mfrozen = 0;
X+ 				else mtmp->mfrozen -= tmoves;
X+ 			}
X  			if(nhp > mtmp->mhpmax)
X  				mtmp->mhp = mtmp->mhpmax;
X  			else
X***************
X*** 780,786 ****
X  	  }
X  	}
X  
X- 	setgd();
X  	fgold = 0;
X  	while(gold = newgold(),
X  	      mread(fd, (genericptr_t)gold, sizeof(struct gold)),
X--- 814,819 ----
X***************
X*** 915,920 ****
X--- 948,956 ----
X  		pline("Read %d instead of %u bytes.\n", rlen, len);
X  		if(restoring) {
X  			(void) unlink(SAVEF);
X+ #ifdef AMIGA_WBENCH
X+ 			ami_wbench_unlink(SAVEF);
X+ #endif
X  			error("Error restoring old game.");
X  		}
X  		panic("Error reading level file.");
X*** src/Old/rip.c	Mon Feb 19 18:56:50 1990
X--- src/rip.c	Thu Jan 25 22:16:01 1990
X***************
X*** 5,11 ****
X  #include "hack.h"
X  #include <ctype.h>
X  
X! static char *rip[] = {
X  "                       ----------",
X  "                      /          \\",
X  "                     /    REST    \\",
X--- 5,13 ----
X  #include "hack.h"
X  #include <ctype.h>
X  
X! static void FDECL(center,(int,char *));
X! 
X! static const char *rip_txt[] = {
X  "                       ----------",
X  "                      /          \\",
X  "                     /    REST    \\",
X***************
X*** 23,28 ****
X--- 25,32 ----
X  0
X  };
X  
X+ char **rip;
X+ 
X  static void
X  center(line, text)
X  int line;
X***************
X*** 36,45 ****
X  
X  void
X  outrip(){
X! 	register char **dp = rip;
X  	register char *dpx;
X  	char buf[BUFSZ];
X  	register int x, y;
X  
X  	cls();
X  	Sprintf(buf, "%s", plname);
X--- 40,59 ----
X  
X  void
X  outrip(){
X! 	register char **dp;
X  	register char *dpx;
X  	char buf[BUFSZ];
X  	register int x, y;
X+ 	int killed_by_line = 0;
X+ 
X+ 	rip = dp = (char **) alloc(sizeof(rip_txt));
X+ 	if (!dp) return;
X+ 	for (x = 0; rip_txt[x]; x++) {
X+ 		dp[x] = (char *) alloc((unsigned int)(strlen(rip_txt[x]) + 1));
X+ 		if (!dp[x]) return;
X+ 		Strcpy(dp[x], rip_txt[x]);
X+ 	}
X+ 	dp[x] = (char *)0;
X  
X  	cls();
X  	Sprintf(buf, "%s", plname);
X***************
X*** 47,58 ****
X  	center(6, buf);
X  	Sprintf(buf, "%ld Au", u.ugold);
X  	center(7, buf);
X! 	Strcpy(buf, "killed by");
X! 	if (islower(*killer) && strncmp(killer, "the ", 4) &&
X! 	    (strcmp(eos(killer)-4, "tion") || *(eos(killer)-5) == 'o') &&
X! 	    strcmp(killer, "contaminated water"))
X! 		Strcat(buf, index(vowels, *killer) ? " an" : " a");
X! 	center(8, buf);
X  	Strcpy(buf, killer);
X  	if(strlen(buf) > 16) {
X  	    register int i,i0,i1;
X--- 61,73 ----
X  	center(6, buf);
X  	Sprintf(buf, "%ld Au", u.ugold);
X  	center(7, buf);
X! 	if (killer_format != NO_KILLER_PREFIX) {
X! 		killed_by_line = 1;
X! 		Strcpy(buf, "killed by");
X! 		if (killer_format == KILLED_BY_AN)
X! 			Strcat(buf, index(vowels, *killer) ? " an" : " a");
X! 		center(8, buf);
X! 	}
X  	Strcpy(buf, killer);
X  	if(strlen(buf) > 16) {
X  	    register int i,i0,i1;
X***************
X*** 61,70 ****
X  			if(buf[i] == ' ') i0 = i, i1 = i+1;
X  		if(!i0) i0 = i1 = 16;
X  		buf[i1 + 16] = 0;
X! 		center(10, buf+i1);
X  		buf[i0] = 0;
X  	}
X! 	center(9, buf);
X  	Sprintf(buf, "%4d", getyear());
X  	center(11, buf);
X  	for(y=8; *dp; y++,dp++){
X--- 76,85 ----
X  			if(buf[i] == ' ') i0 = i, i1 = i+1;
X  		if(!i0) i0 = i1 = 16;
X  		buf[i1 + 16] = 0;
X! 		center(9 + killed_by_line, buf+i1);
X  		buf[i0] = 0;
X  	}
X! 	center(8 + killed_by_line, buf);
X  	Sprintf(buf, "%4d", getyear());
X  	center(11, buf);
X  	for(y=8; *dp; y++,dp++){
X*** src/Old/rnd.c	Mon Feb 19 18:57:04 1990
X--- src/rnd.c	Thu Jan 25 22:14:22 1990
X***************
X*** 17,22 ****
X--- 17,24 ----
X  #endif
X  #endif /* LINT */
X  
X+ #ifdef OVL2
X+ 
X  int
X  rn1(x,y)	/* y <= rn1(x,y) < (y+x) */
X  register int x, y;
X***************
X*** 24,29 ****
X--- 26,34 ----
X  	return(RND(x)+y);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL0
X+ 
X  int
X  rn2(x)		/* 0 <= rn2(x) < x */
X  register int x;
X***************
X*** 37,44 ****
X  	return(RND(x));
X  }
X  
X  int
X! rnl(x)		/* 0 <= rnl(x) < x; somtimes subtracting Luck */
X  register int x;	/* good luck approaches 0, bad luck approaches (x-1) */
X  {
X  	register int i = RND(x);
X--- 42,52 ----
X  	return(RND(x));
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  int
X! rnl(x)		/* 0 <= rnl(x) < x; sometimes subtracting Luck */
X  register int x;	/* good luck approaches 0, bad luck approaches (x-1) */
X  {
X  	register int i = RND(x);
X***************
X*** 52,57 ****
X--- 60,68 ----
X  	return i;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  rnd(x)		/* 1 <= rnd(x) <= x */
X  register int x;
X***************
X*** 65,70 ****
X--- 76,84 ----
X  	return(RND(x)+1);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  int
X  d(n,x)		/* n <= d(n,x) <= (n*x) */
X  register int n, x;
X***************
X*** 75,80 ****
X--- 89,97 ----
X  	return(tmp);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  rne(x)	  /* by stewr 870807 */
X  register int x;
X***************
X*** 103,105 ****
X--- 120,124 ----
X  	return((int)x);
X  }
X  #endif
X+ 
X+ #endif /* OVLB */
X*** src/Old/rumors.c	Mon Feb 19 18:57:18 1990
X--- src/rumors.c	Mon Jan 22 21:02:34 1990
X***************
X*** 22,28 ****
X  /* The oracle file consists of a number of multiple-line records, separated
X   * (but not terminated) by "-----" lines.
X   */
X! 
X  long first_rumor = sizeof(long);
X  long true_rumor_size, false_rumor_size, end_rumor_file;
X  #ifdef ORACLE
X--- 22,29 ----
X  /* The oracle file consists of a number of multiple-line records, separated
X   * (but not terminated) by "-----" lines.
X   */
X! static void NDECL(init_rumors);
X! static void NDECL(outoracle);
X  long first_rumor = sizeof(long);
X  long true_rumor_size, false_rumor_size, end_rumor_file;
X  #ifdef ORACLE
X***************
X*** 43,49 ****
X--- 44,56 ----
X  	Strcat(tmp,RUMORFILE);
X  	if(fp = fopen(tmp, "r")) {
X  #else
X+ # ifdef MACOS
X+ 	if(!(fp = fopen(RUMORFILE, "r")))
X+ 		fp = openFile(RUMORFILE, "r");
X+ 	if (fp) {
X+ # else
X  	if(fp = fopen(RUMORFILE, "r")) {
X+ # endif
X  #endif
X  	    (void) fread((genericptr_t)&true_rumor_size,sizeof(long),1,fp);
X  	    (void) fseek(fp, 0L, 2);
X***************
X*** 67,73 ****
X--- 74,86 ----
X  	Strcat(tmp,ORACLEFILE);
X  	if(fp = fopen(tmp, "r")) {
X  #else
X+ # ifdef MACOS
X+ 	if(!(fp = fopen(ORACLEFILE, "r")))
X+ 		fp = openFile(ORACLEFILE, "r");
X+ 	if (fp) {
X+ # else
X  	if(fp = fopen(ORACLEFILE, "r")) {
X+ # endif
X  #endif
X  	    (void) fseek(fp, 0L, 2);
X  	    oracle_size = ftell(fp);
X***************
X*** 112,118 ****
X  	if(rumors = fopen(tmp, "r")) {
X  #else
X  # ifdef MACOS
X! 	if(rumors = fopen(RUMORFILE, "r"))
X  		rumors = openFile(RUMORFILE, "r");
X  	if (rumors) {
X  # else
X--- 125,131 ----
X  	if(rumors = fopen(tmp, "r")) {
X  #else
X  # ifdef MACOS
X! 	if(!(rumors = fopen(RUMORFILE, "r")))
X  		rumors = openFile(RUMORFILE, "r");
X  	if (rumors) {
X  # else
X***************
X*** 131,136 ****
X--- 144,153 ----
X  		    case -1: beginning = first_rumor + true_rumor_size;
X  			tidbit = true_rumor_size + Rand() % false_rumor_size;
X  			break;
X+ 		    default:
X+ 			impossible("strange truth value for rumor");
X+ 			tidbit = 0; beginning = first_rumor;
X+ 			break;
X  		}
X  		(void) fseek(rumors, first_rumor + tidbit, 0);
X  		(void) fgets(line, COLNO, rumors);
X***************
X*** 176,182 ****
X  	if(oracles = fopen(tmp, "r")) {
X  #else
X  # ifdef MACOS
X! 	if(oracles = fopen(ORACLEFILE, "r"))
X  		oracles = openFile(ORACLEFILE, "r");
X  	if (oracles) {
X  # else
X--- 193,199 ----
X  	if(oracles = fopen(tmp, "r")) {
X  #else
X  # ifdef MACOS
X! 	if(!(oracles = fopen(ORACLEFILE, "r")))
X  		oracles = openFile(ORACLEFILE, "r");
X  	if (oracles) {
X  # else
X*** src/Old/save.c	Mon Feb 19 18:57:35 1990
X--- src/save.c	Fri Feb 16 22:07:43 1990
X***************
X*** 2,9 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include "hack.h"
X  #include "lev.h"
X  
X--- 2,9 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  #include "lev.h"
X  
X***************
X*** 14,26 ****
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #if defined(EXPLORE_MODE) && !defined(LSC) && !defined(O_RDONLY)
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X  boolean hu;		/* set during hang-up */
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  struct finfo fileinfo[MAXLEVEL+1];
X  long bytes_counted;
X  int count_only;
X--- 14,26 ----
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #if defined(EXPLORE_MODE) && !defined(LSC) && !defined(O_RDONLY) && !defined(AZTEC_C)
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X  boolean hu;		/* set during hang-up */
X  
X! #if defined(DGK)
X  struct finfo fileinfo[MAXLEVEL+1];
X  long bytes_counted;
X  int count_only;
X***************
X*** 28,66 ****
X  boolean level_exists[MAXLEVEL+1];
X  #endif
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  static void savelev0();
X! #endif /* DGK && !OLD_TOS */
X  static void saveobjchn();
X  static void savemonchn();
X  static void savegoldchn();
X  static void savetrapchn();
X  static void savegenoinfo();
X! #if defined(DGK) && !defined(OLD_TOS)
X  static boolean swapout_oldest();
X  static void copyfile();
X! #endif /* defined(DGK) && !defined(OLD_TOS) */
X  static void spill_objs();
X  
X  int
X  dosave(){
X  	clrlin();
X  	pline("Really save? ");	/* especially useful if COMPRESS defined */
X  	if(yn() == 'n') {
X  		clrlin();
X  		(void) fflush(stdout);
X  		if(multi > 0) nomul(0);
X  	} else {
X- #ifdef EXPLORE_MODE
X- # ifdef WIZARD
X- 		if(!discover && !wizard) {
X- # else
X- 		if(!discover) {
X- # endif
X- 	pline("Do you want to create a non-scoring, restartable save file? ");
X- 			if(yn() == 'y')  discover = TRUE;
X- 		}
X- #endif
X  		clear_screen();
X  		(void) fflush(stdout);
X  		hu = FALSE;
X--- 28,66 ----
X  boolean level_exists[MAXLEVEL+1];
X  #endif
X  
X! #if defined(DGK)
X  static void savelev0();
X! #endif /* DGK */
X  static void saveobjchn();
X  static void savemonchn();
X  static void savegoldchn();
X  static void savetrapchn();
X  static void savegenoinfo();
X! #if defined(DGK)
X  static boolean swapout_oldest();
X  static void copyfile();
X! #endif /* defined(DGK) */
X  static void spill_objs();
X+ #ifdef __GNULINT__
X+ static long nulls[10];
X+ #else
X+ #define nulls nul
X+ #endif
X  
X  int
X  dosave(){
X  	clrlin();
X+ #ifdef MACOS
X+ 	if(!flags.silent) SysBeep(1);
X+ 	if(UseMacAlertText(128, "Really save ?") != 1) {
X+ #else
X  	pline("Really save? ");	/* especially useful if COMPRESS defined */
X  	if(yn() == 'n') {
X+ #endif
X  		clrlin();
X  		(void) fflush(stdout);
X  		if(multi > 0) nomul(0);
X  	} else {
X  		clear_screen();
X  		(void) fflush(stdout);
X  		hu = FALSE;
X***************
X*** 93,99 ****
X  	register int fd, ofd;
X  	int tmp;		/* not register ! */
X  	xchar ltmp;
X! #if defined(DGK) && !defined(OLD_TOS)
X  	long fds, needed;
X  	int mode;
X  #endif
X--- 93,99 ----
X  	register int fd, ofd;
X  	int tmp;		/* not register ! */
X  	xchar ltmp;
X! #if defined(DGK)
X  	long fds, needed;
X  	int mode;
X  #endif
X***************
X*** 110,116 ****
X  #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X! #if !defined(__TURBOC__) && !defined(OLD_TOS) && !defined(NO_SIGNAL)
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  
X--- 110,116 ----
X  #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X! #if !defined(__TURBOC__) && !defined(NO_SIGNAL)
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  
X***************
X*** 120,127 ****
X  # endif
X  # ifdef EXPLORE_MODE
X  	if(!hu) {
X! 
X! 	    fd = open(SAVEF, O_RDONLY);
X  	    if (fd > 0) {
X  		(void) close(fd);
X  		clrlin();
X--- 120,130 ----
X  # endif
X  # ifdef EXPLORE_MODE
X  	if(!hu) {
X! #  ifdef AMIGA_WBENCH
X! 	    (fd = ami_wbench_getsave(O_RDONLY));
X! #  else
X! 	    (fd = open(SAVEF, O_RDONLY));
X! #  endif
X  	    if (fd > 0) {
X  		(void) close(fd);
X  		clrlin();
X***************
X*** 133,139 ****
X  # ifdef TOS
X  	fd = creat(SAVEF, FCMASK);
X  # else
X! 	fd = open(SAVEF, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X  # endif
X  #else /* MSDOS */
X  # ifdef EXPLORE_MODE
X--- 136,146 ----
X  # ifdef TOS
X  	fd = creat(SAVEF, FCMASK);
X  # else
X! #  ifdef AMIGA_WBENCH
X! 	fd=ami_wbench_getsave(O_WRONLY | O_CREAT | O_TRUNC);
X! #  else
X! 	(fd = open(SAVEF, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK));
X! #  endif
X  # endif
X  #else /* MSDOS */
X  # ifdef EXPLORE_MODE
X***************
X*** 183,188 ****
X--- 190,198 ----
X  #endif /* MSDOS */
X  	if(fd < 0) {
X  		if(!hu) pline("Cannot open save file.");
X+ #ifdef AMIGA_WBENCH
X+ 		ami_wbench_unlink(SAVEF);
X+ #endif
X  		(void) unlink(SAVEF);		/* ab@unido */
X  		return(0);
X  	}
X***************
X*** 193,199 ****
X  		change_luck(-1);		/* and unido!ab */
X  	home();
X  	cl_end();
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if(!hu) msmsg("Saving: ");
X  	mode = COUNT;
X  again:
X--- 203,209 ----
X  		change_luck(-1);		/* and unido!ab */
X  	home();
X  	cl_end();
X! #if defined(DGK)
X  	if(!hu) msmsg("Saving: ");
X  	mode = COUNT;
X  again:
X***************
X*** 235,241 ****
X  	bwrite(fd, (genericptr_t) &is_maze_lev, sizeof is_maze_lev);
X  	bwrite(fd, (genericptr_t) &u, sizeof(struct you));
X  #ifdef SPELLS
X! 	bwrite(fd, (genericptr_t) spl_book, sizeof(struct spell) * (MAXSPELL + 1));
X  #endif
X  	if(u.ustuck)
X  		bwrite(fd, (genericptr_t) &(u.ustuck->m_id), sizeof u.ustuck->m_id);
X--- 245,256 ----
X  	bwrite(fd, (genericptr_t) &is_maze_lev, sizeof is_maze_lev);
X  	bwrite(fd, (genericptr_t) &u, sizeof(struct you));
X  #ifdef SPELLS
X! 	bwrite(fd, (genericptr_t) spl_book, 
X! 				sizeof(struct spell) * (MAXSPELL + 1));
X! #endif
X! #ifdef NAMED_ITEMS
X! 	bwrite(fd, (genericptr_t) artiexist, 
X! 				(unsigned)(sizeof(boolean) * artifact_num));
X  #endif
X  	if(u.ustuck)
X  		bwrite(fd, (genericptr_t) &(u.ustuck->m_id), sizeof u.ustuck->m_id);
X***************
X*** 246,252 ****
X  	savefruitchn(fd);
X  #endif
X  	savenames(fd);
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if (mode == COUNT) {
X  # ifdef ZEROCOMP
X  		bflush(fd);
X--- 261,267 ----
X  	savefruitchn(fd);
X  #endif
X  	savenames(fd);
X! #if defined(DGK)
X  	if (mode == COUNT) {
X  # ifdef ZEROCOMP
X  		bflush(fd);
X***************
X*** 256,261 ****
X--- 271,279 ----
X  		for (ltmp = 1; ltmp <= maxdlevel; ltmp++)
X  			if (ltmp != dlevel && fileinfo[ltmp].where)
X  				needed += fileinfo[ltmp].size + (sizeof ltmp);
X+ #ifdef AMIGA_WBENCH
X+ 		needed+=ami_wbench_iconsize(SAVEF);
X+ #endif
X  		fds = freediskspace(SAVEF);
X  		if(needed > fds) {
X  		    if(!hu) {
X***************
X*** 264,269 ****
X--- 282,290 ----
X  				fds);
X  		    }
X  		    flushout();
X+ #ifdef AMIGA_WBENCH
X+ 		    ami_wbench_unlink(SAVEF);
X+ #endif
X  		    (void) close(fd);
X  		    (void) unlink(SAVEF);
X  		    return 0;
X***************
X*** 273,279 ****
X  	}
X  #endif
X  	for(ltmp = (xchar)1; ltmp <= maxdlevel; ltmp++) {
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (ltmp == dlevel || !fileinfo[ltmp].where) continue;
X  		if (fileinfo[ltmp].where != ACTIVE)
X  			swapin_file(ltmp);
X--- 294,300 ----
X  	}
X  #endif
X  	for(ltmp = (xchar)1; ltmp <= maxdlevel; ltmp++) {
X! #if defined(DGK)
X  		if (ltmp == dlevel || !fileinfo[ltmp].where) continue;
X  		if (fileinfo[ltmp].where != ACTIVE)
X  			swapin_file(ltmp);
X***************
X*** 294,299 ****
X--- 315,323 ----
X  			(void)SetVol(0L, savenum);
X  #endif
X  		    (void) unlink(SAVEF);
X+ #ifdef AMIGA_WBENCH
X+ 		    ami_wbench_unlink(SAVEF);
X+ #endif
X  		    if(!hu) done(TRICKED);
X  		    return(0);
X  		}
X***************
X*** 303,309 ****
X  		getlev(ofd, hackpid, ltmp, FALSE);
X  		(void) close(ofd);
X  		bwrite(fd, (genericptr_t) &ltmp, sizeof ltmp);  /* level number */
X! #if defined(DGK) && !defined(OLD_TOS)
X  		savelev(fd, ltmp, WRITE);			/* actual level */
X  #else
X  		savelev(fd, ltmp);			/* actual level */
X--- 327,333 ----
X  		getlev(ofd, hackpid, ltmp, FALSE);
X  		(void) close(ofd);
X  		bwrite(fd, (genericptr_t) &ltmp, sizeof ltmp);  /* level number */
X! #if defined(DGK)
X  		savelev(fd, ltmp, WRITE);			/* actual level */
X  #else
X  		savelev(fd, ltmp);			/* actual level */
X***************
X*** 328,337 ****
X  	Strcat(cmd, SAVEF);
X  	(void) system(cmd);
X  #endif
X  	return(1);
X  }
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  boolean
X  savelev(fd, lev, mode)
X  int fd;
X--- 352,364 ----
X  	Strcat(cmd, SAVEF);
X  	(void) system(cmd);
X  #endif
X+ #ifdef AMIGA_WBENCH
X+ 	ami_wbench_iconwrite(SAVEF);
X+ #endif
X  	return(1);
X  }
X  
X! #if defined(DGK)
X  boolean
X  savelev(fd, lev, mode)
X  int fd;
X***************
X*** 385,391 ****
X  #endif
X  
X  	if(fd < 0) panic("Save on bad file!");	/* impossible */
X! #if !defined(DGK) || defined(OLD_TOS)
X  	if(lev >= 0 && lev <= MAXLEVEL)
X  		level_exists[lev] = TRUE;
X  #endif
X--- 412,418 ----
X  #endif
X  
X  	if(fd < 0) panic("Save on bad file!");	/* impossible */
X! #if !defined(DGK)
X  	if(lev >= 0 && lev <= MAXLEVEL)
X  		level_exists[lev] = TRUE;
X  #endif
X***************
X*** 430,438 ****
X  		 * the display of the screen when the game is restored under
X  		 * a potentially different value of showsyms from the
X  		 * environment */
X! 		/* if a game is saved off the rogue level, the usual showsyms
X! 		 * will be written out for the rogue level too, but they will
X! 		 * be ignored on restore so it doesn't matter */
X  		bwrite(fd, (genericptr_t) savesyms, sizeof savesyms);
X  	else
X  #endif
X--- 457,465 ----
X  		 * the display of the screen when the game is restored under
X  		 * a potentially different value of showsyms from the
X  		 * environment */
X! 		/* if a game is saved while not on rogue level, the usual
X! 		 * showsyms will be written out for the rogue level too, but
X! 		 * they will be ignored on restore so it doesn't matter */
X  		bwrite(fd, (genericptr_t) savesyms, sizeof savesyms);
X  	else
X  #endif
X***************
X*** 466,472 ****
X  		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg){
X  			bwrite(fd,(genericptr_t) wtmp,sizeof(struct wseg));
X  		}
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  			wsegs[tmp] = 0;
X--- 493,499 ----
X  		for(wtmp = wsegs[tmp]; wtmp; wtmp = wtmp->nseg){
X  			bwrite(fd,(genericptr_t) wtmp,sizeof(struct wseg));
X  		}
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			wsegs[tmp] = 0;
X***************
X*** 473,479 ****
X  	}
X  	bwrite(fd,(genericptr_t) wgrowtime,sizeof(wgrowtime));
X  #endif /* WORM /**/
X! #if defined(DGK) && !defined(OLD_TOS)
X  	if (count_only)	return;
X  #endif
X  	billobjs = 0;
X--- 500,506 ----
X  	}
X  	bwrite(fd,(genericptr_t) wgrowtime,sizeof(wgrowtime));
X  #endif /* WORM /**/
X! #if defined(DGK)
X  	if (count_only)	return;
X  #endif
X  	billobjs = 0;
X***************
X*** 522,528 ****
X  	  flushoutrun(outrunlength);
X        }
X        if (outbufp) {
X! #if defined(DGK) && !defined(OLD_TOS)
X  	  if (!count_only)    /* flush buffer */
X  #endif
X  		  (void) write(fd, outbuf, outbufp);
X--- 549,555 ----
X  	  flushoutrun(outrunlength);
X        }
X        if (outbufp) {
X! #if defined(DGK)
X  	  if (!count_only)    /* flush buffer */
X  #endif
X  		  (void) write(fd, outbuf, outbufp);
X***************
X*** 560,566 ****
X  register genericptr_t loc;
X  register unsigned num;
X  {
X! #if defined(DGK) && !defined(OLD_TOS)
X  	bytes_counted += num;
X  	if (!count_only)
X  #endif
X--- 587,593 ----
X  register genericptr_t loc;
X  register unsigned num;
X  {
X! #if defined(DGK)
X  	bytes_counted += num;
X  	if (!count_only)
X  #endif
X***************
X*** 593,599 ****
X  	    xl = otmp->onamelth;
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X! #if defined(DGK) && !defined(OLD_TOS)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) otmp);
X--- 620,626 ----
X  	    xl = otmp->onamelth;
X  	    bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  	    bwrite(fd, (genericptr_t) otmp, xl + sizeof(struct obj));
X! #if defined(DGK)
X  	    if (!count_only)
X  #endif
X  		free((genericptr_t) otmp);
X***************
X*** 620,626 ****
X  		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X  		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  		free((genericptr_t) mtmp);
X--- 647,653 ----
X  		bwrite(fd, (genericptr_t) &xl, sizeof(int));
X  		bwrite(fd, (genericptr_t) mtmp, xl + sizeof(struct monst));
X  		if(mtmp->minvent) saveobjchn(fd,mtmp->minvent);
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  		free((genericptr_t) mtmp);
X***************
X*** 638,650 ****
X  	while(gold) {
X  		gold2 = gold->ngold;
X  		bwrite(fd, (genericptr_t) gold, sizeof(struct gold));
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) gold);
X  		gold = gold2;
X  	}
X! 	bwrite(fd, (genericptr_t)nul, sizeof(struct gold));
X  }
X  
X  static void
X--- 665,677 ----
X  	while(gold) {
X  		gold2 = gold->ngold;
X  		bwrite(fd, (genericptr_t) gold, sizeof(struct gold));
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) gold);
X  		gold = gold2;
X  	}
X! 	bwrite(fd, (genericptr_t)nulls, sizeof(struct gold));
X  }
X  
X  static void
X***************
X*** 656,668 ****
X  	while(trap) {
X  		trap2 = trap->ntrap;
X  		bwrite(fd, (genericptr_t) trap, sizeof(struct trap));
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) trap);
X  		trap = trap2;
X  	}
X! 	bwrite(fd, (genericptr_t)nul, sizeof(struct trap));
X  }
X  
X  #ifdef TUTTI_FRUTTI
X--- 683,695 ----
X  	while(trap) {
X  		trap2 = trap->ntrap;
X  		bwrite(fd, (genericptr_t) trap, sizeof(struct trap));
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) trap);
X  		trap = trap2;
X  	}
X! 	bwrite(fd, (genericptr_t)nulls, sizeof(struct trap));
X  }
X  
X  #ifdef TUTTI_FRUTTI
X***************
X*** 683,695 ****
X  		if (f1->fid >= 0) {
X  			bwrite(fd, (genericptr_t) f1, sizeof(struct fruit));
X  		}
X! #if defined(DGK) && !defined(OLD_TOS)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) f1);
X  		f1 = f2;
X  	}
X! 	bwrite(fd, (genericptr_t)nul, sizeof(struct fruit));
X  }
X  #endif
X  
X--- 710,722 ----
X  		if (f1->fid >= 0) {
X  			bwrite(fd, (genericptr_t) f1, sizeof(struct fruit));
X  		}
X! #if defined(DGK)
X  		if (!count_only)
X  #endif
X  			free((genericptr_t) f1);
X  		f1 = f2;
X  	}
X! 	bwrite(fd, (genericptr_t)nulls, sizeof(struct fruit));
X  }
X  #endif
X  
X***************
X*** 703,709 ****
X  		bwrite(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X  }
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  boolean
X  swapin_file(lev)
X  int lev;
X--- 730,736 ----
X  		bwrite(fd, (genericptr_t) &(mons[i].geno), sizeof(unsigned));
X  }
X  
X! #if defined(DGK)
X  boolean
X  swapin_file(lev)
X  int lev;
X***************
X*** 808,814 ****
X  {
X  	register struct obj *otmp, *otmp2, *probj;
X  
X! #ifdef LINT
X  	probj = (struct obj *)0;    /* suppress "used before set" error */
X  #endif
X  	for(otmp = fcobj; otmp; otmp = otmp2) {
X--- 835,841 ----
X  {
X  	register struct obj *otmp, *otmp2, *probj;
X  
X! #if defined(LINT) || defined(__GNULINT__)
X  	probj = (struct obj *)0;    /* suppress "used before set" error */
X  #endif
X  	for(otmp = fcobj; otmp; otmp = otmp2) {
X
END_OF_FILE
if test 53513 -ne `wc -c <'patch7.07'`; then
    echo shar: \"'patch7.07'\" unpacked with wrong size!
fi
# end of 'patch7.07'
echo shar: End of archive 17 \(of 30\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
