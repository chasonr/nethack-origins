Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!zaphod.mps.ohio-state.edu!think!mintaka!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i018:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7r
Message-ID: <5232@tekred.CNA.TEK.COM>
Date: 24 Feb 90 01:00:59 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2202
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 18
Archive-name: NetHack3/Patch7r
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 18 (of 30)."
# Contents:  patch7.12
# Wrapped by billr@saab on Thu Feb 22 16:18:37 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.12' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch7.12'\"
else
echo shar: Extracting \"'patch7.12'\" \(53746 characters\)
sed "s/^X//" >'patch7.12' <<'END_OF_FILE'
X*** src/Old/mondata.c	Mon Feb 19 20:32:59 1990
X--- src/mondata.c	Thu Jan 25 22:13:40 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mondata.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mondata.c	3.0	89/11/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,13 ****
X--- 8,15 ----
X  
X  /*	These routines provide basic data for any type of monster. */
X  
X+ #ifdef OVL0
X+ 
X  boolean
X  attacktype(ptr, atyp)
X  	register struct	permonst	*ptr;
X***************
X*** 21,32 ****
X  	return(FALSE);
X  }
X  
X  boolean
X  resists_ston(ptr)	/* returns TRUE if monster is petrify resistant */
X  	register struct permonst *ptr;
X  {
X! 	return (ptr->mflags1 & M1_STON_RES || dmgtype(ptr, AD_STON) ||
X! 		dmgtype(ptr, AD_ACID));
X  }
X  
X  boolean
X--- 23,36 ----
X  	return(FALSE);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  boolean
X  resists_ston(ptr)	/* returns TRUE if monster is petrify resistant */
X  	register struct permonst *ptr;
X  {
X! 	return (ptr->mflags1 & (M1_STON_RES | M1_ACID) || dmgtype(ptr, AD_STON));
X  }
X  
X  boolean
X***************
X*** 37,42 ****
X--- 41,49 ----
X  	return(is_undead(ptr) || is_demon(ptr) || is_were(ptr));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  boolean
X  ranged_attk(ptr)	/* returns TRUE if monster can attack at range */
X  	register struct permonst *ptr;
X***************
X*** 46,51 ****
X--- 53,61 ----
X  		attacktype(ptr, AT_MAGC));
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  boolean
X  can_track(ptr)		/* returns TRUE if monster can track well */
X  	register struct permonst *ptr;
X***************
X*** 56,61 ****
X--- 66,74 ----
X  	return(haseyes(ptr));
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifdef POLYSELF
X  boolean
X  breakarm(ptr)	/* creature will break out of armor */
X***************
X*** 82,87 ****
X--- 95,103 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  boolean
X  sticks(ptr)	/* creature sticks other creatures it hits */
X  	register struct permonst *ptr;
X***************
X*** 121,132 ****
X  monsndx(ptr)		/* return an index into the mons array */
X  	struct	permonst	*ptr;
X  {
X  	register int	i;
X  
X  	if(ptr == &playermon) return(-1);
X! 
X  	i = (int)(ptr - &mons[0]);
X! 
X  	if(i < 0 || i >= NUMMONS) {    
X  	    panic("monsndx - could not index monster (%x)", ptr);
X  	    return FALSE;		/* will not get here */
X--- 137,156 ----
X  monsndx(ptr)		/* return an index into the mons array */
X  	struct	permonst	*ptr;
X  {
X+ #ifdef LATTICE_504_BUG
X+ 	register int d;
X+ /* no problem - see, pspace IS bounded (and fits in 32 bits!) KL */
X+ const int pspace= sizeof(struct permonst[NUMMONS])/NUMMONS;
X+ #endif
X  	register int	i;
X  
X  	if(ptr == &playermon) return(-1);
X! #ifndef LATTICE_504_BUG
X  	i = (int)(ptr - &mons[0]);
X! #else
X! 	d=(int)((int)ptr-(int)&mons[0]);
X! 	i= d/pspace;
X! #endif
X  	if(i < 0 || i >= NUMMONS) {    
X  	    panic("monsndx - could not index monster (%x)", ptr);
X  	    return FALSE;		/* will not get here */
X***************
X*** 175,186 ****
X  	if (!strncmp(str, "cavewomen", 9)) return PM_CAVEWOMAN;
X  	if (!strncmp(str, "zruties", 7)) return PM_ZRUTY;
X  	if (!strncmp(str, "djinn", 5)) return PM_DJINNI;
X- 		/* be careful with "ies"; "priest", "zombies" */
X  	for(s=str; *s; s++) {
X  		if (!strncmp(s, "vortices", 8)) {
X  			Strcpy(s+4, "ex");
X  			break;
X  		}
X  		if (!strncmp(s, "jellies", 7) || !strncmp(s, "mummies", 7)) {
X  			Strcpy(s+4, "y");
X  			break;
X--- 199,210 ----
X  	if (!strncmp(str, "cavewomen", 9)) return PM_CAVEWOMAN;
X  	if (!strncmp(str, "zruties", 7)) return PM_ZRUTY;
X  	if (!strncmp(str, "djinn", 5)) return PM_DJINNI;
X  	for(s=str; *s; s++) {
X  		if (!strncmp(s, "vortices", 8)) {
X  			Strcpy(s+4, "ex");
X  			break;
X  		}
X+ 		/* be careful with "ies"; "priest", "zombies" */
X  		if (!strncmp(s, "jellies", 7) || !strncmp(s, "mummies", 7)) {
X  			Strcpy(s+4, "y");
X  			break;
X***************
X*** 203,208 ****
X--- 227,235 ----
X  	return mntmp;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifdef POLYSELF
X  boolean
X  webmaker(ptr)   /* creature can spin a web */
X***************
X*** 220,228 ****
X  #if defined(ALTARS) && defined(THEOLOGY)
X  	if (mtmp->ispriest) return !EPRI(mtmp)->ismale;
X  #endif
X! 	return !!(mtmp->data->mflags1 & M1_FEM);
X  }
X  
X  /* Gender function.  Differs from is_female() in that 1) It allows the monster
X   * type of a polymorphed shopkeeper to override ESHK(mtmp)->ismale, and 2)
X   * it returns 3 values (0=male, 1=female, 2=none) instead of 2.
X--- 247,258 ----
X  #if defined(ALTARS) && defined(THEOLOGY)
X  	if (mtmp->ispriest) return !EPRI(mtmp)->ismale;
X  #endif
X! 	return !!(mtmp->data->mflags2 & M2_FEM);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  /* Gender function.  Differs from is_female() in that 1) It allows the monster
X   * type of a polymorphed shopkeeper to override ESHK(mtmp)->ismale, and 2)
X   * it returns 3 values (0=male, 1=female, 2=none) instead of 2.
X***************
X*** 232,238 ****
X  	register struct monst *mtmp;
X  {
X  	if (!humanoid(mtmp->data)) return 2;
X! 	if (mtmp->data->mflags1 & M1_FEM) return 1;
X  	if (mtmp->data == &mons[PM_CAVEMAN]
X  		|| mtmp->data == &mons[PM_PRIEST]
X  #ifdef INFERNO
X--- 262,268 ----
X  	register struct monst *mtmp;
X  {
X  	if (!humanoid(mtmp->data)) return 2;
X! 	if (mtmp->data->mflags2 & M2_FEM) return 1;
X  	if (mtmp->data == &mons[PM_CAVEMAN]
X  		|| mtmp->data == &mons[PM_PRIEST]
X  #ifdef INFERNO
X***************
X*** 246,256 ****
X  	return 0;
X  }
X  
X  boolean
X  levl_follower(mtmp)
X  register struct monst *mtmp;
X  {
X! 	return (mtmp->mtame || (mtmp->data->mflags1 & M1_STALK) || is_fshk(mtmp)
X  		|| (mtmp->iswiz && !mon_has_amulet(mtmp)));
X  }
X  
X--- 276,289 ----
X  	return 0;
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  boolean
X  levl_follower(mtmp)
X  register struct monst *mtmp;
X  {
X! 	return (mtmp->mtame || (mtmp->data->mflags2 & M2_STALK) || is_fshk(mtmp)
X  		|| (mtmp->iswiz && !mon_has_amulet(mtmp)));
X  }
X  
X***************
X*** 280,285 ****
X--- 313,326 ----
X  const int grownups[][2] = { {PM_LITTLE_DOG, PM_DOG}, {PM_DOG, PM_LARGE_DOG},
X  	{PM_HELL_HOUND_PUP, PM_HELL_HOUND}, {PM_KITTEN, PM_HOUSECAT},
X  	{PM_HOUSECAT, PM_LARGE_CAT}, {PM_BABY_GRAY_DRAGON, PM_GRAY_DRAGON},
X+ 	{PM_KOBOLD, PM_LARGE_KOBOLD}, {PM_LARGE_KOBOLD, PM_KOBOLD_LORD},
X+ 	{PM_GNOME, PM_GNOME_LORD}, {PM_GNOME_LORD, PM_GNOME_KING},
X+ 	{PM_DWARF, PM_DWARF_LORD}, {PM_DWARF_LORD, PM_DWARF_KING},
X+ 	{PM_SMALL_MIMIC, PM_LARGE_MIMIC}, {PM_LARGE_MIMIC, PM_GIANT_MIMIC},
X+ 	{PM_BAT, PM_GIANT_BAT},
X+ 	{PM_LICH, PM_DEMILICH}, {PM_DEMILICH, PM_MASTER_LICH},
X+ 	{PM_OGRE, PM_OGRE_LORD}, {PM_OGRE_LORD, PM_OGRE_KING},
X+ 	{PM_VAMPIRE, PM_VAMPIRE_LORD},
X  	{PM_BABY_RED_DRAGON, PM_RED_DRAGON},
X  	{PM_BABY_WHITE_DRAGON, PM_WHITE_DRAGON},
X  	{PM_BABY_BLUE_DRAGON, PM_BLUE_DRAGON},
X***************
X*** 300,305 ****
X--- 341,347 ----
X  	{PM_SERGEANT, PM_LIEUTENANT},
X  	{PM_LIEUTENANT, PM_CAPTAIN},
X  #endif
X+ 	{PM_BABY_CROCODILE, PM_CROCODILE},
X  	{-1,-1}
X  };
X  
X***************
X*** 324,329 ****
X--- 366,387 ----
X  }
X  
X  
X+ const char *
X+ locomotion(ptr, def)
X+ const struct permonst *ptr;
X+ const char *def;
X+ {
X+ 	return (
X+ 		is_floater(ptr) ? "float" :
X+ 		is_flyer(ptr) ? "fly" :
X+ 		slithy(ptr) ? "slither" :
X+ 		amorphous(ptr) ? "ooze" :
X+ 		nolimbs(ptr) ? "crawl" :
X+ 		def
X+ 	       );
X+ 
X+ }
X+ 
X  #ifdef STUPID_CPP	/* otherwise these functions are macros in mondata.h */
X  
X  int
X***************
X*** 362,387 ****
X  }
X  
X  int
X! is_animal(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_ANIMAL) != 0L);
X  }
X  
X  int
X! humanoid(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_HUMANOID) != 0L);
X  }
X  
X  int
X! is_undead(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_UNDEAD) != 0L);
X  }
X  
X  int
X! is_were(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_WERE) != 0L);
X  }
X  
X! int haseyes(ptr) struct permonst *ptr; {
X  	return((ptr->mflags1 & M1_NOEYES) == 0L);
X  }
X  
X--- 420,451 ----
X  }
X  
X  int
X! amorphous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_AMORPHOUS) != 0L);
X  }
X  
X  int
X! tunnels(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_TUNNEL) != 0L);
X  }
X  
X  int
X! needspick(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_NEEDPICK) != 0L);
X  }
X  
X  int
X! hides_under(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_CONCEAL) != 0L);
X  }
X  
X! int
X! is_hider(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_HIDE) != 0L);
X! }
X! 
X! int
X! haseyes(ptr) struct permonst *ptr; {
X  	return((ptr->mflags1 & M1_NOEYES) == 0L);
X  }
X  
X***************
X*** 391,408 ****
X  }
X  
X  int
X! lays_eggs(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_EGGS) != 0L);
X  }
X  
X  int
X! poisonous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_POIS) != 0L);
X  }
X  
X  int
X! resists_poison(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & (M1_POIS | M1_POIS_RES)) != 0L);
X  }
X  
X  int
X--- 455,495 ----
X  }
X  
X  int
X! nolimbs(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_NOLIMBS) == M1_NOLIMBS);
X  }
X  
X+ # ifdef POLYSELF
X  int
X! polyok(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_NOPOLY) == 0L);
X  }
X+ # endif
X  
X  int
X! is_whirly(ptr) struct permonst *ptr; {
X! 	return((ptr->mlet == S_VORTEX) || 
X! 	       (ptr == &mons[PM_AIR_ELEMENTAL]));
X! }
X! 
X! int
X! humanoid(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_HUMANOID) != 0L);
X! }
X! 
X! int
X! is_animal(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_ANIMAL) != 0L);
X! }
X! 
X! int
X! slithy(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_SLITHY) != 0L);
X! }
X! 
X! int
X! thick_skinned(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_THICK_HIDE) != 0L);
X  }
X  
X  int
X***************
X*** 411,423 ****
X  }
X  
X  int
X  resists_cold(ptr) struct permonst *ptr; {
X  	return((ptr->mflags1 & M1_COLD_RES) != 0L);
X  }
X  
X  int
X! resists_acid(ptr) struct permonst *ptr; {
X! 	return(dmgtype(ptr, AD_ACID));
X  }
X  
X  int
X--- 498,516 ----
X  }
X  
X  int
X+ resists_sleep(ptr) struct permonst *ptr; {
X+ 	return((ptr->mflags1 & M1_SLEE_RES) != 0L || is_undead(ptr));
X+ }
X+ 
X+ int
X  resists_cold(ptr) struct permonst *ptr; {
X  	return((ptr->mflags1 & M1_COLD_RES) != 0L);
X  }
X  
X  int
X! resists_disint(ptr) struct permonst *ptr; {
X! 	return(ptr == &mons[PM_BLACK_DRAGON] ||
X! 		ptr == &mons[PM_BABY_BLACK_DRAGON]);
X  }
X  
X  int
X***************
X*** 426,439 ****
X  }
X  
X  int
X! resists_sleep(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & (M1_SLEE_RES | M1_UNDEAD)) != 0L);
X  }
X  
X  int
X! resists_disint(ptr) struct permonst *ptr; {
X! 	return(ptr == &mons[PM_BLACK_DRAGON] ||
X! 		ptr == &mons[PM_BABY_BLACK_DRAGON]);
X  }
X  
X  int
X--- 519,541 ----
X  }
X  
X  int
X! resists_acid(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_ACID) != 0L);
X  }
X  
X  int
X! acidic(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_ACID) != 0L);
X! }
X! 
X! int
X! resists_poison(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & (M1_POIS | M1_POIS_RES)) != 0L);
X! }
X! 
X! int
X! poisonous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_POIS) != 0L);
X  }
X  
X  int
X***************
X*** 482,511 ****
X  }
X  
X  int
X! hides_under(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_CONCEAL) != 0L);
X! }
X! 
X! int
X! is_hider(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_HIDE) != 0L);
X! }
X! 
X! # ifdef POLYSELF
X! int
X! polyok(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_NOPOLY) == 0L);
X! }
X! # endif /* POLYSELF */
X! 
X! int
X! tunnels(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_TUNNEL) != 0L);
X  }
X  
X  int
X! needspick(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_NEEDPICK) != 0L);
X  }
X  
X  int
X--- 584,596 ----
X  }
X  
X  int
X! is_undead(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_UNDEAD) != 0L);
X  }
X  
X  int
X! is_were(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_WERE) != 0L);
X  }
X  
X  int
X***************
X*** 531,536 ****
X--- 616,627 ----
X  # endif /* GOLEMS */
X  
X  int
X+ is_domestic(ptr) struct permonst *ptr; {
X+ 	return((ptr->mflags2 & M2_DOMESTIC) != 0L);
X+ }
X+ 
X+ 
X+ int
X  is_orc(ptr) struct permonst *ptr; {
X  	return((ptr->mflags2 & M2_ORC) != 0L);
X  }
X***************
X*** 551,663 ****
X  }
X  
X  int
X- throws_rocks(ptr) struct permonst *ptr; {
X- 	return((ptr->mflags2 & M2_ROCKTHROW) != 0L);
X- }
X- 
X- int
X  is_wanderer(ptr) struct permonst *ptr; {
X  	return((ptr->mflags2 & M2_WANDER) != 0L);
X  }
X  
X  int
X! is_lord(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_LORD) != 0L);
X  }
X  
X  int
X! is_prince(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_PRINCE) != 0L);
X  }
X  
X- # ifdef INFERNO
X  int
X! is_ndemon(ptr) struct permonst *ptr; {
X! 	return(is_demon(ptr) &&
X! 		(ptr->mflags1 & (M1_LORD | M1_PRINCE)) == 0L);
X  }
X! # else
X  int
X! is_ndemon(ptr) struct permonst *ptr; {
X! 	return(ptr == &mons[PM_DEMON]);
X  }
X- # endif
X  
X  int
X! is_dlord(ptr) struct permonst *ptr; {
X! 	return(is_demon(ptr) && is_lord(ptr));
X  }
X  
X  int
X! is_dprince(ptr) struct permonst *ptr; {
X! 	return(is_demon(ptr) && is_prince(ptr));
X  }
X  
X  int
X! type_is_pname(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_PNAME) != 0L);
X  }
X  
X  int
X! always_hostile(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_HOSTILE) != 0L);
X  }
X  
X  int
X! always_peaceful(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_PEACEFUL) != 0L);
X  }
X  
X  int
X! strongmonst(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_STRONG) != 0L);
X  }
X  
X  int
X! extra_nasty(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_NASTY) != 0L);
X  }
X  
X- # ifdef POLYSELF
X  int
X! can_breathe(ptr) struct permonst *ptr; {
X! 	return(attacktype(ptr, AT_BREA));
X  }
X  
X  int
X! cantwield(ptr) struct permonst *ptr; {
X! 	return(nohands(ptr) || verysmall(ptr));
X  }
X  
X  int
X! cantweararm(ptr) struct permonst *ptr; {
X! 	return(breakarm(ptr) || sliparm(ptr));
X  }
X- # endif /* POLYSELF */
X  
X  int
X! nolimbs(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_NOLIMBS) != 0L);
X  }
X  
X  int
X! carnivorous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_CARNIVORE) != 0L);
X  }
X! 
X  int
X! herbivorous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_HERBIVORE) != 0L);
X  }
X  
X  int
X! thick_skinned(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_THICK_HIDE) != 0L);
X  }
X  
X  int
X! amorphous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_AMORPHOUS) != 0L);
X  }
X  
X  #endif /* STUPID_CPP */
X--- 642,751 ----
X  }
X  
X  int
X  is_wanderer(ptr) struct permonst *ptr; {
X  	return((ptr->mflags2 & M2_WANDER) != 0L);
X  }
X  
X  int
X! always_hostile(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_HOSTILE) != 0L);
X  }
X  
X  int
X! always_peaceful(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_PEACEFUL) != 0L);
X  }
X  
X  int
X! extra_nasty(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_NASTY) != 0L);
X  }
X! 
X  int
X! strongmonst(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_STRONG) != 0L);
X  }
X  
X+ # ifdef POLYSELF
X  int
X! can_breathe(ptr) struct permonst *ptr; {
X! 	return(attacktype(ptr, AT_BREA));
X  }
X  
X  int
X! cantwield(ptr) struct permonst *ptr; {
X! 	return(nohands(ptr) || verysmall(ptr));
X  }
X  
X  int
X! cantweararm(ptr) struct permonst *ptr; {
X! 	return(breakarm(ptr) || sliparm(ptr));
X  }
X+ # endif /* POLYSELF */
X  
X  int
X! carnivorous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_CARNIVORE) != 0L);
X  }
X  
X  int
X! herbivorous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_HERBIVORE) != 0L);
X  }
X  
X  int
X! metallivorous(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_METALLIVORE) != 0L);
X  }
X  
X  int
X! lays_eggs(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_EGGS) != 0L);
X  }
X  
X  int
X! throws_rocks(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_ROCKTHROW) != 0L);
X  }
X  
X  int
X! type_is_pname(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_PNAME) != 0L);
X  }
X  
X  int
X! is_lord(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_LORD) != 0L);
X  }
X  
X  int
X! is_prince(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags2 & M2_PRINCE) != 0L);
X  }
X  
X+ # ifdef INFERNO
X  int
X! is_ndemon(ptr) struct permonst *ptr; {
X! 	return(is_demon(ptr) &&
X! 		(ptr->mflags2 & (M2_LORD | M2_PRINCE)) == 0L);
X  }
X! # else
X  int
X! is_ndemon(ptr) struct permonst *ptr; {
X! 	return(ptr == &mons[PM_DEMON]);
X  }
X+ # endif
X  
X  int
X! is_dlord(ptr) struct permonst *ptr; {
X! 	return(is_demon(ptr) && is_lord(ptr));
X  }
X  
X  int
X! is_dprince(ptr) struct permonst *ptr; {
X! 	return(is_demon(ptr) && is_prince(ptr));
X  }
X  
X  #endif /* STUPID_CPP */
X+ 
X+ #endif /* OVLB */
X*** Old/monmove.c	Wed Feb 21 18:10:20 1990
X--- src/monmove.c	Wed Feb 21 18:00:56 1990
X***************
X*** 1,7 ****
X! /*	SCCS Id: @(#)monmove.c	3.0	88/11/10
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X  #ifdef NAMED_ITEMS
X--- 1,14 ----
X! /*	SCCS Id: @(#)monmove.c	3.0	89/11/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #ifndef LINT
X+ # ifndef __STDC__
X+ #define TRAP_H	/* comment line for pre-compiled headers */
X+ /* block some unused #defines to avoid overloading some cpp's */
X+ # endif
X+ #endif
X+ 
X  #include "hack.h"
X  #include "mfndpos.h"
X  #ifdef NAMED_ITEMS
X***************
X*** 8,13 ****
X--- 15,27 ----
X  #  include "artifact.h"
X  #endif
X  
X+ static void FDECL(distfleeck,(struct monst *,int *,int *,int *));
X+ #ifdef POLYSELF
X+ static boolean FDECL(itsstuck,(struct monst *));
X+ #endif
X+ 
X+ #ifdef OVLB
X+ 
X  boolean /* TRUE : mtmp died */
X  mb_trapped(mtmp)
X  register struct monst *mtmp;
X***************
X*** 36,72 ****
X  	boolean canseeit = cansee(mtmp->mx, mtmp->my);
X  	here = &levl[mtmp->mx][mtmp->my];
X  
X  	if(IS_ROCK(here->typ)) {
X  	    /* Just ate something. */
X! 	    if(here->typ == STONE) here->typ = CORR;
X! 	    else if(IS_WALL(here->typ) &&
X! 			!(here->diggable & W_NONDIGGABLE)) {
X! 		if(flags.soundok && flags.verbose && !rn2(5))
X! 		       You("hear the sound of crashing rock.");
X! 		if(!is_maze_lev) {
X! 		  here->typ = DOOR;
X! 		  here->doormask = D_NODOOR;
X! 		}
X! 		else
X! 		  here->typ = ROOM;
X! 		mnewsym(mtmp->mx, mtmp->my);
X! 	    }
X! 	}
X! 	/* Eats away door if present & closed or locked */
X! 	else if(IS_DOOR(here->typ) &&
X! 		(here->doormask & (D_LOCKED | D_CLOSED))) {
X! 		if(here->doormask & D_TRAPPED) {
X! 		    here->doormask = D_NODOOR;
X! 		    mnewsym(mtmp->mx, mtmp->my);
X! 		    if(mb_trapped(mtmp)) return(FALSE);
X! 		} else {
X! 		    if(!rn2(3) && flags.verbose) /* not too often.. */
X! 		        You("feel an unexpected draft of air.");
X! 		    here->doormask = D_BROKEN;
X! 		    mnewsym(mtmp->mx, mtmp->my);
X  		}
X! 	    }
X! 	else return TRUE; /* it doesn't leave rocks if it didn't dig */
X  
X  	/* Left behind a pile? */
X  	if(pile < 5) {
X--- 50,88 ----
X  	boolean canseeit = cansee(mtmp->mx, mtmp->my);
X  	here = &levl[mtmp->mx][mtmp->my];
X  
X+ 	if (here->typ == SDOOR)
X+ 		here->typ = DOOR;
X  	if(IS_ROCK(here->typ)) {
X  	    /* Just ate something. */
X! 	    if(IS_WALL(here->typ)) {
X! 		if (!(here->diggable & W_NONDIGGABLE)) {
X! 			if(flags.soundok && flags.verbose && !rn2(5))
X! 		       		You("hear the sound of crashing rock.");
X! 			if(!is_maze_lev) {
X! 		  		here->typ = DOOR;
X! 		  		here->doormask = D_NODOOR;
X! 			}
X! 			else
X! 		  		here->typ = ROOM;
X  		}
X! 	    } else	
X! 	    	here->typ = CORR;
X! 	    mnewsym(mtmp->mx, mtmp->my);
X! 	} else 		/* Eats away door if present & closed or locked */
X! 		if(closed_door(mtmp->mx, mtmp->my)) {
X! 			if(here->doormask & D_TRAPPED) {
X! 		    		here->doormask = D_NODOOR;
X! 		    		if(mb_trapped(mtmp)) return(FALSE);
X! 			} else {
X! 		    		if(!rn2(3) && flags.verbose)
X! 				    /* not too often.. */
X! 		        		You("feel an unexpected draft of air.");
X! 		    		here->doormask = D_BROKEN;
X! 			}
X! 		    	mnewsym(mtmp->mx, mtmp->my);
X! 	    	} else 
X! 		    /* it doesn't leave rocks if it didn't dig */
X! 			return TRUE; 
X  
X  	/* Left behind a pile? */
X  	if(pile < 5) {
X***************
X*** 80,88 ****
X--- 96,108 ----
X  	    newsym(mtmp->mx,mtmp->my);
X  	else
X  	    mnewsym(mtmp->mx,mtmp->my);
X+ 	here->seen = FALSE;
X  	return(TRUE);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  int
X  dochugw(mtmp)
X  	register struct monst *mtmp;
X***************
X*** 110,115 ****
X--- 130,138 ----
X  	return(rd);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL2
X+ 
X  boolean
X  onscary(x, y, mtmp)
X  int x, y;
X***************
X*** 130,135 ****
X--- 153,161 ----
X  		    sobj_at(SCR_SCARE_MONSTER, x, y) != (struct obj *)0);
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL1
X+ 
X  static void
X  distfleeck(mtmp,inrange,nearby,scared)
X  register struct monst *mtmp;
X***************
X*** 197,203 ****
X  	/* polymorph lycanthropes */
X  	were_change(mtmp);
X  
X! 	if(mtmp->mfroz) {
X  		if (Hallucination) pmon(mtmp);
X  		return(0);	/* frozen monsters don't do anything */
X  	}
X--- 223,229 ----
X  	/* polymorph lycanthropes */
X  	were_change(mtmp);
X  
X! 	if(!mtmp->mcanmove) {
X  		if (Hallucination) pmon(mtmp);
X  		return(0);	/* frozen monsters don't do anything */
X  	}
X***************
X*** 239,262 ****
X  	/* check distance and scariness of attacks */
X  	distfleeck(mtmp,&inrange,&nearby,&scared);
X  
X! #ifdef INFERNO		/* Demonic Blackmail!!! */
X! 	if(nearby && is_demon(mdat) && mtmp->mpeaceful && !mtmp->mtame) {
X  		if (mtmp->mux != u.ux || mtmp->muy != u.uy) {
X  			pline("%s whispers something to thin air.",
X  			    cansee(mtmp->mux, mtmp->muy) ? Monnam(mtmp) : "It");
X! #ifdef POLYSELF
X  			if (is_demon(uasmon)) rloc(mtmp);
X  			  /* "Good hunting, brother" */
X! 			else
X! #endif
X! 			if (is_lord(mdat) || is_prince(mdat)) {
X! 			  /* use is_lord instead of is_dlord */
X  			    mtmp->minvis = 0;
X  			    /* Why?  For the same reason in real demon talk */
X  			    pline("%s gets angry.", Xmonnam(mtmp));
X  			    mtmp->mpeaceful = 0;
X  			    /* since no way is an image going to pay it off */
X  			}
X  		} else if(demon_talk(mtmp)) return(1);	/* you paid it off */
X  	}
X  #endif
X--- 265,289 ----
X  	/* check distance and scariness of attacks */
X  	distfleeck(mtmp,&inrange,&nearby,&scared);
X  
X! #ifdef INFERNO		/* Demonic Blackmail! */
X! 	if(nearby && mdat->msound == MS_BRIBE &&
X! 	   mtmp->mpeaceful && !mtmp->mtame) {
X  		if (mtmp->mux != u.ux || mtmp->muy != u.uy) {
X  			pline("%s whispers something to thin air.",
X  			    cansee(mtmp->mux, mtmp->muy) ? Monnam(mtmp) : "It");
X! # ifdef POLYSELF
X  			if (is_demon(uasmon)) rloc(mtmp);
X  			  /* "Good hunting, brother" */
X! 			else {
X! # endif
X  			    mtmp->minvis = 0;
X  			    /* Why?  For the same reason in real demon talk */
X  			    pline("%s gets angry.", Xmonnam(mtmp));
X  			    mtmp->mpeaceful = 0;
X  			    /* since no way is an image going to pay it off */
X+ # ifdef POLYSELF
X  			}
X+ # endif
X  		} else if(demon_talk(mtmp)) return(1);	/* you paid it off */
X  	}
X  #endif
X***************
X*** 284,290 ****
X   			break;
X   		    case 1:	/* monster moved */
X  			/* Maybe it stepped on a trap and fell asleep... */
X! 			if(mtmp->msleep || mtmp->mfroz) return(0);
X   			if(!nearby && ranged_attk(mdat)) break;
X   			else if(mdat->mmove <= 12) return(0);
X   			break;
X--- 311,317 ----
X   			break;
X   		    case 1:	/* monster moved */
X  			/* Maybe it stepped on a trap and fell asleep... */
X! 			if(mtmp->msleep || !mtmp->mcanmove) return(0);
X   			if(!nearby && ranged_attk(mdat)) break;
X   			else if(mdat->mmove <= 12) return(0);
X   			break;
X***************
X*** 303,308 ****
X--- 330,340 ----
X  	if(mtmp->wormno && !mtmp->mtame) wormhit(mtmp);
X  #endif
X  
X+ 	/* extra emotional attack for vile monsters */
X+ 	if(inrange && mtmp->data->msound == MS_CUSS &&
X+ 	   !mtmp->minvis && !mtmp->mpeaceful && !rn2(5))
X+ 	    cuss(mtmp);
X+ 
X  	/* extra movement for fast monsters */
X  	if(mdat->mmove-12 > rnd(12)) tmp = m_move(mtmp, 1);
X  	return(tmp == 2);
X***************
X*** 330,335 ****
X--- 362,370 ----
X  }
X  #endif
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  int
X  m_move(mtmp, after)
X  register struct monst *mtmp;
X***************
X*** 341,346 ****
X--- 376,382 ----
X  	schar chi;
X  	boolean likegold=0, likegems=0, likeobjs=0, likemagic=0, conceals=0;
X  	boolean likerock=0, can_tunnel=0;
X+ 	boolean can_open=0, can_unlock=0, doorbuster=0;
X  	struct permonst *ptr = mtmp->data;
X  	schar mmoved = 0;	/* not strictly nec.: chi >= 0 will do */
X  	coord poss[9];
X***************
X*** 371,376 ****
X--- 407,415 ----
X  		     dlevel != rogue_level &&
X  #endif
X  		     (!needspick(ptr) || m_carrying(mtmp, PICK_AXE));
X+ 	can_open = !(nohands(ptr) || verysmall(ptr));
X+ 	can_unlock = ((can_open && m_carrying(mtmp, SKELETON_KEY)) || mtmp->iswiz);
X+ 	doorbuster = is_giant(ptr);
X  #ifdef WORM
X  	if(mtmp->wormno) goto not_special;
X  #endif
X***************
X*** 390,397 ****
X  
X  	/* and for the guard */
X  	if(mtmp->isgd) {
X! 	    mmoved = gd_move();
X! 	    goto postmov;
X  	}
X  
X  	/* and the wiz already got special treatment */
X--- 429,438 ----
X  
X  	/* and for the guard */
X  	if(mtmp->isgd) {
X! 	    mmoved = gd_move(mtmp);
X! 	    if(mmoved == -2) return(2);
X! 	    if(mmoved >= 0) goto postmov;
X! 	    mmoved = 0;
X  	}
X  
X  	/* and the wiz already got special treatment */
X***************
X*** 411,422 ****
X  #ifdef MAIL
X  	if(ptr == &mons[PM_MAIL_DAEMON]) {
X  	    if(flags.soundok && canseemon(mtmp))
X! 		pline("\"I'm late!\"");
X  	    mongone(mtmp);
X  	    return(2);	    
X  	}
X  #endif
X- 
X  	/* teleport if that lies in our nature */
X  	if(ptr == &mons[PM_TENGU] && !rn2(5)) {
X  	    if(mtmp->mhp < 7 || mtmp->mpeaceful || rn2(2))
X--- 452,462 ----
X  #ifdef MAIL
X  	if(ptr == &mons[PM_MAIL_DAEMON]) {
X  	    if(flags.soundok && canseemon(mtmp))
X! 		verbalize("I'm late!");
X  	    mongone(mtmp);
X  	    return(2);	    
X  	}
X  #endif
X  	/* teleport if that lies in our nature */
X  	if(ptr == &mons[PM_TENGU] && !rn2(5)) {
X  	    if(mtmp->mhp < 7 || mtmp->mpeaceful || rn2(2))
X***************
X*** 433,438 ****
X--- 473,481 ----
X  	appr = 1;
X  	if(mtmp->mflee) appr = -1;
X  	if(mtmp->mconf || (Invis && !perceives(ptr)) ||  !mtmp->mcansee ||
X+ #ifdef POLYSELF
X+ 	   (u.usym == S_MIMIC_DEF) || u.uundetected ||
X+ #endif
X  	   (mtmp->mpeaceful && !mtmp->isshk) ||	/* allow shks to follow */
X  	   ((ptr->mlet == S_STALKER || ptr->mlet == S_BAT ||
X  	     ptr->mlet == S_YLIGHT) && !rn2(3)))
X***************
X*** 536,541 ****
X--- 579,587 ----
X  	if (is_human(ptr)) flag |= ALLOW_SSM;
X  	if (is_undead(ptr)) flag |= NOGARLIC;
X  	if (throws_rocks(ptr)) flag |= ALLOW_ROCK;
X+ 	if (can_open) flag |= OPENDOOR;
X+ 	if (can_unlock) flag |= UNLOCKDOOR;
X+ 	if (doorbuster) flag |= BUSTDOOR;
X  	cnt = mfndpos(mtmp, poss, info, flag);
X  	chcnt = 0;
X  	chi = -1;
X***************
X*** 577,587 ****
X  	     */
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X  		mtmp2 = 
X  		    (MON_AT(nix, niy) ? m_at(nix,niy) : (struct monst *)0);
X! 		if(mattackm(mtmp, mtmp2) == 1 && rn2(4) &&
X  			mtmp2->mlstmv != moves && mattackm(mtmp2, mtmp) == 2)
X  		    return(2);
X  		return(3);
X  	    }
X  #ifdef WORM
X--- 623,635 ----
X  	     */
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X+ 		int stat;
X  		mtmp2 = 
X  		    (MON_AT(nix, niy) ? m_at(nix,niy) : (struct monst *)0);
X! 		if((stat = mattackm(mtmp, mtmp2)) == 1 && rn2(4) &&
X  			mtmp2->mlstmv != moves && mattackm(mtmp2, mtmp) == 2)
X  		    return(2);
X+ 		if(stat == -1) return(2);
X  		return(3);
X  	    }
X  #ifdef WORM
X***************
X*** 616,629 ****
X  	    /* open a door, or crash through it, if you can */
X  	    if(IS_DOOR(levl[mtmp->mx][mtmp->my].typ)
X  		    && !passes_walls(ptr) /* doesn't need to open doors */
X- 	            && !amorphous(ptr) /* ditto */
X  		    && !can_tunnel /* taken care of below */
X  		  ) {
X  		struct rm *here = &levl[mtmp->mx][mtmp->my];
X  		boolean btrapped = (here->doormask & D_TRAPPED);
X  
X! 		if(here->doormask & D_LOCKED && mtmp->isshk) {
X! 			/* can't lock out shk */
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			mnewsym(mtmp->mx, mtmp->my);
X--- 664,679 ----
X  	    /* open a door, or crash through it, if you can */
X  	    if(IS_DOOR(levl[mtmp->mx][mtmp->my].typ)
X  		    && !passes_walls(ptr) /* doesn't need to open doors */
X  		    && !can_tunnel /* taken care of below */
X  		  ) {
X  		struct rm *here = &levl[mtmp->mx][mtmp->my];
X  		boolean btrapped = (here->doormask & D_TRAPPED);
X  
X! 		if(here->doormask & (D_LOCKED|D_CLOSED) && amorphous(ptr)) {
X! 		    if (flags.verbose && canseeit)
X! 			pline("%s %ss under the door.", Monnam(mtmp),
X! 			      ptr == &mons[PM_FOG_CLOUD] ? "flow" : "ooze");
X! 		} else if(here->doormask & D_LOCKED && can_unlock) {
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			mnewsym(mtmp->mx, mtmp->my);
X***************
X*** 640,647 ****
X  			mnewsym(mtmp->mx, mtmp->my);
X  			if (canseeit) prl(mtmp->mx,mtmp->my);
X  		    }
X! 		} else if (here->doormask == D_CLOSED && 
X! 					!nohands(mtmp->data)) {
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			mnewsym(mtmp->mx, mtmp->my);
X--- 690,696 ----
X  			mnewsym(mtmp->mx, mtmp->my);
X  			if (canseeit) prl(mtmp->mx,mtmp->my);
X  		    }
X! 		} else if (here->doormask == D_CLOSED && can_open) {
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			mnewsym(mtmp->mx, mtmp->my);
X***************
X*** 658,665 ****
X  			mnewsym(mtmp->mx, mtmp->my);
X  			if (canseeit) prl(mtmp->mx,mtmp->my);
X  		    }
X! 		} else if(here->doormask & (D_LOCKED | D_CLOSED)) {
X! 			/* mfndpos guarantees monster is a giant */
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			mnewsym(mtmp->mx, mtmp->my);
X--- 707,714 ----
X  			mnewsym(mtmp->mx, mtmp->my);
X  			if (canseeit) prl(mtmp->mx,mtmp->my);
X  		    }
X! 		} else if (here->doormask & (D_LOCKED|D_CLOSED)) {
X! 		       /* mfndpos guarantees this must be a doorbuster */
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			mnewsym(mtmp->mx, mtmp->my);
X***************
X*** 683,696 ****
X  	    /* Maybe a rock mole just ate something? */
X  	    if(can_tunnel) if(!mdig_tunnel(mtmp)) return(2); /* died? */
X  
X! 	    if(levl[mtmp->mx][mtmp->my].gmask == 1) {
X  		/* Maybe a rock mole just ate some gold */
X! 		if(ptr == &mons[PM_ROCK_MOLE]) meatgold(mtmp);
X  		if(likegold && (!abstain || !rn2(10))) mpickgold(mtmp);
X  	    }
X  	    if(OBJ_AT(mtmp->mx, mtmp->my)) {
X  		/* Maybe a rock mole just ate some metal object */
X! 		if(ptr == &mons[PM_ROCK_MOLE]) meatgold(mtmp);
X  		/* Maybe a cube ate just about anything */
X  		if(ptr == &mons[PM_GELATINOUS_CUBE]) meatobj(mtmp);
X  
X--- 732,745 ----
X  	    /* Maybe a rock mole just ate something? */
X  	    if(can_tunnel) if(!mdig_tunnel(mtmp)) return(2); /* died? */
X  
X! 	    if(levl[mtmp->mx][mtmp->my].gmask == TRUE) {
X  		/* Maybe a rock mole just ate some gold */
X! 		if(metallivorous(ptr)) meatgold(mtmp);
X  		if(likegold && (!abstain || !rn2(10))) mpickgold(mtmp);
X  	    }
X  	    if(OBJ_AT(mtmp->mx, mtmp->my)) {
X  		/* Maybe a rock mole just ate some metal object */
X! 		if(metallivorous(ptr)) meatgold(mtmp);
X  		/* Maybe a cube ate just about anything */
X  		if(ptr == &mons[PM_GELATINOUS_CUBE]) meatobj(mtmp);
X  
X***************
X*** 720,725 ****
X--- 769,795 ----
X  	return(mmoved);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X+ boolean
X+ closed_door(x, y)
X+ register int x, y;
X+ {
X+ 	return(IS_DOOR(levl[x][y].typ) &&
X+ 			(levl[x][y].doormask & (D_LOCKED | D_CLOSED)));
X+ }
X+ 
X+ boolean
X+ accessible(x, y)
X+ register int x, y;
X+ {
X+ 	return(ACCESSIBLE(levl[x][y].typ) && !closed_door(x, y));
X+ }
X+ 
X+ #endif /* OVL2 */
X+ #ifdef OVL1
X+ 
X  void
X  set_apparxy(mtmp)		/* where does mtmp think you are standing? */
X  	register struct monst *mtmp;
X***************
X*** 748,765 ****
X  		mtmp->mux = u.ux - disp + rn2(2*disp+1);
X  		mtmp->muy = u.uy - disp + rn2(2*disp+1);
X  	} while((mtmp->mux != u.ux || mtmp->muy != u.uy) &&
X! 	       (  (!passes_walls(mtmp->data) &&
X  		      (!ACCESSIBLE(levl[mtmp->mux][mtmp->muy].typ) ||
X! 		       (IS_DOOR(levl[mtmp->mux][mtmp->muy].typ) &&
X! 			(levl[mtmp->mux][mtmp->muy].doormask & (D_LOCKED | D_CLOSED)) &&
X  			!amorphous(mtmp->data)
X! 		      ))
X  		  ) ||
X  		  (disp==1 && mtmp->mux == mtmp->mx && mtmp->muy == mtmp->my)
X! 	       )
X! 	);
X  }
X  
X  #ifdef STUPID_CPP	/* otherwise these functions are macros in rm.h */
X  /*
X   * Functions for encapsulation of level.monsters references.
X--- 818,838 ----
X  		mtmp->mux = u.ux - disp + rn2(2*disp+1);
X  		mtmp->muy = u.uy - disp + rn2(2*disp+1);
X  	} while((mtmp->mux != u.ux || mtmp->muy != u.uy) &&
X! 	        ( (!passes_walls(mtmp->data) &&
X  		      (!ACCESSIBLE(levl[mtmp->mux][mtmp->muy].typ) ||
X! 		       (closed_door(mtmp->mux, mtmp->muy) &&
X  			!amorphous(mtmp->data)
X! 		       )
X! 		      )
X  		  ) ||
X  		  (disp==1 && mtmp->mux == mtmp->mx && mtmp->muy == mtmp->my)
X! 	        )
X! 	       );
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifdef STUPID_CPP	/* otherwise these functions are macros in rm.h */
X  /*
X   * Functions for encapsulation of level.monsters references.
X***************
X*** 799,801 ****
X--- 872,876 ----
X      return(level.monsters[x][y]);
X  }
X  #endif	/* STUPID_CPP */
X+ 
X+ #endif /* OVLB */
X
X*** src/Old/write.c	Mon Feb 19 19:10:15 1990
X--- src/write.c	Thu Jan 25 22:16:35 1990
X***************
X*** 4,9 ****
X--- 4,11 ----
X  
X  #include "hack.h"
X  
X+ static int FDECL(cost,(struct obj *));
X+ 
X  /*
X   * returns basecost of a scroll
X   */
X***************
X*** 109,114 ****
X--- 111,117 ----
X  	   newscroll->otyp == SCR_BLANK_PAPER)  {
X  		You("can't write that!");
X  		pline("It's obscene!");
X+ 		obfree(newscroll, (struct obj *) 0); /* pb@ethz.uucp */
X  		return;
X  	}
X  	
X*** src/Old/zap.c	Mon Feb 19 19:10:33 1990
X--- src/zap.c	Wed Feb 14 17:54:22 1990
X***************
X*** 8,13 ****
X--- 8,26 ----
X  static boolean priesthit = FALSE;
X  #endif
X  
X+ static int FDECL(burn_floor_paper,(int,int));
X+ #ifndef OVERLAY
X+ static int FDECL(bhitm,(struct monst *,struct obj *));
X+ #endif
X+ static void FDECL(cancel_item,(struct obj *));
X+ static int FDECL(bhitgold,(struct gold *,struct obj *));
X+ #ifndef OVERLAY
X+ static int FDECL(bhito,(struct obj *,struct obj *));
X+ #endif
X+ static void FDECL(backfire,(struct obj *));
X+ static uchar FDECL(dirlet,(int,int));
X+ static int FDECL(zhit,(struct monst *,int,int));
X+ 
X  const char *fl[]= {
X  	"magic missile",	/* Wands must be 0-9 */
X  	"bolt of fire",
X***************
X*** 76,84 ****
X  #ifdef SPELLS
X  	case SPE_SLOW_MONSTER:
X  #endif
X! 		if(! resist(mtmp, otmp->olet, 0, NOTELL))
X  			if (mtmp->mspeed == MFAST) mtmp->mspeed = 0;
X  			else mtmp->mspeed = MSLOW;
X  		break;
X  	case WAN_SPEED_MONSTER:
X  		if (!resist(mtmp, otmp->olet, 0, NOTELL))
X--- 89,104 ----
X  #ifdef SPELLS
X  	case SPE_SLOW_MONSTER:
X  #endif
X! 		if(! resist(mtmp, otmp->olet, 0, NOTELL)) {
X  			if (mtmp->mspeed == MFAST) mtmp->mspeed = 0;
X  			else mtmp->mspeed = MSLOW;
X+ 			if (u.uswallow && (mtmp == u.ustuck) && 
X+ 			    is_whirly(mtmp->data)) {
X+ 				You("disrupt %s!", mon_nam(mtmp));
X+ 				pline("A huge hole opens up...");
X+ 				expels(mtmp, mtmp->data, TRUE);
X+ 			}
X+ 		}
X  		break;
X  	case WAN_SPEED_MONSTER:
X  		if (!resist(mtmp, otmp->olet, 0, NOTELL))
X***************
X*** 149,157 ****
X  #endif
X  	case WAN_OPENING:
X  		if(u.uswallow && mtmp == u.ustuck) {
X! 			if (Blind) pline("Its mouth opens!");
X! 			else pline("%s opens its mouth!", Monnam(mtmp));
X! 			regurgitates(mtmp);
X  			break;
X  		}
X  	case WAN_LOCKING:
X--- 169,179 ----
X  #endif
X  	case WAN_OPENING:
X  		if(u.uswallow && mtmp == u.ustuck) {
X! 			if (is_animal(mtmp->data)) {
X! 				if (Blind) pline("Its mouth opens!");
X! 				else pline("%s opens its mouth!", Monnam(mtmp));
X! 			}
X! 			expels(mtmp, mtmp->data, TRUE);
X  			break;
X  		}
X  	case WAN_LOCKING:
X***************
X*** 190,202 ****
X  			if (is_mercenary(&mons[montype]))
X  				montype = PM_UNARMORED_SOLDIER;
X  #endif
X- 			mons[montype].pxlth += obj->onamelth;
X  			mtmp = makemon(&mons[montype], x, y);
X- 			mons[montype].pxlth -= obj->onamelth;
X  			if (mtmp) {
X  				/* Monster retains its name */
X! 				if (mtmp->mnamelth = obj->onamelth)
X! 					Strcpy(NAME(mtmp), ONAME(obj));
X  				/* No inventory for newly revived monsters */
X  				while(otmp = (mtmp->minvent)) {
X  					mtmp->minvent = otmp->nobj;
X--- 212,222 ----
X  			if (is_mercenary(&mons[montype]))
X  				montype = PM_UNARMORED_SOLDIER;
X  #endif
X  			mtmp = makemon(&mons[montype], x, y);
X  			if (mtmp) {
X  				/* Monster retains its name */
X! 				if (obj->onamelth)
X! 					mtmp = christen_monst(mtmp, ONAME(obj));
X  				/* No inventory for newly revived monsters */
X  				while(otmp = (mtmp->minvent)) {
X  					mtmp->minvent = otmp->nobj;
X***************
X*** 207,214 ****
X  		if (mtmp && obj->oeaten)
X  			mtmp->mhp = eaten_stat(mtmp->mhp, obj);
X  		if (ininv) useup(obj);
X! 		else useupf(obj);
X! 		newsym(x, y);
X  	}
X  	return mtmp;
X  }
X--- 227,239 ----
X  		if (mtmp && obj->oeaten)
X  			mtmp->mhp = eaten_stat(mtmp->mhp, obj);
X  		if (ininv) useup(obj);
X! 		else {
X! 			/* not useupf(), which charges */
X! 			if (obj->quan > 1) obj->quan--;
X! 			else delobj(obj);
X! 		}
X! 		if (x != u.ux || y != u.uy || Invisible)
X! 			newsym(x, y);
X  	}
X  	return mtmp;
X  }
X***************
X*** 219,224 ****
X--- 244,272 ----
X  cancel_item(obj)
X  register struct obj *obj;
X  {
X+ 	switch(obj->otyp) {
X+ 		case RIN_GAIN_STRENGTH:
X+ 			ABON(A_STR) -= obj->spe;
X+ 			flags.botl = 1;
X+ 			break;
X+ 		case RIN_ADORNMENT:
X+ 			ABON(A_CHA) -= obj->spe;
X+ 			flags.botl = 1;
X+ 			break;
X+ 		case RIN_INCREASE_DAMAGE:
X+ 			u.udaminc -= obj->spe;
X+ 			break;
X+ 		case GAUNTLETS_OF_DEXTERITY:
X+ 			ABON(A_DEX) -= obj->spe;
X+ 			flags.botl = 1;
X+ 			break;
X+ 		case HELM_OF_BRILLIANCE:
X+ 			ABON(A_INT) -= obj->spe;
X+ 			ABON(A_WIS) -= obj->spe;
X+ 			flags.botl = 1;
X+ 			break;
X+ 		/* case RIN_PROTECTION: /* not needed */
X+ 	}
X  	if(obj->spe &&
X  	  !(obj->otyp == AMULET_OF_YENDOR ||
X  	    obj->otyp == WAN_CANCELLATION || /* can't cancel cancellation */
X***************
X*** 290,296 ****
X  		 */
X  		if (obj->otyp == SCR_MAIL) {
X  			otmp2->otyp = SCR_MAIL;
X! 			obj->spe = 1;
X  		}
X  #endif
X  		/* keep special fields (including charges on wands) */
X--- 338,344 ----
X  		 */
X  		if (obj->otyp == SCR_MAIL) {
X  			otmp2->otyp = SCR_MAIL;
X! 			otmp2->spe = 1;
X  		}
X  #endif
X  		/* keep special fields (including charges on wands) */
X***************
X*** 341,346 ****
X--- 389,405 ----
X  		    }
X  		}
X  
X+ 		/* no named weapons --KAA */
X+ 		if (otmp2->onamelth) {
X+ 			otmp2 = oname(otmp2, "", 0);
X+ 			fobj = otmp2;
X+ 			/* cannot use place_object() */
X+ 			level.objects[otmp2->ox][otmp2->oy] = otmp2;
X+ 		}
X+ 
X+ 		/* no box contents --KAA */
X+ 		if (Is_container(otmp2)) delete_contents(otmp2);
X+ 
X  		/* update the weight */
X  		otmp2->owt = weight(otmp2);
X  		delobj(obj);
X***************
X*** 447,454 ****
X  			}
X  			break;
X  		case WAN_WISHING:
X! 
X! 			if(u.uluck + rn2(5) < 0) {
X  				pline("Unfortunately, nothing happens.");
X  				break;
X  			}
X--- 506,512 ----
X  			}
X  			break;
X  		case WAN_WISHING:
X! 			if(Luck + rn2(5) < 0) {
X  				pline("Unfortunately, nothing happens.");
X  				break;
X  			}
X***************
X*** 467,473 ****
X  	register struct obj * otmp;
X  {
X  	pline("The %s suddenly explodes!", xname(otmp));
X! 	losehp(d(otmp->spe+2,6), "exploding wand");
X  	useup(otmp);
X  }
X  
X--- 525,531 ----
X  	register struct obj * otmp;
X  {
X  	pline("The %s suddenly explodes!", xname(otmp));
X! 	losehp(d(otmp->spe+2,6), "exploding wand", KILLED_BY_AN);
X  	useup(otmp);
X  }
X  
X***************
X*** 495,501 ****
X  		/* make him pay for knowing !NODIR */
X  	} else if(!u.dx && !u.dy && !u.dz && !(objects[obj->otyp].bits & NODIR)) {
X  	    if((damage = zapyourself(obj)))
X! 		losehp(damage,"self-inflicted injury");
X  	}
X  	else {
X  		weffects(obj);
X--- 553,560 ----
X  		/* make him pay for knowing !NODIR */
X  	} else if(!u.dx && !u.dy && !u.dz && !(objects[obj->otyp].bits & NODIR)) {
X  	    if((damage = zapyourself(obj)))
X! 		losehp(damage, self_pronoun("zapped %sself with a wand", "him"),
X! 			NO_KILLER_PREFIX);
X  	}
X  	else {
X  		weffects(obj);
X***************
X*** 698,704 ****
X  			break;
X  		    }
X  #endif
X! 		    killer = "death ray";
X  		    You("irradiate yourself with pure energy!");
X  		    You("die.");
X  		    makeknown(WAN_DEATH);
X--- 757,764 ----
X  			break;
X  		    }
X  #endif
X! 		    killer_format = NO_KILLER_PREFIX;
X! 		    killer = self_pronoun("shot %sself with a death ray","him");
X  		    You("irradiate yourself with pure energy!");
X  		    You("die.");
X  		    makeknown(WAN_DEATH);
X***************
X*** 711,717 ****
X  		case WAN_UNDEAD_TURNING:
X  #ifdef POLYSELF
X  		    if (is_undead(uasmon)) {
X! 			Printf("You feel frightened and %sstunned.",
X  			     Stunned ? "even more " : "");
X  			make_stunned(HStun + rnd(30), FALSE);
X  		    }
X--- 771,777 ----
X  		case WAN_UNDEAD_TURNING:
X  #ifdef POLYSELF
X  		    if (is_undead(uasmon)) {
X! 			You("feel frightened and %sstunned.",
X  			     Stunned ? "even more " : "");
X  			make_stunned(HStun + rnd(30), FALSE);
X  		    }
X***************
X*** 799,805 ****
X  			}
X  			break;
X  		case WAN_WISHING:
X! 			if(u.uluck + rn2(5) < 0) {
X  			    pline("Unfortunately, nothing happens.");
X  			    break;
X  			}
X--- 859,865 ----
X  			}
X  			break;
X  		case WAN_WISHING:
X! 			if(Luck + rn2(5) < 0) {
X  			    pline("Unfortunately, nothing happens.");
X  			    break;
X  			}
X***************
X*** 819,832 ****
X  			{ register struct rm *room;
X  			  register int digdepth,dlx,dly;
X  			  register boolean shopdoor = FALSE;
X  			if(u.uswallow) {
X  				register struct monst *mtmp = u.ustuck;
X  
X! 				if (Blind) You("pierce its stomach wall!");
X! 				else You("pierce %s's stomach wall!",
X! 					mon_nam(mtmp));
X! 				mtmp->mhp = 1;	/* almost dead */
X! 				regurgitates(mtmp);
X  				break;
X  			}
X  			if(u.dz) {
X--- 879,901 ----
X  			{ register struct rm *room;
X  			  register int digdepth,dlx,dly;
X  			  register boolean shopdoor = FALSE;
X+ #ifdef __GNULINT__
X+ 			dlx = dly = 0;
X+ #endif
X  			if(u.uswallow) {
X  				register struct monst *mtmp = u.ustuck;
X  
X! 				if (!is_whirly(mtmp->data)) {
X! 					if (is_animal(mtmp->data)) 
X! 						if (Blind) 
X! 						You("pierce its stomach wall!");
X! 						else 
X! 						You("pierce %s's stomach wall!",
X! 				  	 	    mon_nam(mtmp));
X! 					mtmp->mhp = 1;	/* almost dead */
X! 					expels(mtmp, mtmp->data,
X! 					       !is_animal(mtmp->data));
X! 				}
X  				break;
X  			}
X  			if(u.dz) {
X***************
X*** 834,840 ****
X  				You("loosen a rock from the ceiling.");
X  				pline("It falls on your %s!",
X  					body_part(HEAD));
X! 				losehp(1, "falling rock");
X  				(void) mksobj_at((int)ROCK, u.ux, u.uy);
X  				fobj->quan = 1;
X  				stackobj(fobj);
X--- 903,909 ----
X  				You("loosen a rock from the ceiling.");
X  				pline("It falls on your %s!",
X  					body_part(HEAD));
X! 				losehp(1, "falling rock", KILLED_BY_AN);
X  				(void) mksobj_at((int)ROCK, u.ux, u.uy);
X  				fobj->quan = 1;
X  				stackobj(fobj);
X***************
X*** 883,890 ****
X  					}
X  				    else
X  					break;
X! 				else if(room->typ == DOOR &&
X! 					(room->doormask & (D_LOCKED | D_CLOSED))) {
X  				    room->doormask = D_NODOOR;
X  				    mnewsym(zx, zy);
X  				    if (cansee(zx,zy)) prl(zx, zy);
X--- 952,958 ----
X  					}
X  				    else
X  					break;
X! 				else if(closed_door(zx, zy)) {
X  				    room->doormask = D_NODOOR;
X  				    mnewsym(zx, zy);
X  				    if (cansee(zx,zy)) prl(zx, zy);
X***************
X*** 927,933 ****
X  	return;
X  }
X  
X! char *
X  exclam(force)
X  register int force;
X  {
X--- 995,1001 ----
X  	return;
X  }
X  
X! const char *
X  exclam(force)
X  register int force;
X  {
X***************
X*** 934,940 ****
X  	/* force == 0 occurs e.g. with sleep ray */
X  	/* note that large force is usual with wands so that !! would
X  		require information about hand/weapon/wand */
X! 	return( (force < 0) ? "?" : (force <= 4) ? "." : "!" );
X  }
X  
X  void
X--- 1002,1008 ----
X  	/* force == 0 occurs e.g. with sleep ray */
X  	/* note that large force is usual with wands so that !! would
X  		require information about hand/weapon/wand */
X! 	return (const char *)((force < 0) ? "?" : (force <= 4) ? "." : "!");
X  }
X  
X  void
X***************
X*** 968,974 ****
X  bhit(ddx,ddy,range,sym,fhitm,fhito,obj)
X  register int ddx,ddy,range;		/* direction and range */
X  char sym;				/* symbol displayed on path */
X! int (*fhitm)(), (*fhito)();		/* fns called when mon/obj hit */
X  struct obj *obj;			/* 2nd arg to fhitm/fhito */
X  {
X  	register struct monst *mtmp;
X--- 1036,1043 ----
X  bhit(ddx,ddy,range,sym,fhitm,fhito,obj)
X  register int ddx,ddy,range;		/* direction and range */
X  char sym;				/* symbol displayed on path */
X! int FDECL((*fhitm), (struct monst *, struct obj *)),
X!     FDECL((*fhito), (struct obj *, struct obj *));		/* fns called when mon/obj hit */
X  struct obj *obj;			/* 2nd arg to fhitm/fhito */
X  {
X  	register struct monst *mtmp;
X***************
X*** 975,981 ****
X--- 1044,1054 ----
X  	register struct obj *otmp;
X  	register uchar typ;
X  	boolean shopdoor = FALSE;
X+ #ifdef __GNULINT__
X+ 	xchar dlx=0, dly=0;
X+ #else
X  	xchar dlx, dly;
X+ #endif
X  
X  	bhitpos.x = u.ux;
X  	bhitpos.y = u.uy;
X***************
X*** 1063,1071 ****
X  			    break;
X  		    }
X  		}
X! 		if(!ZAP_POS(typ) || (IS_DOOR(typ) &&
X! 		   (levl[bhitpos.x][bhitpos.y].doormask & (D_LOCKED | D_CLOSED)))
X! 		  ) {
X  			bhitpos.x -= ddx;
X  			bhitpos.y -= ddy;
X  			break;
X--- 1136,1142 ----
X  			    break;
X  		    }
X  		}
X! 		if(!ZAP_POS(typ) || closed_door(bhitpos.x, bhitpos.y)) {
X  			bhitpos.x -= ddx;
X  			bhitpos.y -= ddy;
X  			break;
X***************
X*** 1179,1185 ****
X  		if(resists_sleep(mon->data) ||
X  		   resist(mon, (type == 2) ? WAND_SYM : '\0', 0, NOTELL))
X  			shieldeff(mon->mx, mon->my);
X! 		else	mon->mfroz = 1;
X  		break;
X  	case 3:			/* cold */
X  		if(resists_cold(mon->data)) {
X--- 1250,1261 ----
X  		if(resists_sleep(mon->data) ||
X  		   resist(mon, (type == 2) ? WAND_SYM : '\0', 0, NOTELL))
X  			shieldeff(mon->mx, mon->my);
X! 		else if (mon->mcanmove) {
X! 			int tmp2 = d(nd,25);
X! 			mon->mcanmove = 0;
X! 			if (mon->mfrozen + tmp2 > 127) mon->mfrozen = 127;
X! 			else mon->mfrozen += tmp2;
X! 		}
X  		break;
X  	case 3:			/* cold */
X  		if(resists_cold(mon->data)) {
X***************
X*** 1256,1266 ****
X  #else
X  	    if(obj->olet == SCROLL_SYM) {
X  #endif
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X  		    if(!rn2(3))  {
X  			cnt++;
X! 			useupf(obj);
X  		    }
X  	    }
X  	}
X--- 1332,1349 ----
X  #else
X  	    if(obj->olet == SCROLL_SYM) {
X  #endif
X+ 		if (obj->otyp == SCR_FIRE
X+ #ifdef SPELLS
X+ 					|| obj->otyp == SPE_FIREBALL)
X+ #endif
X+ 		    continue;
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X  		    if(!rn2(3))  {
X  			cnt++;
X! 			/* not useupf(), which charges */
X! 			if (obj->quan > 1) obj->quan--;
X! 			else delobj(obj);
X  		    }
X  	    }
X  	}
X***************
X*** 1282,1288 ****
X--- 1365,1376 ----
X  	int abstype = abs(type) % 10;
X  	register const char *fltxt = fl[abs(type)];
X  	struct rm *lev;
X+ 	register xchar lsx, lsy;
X+ #ifdef __GNULINT__
X+ 	xchar range, olx=0, oly=0;
X+ #else
X  	xchar range, olx, oly;
X+ #endif
X  	struct monst *mon;
X  	register boolean bodyhit = FALSE;
X  	register boolean shopdoor = FALSE;
X***************
X*** 1306,1315 ****
X  	Tmp_at2(-3, zapcolor[abstype]);
X  #endif
X  	while(range-- > 0) {
X! 		sx += dx;
X! 		sy += dy;
X! 		if((lev = &levl[sx][sy])->typ) Tmp_at2(sx,sy);
X! 		else {
X  			int bounce = 0;
X  			if(cansee(sx-dx,sy-dy))
X  				pline("The %s bounces!", fltxt);
X--- 1394,1407 ----
X  	Tmp_at2(-3, zapcolor[abstype]);
X  #endif
X  	while(range-- > 0) {
X! 		lsx = sx; sx += dx;
X! 		lsy = sy; sy += dy;
X! 		if((lev = &levl[sx][sy])->typ) {
X! 			if((cansee(lsx,lsy) && cansee(sx,sy)) ||
X! 				(!cansee(lsx,lsy) && cansee(sx,sy) &&
X! 				 (IS_DOOR(lev->typ) || IS_ROOM(lev->typ))))
X! 			    Tmp_at2(sx,sy);
X! 		} else {
X  			int bounce = 0;
X  			if(cansee(sx-dx,sy-dy))
X  				pline("The %s bounces!", fltxt);
X***************
X*** 1388,1394 ****
X  			} else if(flags.soundok)
X  				You("hear a crackling sound.");
X  		}
X! 		if(IS_DOOR(lev->typ) && (lev->doormask & (D_LOCKED | D_CLOSED))) {
X  			range = 0;
X  			switch(abstype) {
X  			case 1:
X--- 1480,1486 ----
X  			} else if(flags.soundok)
X  				You("hear a crackling sound.");
X  		}
X! 		if(closed_door(sx, sy)) {
X  			range = 0;
X  			switch(abstype) {
X  			case 1:
X***************
X*** 1545,1551 ****
X  					case 1:
X  					    bodyhit = TRUE;
X  					    if (uarmc) break;
X! 		(void)(rust_dmg(uarm, "leather armor", 0, FALSE));
X  					    break;
X  					case 2:
X  		if (!rust_dmg(uarms, "wooden shield", 0, FALSE)) continue;
X--- 1637,1643 ----
X  					case 1:
X  					    bodyhit = TRUE;
X  					    if (uarmc) break;
X! 		if (uarm) (void)(rust_dmg(uarm, xname(uarm), 0, FALSE));
X  					    break;
X  					case 2:
X  		if (!rust_dmg(uarms, "wooden shield", 0, FALSE)) continue;
X***************
X*** 1623,1629 ****
X  					dam = d(nd, 6);
X  				    break;
X  				case 6:		/* poison */
X! 				    poisoned("blast", A_DEX, "poisoned blast");
X  				    break;
X  				case 7:		/* acid */
X  				    pline("The acid burns!");
X--- 1715,1721 ----
X  					dam = d(nd, 6);
X  				    break;
X  				case 6:		/* poison */
X! 				    poisoned("blast", A_DEX, "poisoned blast", 15);
X  				    break;
X  				case 7:		/* acid */
X  				    pline("The acid burns!");
X***************
X*** 1632,1638 ****
X  				    if(!rn2(6)) corrode_armor();
X  				    break;
X  				}
X! 				losehp(dam,fltxt);
X  			} else pline("The %s whizzes by you!",fltxt);
X  			if (abstype == 5 && !Blind) { /* LIGHTNING */
X  		    		You("are blinded by the flash!");
X--- 1724,1730 ----
X  				    if(!rn2(6)) corrode_armor();
X  				    break;
X  				}
X! 				losehp(dam,fltxt, KILLED_BY_AN);
X  			} else pline("The %s whizzes by you!",fltxt);
X  			if (abstype == 5 && !Blind) { /* LIGHTNING */
X  		    		You("are blinded by the flash!");
X***************
X*** 1675,1682 ****
X  		}
X  	}
X  	Tmp_at2(-1,-1);
X! 	if(shopdoor && !in_shop(u.ux, u.uy))
X! 		pay_for_door(olx, oly, abstype == 1 ? "burn away" :
X  				       abstype == 3 ? "shatter" :
X  				       abstype == 4 ? "disintegrate" :
X  				       "destroy");
X--- 1767,1773 ----
X  		}
X  	}
X  	Tmp_at2(-1,-1);
X! 	if(shopdoor) pay_for_door(olx, oly, abstype == 1 ? "burn away" :
X  				       abstype == 3 ? "shatter" :
X  				       abstype == 4 ? "disintegrate" :
X  				       "destroy");
X***************
X*** 1780,1786 ****
X  	register struct obj *obj, *obj2;
X  	register int quan, i, cnt, dmg, xresist, skip;
X  	register int dindx;
X! 	char *mult;
X  
X  	for(obj = invent; obj; obj = obj2) {
X  
X--- 1871,1877 ----
X  	register struct obj *obj, *obj2;
X  	register int quan, i, cnt, dmg, xresist, skip;
X  	register int dindx;
X! 	const char *mult;
X  
X  	for(obj = invent; obj; obj = obj2) {
X  
X***************
X*** 1787,1793 ****
X  	    obj2 = obj->nobj;
X  	    if(obj->olet != osym) continue; /* test only objs of type osym */
X  	    xresist = skip = 0;
X! 
X  	    switch(dmgtyp) {
X  		case AD_COLD:
X  		    if(osym == POTION_SYM) {
X--- 1878,1886 ----
X  	    obj2 = obj->nobj;
X  	    if(obj->olet != osym) continue; /* test only objs of type osym */
X  	    xresist = skip = 0;
X! #ifdef __GNULINT__
X! 	    quan = dmg = dindx = 0;
X! #endif
X  	    switch(dmgtyp) {
X  		case AD_COLD:
X  		    if(osym == POTION_SYM) {
X***************
X*** 1799,1807 ****
X  		case AD_FIRE:
X  		    xresist = (Fire_resistance && obj->olet != POTION_SYM);
X  
X! 		    /* Let's say scrolls of fire are fire resistant */
X! 
X! 		    if (obj->otyp == SCR_FIRE)
X  		      skip++;
X  		    quan = obj->quan;
X  		    switch(osym) {
X--- 1892,1902 ----
X  		case AD_FIRE:
X  		    xresist = (Fire_resistance && obj->olet != POTION_SYM);
X  
X! 		    if (obj->otyp == SCR_FIRE
X! #ifdef SPELLS
X! 					|| obj->otyp == SPE_FIREBALL
X! #endif
X! 								)
X  		      skip++;
X  		    quan = obj->quan;
X  		    switch(osym) {
X***************
X*** 1863,1869 ****
X  		for(i = 0; i < cnt; i++) useup(obj);
X  		if(dmg) {
X  		    if(xresist)	You("aren't hurt!");
X! 		    else	losehp(dmg, destroy_strings[dindx*3 + 2]);
X  		}
X  	    }
X  	}
X--- 1958,1967 ----
X  		for(i = 0; i < cnt; i++) useup(obj);
X  		if(dmg) {
X  		    if(xresist)	You("aren't hurt!");
X! 		    else	losehp(dmg,
X! 			(cnt==1) ? destroy_strings[dindx*3 + 2] :
X! 				(const char *)makeplural(destroy_strings[dindx*3 + 2]),
X! 			(cnt==1) ? KILLED_BY_AN : KILLED_BY);
X  		}
X  	    }
X  	}
X***************
X*** 1884,1890 ****
X  	    obj2 = obj->nobj;
X  	    if(obj->olet != osym) continue; /* test only objs of type osym */
X  	    skip = 0;
X! 
X  	    switch(dmgtyp) {
X  		case AD_COLD:
X  		    if(osym == POTION_SYM) {
X--- 1982,1990 ----
X  	    obj2 = obj->nobj;
X  	    if(obj->olet != osym) continue; /* test only objs of type osym */
X  	    skip = 0;
X! #ifdef __GNULINT__
X! 	    quan = dindx = 0;
X! #endif
X  	    switch(dmgtyp) {
X  		case AD_COLD:
X  		    if(osym == POTION_SYM) {
X***************
X*** 1894,1902 ****
X  		    } else skip++;
X  	    	    break;
X  		case AD_FIRE:
X! 		    /* Let's say scrolls of fire are fire resistant */
X! 
X! 		    if (obj->otyp == SCR_FIRE)
X  		      skip++;
X  		    quan = obj->quan;
X  		    switch(osym) {
X--- 1994,2004 ----
X  		    } else skip++;
X  	    	    break;
X  		case AD_FIRE:
X! 		    if (obj->otyp == SCR_FIRE
X! #ifdef SPELLS
X! 					|| obj->otyp == SPE_FIREBALL
X! #endif
X! 								)
X  		      skip++;
X  		    quan = obj->quan;
X  		    switch(osym) {
X***************
X*** 2036,2046 ****
X  	    	prinv(otmp);
X  	    	otmp->quan = mergquan;
X  	    }
X- #ifdef WIZARD
X-  	if (!wizard)
X- #endif
X- 	    if(otmp->otyp == WAN_WISHING) otmp->recharged = 1;
X- 
X  #ifdef THEOLOGY
X  	    u.ublesscnt += rn1(100,50);  /* the gods take notice */
X  #endif
X--- 2138,2143 ----
X
END_OF_FILE
if test 53746 -ne `wc -c <'patch7.12'`; then
    echo shar: \"'patch7.12'\" unpacked with wrong size!
fi
# end of 'patch7.12'
fi
echo shar: End of archive 18 \(of 30\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
