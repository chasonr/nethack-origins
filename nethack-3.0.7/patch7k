Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!swrinde!zaphod.mps.ohio-state.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i011:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7k
Message-ID: <5225@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:36:42 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2137
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 11
Archive-name: NetHack3/Patch7k
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 30)."
# Contents:  patch7.08
# Wrapped by billr@saab on Wed Feb 21 10:04:32 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.08' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.08'\" to \"'patch7.08.orig'\"
  mv -f 'patch7.08' 'patch7.08.orig'
fi
echo shar: Extracting \"'patch7.08'\" \(55436 characters\)
sed "s/^X//" >'patch7.08' <<'END_OF_FILE'
X*** src/Old/shk.c	Mon Feb 19 18:58:28 1990
X--- src/shk.c	Sun Feb 18 11:46:50 1990
X***************
X*** 1,9 ****
X! /*	SCCS Id: @(#)shk.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include "hack.h"
X  
X  #include "eshk.h"
X--- 1,9 ----
X! /*	SCCS Id: @(#)shk.c	3.0	89/11/27
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  
X  #include "eshk.h"
X***************
X*** 10,16 ****
X  
X  #ifdef KOPS
X  static int FDECL(makekops, (coord *));
X! static void kops_gone();
X  #endif /* KOPS */
X  
X  #define	NOTANGRY(mon)	mon->mpeaceful
X--- 10,16 ----
X  
X  #ifdef KOPS
X  static int FDECL(makekops, (coord *));
X! static void NDECL(kops_gone);
X  #endif /* KOPS */
X  
X  #define	NOTANGRY(mon)	mon->mpeaceful
X***************
X*** 18,34 ****
X  
X  /* Descriptor of current shopkeeper. Note that the bill need not be
X     per-shopkeeper, since it is valid only when in a shop. */
X! static struct monst *shopkeeper = 0;
X! static struct bill_x *bill;
X! static int shlevel = 0;	/* level of this shopkeeper */
X  /* struct obj *billobjs;	/* objects on bill with bp->useup */
X  				/* only accessed here and by save & restore */
X! static long int total;		/* filled by addupbill() */
X! static long int followmsg;	/* last time of follow message */
X  static void setpaid(), FDECL(findshk, (int));
X  static int FDECL(dopayobj, (struct bill_x *)), FDECL(getprice, (struct obj *));
X  static struct obj *FDECL(bp_to_obj, (struct bill_x *));
X  
X  /*
X  	invariants: obj->unpaid iff onbill(obj) [unless bp->useup]
X  		obj->quan <= bp->bquan
X--- 18,37 ----
X  
X  /* Descriptor of current shopkeeper. Note that the bill need not be
X     per-shopkeeper, since it is valid only when in a shop. */
X! VSTATIC struct monst *shopkeeper;
X! VSTATIC struct bill_x *bill;
X! VSTATIC int shlevel;		/* level of this shopkeeper */
X  /* struct obj *billobjs;	/* objects on bill with bp->useup */
X  				/* only accessed here and by save & restore */
X! VSTATIC long int total; 	/* filled by addupbill() */
X! VSTATIC long int followmsg;	/* last time of follow message */
X! 
X  static void setpaid(), FDECL(findshk, (int));
X  static int FDECL(dopayobj, (struct bill_x *)), FDECL(getprice, (struct obj *));
X  static struct obj *FDECL(bp_to_obj, (struct bill_x *));
X  
X+ #ifdef OVLB
X+ 
X  /*
X  	invariants: obj->unpaid iff onbill(obj) [unless bp->useup]
X  		obj->quan <= bp->bquan
X***************
X*** 106,111 ****
X--- 109,117 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  int
X  inshop() {
X  	register int roomno = inroom(u.ux,u.uy);
X***************
X*** 252,257 ****
X--- 258,268 ----
X  		    NOTANGRY(shopkeeper) = 1;
X  		}
X  		if(!ESHK(shopkeeper)->following && inhishop(shopkeeper)) {
X+ 		    if(Invis) {
X+ 			pline("%s senses your presence.", shkname(shopkeeper));
X+ 			verbalize("Invisible customers are not welcome!");
X+ 		    }
X+ 		    else
X  		    if(ANGRY(shopkeeper))
X  			pline("\"So, %s, you dare return to %s's %s?!\"",
X  			    plname,
X***************
X*** 267,276 ****
X  			    ESHK(shopkeeper)->visitct++ ? " again" : "",
X  			    shkname(shopkeeper),
X  			    shtypes[rt - SHOPBASE].name);
X! 		    if(carrying(PICK_AXE) != (struct obj *)0) {
X! 			pline(NOTANGRY(shopkeeper) ?
X! 			   "\"Will you please leave your pick-axe outside?\"" :
X! 			   "\"Leave the pick-axe outside.\"");
X  			if(dochug(shopkeeper)) {
X  			    u.uinshop = 0;	/* he died moving */
X  			    return(0);
X--- 278,287 ----
X  			    ESHK(shopkeeper)->visitct++ ? " again" : "",
X  			    shkname(shopkeeper),
X  			    shtypes[rt - SHOPBASE].name);
X! 		    if(carrying(PICK_AXE) != (struct obj *)0 && !Invis) {
X! 			verbalize(NOTANGRY(shopkeeper) ?
X! 			   "Will you please leave your pick-axe outside?" :
X! 			   "Leave the pick-axe outside.");
X  			if(dochug(shopkeeper)) {
X  			    u.uinshop = 0;	/* he died moving */
X  			    return(0);
X***************
X*** 283,288 ****
X--- 294,302 ----
X  	return (int)u.uinshop;
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  int
X  inhishop(mtmp)
X  register struct monst *mtmp;
X***************
X*** 597,606 ****
X  #endif /* MSDOS /**/
X  		}
X  	}
X! 	pline("\"Thank you for shopping in %s's %s!\"",
X  		shkname(shopkeeper),
X  		shtypes[rooms[ESHK(shopkeeper)->shoproom].rtype - SHOPBASE].name);
X- 	NOTANGRY(shopkeeper) = 1;
X  	return(1);
X  }
X  
X--- 611,620 ----
X  #endif /* MSDOS /**/
X  		}
X  	}
X! 	if(!ANGRY(shopkeeper))
X! 	    pline("\"Thank you for shopping in %s's %s!\"",
X  		shkname(shopkeeper),
X  		shtypes[rooms[ESHK(shopkeeper)->shoproom].rtype - SHOPBASE].name);
X  	return(1);
X  }
X  
X***************
X*** 790,798 ****
X  	if (ACURR(A_CHA) > 18)		tmp /= 2L;
X  	else if (ACURR(A_CHA) > 17)	tmp = (tmp * 2L)/3L;
X  	else if (ACURR(A_CHA) > 15)	tmp = (tmp * 3L)/4L;
X- 	else if (ACURR(A_CHA) < 11)	tmp = (tmp * 4L)/3L;
X- 	else if (ACURR(A_CHA) < 8)	tmp = (tmp * 3L)/2L;
X  	else if (ACURR(A_CHA) < 6)	tmp *= 2L;
X  	return(tmp);
X  }
X  
X--- 804,813 ----
X  	if (ACURR(A_CHA) > 18)		tmp /= 2L;
X  	else if (ACURR(A_CHA) > 17)	tmp = (tmp * 2L)/3L;
X  	else if (ACURR(A_CHA) > 15)	tmp = (tmp * 3L)/4L;
X  	else if (ACURR(A_CHA) < 6)	tmp *= 2L;
X+ 	else if (ACURR(A_CHA) < 8)	tmp = (tmp * 3L)/2L;
X+ 	else if (ACURR(A_CHA) < 11)	tmp = (tmp * 4L)/3L;
X+ 	if (!tmp) return 1;
X  	return(tmp);
X  }
X  
X***************
X*** 940,956 ****
X  		return;
X  	}
X  	/* you dropped something of your own - probably want to sell it */
X! 	if(shopkeeper->msleep || shopkeeper->mfroz || !inhishop(shopkeeper))
X  		return;
X  	ltmp = (long) getprice(obj) * (long) obj->quan;
X- 	if(ESHK(shopkeeper)->billct == BILLSZ
X- 	   || !saleable(rooms[ESHK(shopkeeper)->shoproom].rtype-SHOPBASE, obj)
X- 	   || obj->olet == BALL_SYM || ltmp == 0L
X- 	   || (obj->olet == FOOD_SYM && obj->oeaten)) {
X- 		pline("%s seems not interested.", Monnam(shopkeeper));
X- 		obj->no_charge = 1;
X- 		return;
X- 	}
X  	if (ANGRY(shopkeeper) || (pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X--- 955,963 ----
X  		return;
X  	}
X  	/* you dropped something of your own - probably want to sell it */
X! 	if(shopkeeper->msleep || !shopkeeper->mcanmove || !inhishop(shopkeeper))
X  		return;
X  	ltmp = (long) getprice(obj) * (long) obj->quan;
X  	if (ANGRY(shopkeeper) || (pl_character[0] == 'T' && u.ulevel < (MAXULEV/2))
X  #ifdef SHIRT
X  	    || (uarmu && !uarm) /* wearing just a Hawaiian shirt */
X***************
X*** 959,968 ****
X  		ltmp /= 3L;
X  		NOTANGRY(shopkeeper) = 1;
X  	} else	ltmp /= 2L;
X  	if(ESHK(shopkeeper)->robbed) {
X  		if((ESHK(shopkeeper)->robbed -= ltmp) < 0L)
X  			ESHK(shopkeeper)->robbed = 0L;
X! pline("\"Thank you for your contribution to restock this recently plundered shop.\"");
X  		return;
X  	}
X  	if(ltmp > shopkeeper->mgold)
X--- 966,983 ----
X  		ltmp /= 3L;
X  		NOTANGRY(shopkeeper) = 1;
X  	} else	ltmp /= 2L;
X+ 	if(ESHK(shopkeeper)->billct == BILLSZ
X+ 	   || !saleable(rooms[ESHK(shopkeeper)->shoproom].rtype-SHOPBASE, obj)
X+ 	   || obj->olet == BALL_SYM || ltmp == 0L
X+ 	   || (obj->olet == FOOD_SYM && obj->oeaten)) {
X+ 		pline("%s seems not interested.", Monnam(shopkeeper));
X+ 		obj->no_charge = 1;
X+ 		return;
X+ 	}
X  	if(ESHK(shopkeeper)->robbed) {
X  		if((ESHK(shopkeeper)->robbed -= ltmp) < 0L)
X  			ESHK(shopkeeper)->robbed = 0L;
X! verbalize("Thank you for your contribution to restock this recently plundered shop.");
X  		return;
X  	}
X  	if(ltmp > shopkeeper->mgold)
X***************
X*** 983,989 ****
X--- 998,1009 ----
X  {
X  	register struct bill_x *bp;
X  	register struct obj *obj;
X+ #ifdef __GNULINT__
X+ 	long totused, thisused = 0L;
X+ /* possibly a bug in the GCC; clearly thisused is always set before use */
X+ #else
X  	long totused, thisused;
X+ #endif
X  	char buf[BUFSZ];
X  
X  	if(mode == 0) {
X***************
X*** 1058,1064 ****
X  	case FOOD_SYM:
X  		/* simpler hunger check, (2-4)*cost */
X  		if (u.uhs >= HUNGRY) tmp *= u.uhs;
X! 		if (obj->oeaten) tmp /= 2;		/* partly eaten */
X  		break;
X  	case WAND_SYM:
X  		if (obj->spe == -1) tmp = 0;
X--- 1078,1084 ----
X  	case FOOD_SYM:
X  		/* simpler hunger check, (2-4)*cost */
X  		if (u.uhs >= HUNGRY) tmp *= u.uhs;
X! 		if (obj->oeaten) tmp = eaten_stat(tmp, obj); /* partly eaten */
X  		break;
X  	case WAND_SYM:
X  		if (obj->spe == -1) tmp = 0;
X***************
X*** 1085,1091 ****
X  	register struct monst *shkp = shopkeeper;
X  
X  	if(obj->otyp != PICK_AXE) return(0);
X! 	if(u.uinshop && shkp && !shkp->mfroz && !shkp->msleep &&
X  	    inroom(u.ux+u.dx, u.uy+u.dy) + 1 == u.uinshop &&
X  	    shkp->mx == ESHK(shkp)->shk.x && shkp->my == ESHK(shkp)->shk.y &&
X  	    u.ux == ESHK(shkp)->shd.x && u.uy == ESHK(shkp)->shd.y) {
X--- 1105,1111 ----
X  	register struct monst *shkp = shopkeeper;
X  
X  	if(obj->otyp != PICK_AXE) return(0);
X! 	if(u.uinshop && shkp && shkp->mcanmove && !shkp->msleep &&
X  	    inroom(u.ux+u.dx, u.uy+u.dy) + 1 == u.uinshop &&
X  	    shkp->mx == ESHK(shkp)->shk.x && shkp->my == ESHK(shkp)->shk.y &&
X  	    u.ux == ESHK(shkp)->shd.x && u.uy == ESHK(shkp)->shd.y) {
X***************
X*** 1110,1116 ****
X  	register schar appr;
X  	int z;
X  	schar shkroom;
X! 	boolean uondoor, satdoor, avoid, badinv;
X  
X  	omx = shkp->mx;
X  	omy = shkp->my;
X--- 1130,1136 ----
X  	register schar appr;
X  	int z;
X  	schar shkroom;
X! 	boolean uondoor = FALSE, satdoor, avoid = FALSE, badinv;
X  
X  	omx = shkp->mx;
X  	omy = shkp->my;
X***************
X*** 1207,1212 ****
X--- 1227,1235 ----
X  	return(move_special(shkp,shkroom,appr,uondoor,avoid,omx,omy,gx,gy));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  online(x,y)		/*	New version to speed things up.
X  			 *	Compiler dependant, may not always work.
X***************
X*** 1222,1227 ****
X--- 1245,1253 ----
X   *}
X   */
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  /* for use in levl_follower (mondata.c) */
X  boolean
X  is_fshk(mtmp)
X***************
X*** 1249,1259 ****
X  	    pline("\"%s, do not damage the floor here!\"",
X  			flags.female ? "Madam" : "Sir");
X  	if (pl_character[0] == 'K') adjalign(-sgn(u.ualigntyp));
X!     } else if(!um_dist(shopkeeper->mx, shopkeeper->my, 5) &&
X! 	      !shopkeeper->msleep && !shopkeeper->mfroz) {
X! 	register struct obj *obj, *obj2;
X  
X! 	if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X  		mnexto(shopkeeper);
X  		/* for some reason he can't come next to you */
X  		if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X--- 1275,1287 ----
X  	    pline("\"%s, do not damage the floor here!\"",
X  			flags.female ? "Madam" : "Sir");
X  	if (pl_character[0] == 'K') adjalign(-sgn(u.ualigntyp));
X!     } else 
X! 	if(!um_dist(shopkeeper->mx, shopkeeper->my, 5) &&
X! 	      !shopkeeper->msleep && shopkeeper->mcanmove &&
X! 	      (ESHK(shopkeeper)->billct || ESHK(shopkeeper)->debit)) {
X! 	    register struct obj *obj, *obj2;
X  
X! 	    if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X  		mnexto(shopkeeper);
X  		/* for some reason he can't come next to you */
X  		if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X***************
X*** 1263,1278 ****
X  		    return;
X  		} else pline("%s leaps, and grabs your backpack!",
X  					shkname(shopkeeper));
X! 	} else pline("%s grabs your backpack!", shkname(shopkeeper));
X  
X! 	for(obj = invent; obj; obj = obj2) {
X  		obj2 = obj->nobj;
X  		if(obj->owornmask) continue;
X  		freeinv(obj);
X  		obj->nobj = shopkeeper->minvent;
X  		shopkeeper->minvent = obj;
X  		subfrombill(obj);
X! 	}
X      }
X  }
X  
X--- 1291,1309 ----
X  		    return;
X  		} else pline("%s leaps, and grabs your backpack!",
X  					shkname(shopkeeper));
X! 	    } else pline("%s grabs your backpack!", shkname(shopkeeper));
X  
X! 	    for(obj = invent; obj; obj = obj2) {
X  		obj2 = obj->nobj;
X  		if(obj->owornmask) continue;
X+ #ifdef WALKIES
X+ 		if(obj->otyp == LEASH && obj->leashmon) continue;
X+ #endif
X  		freeinv(obj);
X  		obj->nobj = shopkeeper->minvent;
X  		shopkeeper->minvent = obj;
X  		subfrombill(obj);
X! 	    }
X      }
X  }
X  
X***************
X*** 1306,1311 ****
X--- 1337,1345 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  boolean
X  in_shop(x,y)
X  register int x, y;
X***************
X*** 1316,1338 ****
X  	return (IS_SHOP(rooms[roomno]));
X  }
X  
X  void
X  pay_for_door(x,y,dmgstr)
X  int x, y;
X! char *dmgstr;
X  {
X  	struct monst *mtmp;
X  	int roomno = inroom(x, y);
X! 	register int damage;
X  
X  	/* make sure this function is not used in the wrong place */
X  	if(!(IS_DOOR(levl[x][y].typ) && in_shop(x, y))) return;
X  
X! 	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 	    if(mtmp->isshk && ESHK(mtmp)->shoproom == roomno
X! 			   && ESHK(mtmp)->shoplevel == dlevel) {
X! 		shopkeeper = mtmp;
X! 	}
X  
X  	if(!shopkeeper) return;
X  
X--- 1350,1372 ----
X  	return (IS_SHOP(rooms[roomno]));
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  pay_for_door(x,y,dmgstr)
X  int x, y;
X! const char *dmgstr;
X  {
X  	struct monst *mtmp;
X  	int roomno = inroom(x, y);
X! 	long damage;
X! 	boolean uinshp = in_shop(u.ux, u.uy);
X  
X  	/* make sure this function is not used in the wrong place */
X  	if(!(IS_DOOR(levl[x][y].typ) && in_shop(x, y))) return;
X  
X! 	findshk(roomno);
X  
X  	if(!shopkeeper) return;
X  
X***************
X*** 1347,1360 ****
X  	}
X  
X  	/* if he's not in his shop.. */
X! 	if(!in_shop(shopkeeper->mx ,shopkeeper->my)) return;
X  
X! 	if(in_shop(u.ux, u.uy)) mnexto(shopkeeper);
X! 	else {
X  	    /* if a !shopkeeper shows up at the door, move him */
X  	    if(MON_AT(x, y) && (mtmp = m_at(x, y)) != shopkeeper) {
X  		if(flags.soundok) {
X! 		    You("hear an angry voice: \"Out of my way, scum!\"");
X  		    (void) fflush(stdout);
X  #if defined(SYSV) || defined(ULTRIX) || defined(VMS)
X  		    (void)
X--- 1381,1404 ----
X  	}
X  
X  	/* if he's not in his shop.. */
X! 	if(!in_shop(shopkeeper->mx ,shopkeeper->my)) {
X! 		if(!cansee(shopkeeper->mx, shopkeeper->my)) return;
X! 		goto gethim;
X! 	}
X  
X! 	if(uinshp) {
X! 		if(um_dist(shopkeeper->mx, shopkeeper->my, 1) &&
X! 		       !um_dist(shopkeeper->mx, shopkeeper->my, 3)) { 
X! 		    pline("%s leaps towards you!", shkname(shopkeeper));
X! 		    mnexto(shopkeeper);
X! 		}
X! 		if(um_dist(shopkeeper->mx, shopkeeper->my, 1)) goto gethim;
X! 	} else {
X  	    /* if a !shopkeeper shows up at the door, move him */
X  	    if(MON_AT(x, y) && (mtmp = m_at(x, y)) != shopkeeper) {
X  		if(flags.soundok) {
X! 		    You("hear an angry voice:");
X! 		    verbalize("Out of my way, scum!");
X  		    (void) fflush(stdout);
X  #if defined(SYSV) || defined(ULTRIX) || defined(VMS)
X  		    (void)
X***************
X*** 1372,1403 ****
X  	    pmon(shopkeeper);
X  	}
X  
X! 	if(!strcmp(dmgstr, "destroy")) damage = 400;
X! 	else damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X  
X- 	if(um_dist(x, y, 1) || u.ugold < (long) damage || !rn2(50)) {
X- 		if(um_dist(x, y, 1))
X- 		    pline("%s shouts: \"Who dared %s my door?\"",
X- 				shkname(shopkeeper), dmgstr);
X- 		else pline("\"How dare you %s my door?\"", dmgstr);
X  		NOTANGRY(shopkeeper) = 0;
X  		ESHK(shopkeeper)->following = 1;
X  		return;
X  	}
X  
X! 	pline("\"Cad!  You did %d zorkmids worth of damage!\"  Pay? ", damage);
X  	if(yn() != 'n') {
X! 		u.ugold -= (long) damage;
X! 		shopkeeper->mgold += (long) damage;
X  		flags.botl = 1;
X  		pline("Mollified, %s accepts your restitution.",
X  			shkname(shopkeeper));
X- 
X  		/* move shk back to his home loc */
X  		home_shk(shopkeeper);
X  		NOTANGRY(shopkeeper) = 1;
X! 	}
X! 	else {
X  		verbalize("Oh, yes!  You'll pay!");
X  		ESHK(shopkeeper)->following = 1;
X  		NOTANGRY(shopkeeper) = 0;
X--- 1416,1453 ----
X  	    pmon(shopkeeper);
X  	}
X  
X! 	if(!strcmp(dmgstr, "destroy")) damage = 400L;
X! 	else damage = (long)(ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X! 
X! 	if((um_dist(x, y, 1) && !uinshp) || 
X! 			(u.ugold + ESHK(shopkeeper)->credit) < damage 
X! 				|| !rn2(50)) {
X! 		if(um_dist(x, y, 1) && !uinshp) {
X! 		    pline("%s shouts:", shkname(shopkeeper));
X! 		    pline("\"Who dared %s my door?\"", dmgstr);
X! 		} 
X! 		else
X! gethim:
X! 		    pline("\"How dare you %s my door?\"", dmgstr);
X  
X  		NOTANGRY(shopkeeper) = 0;
X  		ESHK(shopkeeper)->following = 1;
X  		return;
X  	}
X  
X! 	if(Invis) Your("invisibility does not fool %s!", shkname(shopkeeper));
X! 	pline("\"Cad!  You did %ld zorkmids worth of damage!\"  Pay? ", damage);
X  	if(yn() != 'n') {
X! 		damage = check_credit(damage, shopkeeper);
X! 		u.ugold -= damage;
X! 		shopkeeper->mgold += damage;
X  		flags.botl = 1;
X  		pline("Mollified, %s accepts your restitution.",
X  			shkname(shopkeeper));
X  		/* move shk back to his home loc */
X  		home_shk(shopkeeper);
X  		NOTANGRY(shopkeeper) = 1;
X! 	} else {
X  		verbalize("Oh, yes!  You'll pay!");
X  		ESHK(shopkeeper)->following = 1;
X  		NOTANGRY(shopkeeper) = 0;
X***************
X*** 1466,1473 ****
X  		  otmp->otyp <= DRUM_OF_EARTHQUAKE) || 	 /* 5 - 9 */
X  #endif
X  	  	  otmp->olet == WAND_SYM) {		 /* 3 - 11 */
X! 		if(otmp->spe == 1) tmp += (tmp/3L);
X! 		else tmp = (tmp/4L);
X  	}
X  	else return(0L);
X  	return(tmp);
X--- 1516,1522 ----
X  		  otmp->otyp <= DRUM_OF_EARTHQUAKE) || 	 /* 5 - 9 */
X  #endif
X  	  	  otmp->olet == WAND_SYM) {		 /* 3 - 11 */
X! 		if(otmp->spe > 1) tmp = (tmp/4L);
X  	}
X  	else return(0L);
X  	return(tmp);
X***************
X*** 1486,1488 ****
X--- 1535,1603 ----
X  		ESHK(shopkeeper)->debit += cost_per_charge(otmp);
X  	}
X  }
X+ 
X+ boolean
X+ block_door(x,y)  	/* used in domove to block diagonal shop-exit */
X+ register int x, y;
X+ {
X+ 	register int roomno = inroom(x, y);
X+ 
X+ 	if(!in_shop(u.ux, u.uy)) return(FALSE);
X+ 
X+ 	if(!IS_DOOR(levl[x][y].typ)) return(FALSE);
X+ 
X+ 	if(roomno != inroom(u.ux,u.uy)) return(FALSE);
X+ 
X+ 	findshk(roomno);
X+ 
X+ 	if(inhishop(shopkeeper)
X+ 	    && shopkeeper->mx == ESHK(shopkeeper)->shk.x
X+ 	    && shopkeeper->my == ESHK(shopkeeper)->shk.y
X+ 	    /* Actually, the shk should be made to block _any_ */
X+ 	    /* door, including a door the player digs, if the  */
X+ 	    /* shk is within a 'jumping' distance.	       */
X+ 	    && ESHK(shopkeeper)->shd.x == x && ESHK(shopkeeper)->shd.y == y
X+ 	    && shopkeeper->mcanmove && !shopkeeper->msleep
X+ 	    && (ESHK(shopkeeper)->debit || ESHK(shopkeeper)->billct ||
X+ 		ESHK(shopkeeper)->robbed)) {
X+ 		pline("%s%s blocks your way!", shkname(shopkeeper),
X+ 				Invis ? " senses your motion and" : "");
X+ 		return(TRUE);
X+ 	}
X+ 	return(FALSE);
X+ }
X+ 
X+ boolean
X+ block_entry(x,y)  	/* used in domove to block diagonal shop-entry */
X+ register int x, y;
X+ {
X+ 	register int sx, sy, roomno = inroom(x, y);
X+ 
X+ 	if(roomno != inroom(u.ux,u.uy)) return(FALSE);
X+ 
X+ 	if(!(in_shop(u.ux, u.uy) && IS_DOOR(levl[u.ux][u.uy].typ) &&
X+ 		levl[u.ux][u.uy].doormask == D_BROKEN)) return(FALSE);
X+ 
X+ 	findshk(roomno);
X+ 	if(!inhishop(shopkeeper)) return(FALSE);
X+ 
X+ 	if(ESHK(shopkeeper)->shd.x != u.ux || ESHK(shopkeeper)->shd.y != u.uy)
X+ 		return(FALSE);
X+ 
X+ 	sx = ESHK(shopkeeper)->shk.x;
X+ 	sy = ESHK(shopkeeper)->shk.y;
X+ 
X+ 	if(shopkeeper->mx == sx && shopkeeper->my == sy
X+ 	    	&& shopkeeper->mcanmove && !shopkeeper->msleep
X+ 	    	&& in_shop(x, y)
X+ 	        && (x == sx-1 || x == sx+1 || y == sy-1 || y == sy+1)  
X+ 	    	&& (Invis || carrying(PICK_AXE))
X+           ) {
X+ 		pline("%s%s blocks your way!", shkname(shopkeeper),
X+ 				Invis ? " senses your motion and" : "");
X+ 		return(TRUE);
X+ 	}
X+ 	return(FALSE);
X+ }
X+ 
X+ #endif /* OVLB */
X*** src/Old/shknam.c	Mon Feb 19 18:59:31 1990
X--- src/shknam.c	Sun Feb 11 12:27:44 1990
X***************
X*** 7,12 ****
X--- 7,14 ----
X  #include "hack.h"
X  #include "eshk.h"
X  
X+ #ifdef OVLB
X+ 
X  static const char *shkliquors[] = {
X      /* Ukraine */
X      "Njezjin", "Tsjernigof", "Gomel", "Ossipewsk", "Gorlowka",
X***************
X*** 137,142 ****
X--- 139,145 ----
X   * In the latter case, prepend it with a unary minus so the code can know
X   * (by testing the sign) whether to use mkobj() or mksobj().
X   */
X+ 
X  const struct shclass shtypes[] = {
X  	{"general store", RANDOM_SYM,
X  #ifdef SPELLS
X***************
X*** 144,152 ****
X  #else
X  	    47,
X  #endif
X! 	    D_SHOP, {{100, RANDOM_SYM}, {0, 0}, {0, 0}}, shkgeneral},
X  	{"used armor dealership", ARMOR_SYM, 14,
X! 	    D_SHOP, {{90, ARMOR_SYM}, {10, WEAPON_SYM}, {0, 0}}, shkarmors},
X  	{"second hand bookstore", SCROLL_SYM, 10, D_SHOP,
X  #ifdef SPELLS
X  	    {{90, SCROLL_SYM}, {10, SPBOOK_SYM}, {0, 0}},
X--- 147,155 ----
X  #else
X  	    47,
X  #endif
X! 	    D_SHOP, {{100, RANDOM_SYM}, {0, 0}, {0, 0}}, (char **)shkgeneral},
X  	{"used armor dealership", ARMOR_SYM, 14,
X! 	    D_SHOP, {{90, ARMOR_SYM}, {10, WEAPON_SYM}, {0, 0}}, (char **)shkarmors},
X  	{"second hand bookstore", SCROLL_SYM, 10, D_SHOP,
X  #ifdef SPELLS
X  	    {{90, SCROLL_SYM}, {10, SPBOOK_SYM}, {0, 0}},
X***************
X*** 153,178 ****
X  #else
X  	    {{100, SCROLL_SYM}, {0, 0}, {0, 0}},
X  #endif
X! 	    shkbooks},
X  	{"liquor emporium", POTION_SYM, 10, D_SHOP,
X! 	    {{100, POTION_SYM}, {0, 0}, {0, 0}}, shkliquors},
X  	{"antique weapons outlet", WEAPON_SYM, 5, D_SHOP,
X! 	    {{90, WEAPON_SYM}, {10, ARMOR_SYM}, {0, 0}}, shkweapons},
X  	{"delicatessen", FOOD_SYM, 5, D_SHOP,
X! 	    {{95, FOOD_SYM}, {5, POTION_SYM}, {0, 0}}, shkfoods},
X  	{"jewelers", RING_SYM, 3, D_SHOP,
X! 	    {{85, RING_SYM}, {10, GEM_SYM}, {5, AMULET_SYM}, {0, 0}}, shkrings},
X  	{"quality apparel and accessories", WAND_SYM, 3, D_SHOP,
X  	    {{90, WAND_SYM}, {5, -LEATHER_GLOVES}, {5, -ELVEN_CLOAK}, {0, 0}},
X! 	     shkwands},
X  	{"hardware store", TOOL_SYM, 3, D_SHOP,
X! 	    {{100, TOOL_SYM}, {0, 0}, {0, 0}}, shktools},
X  	/* Actually shktools is ignored; the code specifically chooses a
X  	 * random implementor name (the only shop type with random shopkeepers)
X  	 */
X  #ifdef SPELLS
X  	{"rare books", SPBOOK_SYM, 3, D_SHOP,
X! 	    {{90, SPBOOK_SYM}, {10, SCROLL_SYM}, {0, 0}}, shkbooks},
X  #endif
X  	{NULL, 0, 0, 0, {{0, 0}, {0, 0}, {0, 0}}, (char **)0}
X  };
X--- 156,181 ----
X  #else
X  	    {{100, SCROLL_SYM}, {0, 0}, {0, 0}},
X  #endif
X! 	    (char **)shkbooks},
X  	{"liquor emporium", POTION_SYM, 10, D_SHOP,
X! 	    {{100, POTION_SYM}, {0, 0}, {0, 0}}, (char **)shkliquors},
X  	{"antique weapons outlet", WEAPON_SYM, 5, D_SHOP,
X! 	    {{90, WEAPON_SYM}, {10, ARMOR_SYM}, {0, 0}}, (char **)shkweapons},
X  	{"delicatessen", FOOD_SYM, 5, D_SHOP,
X! 	    {{95, FOOD_SYM}, {5, POTION_SYM}, {0, 0}}, (char **)shkfoods},
X  	{"jewelers", RING_SYM, 3, D_SHOP,
X! 	    {{85, RING_SYM}, {10, GEM_SYM}, {5, AMULET_SYM}, {0, 0}}, (char **)shkrings},
X  	{"quality apparel and accessories", WAND_SYM, 3, D_SHOP,
X  	    {{90, WAND_SYM}, {5, -LEATHER_GLOVES}, {5, -ELVEN_CLOAK}, {0, 0}},
X! 	     (char **)shkwands},
X  	{"hardware store", TOOL_SYM, 3, D_SHOP,
X! 	    {{100, TOOL_SYM}, {0, 0}, {0, 0}}, (char **)shktools},
X  	/* Actually shktools is ignored; the code specifically chooses a
X  	 * random implementor name (the only shop type with random shopkeepers)
X  	 */
X  #ifdef SPELLS
X  	{"rare books", SPBOOK_SYM, 3, D_SHOP,
X! 	    {{90, SPBOOK_SYM}, {10, SCROLL_SYM}, {0, 0}}, (char **)shkbooks},
X  #endif
X  	{NULL, 0, 0, 0, {{0, 0}, {0, 0}, {0, 0}}, (char **)0}
X  };
X***************
X*** 191,197 ****
X  				(mtmp=makemon(ptr,sx,sy))) {
X  		mtmp->mimic = 1;
X  		/* note: makemon will set the mimic symbol to a shop item */
X! 		if (rn2(10) >= dlevel) mtmp->mappearance = S_MIMIC_DEF;
X  	} else if ((atype = get_shop_item(shp - shtypes)) < 0)
X  		(void) mksobj_at(-atype, sx, sy);
X  	else (void) mkobj_at(atype, sx, sy);
X--- 194,203 ----
X  				(mtmp=makemon(ptr,sx,sy))) {
X  		mtmp->mimic = 1;
X  		/* note: makemon will set the mimic symbol to a shop item */
X! 		if (rn2(10) >= dlevel) {
X! 			mtmp->m_ap_type = M_AP_OBJECT;
X! 			mtmp->mappearance = STRANGE_OBJECT;
X! 		}
X  	} else if ((atype = get_shop_item(shp - shtypes)) < 0)
X  		(void) mksobj_at(-atype, sx, sy);
X  	else (void) mkobj_at(atype, sx, sy);
X***************
X*** 208,214 ****
X      for(i = 0; i < dlevel; i++)
X  	if (strlen(nlp[i]) == 0) {
X  	    /* Not enough names, try general name */
X! 	    if (nlp != shkgeneral)
X  		findname(nampt, shkgeneral);
X  	    else
X  		Strcpy(nampt, "Dirk");
X--- 214,220 ----
X      for(i = 0; i < dlevel; i++)
X  	if (strlen(nlp[i]) == 0) {
X  	    /* Not enough names, try general name */
X! 	    if (nlp != (char **)shkgeneral)
X  		findname(nampt, shkgeneral);
X  	    else
X  		Strcpy(nampt, "Dirk");
X***************
X*** 278,284 ****
X  	ESHK(shk)->following = 0;
X  	ESHK(shk)->billct = 0;
X  	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
X! 	if (shp->shknms == shktools) {
X  		static int who;
X  		who = rn2(sizeof(shktools)/sizeof(char *) - 1);
X  		if (who==21) ESHK(shk)->ismale = FALSE;
X--- 284,290 ----
X  	ESHK(shk)->following = 0;
X  	ESHK(shk)->billct = 0;
X  	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
X! 	if (shp->shknms == (char **)shktools) {
X  		static int who;
X  		who = rn2(sizeof(shktools)/sizeof(char *) - 1);
X  		if (who==21) ESHK(shk)->ismale = FALSE;
X***************
X*** 296,302 ****
X  void
X  stock_room(shp, sroom)
X  /* stock a newly-created room with artifacts */
X! struct shclass	*shp;
X  register struct mkroom *sroom;
X  {
X      /*
X--- 302,308 ----
X  void
X  stock_room(shp, sroom)
X  /* stock a newly-created room with artifacts */
X! const struct shclass	*shp;
X  register struct mkroom *sroom;
X  {
X      /*
X***************
X*** 306,325 ****
X       * door get artifacts).
X       */
X      register int sx, sy, sh;
X  
X      /* first, try to place a shopkeeper in the room */
X      if ((sh = shkinit(shp, sroom)) < 0)
X  	return;
X  
X!     /* make sure no doorways without doors in shops */
X!     for(sx = sroom->lx - 1; sx <= sroom->hx + 1; sx++)
X! 	for(sy = sroom->ly - 1; sy <= sroom->hy + 1; sy++) {
X! 	    if(IS_DOOR(levl[sx][sy].typ))
X! 		if (levl[sx][sy].doormask == D_NODOOR) {
X! 		  levl[sx][sy].doormask = D_ISOPEN;
X! 		  mnewsym(sx,sy);
X! 		}
X      }
X  
X      for(sx = sroom->lx; sx <= sroom->hx; sx++)
X  	for(sy = sroom->ly; sy <= sroom->hy; sy++) {
X--- 312,347 ----
X       * door get artifacts).
X       */
X      register int sx, sy, sh;
X+     char buf[BUFSZ];
X  
X      /* first, try to place a shopkeeper in the room */
X      if ((sh = shkinit(shp, sroom)) < 0)
X  	return;
X  
X!     /* make sure no doorways without doors, and no */
X!     /* trapped doors, in shops.			   */
X!     sx = doors[sroom->fdoor].x;
X!     sy = doors[sroom->fdoor].y;
X! 
X!     if(levl[sx][sy].doormask == D_NODOOR) {
X! 	    levl[sx][sy].doormask = D_ISOPEN;
X! 	    mnewsym(sx,sy);
X      }
X+     if(levl[sx][sy].doormask & D_TRAPPED) {	
X+ 	    levl[sx][sy].doormask &= ~D_TRAPPED;
X+ 	    levl[sx][sy].doormask = D_LOCKED;
X+     }
X+ 
X+     if(levl[sx][sy].doormask == D_LOCKED) {
X+ 	    register int m = sx, n = sy;
X+ 
X+ 	    if(IS_ROOM(levl[sx+1][sy].typ)) m--;
X+ 	    else if(IS_ROOM(levl[sx-1][sy].typ)) m++;
X+ 	    if(IS_ROOM(levl[sx][sy+1].typ)) n--;
X+ 	    else if(IS_ROOM(levl[sx][sy-1].typ)) n++;
X+ 	    Sprintf(buf, "Closed for inventory"); 
X+ 	    make_engr_at(m, n, buf); 
X+     }
X  
X      for(sx = sroom->lx; sx <= sroom->hx; sx++)
X  	for(sy = sroom->ly; sy <= sroom->hy; sy++) {
X***************
X*** 336,341 ****
X--- 358,366 ----
X       */
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  saleable(nshop, obj)			/* does "shop" stock this item type */
X  register int nshop;
X***************
X*** 359,365 ****
X  get_shop_item(type)
X  int type;
X  {
X! 	struct shclass *shp = shtypes+type;
X  	register int i,j;
X  
X  	/* select an appropriate artifact type at random */
X--- 384,390 ----
X  get_shop_item(type)
X  int type;
X  {
X! 	const struct shclass *shp = shtypes+type;
X  	register int i,j;
X  
X  	/* select an appropriate artifact type at random */
X***************
X*** 368,370 ****
X--- 393,397 ----
X  
X  	return shp->iprobs[i].itype;
X  }
X+ 
X+ #endif /* OVL0 */
X*** src/Old/sit.c	Mon Feb 19 18:59:54 1990
X--- src/sit.c	Mon Jan 15 12:37:51 1990
X***************
X*** 33,39 ****
X  		switch (rnd(13))  {
X  		    case 1:
X  			adjattrib(rn2(A_MAX), -rn1(4,3), FALSE);
X! 			losehp(rnd(10), "cursed throne");
X  			break;
X  		    case 2:
X  			adjattrib(rn2(A_MAX), 1, FALSE);
X--- 33,39 ----
X  		switch (rnd(13))  {
X  		    case 1:
X  			adjattrib(rn2(A_MAX), -rn1(4,3), FALSE);
X! 			losehp(rnd(10), "cursed throne", KILLED_BY_AN);
X  			break;
X  		    case 2:
X  			adjattrib(rn2(A_MAX), 1, FALSE);
X***************
X*** 42,49 ****
X  		pline("A%s charge of electricity shoots through your body!",
X  			      (Shock_resistance) ? "" : " massive");
X  			if(Shock_resistance)
X! 				losehp(rnd(6), "electric chair");
X! 			else	losehp(rnd(30), "electric chair");
X  			break;
X  		    case 4:
X  			You("feel much, much better!");
X--- 42,49 ----
X  		pline("A%s charge of electricity shoots through your body!",
X  			      (Shock_resistance) ? "" : " massive");
X  			if(Shock_resistance)
X! 				losehp(rnd(6), "electric chair", KILLED_BY_AN);
X! 			else	losehp(rnd(30), "electric chair", KILLED_BY_AN);
X  			break;
X  		    case 4:
X  			You("feel much, much better!");
X***************
X*** 78,89 ****
X  		    case 9:
X  			You("hear a voice echo:");
X  	pline("\"A curse upon thee for sitting upon this most holy throne!\"");
X! 			if (u.uluck > 0)  {
X  			    make_blinded(Blinded + rn1(100,250),TRUE);
X  			} else	    rndcurse();
X  			break;
X  		    case 10:
X! 			if (u.uluck < 0 || (HSee_invisible & INTRINSIC))  {
X  				pline("An image forms in your mind.");
X  				do_mapping();
X  			} else  {
X--- 78,89 ----
X  		    case 9:
X  			You("hear a voice echo:");
X  	pline("\"A curse upon thee for sitting upon this most holy throne!\"");
X! 			if (Luck > 0)  {
X  			    make_blinded(Blinded + rn1(100,250),TRUE);
X  			} else	    rndcurse();
X  			break;
X  		    case 10:
X! 			if (Luck < 0 || (HSee_invisible & INTRINSIC))  {
X  				pline("An image forms in your mind.");
X  				do_mapping();
X  			} else  {
X***************
X*** 92,98 ****
X  			}
X  			break;
X  		    case 11:
X! 			if (u.uluck < 0)  {
X  			    You("feel threatened.");
X  			    aggravate();
X  			} else  {
X--- 92,98 ----
X  			}
X  			break;
X  		    case 11:
X! 			if (Luck < 0)  {
X  			    You("feel threatened.");
X  			    aggravate();
X  			} else  {
X***************
X*** 180,186 ****
X  			HFire_resistance &= ~INTRINSIC;
X  			if (Inhell && !Fire_resistance) {
X  			    You("burn to a crisp.");
X! 			    killer = "gremlin curse";
X  			    done(BURNING);
X  			} else You("feel warmer.");
X  			break;
X--- 180,187 ----
X  			HFire_resistance &= ~INTRINSIC;
X  			if (Inhell && !Fire_resistance) {
X  			    You("burn to a crisp.");
X! 			    killer_format = NO_KILLER_PREFIX;
X! 			    killer = self_pronoun("a gremlin stole %s fire resistance in hell", "his");
X  			    done(BURNING);
X  			} else You("feel warmer.");
X  			break;
X*** src/Old/sounds.c	Mon Feb 19 19:00:11 1990
X--- src/sounds.c	Fri Feb 16 22:11:07 1990
X***************
X*** 1,22 ****
X! /*	SCCS Id: @(#)sounds.c	3.0	88/06/19 */
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* Copyright (c) 1989 Janet Walz, Mike Threepoint */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  
X- #define ONAMES_H
X  #include "hack.h"
X  #include "edog.h"
X  
X  void
X  verbalize(str)
X! register char *str;
X  {
X  	if(flags.soundok) pline("\"%s\"", str);
X  }
X  
X  #ifdef SOUNDS
X  
X  void
X  dosounds()
X  {
X--- 1,30 ----
X! /*	SCCS Id: @(#)sounds.c	3.0	90/02/05 */
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* Copyright (c) 1989 Janet Walz, Mike Threepoint */
X  
X+ #define ONAMES_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  
X  #include "hack.h"
X  #include "edog.h"
X  
X+ static int FDECL(domonnoise,(struct monst *));
X+ 
X+ #ifdef OVLB
X+ 
X  void
X  verbalize(str)
X! register const char *str;
X  {
X  	if(flags.soundok) pline("\"%s\"", str);
X  }
X  
X+ #endif /* OVLB */
X+ 
X  #ifdef SOUNDS
X  
X+ #ifdef OVL0
X+ 
X  void
X  dosounds()
X  {
X***************
X*** 24,29 ****
X--- 32,43 ----
X      register struct mkroom *sroom;
X      register xchar roomtype;
X      register int croomno;
X+     boolean gold_in_vault, u_in_room;
X+     register int vx, vy;
X+ 
X+ #ifdef __GNULINT__
X+     gold_in_vault = u_in_room = FALSE;
X+ #endif
X  
X      hallu = Hallucination ? 1 : 0;
X  
X***************
X*** 61,79 ****
X  	for (sroom = &rooms[0]; ; sroom++) {	/* find any special room */
X  	    if (sroom->hx < 0) break;		/* no more rooms */
X  	    if (sroom->rtype != OROOM) {
X  		if (sroom->rtype < SHOPBASE)
X  		    roomtype = sroom->rtype;
X! 		else {
X! 		    croomno = inroom(u.ux,u.uy);
X! 		    if (croomno == -1 || sroom != &rooms[croomno])
X  			/* player not presently in shop */
X! 			/* other special room types disappear when player
X! 			   enters */
X! 			roomtype = SHOPBASE;
X  		}
X  		break;
X  	    }
X  	}
X  	switch (roomtype) {
X  #ifdef THRONES
X  	    case COURT:
X--- 75,104 ----
X  	for (sroom = &rooms[0]; ; sroom++) {	/* find any special room */
X  	    if (sroom->hx < 0) break;		/* no more rooms */
X  	    if (sroom->rtype != OROOM) {
X+ 		croomno = inroom(u.ux,u.uy);
X+ 		u_in_room = croomno >= 0 && sroom == &rooms[croomno];
X  		if (sroom->rtype < SHOPBASE)
X  		    roomtype = sroom->rtype;
X! 		else if (!u_in_room) {
X  			/* player not presently in shop */
X! 			/* NOTE: other special room types disappear when player
X! 			   enters (except VAULT) */
X! 		    roomtype = SHOPBASE;
X  		}
X  		break;
X  	    }
X  	}
X+ 
X+ 	if (roomtype == VAULT) {
X+ 	    gold_in_vault = FALSE;
X+ 	    for (vx = sroom->lx; vx <= sroom->hx && !gold_in_vault; vx++)
X+ 		for (vy = sroom->ly; vy <= sroom->hy; vy++)
X+ 		    if (g_at(vx, vy)) {
X+ 			gold_in_vault = TRUE;
X+ 			break;
X+ 		    }
X+ 	}
X+ 
X  	switch (roomtype) {
X  #ifdef THRONES
X  	    case COURT:
X***************
X*** 108,116 ****
X  		}
X  		break;
X  	    case VAULT:
X! 		switch (rn2(2)+hallu) {
X  		    case 0:
X! 			You("hear someone counting money.");
X  			break;
X  		    case 1:
X  			You("hear the footsteps of a guard on patrol.");
X--- 133,145 ----
X  		}
X  		break;
X  	    case VAULT:
X! 		if(gd_sound())
X! 		  switch (rn2(2)+hallu) {
X  		    case 0:
X! 			if (gold_in_vault && !u_in_room)
X! 			    You("hear someone counting money.");
X! 			else
X! 			    You("hear someone searching.");
X  			break;
X  		    case 1:
X  			You("hear the footsteps of a guard on patrol.");
X***************
X*** 198,203 ****
X--- 227,234 ----
X      }
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X  
X  #include "eshk.h"
X  
X***************
X*** 283,290 ****
X--- 314,345 ----
X  	    break;
X      }
X  }
X+ 
X+ #endif /* OVLB */
X+ 
X  #endif /* SOUNDS */
X  
X+ #ifdef OVLB
X+ 
X+ /* for the connoisseurs ... */
X+ static const char *Qmen[] = {
X+ 	"Max",      /* Born */
X+ 	"Wolfgang", /* Pauli */
X+ 	"Louis",    /* de Broglie */
X+ 	"Erwin",    /* Schroedinger */
X+ 	"Werner",   /* Heisenberg */
X+ 	"Niels",    /* Bohr */
X+ 	"Paul",     /* Dirac */
X+ 	"Pascual",  /* Jordan */
X+ 	"Dick",     /* Feynman */
X+ 	"Sam" }; /* Beckett ("Oh, boy." :-) */
X+ 
X+ struct monst *
X+ qname(mtmp)
X+ struct monst *mtmp;
X+ {
X+ 	return(christen_monst(mtmp, Qmen[rn2(SIZE(Qmen))]));
X+ }
X  
X  static int
X  domonnoise(mtmp)
X***************
X*** 391,397 ****
X  		kludge("%s moans.", Monnam(mtmp));
X  	    else if (mtmp->mconf || mtmp->mstun)
X  		verbalize(!rn2(3) ? "Huh?" : rn2(2) ? "What?" : "Eh?");
X! 	    else if (mtmp->mblinded)
X  		verbalize("I can't see!");
X  	    else if (mtmp->mtrapped)
X  		verbalize("I'm trapped!");
X--- 446,452 ----
X  		kludge("%s moans.", Monnam(mtmp));
X  	    else if (mtmp->mconf || mtmp->mstun)
X  		verbalize(!rn2(3) ? "Huh?" : rn2(2) ? "What?" : "Eh?");
X! 	    else if (!mtmp->mcansee)
X  		verbalize("I can't see!");
X  	    else if (mtmp->mtrapped)
X  		verbalize("I'm trapped!");
X***************
X*** 418,423 ****
X--- 473,492 ----
X  		case PM_ARCHEOLOGIST:
X  kludge("%s describes a recent article in \"Spelunker Today\" magazine.", Monnam(mtmp));
X  		    break;
X+ 		case PM_QUANTUM_MECHANIC:
X+ 		    /* a trademark line for other Quantum Leap cultists -3. */
X+ 		    if (mtmp->mnamelth && strcmp(NAME(mtmp), "Sam") == 0)
X+ 			verbalize("Oh, boy.");
X+ 		    else {
X+ 			const char *Qman;
X+ 
X+ 			do Qman = Qmen[rn2(SIZE(Qmen))];
X+ 			while (mtmp->mnamelth && strcmp(NAME(mtmp), Qman) == 0);
X+ 
X+ 			kludge("%s asks if you've seen %s anywhere around.", 
X+ 				Monnam(mtmp), Qman);
X+ 		    }		    
X+ 		    break;
X  		default:
X  		    kludge("%s discusses dungeon exploration.", Monnam(mtmp));
X  	    }
X***************
X*** 481,492 ****
X  		(void) demon_talk(mtmp);
X  		break;
X  	    }
X  # endif
X- 	case MS_JEER:
X- 	    kludge("%s jeers at you.", Monnam(mtmp));
X- 	    break;
X  	case MS_CUSS:
X! 	    cuss(mtmp);
X  	    break;
X  	case MS_GUARD:
X  	    if (u.ugold)
X--- 550,560 ----
X  		(void) demon_talk(mtmp);
X  		break;
X  	    }
X+ 	    /* fall through */
X  # endif
X  	case MS_CUSS:
X! 	    if (!mtmp->mpeaceful && !mtmp->mtame)
X! 		cuss(mtmp);
X  	    break;
X  	case MS_GUARD:
X  	    if (u.ugold)
X***************
X*** 596,602 ****
X  	pline("I see nobody there.");
X  	return(0);
X      }
X!     if (mtmp->mfroz || mtmp->msleep) {
X  	kludge("%s seems not to notice you.", Monnam(mtmp));
X  	return 0;
X      }
X--- 664,670 ----
X  	pline("I see nobody there.");
X  	return(0);
X      }
X!     if (!mtmp->mcanmove || mtmp->msleep) {
X  	kludge("%s seems not to notice you.", Monnam(mtmp));
X  	return 0;
X      }
X***************
X*** 603,605 ****
X--- 671,675 ----
X  
X      return domonnoise(mtmp);
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/sp_lev.c	Mon Feb 19 19:00:38 1990
X--- src/sp_lev.c	Wed Feb  7 18:38:30 1990
X***************
X*** 14,20 ****
X  #ifdef STRONGHOLD
X  #include "sp_lev.h"
X  
X! #if defined(MSDOS) || defined(MACOS) && !defined(AMIGA)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X--- 14,20 ----
X  #ifdef STRONGHOLD
X  #include "sp_lev.h"
X  
X! #if defined(MACOS) || (defined(MSDOS) && !defined(AMIGA))
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X***************
X*** 470,477 ****
X  		get_location(&x, &y);
X  
X  		typ = tmpaltar.align == -11 ? rn2(3) :
X! 		      tmpaltar.align < 0    ? ralign[-tmpaltar.align-1] :
X! 					      tmpaltar.align;
X  		if (tmpaltar.shrine)
X  		    typ |= A_SHRINE;
X  
X--- 470,477 ----
X  		get_location(&x, &y);
X  
X  		typ = tmpaltar.align == -11 ? rn2(3) :
X! 		      (tmpaltar.align < 0    ? ralign[-tmpaltar.align-1] :
X! 					      tmpaltar.align);
X  		if (tmpaltar.shrine)
X  		    typ |= A_SHRINE;
X  
X***************
X*** 570,576 ****
X  
X  boolean
X  load_special(name)
X! char *name;
X  {
X  	FILE *fd;
X  	boolean result;
X--- 570,576 ----
X  
X  boolean
X  load_special(name)
X! const char *name;
X  {
X  	FILE *fd;
X  	boolean result;
X*** src/Old/spell.c	Mon Feb 19 19:01:01 1990
X--- src/spell.c	Wed Feb  7 18:37:45 1990
X***************
X*** 45,63 ****
X  		if (uarmg) {
X  		    if (uarmg->rustfree)
X  			Your("gloves seem unaffected.");
X! 		    else if (uarmg->spe > -6) {
X  			Your("gloves corrode!");
X  			uarmg->spe--;
X  		    } else
X! 			Your("gloves look quite corroded.");
X  		    break;
X  		}
X  		if(Poison_resistance) {
X  		    losestr(rn1(1,2));
X! 		    losehp(rnd(6), "contact poison");
X  		} else {
X  		    losestr(rn1(4,3));
X! 		    losehp(rnd(10), "contact poison");
X  		}
X  		break;
X  	case 6:
X--- 45,63 ----
X  		if (uarmg) {
X  		    if (uarmg->rustfree)
X  			Your("gloves seem unaffected.");
X! 		    else if (uarmg->spe > -2) {
X  			Your("gloves corrode!");
X  			uarmg->spe--;
X  		    } else
X! 			Your("gloves %s quite corroded.",Blind ? "feel":"look");
X  		    break;
X  		}
X  		if(Poison_resistance) {
X  		    losestr(rn1(1,2));
X! 		    losehp(rnd(6), "contact-poisoned spellbook", KILLED_BY_AN);
X  		} else {
X  		    losestr(rn1(4,3));
X! 		    losehp(rnd(10), "contact-poisoned spellbook", KILLED_BY_AN);
X  		}
X  		break;
X  	case 6:
X***************
X*** 67,73 ****
X  		} else {
X  		    pline("As you read the book, it explodes in your %s!",
X  			body_part(FACE));
X! 		    losehp (2*rnd(10)+5, "exploding rune");
X  		}
X  		break;
X  	default:
X--- 67,73 ----
X  		} else {
X  		    pline("As you read the book, it explodes in your %s!",
X  			body_part(FACE));
X! 		    losehp (2*rnd(10)+5, "exploding rune", KILLED_BY_AN);
X  		}
X  		break;
X  	default:
X***************
X*** 316,322 ****
X  
X  #ifdef HARD
X  	if (confused ||
X! 	    ((int)(ACURR(A_INT) + u.uluck) - 3 * spellev(spell)) < 0) {
X  
X  		if (Hallucination)
X  			pline("Far out... a light show!");
X--- 316,322 ----
X  
X  #ifdef HARD
X  	if (confused ||
X! 	    ((int)(ACURR(A_INT) + Luck) - 3 * spellev(spell)) < 0) {
X  
X  		if (Hallucination)
X  			pline("Far out... a light show!");
X***************
X*** 353,359 ****
X  			else (void) getdir(1);
X  			if(!u.dx && !u.dy && !u.dz) {
X  			    if((damage = zapyourself(pseudo)))
X! 				losehp(damage, "self-inflicted injury");
X  			} else	weffects(pseudo);
X  		} else weffects(pseudo);
X  		break;
X--- 353,361 ----
X  			else (void) getdir(1);
X  			if(!u.dx && !u.dy && !u.dz) {
X  			    if((damage = zapyourself(pseudo)))
X! 				losehp(damage, 
X! 		self_pronoun("zapped %sself with a spell", "him"),
X! 					NO_KILLER_PREFIX);
X  			} else	weffects(pseudo);
X  		} else weffects(pseudo);
X  		break;
X***************
X*** 425,430 ****
X--- 427,433 ----
X  
X  static char
X  spellet(spl)
X+ int spl;
X  {
X  	return (spl < 27) ? ('a' + spl - 1) : ('A' + spl - 27);
X  }
X*** src/Old/steal.c	Mon Feb 19 19:01:28 1990
X--- src/steal.c	Sat Feb 17 20:19:49 1990
X***************
X*** 4,10 ****
X  
X  #include "hack.h"
X  
X! static char *
X  equipname(otmp)
X  
X  	register struct obj *otmp;
X--- 4,12 ----
X  
X  #include "hack.h"
X  
X! #ifdef OVLB
X! 
X! static const char *
X  equipname(otmp)
X  
X  	register struct obj *otmp;
X***************
X*** 42,48 ****
X  		freegold(gold);
X  		if(Invisible) newsym(u.ux, u.uy);
X  		pline("%s quickly snatches some gold from between your %s!",
X! 			Monnam(mtmp), makeplural(body_part(FOOT)));
X  		if(!u.ugold || !rn2(5)) {
X  			rloc(mtmp);
X  			mtmp->mflee = 1;
X--- 44,50 ----
X  		freegold(gold);
X  		if(Invisible) newsym(u.ux, u.uy);
X  		pline("%s quickly snatches some gold from between your %s!",
X! 			Blind ? "It" : Monnam(mtmp), makeplural(body_part(FOOT)));
X  		if(!u.ugold || !rn2(5)) {
X  			rloc(mtmp);
X  			mtmp->mflee = 1;
X***************
X*** 74,80 ****
X  	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	      if(mtmp->m_id == stealmid) {
X  		  freeinv(otmp);
X! 		  pline("%s steals %s!", Monnam(mtmp), doname(otmp));
X  		  mpickobj(mtmp,otmp);
X  		  mtmp->mflee = 1;
X  		  rloc(mtmp);
X--- 76,82 ----
X  	    for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	      if(mtmp->m_id == stealmid) {
X  		  freeinv(otmp);
X! 		  pline("%s steals %s!", Blind ? "It" : Monnam(mtmp), doname(otmp));
X  		  mpickobj(mtmp,otmp);
X  		  mtmp->mflee = 1;
X  		  rloc(mtmp);
X***************
X*** 158,186 ****
X  			break;
X  		case ARMOR_SYM:
X  			/* Stop putting on armor which has been stolen. */
X! 			if (donning(otmp))
X! 			    afternmv = 0;
X! 			if(multi < 0 || otmp == uarms){
X  			  if (otmp == uarm)  (void) Armor_off();
X! 			  else if (otmp == uarmc) (void) Cloak_off();
X  			  else if (otmp == uarmf) (void) Boots_off();
X  			  else if (otmp == uarmg) (void) Gloves_off();
X  			  else if (otmp == uarmh) (void) Helmet_off();
X! 			  else if (otmp == uarms) (void) Shield_off();
X  			  else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X  			  break;
X  			}
X! 		{ int curssv = otmp->cursed;
X  			otmp->cursed = 0;
X  			stop_occupation();
X  			if(flags.female)
X  			    pline("%s charms you.  You gladly %s your %s.",
X! 				  Monnam(mtmp),
X  				  curssv ? "let her take" : "hand over",
X  				  equipname(otmp));
X  			else
X  			    pline("%s seduces you and %s off your %s.",
X! 				  Amonnam(mtmp, Blind ? "gentle" : "beautiful"),
X  				  curssv ? "helps you to take" : "you start taking",
X  				  equipname(otmp));
X  			named++;
X--- 160,187 ----
X  			break;
X  		case ARMOR_SYM:
X  			/* Stop putting on armor which has been stolen. */
X! 			if (donning(otmp)) {
X! 			  cancel_don();
X  			  if (otmp == uarm)  (void) Armor_off();
X! 			  /* else if (otmp == uarmc) (void) Cloak_off(); */
X  			  else if (otmp == uarmf) (void) Boots_off();
X  			  else if (otmp == uarmg) (void) Gloves_off();
X  			  else if (otmp == uarmh) (void) Helmet_off();
X! 			  /* else if (otmp == uarms) (void) Shield_off(); */
X  			  else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X  			  break;
X  			}
X! 		    { int curssv = otmp->cursed;
X  			otmp->cursed = 0;
X  			stop_occupation();
X  			if(flags.female)
X  			    pline("%s charms you.  You gladly %s your %s.",
X! 				  Blind ? "She" : Monnam(mtmp),
X  				  curssv ? "let her take" : "hand over",
X  				  equipname(otmp));
X  			else
X  			    pline("%s seduces you and %s off your %s.",
X! 				  Blind ? "It" : Amonnam(mtmp, "beautiful"),
X  				  curssv ? "helps you to take" : "you start taking",
X  				  equipname(otmp));
X  			named++;
X***************
X*** 207,213 ****
X  				return(0);
X  			}
X  			break;
X! 		}
X  		default:
X  			impossible("Tried to steal a strange worn thing.");
X  		}
X--- 208,214 ----
X  				return(0);
X  			}
X  			break;
X! 		    }
X  		default:
X  			impossible("Tried to steal a strange worn thing.");
X  		}
X***************
X*** 217,227 ****
X  	if(otmp == uball) unpunish();
X  
X  	freeinv(otmp);
X! 	pline("%s stole %s.", named ? "She" : Monnam(mtmp), doname(otmp));
X  	mpickobj(mtmp,otmp);
X  	if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X  	    && !resists_ston(mtmp->data)) {
X! 	    pline("%s turns to stone.", Monnam(mtmp));
X  	    stoned = TRUE;
X  	    xkilled(mtmp, 0);
X  	    return -1;
X--- 218,228 ----
X  	if(otmp == uball) unpunish();
X  
X  	freeinv(otmp);
X! 	pline("%s stole %s.", named ? "She" : (Blind ? "It" : Monnam(mtmp)), doname(otmp));
X  	mpickobj(mtmp,otmp);
X  	if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X  	    && !resists_ston(mtmp->data)) {
X! 	    pline("%s turns to stone.", Blind ? "It" : Monnam(mtmp));
X  	    stoned = TRUE;
X  	    xkilled(mtmp, 0);
X  	    return -1;
X***************
X*** 229,234 ****
X--- 230,238 ----
X  	return((multi < 0) ? 0 : 1);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  mpickobj(mtmp,otmp)
X  register struct monst *mtmp;
X***************
X*** 238,243 ****
X--- 242,250 ----
X  	mtmp->minvent = otmp;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  stealamulet(mtmp)
X  register struct monst *mtmp;
X***************
X*** 250,256 ****
X  		setnotworn(otmp);
X  		freeinv(otmp);
X  		mpickobj(mtmp,otmp);
X! 		pline("%s stole %s!", Monnam(mtmp), doname(otmp));
X  		rloc(mtmp);
X  		return;
X  	    }
X--- 257,263 ----
X  		setnotworn(otmp);
X  		freeinv(otmp);
X  		mpickobj(mtmp,otmp);
X! 		pline("%s stole %s!", Blind ? "It":Monnam(mtmp), doname(otmp));
X  		rloc(mtmp);
X  		return;
X  	    }
X***************
X*** 257,262 ****
X--- 264,272 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /* release the objects the killed animal has stolen */
X  void
X  relobj(mtmp,show)
X***************
X*** 266,275 ****
X  	register struct obj *otmp, *otmp2;
X  
X  	for(otmp = mtmp->minvent; otmp; otmp = otmp2){
X- 		place_object(otmp, mtmp->mx, mtmp->my);
X  		otmp2 = otmp->nobj;
X- 		otmp->nobj = fobj;
X  		if (flooreffects(otmp,mtmp->mx,mtmp->my)) continue;
X  		fobj = otmp;
X  		stackobj(fobj);
X  		if(show & cansee(mtmp->mx,mtmp->my))
X--- 276,285 ----
X  	register struct obj *otmp, *otmp2;
X  
X  	for(otmp = mtmp->minvent; otmp; otmp = otmp2){
X  		otmp2 = otmp->nobj;
X  		if (flooreffects(otmp,mtmp->mx,mtmp->my)) continue;
X+ 		place_object(otmp, mtmp->mx, mtmp->my);
X+ 		otmp->nobj = fobj;
X  		fobj = otmp;
X  		stackobj(fobj);
X  		if(show & cansee(mtmp->mx,mtmp->my))
X***************
X*** 285,287 ****
X--- 295,299 ----
X  			atl(mtmp->mx,mtmp->my, Hallucination ? rndobjsym() : GOLD_SYM);
X  	}
X  }
X+ 
X+ #endif /* OVL0 */
X*** src/Old/termcap.c	Mon Feb 19 19:01:50 1990
X--- src/termcap.c	Fri Feb 16 22:11:10 1990
X***************
X*** 2,9 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include "hack.h"	/* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X  
X  #include <ctype.h>	/* for isdigit() */
X--- 2,9 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"	/* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X  
X  #include <ctype.h>	/* for isdigit() */
X***************
X*** 10,16 ****
X  
X  #include "termcap.h"
X  
X! #if !defined(SYSV) || defined(TOS) || defined(UNIXPC)
X  # ifndef LINT
X  extern			/* it is defined in libtermlib (libtermcap) */
X  # endif
X--- 10,16 ----
X  
X  #include "termcap.h"
X  
X! #if (!defined(SYSV) && !defined(HPUX)) || defined(TOS) || defined(UNIXPC)
X  # ifndef LINT
X  extern			/* it is defined in libtermlib (libtermcap) */
X  # endif
X***************
X*** 20,26 ****
X  #endif
X  
X  #ifdef ASCIIGRAPH
X!   boolean IBMgraphics = FALSE;
X  #endif
X  
X  
X--- 20,32 ----
X  #endif
X  
X  #ifdef ASCIIGRAPH
X! 
X! #ifdef OVLB
X! 
X! boolean IBMgraphics = FALSE;
X! 
X! #endif /* OVLB */
X! 
X  #endif
X  
X  
X***************
X*** 30,60 ****
X  #define Tgetstr(key) (tgetstr(key,&tbufptr))
X  #endif /* MICROPORT_286_BUG **/
X  
X! static void nocmov();
X  #ifdef TEXTCOLOR
X  # ifdef TERMLIB
X! static void init_hilite();
X  # endif
X  #endif
X  
X! static char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X! static char *VS, *VE, *US, *UE;
X! static char *MR, *ME;
X  #if 0
X! static char *MB, *MH;
X! static char *MD;	/* may already be in use below */
X  #endif
X  #ifdef TERMLIB
X  # ifdef TEXTCOLOR
X! static char *MD;
X  # endif
X! static int SG;
X! static char PC = '\0';
X! static char tbuf[512];
X! #endif
X  
X  #ifndef TERMLIB
X! static char tgotobuf[20];
X  # ifdef TOS
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+' ', x+' '), tgotobuf)
X  # else
X--- 36,74 ----
X  #define Tgetstr(key) (tgetstr(key,&tbufptr))
X  #endif /* MICROPORT_286_BUG **/
X  
X! OSTATIC void FDECL(nocmov, (int, int));
X  #ifdef TEXTCOLOR
X  # ifdef TERMLIB
X! static void NDECL(init_hilite);
X  # endif
X  #endif
X  
X! VSTATIC char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X! VSTATIC char *VS, *VE, *US, *UE;
X! VSTATIC char *MR, *ME;
X  #if 0
X! VSTATIC char *MB, *MH;
X! VSTATIC char *MD;     /* may already be in use below */
X  #endif
X  #ifdef TERMLIB
X  # ifdef TEXTCOLOR
X! VSTATIC char *MD;
X  # endif
X! VSTATIC int SG;
X! #ifdef OVLB
X! XSTATIC char PC = '\0';
X! #else /* OVLB */
X! OSTATIC char PC;
X! #endif /* OVLB */
X! VSTATIC char tbuf[512];
X! #endif
X! 
X! #ifdef OVLB
X! static char nullstr[] = "";
X! #endif /* OVLB */
X  
X  #ifndef TERMLIB
X! VSTATIC char tgotobuf[20];
X  # ifdef TOS
X  #define tgoto(fmt, x, y)	(Sprintf(tgotobuf, fmt, y+' ', x+' '), tgotobuf)
X  # else
X***************
X*** 62,72 ****
X  # endif
X  #endif /* TERMLIB */
X  
X  void
X  startup()
X  {
X  #ifdef TERMLIB
X! 	register char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  #endif
X--- 76,88 ----
X  # endif
X  #endif /* TERMLIB */
X  
X+ #ifdef OVLB
X+ 
X  void
X  startup()
X  {
X  #ifdef TERMLIB
X! 	register const char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  #endif
X***************
X*** 122,127 ****
X--- 138,145 ----
X  	    showsyms[S_room] = 0xfa;	/* meta-z, centered dot */
X  	    showsyms[S_ndoor] = 0xfa;
X  	    showsyms[S_pool] = 0xf7;	/* meta-w, approx. equals */
X+ 	    showsyms[S_hodoor] = 0xfe;	/* meta-~, small centered square */
X+ 	    showsyms[S_vodoor] = 0xfe;
X  	}
X  #endif /* ASCIIGRAPH */
X  
X***************
X*** 328,339 ****
X  	US = Tgetstr("us");
X  	UE = Tgetstr("ue");
X  	SG = tgetnum("sg");	/* -1: not fnd; else # of spaces left by so */
X! 	if(!SO || !SE || (SG > 0)) SO = SE = US = UE = "";
X  	TI = Tgetstr("ti");
X  	TE = Tgetstr("te");
X! 	VS = VE = "";
X  # ifdef TERMINFO
X! 	VS = Tgetstr("enacs");	/* graphics start */
X  # endif
X  # if 0
X  	MB = Tgetstr("mb");	/* blink */
X--- 346,357 ----
X  	US = Tgetstr("us");
X  	UE = Tgetstr("ue");
X  	SG = tgetnum("sg");	/* -1: not fnd; else # of spaces left by so */
X! 	if(!SO || !SE || (SG > 0)) SO = SE = US = UE = nullstr;
X  	TI = Tgetstr("ti");
X  	TE = Tgetstr("te");
X! 	VS = VE = nullstr;
X  # ifdef TERMINFO
X! 	VS = Tgetstr("eA");	/* enable graphics */
X  # endif
X  # if 0
X  	MB = Tgetstr("mb");	/* blink */
X***************
X*** 419,425 ****
X  register int x, y;	/* not xchar: perhaps xchar is unsigned and
X  			   curx-x would be unsigned as well */
X  {
X- 
X  	if (y == cury && x == curx)
X  		return;
X  	if(!ND && (curx != x || x <= 3)) {	/* Extremely primitive */
X--- 437,442 ----
X***************
X*** 438,445 ****
X  		cmov(x, y);
X  }
X  
X! static void
X  nocmov(x, y)
X  {
X  	if (cury > y) {
X  		if(UP) {
X--- 455,466 ----
X  		cmov(x, y);
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL0
X! 
X! XSTATIC void
X  nocmov(x, y)
X+ int x,y;
X  {
X  	if (cury > y) {
X  		if(UP) {
X***************
X*** 510,516 ****
X  
X  void
X  xputs(s)
X! char *s;
X  {
X  #ifndef MACOS
X  # ifndef TERMLIB
X--- 531,537 ----
X  
X  void
X  xputs(s)
X! const char *s;
X  {
X  #ifndef MACOS
X  # ifndef TERMLIB
X***************
X*** 544,549 ****
X--- 565,573 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  clear_screen() {
X  	xputs(CL);
X***************
X*** 550,555 ****
X--- 574,582 ----
X  	home();
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  home()
X  {
X***************
X*** 633,638 ****
X--- 660,668 ----
X  }
X  #endif
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  #if !defined(MSDOS) && !defined(MACOS)
X  # ifdef VMS
X  static const short tmspc10[] = {		/* from termcap */
X***************
X*** 668,674 ****
X--- 698,708 ----
X  		tputs("$<50>", 1, xputc);
X  #  endif
X  # else
X+ #  ifdef __STDC__
X+ 		tputs("50", 1, (int (*)())xputc);
X+ #  else
X  		tputs("50", 1, xputc);
X+ #  endif
X  # endif
X  
X  	else if(ospeed > 0 && ospeed < SIZE(tmspc10)) if(CM) {
X***************
X*** 684,689 ****
X--- 718,726 ----
X  #endif /* MSDOS || MACOS */
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  cl_eos()			/* free after Robert Viduya */
X  {				/* must only be called with curx = 1 */
X***************
X*** 762,781 ****
X  static void
X  init_hilite()
X  {
X  	int backg = BLACK, foreg = WHITE, len;
X  	register int c, color;
X  
X  	for (c = 0; c < SIZE(hilites); c++)
X  		hilites[c] = HI;
X  
X  #  ifdef TOS
X! 	hilites[RED] = hilites[BRIGHT+RED] = "\033b1";
X! 	hilites[BLUE] = hilites[BRIGHT+BLUE] = "\033b2";
X! 	hilites[CYAN] = hilites[BRIGHT+CYAN] = "\033b3\033c2";
X! 	hilites[ORANGE_COLORED] = hilites[RED];
X! 	hilites[WHITE] = hilites[GRAY] = "\033b3";
X! 	hilites[MAGENTA] = hilites[BRIGHT+MAGENTA] = "\033b1\033c2";
X! 	HE = "\033q\033b3\033c0";	/* to turn off the color stuff too */
X  #  else /* TOS */
X  	/* find the background color, HI[len] == 'm' */
X  	len = strlen(HI) - 1;
X--- 799,827 ----
X  static void
X  init_hilite()
X  {
X+ #  ifdef TOS
X+ 	int c;
X+ 	static char unhilite[] = "\033q\033b3\033c0";
X+ #  else
X  	int backg = BLACK, foreg = WHITE, len;
X  	register int c, color;
X+ #  endif
X  
X  	for (c = 0; c < SIZE(hilites); c++)
X  		hilites[c] = HI;
X  
X  #  ifdef TOS
X! 	hilites[BROWN] = "\033b0\033c1";
X! 	hilites[RED] = "\033b1";
X! 	hilites[MAGENTA] = hilites[MAGENTA|BRIGHT] = "\033b1\033c2";
X! 	hilites[CYAN] = hilites[CYAN|BRIGHT] = "\033b3\033c2";
X! 	hilites[BLUE] = hilites[BLUE|BRIGHT] = "\033b2";
X! 	hilites[GREEN] = hilites[GREEN|BRIGHT] = "\033b2\033c3";
X! 	hilites[GRAY] = "\033b3\033c0";
X! 	hilites[ORANGE_COLORED] = "\033b3\033c1";
X! 	hilites[YELLOW] = "\033b1\033c3";
X! 	hilites[WHITE] = "\033b0\033c3";
X! 	HE = unhilite;	/* to turn off the color stuff too */
X  #  else /* TOS */
X  	/* find the background color, HI[len] == 'm' */
X  	len = strlen(HI) - 1;
X***************
X*** 817,819 ****
X--- 863,867 ----
X  }
X  # endif /* UNIX */
X  #endif /* TEXTCOLOR */
X+ 
X+ #endif /* OVLB */
X
END_OF_FILE
if test 55436 -ne `wc -c <'patch7.08'`; then
    echo shar: \"'patch7.08'\" unpacked with wrong size!
fi
# end of 'patch7.08'
echo shar: End of archive 11 \(of 30\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
