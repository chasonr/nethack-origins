Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!brutus.cs.uiuc.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i013:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7m
Message-ID: <5227@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:56:09 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2114
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 13
Archive-name: NetHack3/Patch7m
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 30)."
# Contents:  patch7.09
# Wrapped by billr@saab on Wed Feb 21 10:04:34 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.09' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.09'\" to \"'patch7.09.orig'\"
  mv -f 'patch7.09' 'patch7.09.orig'
fi
echo shar: Extracting \"'patch7.09'\" \(54742 characters\)
sed "s/^X//" >'patch7.09' <<'END_OF_FILE'
X*** src/Old/u_init.c	Mon Feb 19 19:05:03 1990
X--- src/u_init.c	Fri Feb 16 18:59:15 1990
X***************
X*** 14,25 ****
X  };
X  
X  static void FDECL(ini_inv, (struct trobj *));
X  
X  #define	UNDEF_TYP	0
X  #define	UNDEF_SPE	'\177'
X  #define	UNDEF_BLESS	2
X  
X! char *(roles[]) = {	/* must all have distinct first letter */
X  			/* roles[2] and [6] are changed for females */
X  			/* in all cases, the corresponding male and female */
X  			/* roles must start with the same letter */
X--- 14,27 ----
X  };
X  
X  static void FDECL(ini_inv, (struct trobj *));
X+ static void FDECL(knows_class,(CHAR_P));
X+ static int FDECL(role_index,(CHAR_P));
X  
X  #define	UNDEF_TYP	0
X  #define	UNDEF_SPE	'\177'
X  #define	UNDEF_BLESS	2
X  
X! const char *(roles[]) = {	/* must all have distinct first letter */
X  			/* roles[2] and [6] are changed for females */
X  			/* in all cases, the corresponding male and female */
X  			/* roles must start with the same letter */
X***************
X*** 235,241 ****
X  role_index(pc)
X  char pc;
X  {
X! 	register char *cp;
X  
X  	if(cp = index(pl_classes, pc))
X  		return(cp - pl_classes);
X--- 237,243 ----
X  role_index(pc)
X  char pc;
X  {
X! 	register const char *cp;
X  
X  	if(cp = index(pl_classes, pc))
X  		return(cp - pl_classes);
X***************
X*** 247,254 ****
X  {
X  	register int i;
X  	char pick, pc;
X! 
X! 	Printf("\nNetHack, Copyright 1985, 1986, 1987, 1988, 1989.");
X  	Printf("\n         By Stichting Mathematisch Centrum and M. Stephenson.");
X  	Printf("\n         See license for details.\n\n");
X  
X--- 249,258 ----
X  {
X  	register int i;
X  	char pick, pc;
X! #ifdef __GNULINT__
X! 	pick = i = 0;	/* prevent "used before set" warnings */
X! #endif
X! 	Printf("\nNetHack, Copyright 1985, 1986, 1987, 1988, 1989, 1990.");
X  	Printf("\n         By Stichting Mathematisch Centrum and M. Stephenson.");
X  	Printf("\n         See license for details.\n\n");
X  
X***************
X*** 265,270 ****
X--- 269,276 ----
X  		pl_character[0] = pc = 0;
X  	}
X  
X+ #ifndef MACOS
X+ 
X  	Printf("\nShall I pick a character for you? [Y,N, or Q(quit)] ");
X  
X  	while(!index("yYnNqQ", (pick = readchar())) && !index(quitchars, pick))
X***************
X*** 314,319 ****
X--- 320,329 ----
X  	}
X  	if(pc == '\n')	pc = 0;
X  
X+ #else
X+ 	flags.wantspace = FALSE;
X+ #endif /* MACOS */
X+ 
X  beginner:
X  	if(!pc) {
X  		i = rn2(SIZE(roles));
X***************
X*** 337,343 ****
X  
X  	u.ulevel = 0;	/* set up some of the initial attributes */
X  	u.uhp = u.uhpmax = newhp();
X! 	adjabil(1);
X  	u.ulevel = 1;
X  
X  	u.uluck  = u.moreluck = 0;
X--- 347,353 ----
X  
X  	u.ulevel = 0;	/* set up some of the initial attributes */
X  	u.uhp = u.uhpmax = newhp();
X! 	adjabil(0,1);
X  	u.ulevel = 1;
X  
X  	u.uluck  = u.moreluck = 0;
X***************
X*** 469,479 ****
X  	case 'S':
X  		ini_inv(Samurai);
X  		if(!rn2(5)) ini_inv(Blindfold);
X- 		objects[SHORT_SWORD].oc_name = "wakizashi";
X- 		objects[BROADSWORD].oc_name = "ninja-to";
X- 		objects[GLAIVE].oc_name = "naginata";
X- 		/* objects[BOW].oc_name = "yumi"; */
X- 		objects[LOCK_PICK].oc_name = "osaku";
X  		knows_class(WEAPON_SYM);
X  		break;
X  	case 'P':
X--- 479,484 ----
X*** src/Old/uhitm.c	Mon Feb 19 19:05:35 1990
X--- src/uhitm.c	Sun Feb  4 09:46:50 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)uhitm.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)uhitm.c	3.0	89/11/27
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 11,16 ****
X--- 11,17 ----
X  #ifdef POLYSELF
X  static boolean hmonas();
X  #endif
X+ static void nohandglow();
X  
X  #ifdef WORM
X  extern boolean notonhead;
X***************
X*** 77,85 ****
X--- 78,93 ----
X  	    && !Hallucination && (!mtmp->mhide || !mtmp->mundetected)
X  	    && (!mtmp->mimic || Protection_from_shape_changers)) {
X  		if (Blind ? Telepat : (!mtmp->minvis || See_invisible)) {
X+ #ifdef MACOS
X+ 			char mac_tbuf[80];
X+ 			if(!flags.silent) SysBeep(1);
X+ 			sprintf(mac_tbuf, "Really attack %s?", mon_nam(mtmp));
X+ 			if(UseMacAlertText(128, mac_tbuf) != 1) {
X+ #else
X  			pline("Really attack %s? ", mon_nam(mtmp));
X  			(void) fflush(stdout);
X  			if (yn() != 'y') {
X+ #endif
X  				flags.move = 0;
X  				return(TRUE);
X  			}
X***************
X*** 126,132 ****
X  #endif
X  /*	it is unchivalrous to attack the defenseless or from behind */
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL &&
X! 	    (mtmp->mfroz || mtmp->msleep || mtmp->mflee) &&
X  	    u.ualign > -10) adjalign(-1);
X  
X  /*	Adjust vs. (and possibly modify) monster state.		*/
X--- 134,140 ----
X  #endif
X  /*	it is unchivalrous to attack the defenseless or from behind */
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL &&
X! 	    (!mtmp->mcanmove || mtmp->msleep || mtmp->mflee) &&
X  	    u.ualign > -10) adjalign(-1);
X  
X  /*	Adjust vs. (and possibly modify) monster state.		*/
X***************
X*** 138,146 ****
X  		mtmp->msleep = 0;
X  		tmp += 2;
X  	}
X! 	if(mtmp->mfroz) {
X  		tmp += 4;
X! 		if(!rn2(10)) mtmp->mfroz = 0;
X  	}
X  	if (is_orc(mtmp->data) && pl_character[0]=='E') tmp++;
X  
X--- 146,157 ----
X  		mtmp->msleep = 0;
X  		tmp += 2;
X  	}
X! 	if(!mtmp->mcanmove) {
X  		tmp += 4;
X! 		if(!rn2(10)) {
X! 			mtmp->mcanmove = 1;
X! 			mtmp->mfrozen = 0;
X! 		}
X  	}
X  	if (is_orc(mtmp->data) && pl_character[0]=='E') tmp++;
X  
X***************
X*** 184,190 ****
X  	/* andrew@orca: prevent unlimited pick-axe attacks */
X  	u_wipe_engr(3);
X  
X! 	if(mdat->mlet == S_LEPRECHAUN && !mtmp->mfroz && !mtmp->msleep &&
X  	   !mtmp->mconf && mtmp->mcansee && !rn2(7) &&
X  	   (m_move(mtmp, 0) == 2 ||			    /* he died */
X  	   mtmp->mx != u.ux+u.dx || mtmp->my != u.uy+u.dy)) /* he moved */
X--- 195,201 ----
X  	/* andrew@orca: prevent unlimited pick-axe attacks */
X  	u_wipe_engr(3);
X  
X! 	if(mdat->mlet == S_LEPRECHAUN && mtmp->mfrozen && !mtmp->msleep &&
X  	   !mtmp->mconf && mtmp->mcansee && !rn2(7) &&
X  	   (m_move(mtmp, 0) == 2 ||			    /* he died */
X  	   mtmp->mx != u.ux+u.dx || mtmp->my != u.uy+u.dy)) /* he moved */
X***************
X*** 196,203 ****
X  	 * cinating.
X  	 */
X  	/*  changes by wwp 5/16/85 */
X! 	if (!Blind && !Confusion && !Hallucination && flags.safe_dog &&
X! 	    (mdat->mlet == S_DOG || mdat->mlet == S_FELINE) && mtmp->mtame) {
X  		mtmp->mflee = 1;
X  		mtmp->mfleetim = rnd(6);
X  		if (mtmp->mnamelth)
X--- 207,215 ----
X  	 * cinating.
X  	 */
X  	/*  changes by wwp 5/16/85 */
X! 	if (!Confusion && !Hallucination && flags.safe_dog &&
X! 	    (Blind ? Telepat : (!mtmp->minvis || See_invisible)) &&
X! 								mtmp->mtame) {
X  		mtmp->mflee = 1;
X  		mtmp->mfleetim = rnd(6);
X  		if (mtmp->mnamelth)
X***************
X*** 245,251 ****
X  	if(!mhit) {
X  	    if(!Blind && flags.verbose) You("miss %s.", mon_nam(mon));
X  	    else			You("miss it.");
X! 	    if(!mon->msleep && !mon->mfroz)
X  		wakeup(mon);
X  	} else {
X  	    /* we hit the monster; be careful: it might die! */
X--- 257,263 ----
X  	if(!mhit) {
X  	    if(!Blind && flags.verbose) You("miss %s.", mon_nam(mon));
X  	    else			You("miss it.");
X! 	    if(!mon->msleep && mon->mcanmove)
X  		wakeup(mon);
X  	} else {
X  	    /* we hit the monster; be careful: it might die! */
X***************
X*** 299,304 ****
X--- 311,317 ----
X  register int thrown;
X  {
X  	register int tmp;
X+ 	struct permonst *mdat = mon->data;
X  	/* Why all these booleans?  This stuff has to be done in the
X  	 *      following order:
X  	 * 1) Know what we're attacking with, and print special hittxt for
X***************
X*** 313,319 ****
X--- 326,334 ----
X  	 *	kill poison
X  	 * 5) Print hit message (depends on 1 and 4)
X  	 * 6a) Print poison message (must be done after 5)
X+ #if 0
X  	 * 6b) Rust weapon (must be done after 5)
X+ #endif
X  	 * 7) Possibly kill monster (must be done after 6a, 6b)
X  	 * 8) Instant-kill from poison (can happen anywhere between 5 and 9)
X  	 * 9) Hands not glowing (must be done after 7 and 8)
X***************
X*** 330,336 ****
X  	wakeup(mon);
X  	if(!obj) {
X  	    tmp = rnd(2);	/* attack with bare hands */
X! 	    if(mon->data == &mons[PM_COCKATRICE] && !uarmg
X  #ifdef POLYSELF
X  		&& !resists_ston(uasmon)
X  #endif
X--- 345,352 ----
X  	wakeup(mon);
X  	if(!obj) {
X  	    tmp = rnd(2);	/* attack with bare hands */
X! #if 0
X! 	    if(mdat == &mons[PM_COCKATRICE] && !uarmg
X  #ifdef POLYSELF
X  		&& !resists_ston(uasmon)
X  #endif
X***************
X*** 342,359 ****
X  		done_in_by(mon);
X  		hittxt = TRUE; /* maybe lifesaved */
X  	    }
X  	} else {
X  	    if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X  	       obj->otyp == UNICORN_HORN || obj->olet == ROCK_SYM) {
X  
X! 		if(obj == uwep && (obj->otyp > VOULGE || obj->otyp < BOOMERANG)
X  			&& obj->otyp != PICK_AXE && obj->otyp != UNICORN_HORN)
X  		    tmp = rnd(2);
X  		else {
X! 		    tmp = dmgval(obj, mon->data);
X  #ifdef NAMED_ITEMS
X! 		    if(spec_ability(obj, SPFX_DRLI) &&
X! 						!resists_drli(mon->data)) {
X  			if (!Blind) {
X  			    pline("The %s blade draws the life from %s!",
X  				Hallucination ? hcolor() : black,
X--- 358,375 ----
X  		done_in_by(mon);
X  		hittxt = TRUE; /* maybe lifesaved */
X  	    }
X+ #endif
X  	} else {
X  	    if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X  	       obj->otyp == UNICORN_HORN || obj->olet == ROCK_SYM) {
X  
X! 		if(obj == uwep && (obj->otyp >= BOW || obj->otyp < BOOMERANG)
X  			&& obj->otyp != PICK_AXE && obj->otyp != UNICORN_HORN)
X  		    tmp = rnd(2);
X  		else {
X! 		    tmp = dmgval(obj, mdat);
X  #ifdef NAMED_ITEMS
X! 		    if(spec_ability(obj, SPFX_DRLI) && !resists_drli(mdat)) {
X  			if (!Blind) {
X  			    pline("The %s blade draws the life from %s!",
X  				Hallucination ? hcolor() : black,
X***************
X*** 385,393 ****
X  			    ispoisoned = TRUE;
X  		    }
X  		    if(thrown && obj->otyp == SILVER_ARROW) {
X! 			if (is_were(mon->data) || mon->data->mlet==S_VAMPIRE
X! 			    || (mon->data->mlet==S_IMP && mon->data != &mons[PM_TENGU])
X! 			    || is_demon(mon->data)) {
X  				silvermsg = TRUE;
X  				tmp += rnd(20);
X  			}
X--- 401,409 ----
X  			    ispoisoned = TRUE;
X  		    }
X  		    if(thrown && obj->otyp == SILVER_ARROW) {
X! 			if (is_were(mdat) || mdat->mlet==S_VAMPIRE
X! 			    || (mdat->mlet==S_IMP && mdat != &mons[PM_TENGU])
X! 			    || is_demon(mdat)) {
X  				silvermsg = TRUE;
X  				tmp += rnd(20);
X  			}
X***************
X*** 410,416 ****
X  			You("break your mirror.  That's bad luck!");
X  			change_luck(-2);
X  			useup(obj);
X! 			return(TRUE);
X  #endif
X  		case EXPENSIVE_CAMERA:
X  	You("succeed in destroying your camera.  Congratulations!");
X--- 426,433 ----
X  			You("break your mirror.  That's bad luck!");
X  			change_luck(-2);
X  			useup(obj);
X! 			hittxt = TRUE;
X! 			tmp = 1;
X  #endif
X  		case EXPENSIVE_CAMERA:
X  	You("succeed in destroying your camera.  Congratulations!");
X***************
X*** 420,426 ****
X  			if(obj->corpsenm == PM_COCKATRICE) {
X  			    kludge("You hit %s with the cockatrice corpse.",
X  				  mon_nam(mon));
X! 			    if(resists_ston(mon->data)) {
X  				tmp = 1;
X  				hittxt = TRUE;
X  				break;
X--- 437,443 ----
X  			if(obj->corpsenm == PM_COCKATRICE) {
X  			    kludge("You hit %s with the cockatrice corpse.",
X  				  mon_nam(mon));
X! 			    if(resists_ston(mdat)) {
X  				tmp = 1;
X  				hittxt = TRUE;
X  				break;
X***************
X*** 428,433 ****
X--- 445,451 ----
X  			    kludge("%s turns to stone.", Monnam(mon));
X  			    stoned = TRUE;
X  			    xkilled(mon,0);
X+ 			    nohandglow();
X  			    return(FALSE);
X  			}
X  			tmp = mons[obj->corpsenm].msize + 1;
X***************
X*** 435,441 ****
X  		case EGG: /* only possible if hand-to-hand */
X  			if(obj->corpsenm > -1
X  					&& obj->corpsenm != PM_COCKATRICE
X! 					&& mon->data==&mons[PM_COCKATRICE]) {
X  				kludge("You hit %s with the %s egg%s.",
X  					mon_nam(mon),
X  					mons[obj->corpsenm].mname,
X--- 453,459 ----
X  		case EGG: /* only possible if hand-to-hand */
X  			if(obj->corpsenm > -1
X  					&& obj->corpsenm != PM_COCKATRICE
X! 					&& mdat == &mons[PM_COCKATRICE]) {
X  				kludge("You hit %s with the %s egg%s.",
X  					mon_nam(mon),
X  					mons[obj->corpsenm].mname,
X***************
X*** 451,457 ****
X  			tmp = 1;
X  			break;
X  		case CLOVE_OF_GARLIC:		/* no effect against demons */
X! 			if(is_undead(mon->data)) mon->mflee = 1;
X  			tmp = 1;
X  			break;
X  		case CREAM_PIE:
X--- 469,475 ----
X  			tmp = 1;
X  			break;
X  		case CLOVE_OF_GARLIC:		/* no effect against demons */
X! 			if(is_undead(mdat)) mon->mflee = 1;
X  			tmp = 1;
X  			break;
X  		case CREAM_PIE:
X***************
X*** 468,475 ****
X  			else
X  			    pline("The cream pie splashes over %s%s!",
X  				mon_nam(mon),
X! 				(haseyes(mon->data) &&
X! 					mon->data != &mons[PM_FLOATING_EYE])
X  				? "'s face" : "");
X  			if(mon->msleep) mon->msleep = 0;
X  			setmangry(mon);
X--- 486,493 ----
X  			else
X  			    pline("The cream pie splashes over %s%s!",
X  				mon_nam(mon),
X! 				(haseyes(mdat) &&
X! 				    mdat != &mons[PM_FLOATING_EYE])
X  				? "'s face" : "");
X  			if(mon->msleep) mon->msleep = 0;
X  			setmangry(mon);
X***************
X*** 483,495 ****
X  			break;
X  #ifdef POLYSELF
X  		case ACID_VENOM: /* only possible if thrown */
X! 			if(resists_acid(mon->data)) {
X  				kludge("Your venom hits %s harmlessly.",
X  					mon_nam(mon));
X  				tmp = 0;
X  			} else {
X  				kludge("Your venom burns %s!", mon_nam(mon));
X! 				tmp = dmgval(obj, mon->data);
X  			}
X  			hittxt = TRUE;
X  			get_dmg_bonus = FALSE;
X--- 501,513 ----
X  			break;
X  #ifdef POLYSELF
X  		case ACID_VENOM: /* only possible if thrown */
X! 			if(resists_acid(mdat)) {
X  				kludge("Your venom hits %s harmlessly.",
X  					mon_nam(mon));
X  				tmp = 0;
X  			} else {
X  				kludge("Your venom burns %s!", mon_nam(mon));
X! 				tmp = dmgval(obj, mdat);
X  			}
X  			hittxt = TRUE;
X  			get_dmg_bonus = FALSE;
X***************
X*** 513,522 ****
X  		/* If you throw using a propellor, you don't get a strength
X  		 * bonus but you do get an increase-damage bonus.
X  		 */
X! 		if(!obj || !uwep ||
X  			(obj->olet != GEM_SYM && obj->olet != WEAPON_SYM) ||
X! 			objects[obj->otyp].w_propellor !=
X! 				-objects[uwep->otyp].w_propellor)
X  		    tmp += dbon();
X  	}
X  
X--- 531,541 ----
X  		/* If you throw using a propellor, you don't get a strength
X  		 * bonus but you do get an increase-damage bonus.
X  		 */
X! 		if(!thrown || !obj || !uwep ||
X  			(obj->olet != GEM_SYM && obj->olet != WEAPON_SYM) ||
X! 			!objects[obj->otyp].w_propellor ||
X! 			(objects[obj->otyp].w_propellor !=
X! 				-objects[uwep->otyp].w_propellor))
X  		    tmp += dbon();
X  	}
X  
X***************
X*** 530,536 ****
X  	}
X   */
X  	if (ispoisoned) {
X! 	    if(resists_poison(mon->data))
X  		needpoismsg = TRUE;
X  	    else if (rn2(10))
X  		tmp += rnd(6);
X--- 549,555 ----
X  	}
X   */
X  	if (ispoisoned) {
X! 	    if(resists_poison(mdat))
X  		needpoismsg = TRUE;
X  	    else if (rn2(10))
X  		tmp += rnd(6);
X***************
X*** 550,558 ****
X  		mon->mflee = 1;			/* Rick Richardson */
X  		mon->mfleetim += 10*rnd(tmp);
X  	}
X! 	if((mon->data == &mons[PM_BLACK_PUDDING] ||
X! 		   mon->data == &mons[PM_BROWN_PUDDING]) && obj &&
X! 		   obj == uwep && objects[obj->otyp].oc_material == METAL
X  		   && mon->mhp > 1 && !thrown && !mon->mcan
X  		   /* && !destroyed  -- guaranteed by mhp > 1 */ ) {
X  
X--- 569,577 ----
X  		mon->mflee = 1;			/* Rick Richardson */
X  		mon->mfleetim += 10*rnd(tmp);
X  	}
X! 	if((mdat == &mons[PM_BLACK_PUDDING] || mdat == &mons[PM_BROWN_PUDDING])
X! 		   && obj && obj == uwep
X! 		   && objects[obj->otyp].oc_material == METAL
X  		   && mon->mhp > 1 && !thrown && !mon->mcan
X  		   /* && !destroyed  -- guaranteed by mhp > 1 */ ) {
X  
X***************
X*** 583,611 ****
X  	if (poiskilled) {
X  		pline("The poison was deadly...");
X  		xkilled(mon, 0);
X  		return FALSE;
X! 	} else if (destroyed)
X! 		killed(mon);	/* takes care of messages */
X! 	else if(u.umconf && !thrown) {
X! 		if(!Blind) {
X! 			Your("%s stop glowing %s.",
X! 			makeplural(body_part(HAND)),
X! 			Hallucination ? hcolor() : red);
X! 		}
X  		if(!resist(mon, '+', 0, NOTELL)) mon->mconf = 1;
X! 		if(!mon->mstun && !mon->mfroz && !mon->msleep &&
X  		   !Blind && mon->mconf)
X  			pline("%s appears confused.", Monnam(mon));
X- 		u.umconf = 0;
X  	}
X  
X! 	if(mon->data == &mons[PM_RUST_MONSTER] && obj && obj == uwep &&
X  		objects[obj->otyp].oc_material == METAL &&
X  		obj->olet == WEAPON_SYM && obj->spe > -2) {
X  	    if(obj->rustfree) {
X  		pline("The rust on your %s vanishes instantly!",
X  		      is_sword(obj) ? "sword" : "weapon");
X! 	    } else if(obj->blessed && rnl(4))
X  		pline("Somehow your %s is not affected!",
X  		      is_sword(obj) ? "sword" : "weapon");
X  	    else {
X--- 602,628 ----
X  	if (poiskilled) {
X  		pline("The poison was deadly...");
X  		xkilled(mon, 0);
X+ 		nohandglow();
X  		return FALSE;
X! 	} else if (destroyed) {
X! 		killed(mon);	/* takes care of most messages */
X! 		nohandglow();
X! 	} else if(u.umconf && !thrown) {
X! 		nohandglow();
X  		if(!resist(mon, '+', 0, NOTELL)) mon->mconf = 1;
X! 		if(!mon->mstun && mon->mcanmove && !mon->msleep &&
X  		   !Blind && mon->mconf)
X  			pline("%s appears confused.", Monnam(mon));
X  	}
X  
X! #if 0
X! 	if(mdat == &mons[PM_RUST_MONSTER] && obj && obj == uwep &&
X  		objects[obj->otyp].oc_material == METAL &&
X  		obj->olet == WEAPON_SYM && obj->spe > -2) {
X  	    if(obj->rustfree) {
X  		pline("The rust on your %s vanishes instantly!",
X  		      is_sword(obj) ? "sword" : "weapon");
X! 	    } else if(obj->blessed && !rnl(4))
X  		pline("Somehow your %s is not affected!",
X  		      is_sword(obj) ? "sword" : "weapon");
X  	    else {
X***************
X*** 613,618 ****
X--- 630,636 ----
X  		obj->spe--;
X  	    }
X  	}
X+ #endif
X  
X  	return(destroyed ? FALSE : TRUE);
X  }
X***************
X*** 636,643 ****
X  	    ) {
X  	    struct monst *dtmp;
X  	    pline("Some hell-p has arrived!");
X! /*	    if((dtmp = makemon(uasmon, u.ux, u.uy)))*/
X! 	    if((dtmp = makemon(&mons[ndemon()], u.ux, u.uy)))
X  		(void)tamedog(dtmp, (struct obj *)0);
X  	    return(0);
X  	}
X--- 654,660 ----
X  	    ) {
X  	    struct monst *dtmp;
X  	    pline("Some hell-p has arrived!");
X! 	    if((dtmp = makemon(!rn2(6) ? &mons[ndemon()] : uasmon, u.ux, u.uy)))
X  		(void)tamedog(dtmp, (struct obj *)0);
X  	    return(0);
X  	}
X***************
X*** 716,722 ****
X  		    int isize = inv_cnt();
X  
X  		    stealoid = (struct obj *)0;
X! 		    if (is_mercenary(pd)) {
X  			for(otmp = mdef->minvent; otmp; otmp=otmp->nobj)
X  			    if (otmp->otyp >= PLATE_MAIL && otmp->otyp
X  				<= ELVEN_CLOAK) stealoid = otmp;
X--- 733,739 ----
X  		    int isize = inv_cnt();
X  
X  		    stealoid = (struct obj *)0;
X! 		    if(is_mercenary(pd) && could_seduce(&youmonst,mdef,mattk)){
X  			for(otmp = mdef->minvent; otmp; otmp=otmp->nobj)
X  			    if (otmp->otyp >= PLATE_MAIL && otmp->otyp
X  				<= ELVEN_CLOAK) stealoid = otmp;
X***************
X*** 869,884 ****
X  		    u.ustuck = mdef; /* it's now stuck to you */
X  		break;
X  	    case AD_PLYS:
X! 		if (!mdef->mfroz && !rn2(3) && tmp < mdef->mhp) {
X  		    if (!Blind) pline("%s is frozen by you!", Monnam(mdef));
X! 		    mdef->mfroz = 1;
X  		}
X  	    case AD_SLEE:
X  		if (!resists_sleep(mdef->data) && !mdef->msleep &&
X! 								!mdef->mfroz) {
X  		    if (!Blind)
X  			pline("%s suddenly falls asleep!", Monnam(mdef));
X! 		    mdef->msleep = 1;
X  		}
X  		break;
X  	    default:	tmp = 0;
X--- 886,904 ----
X  		    u.ustuck = mdef; /* it's now stuck to you */
X  		break;
X  	    case AD_PLYS:
X! 		if (mdef->mcanmove && !rn2(3) && tmp < mdef->mhp) {
X  		    if (!Blind) pline("%s is frozen by you!", Monnam(mdef));
X! 		    mdef->mcanmove = 0;
X! 		    mdef->mfrozen = rnd(10);
X  		}
X+ 		break;
X  	    case AD_SLEE:
X  		if (!resists_sleep(mdef->data) && !mdef->msleep &&
X! 							mdef->mcanmove) {
X  		    if (!Blind)
X  			pline("%s suddenly falls asleep!", Monnam(mdef));
X! 		    mdef->mcanmove = 0;
X! 		    mdef->mfrozen = rnd(10);
X  		}
X  		break;
X  	    default:	tmp = 0;
X***************
X*** 910,916 ****
X  	    case AD_BLND:
X  		if(mdef->data->mlet != S_YLIGHT) {
X  		    kludge("%s is blinded by your flash of light!", Monnam(mdef));
X! 		    if (!mdef->mblinded) {
X  			mdef->mblinded += rn2(25);
X  			mdef->mcansee = 0;
X  		    }
X--- 930,936 ----
X  	    case AD_BLND:
X  		if(mdef->data->mlet != S_YLIGHT) {
X  		    kludge("%s is blinded by your flash of light!", Monnam(mdef));
X! 		    if (mdef->mcansee) {
X  			mdef->mblinded += rn2(25);
X  			mdef->mcansee = 0;
X  		    }
X***************
X*** 956,964 ****
X  	 * after exactly 1 round of attack otherwise.  -KAA
X  	 */
X  
X! # ifdef WORM
X! 	if(mdef->wormno) return 0;
X! # endif
X  	if(u.uhunger < 1500 && !u.uswallow) {
X  
X  	    if(mdef->data->mlet != S_COCKATRICE) {
X--- 976,983 ----
X  	 * after exactly 1 round of attack otherwise.  -KAA
X  	 */
X  
X! 	if(mdef->data->msize >= MZ_HUGE) return 0;
X! 
X  	if(u.uhunger < 1500 && !u.uswallow) {
X  
X  	    if(mdef->data->mlet != S_COCKATRICE) {
X***************
X*** 1046,1061 ****
X  		    xkilled(mdef,0);
X  		    return(2);
X  		}
X! 		kludge("You regurgitate %s!", mon_nam(mdef));
X! 		if (Blind)
X! 		    pline("Obviously, you didn't like its taste.");
X! 		else
X! 		    pline("Obviously, you didn't like %s's taste.",
X  								mon_nam(mdef));
X  	    } else {
X  		kludge("You bite into %s", mon_nam(mdef));
X  		You("turn to stone...");
X! 		killer = "poor choice of food";
X  		done(STONING);
X  	    }
X  	}
X--- 1065,1084 ----
X  		    xkilled(mdef,0);
X  		    return(2);
X  		}
X! 		kludge("You %s %s!", is_animal(uasmon) ? "regurgitate"
X! 			: "expel", mon_nam(mdef));
X! 		if (is_animal(uasmon)) {
X! 		    if (Blind)
X! 			pline("Obviously, you didn't like its taste.");
X! 		    else
X! 			pline("Obviously, you didn't like %s's taste.",
X  								mon_nam(mdef));
X+ 		}
X  	    } else {
X  		kludge("You bite into %s", mon_nam(mdef));
X  		You("turn to stone...");
X! 		killer_format = KILLED_BY;
X! 		killer = "swallowing a cockatrice whole";
X  		done(STONING);
X  	    }
X  	}
X***************
X*** 1134,1141 ****
X  				if (!u.uswallow &&
X  				    (compat = could_seduce(&youmonst,
X  							    mon, mattk)))
X! 				pline("You %s %s %s.",
X! 				    mon->mblinded ? "talk to" : "smile at",
X  				    Blind ? "it" : mon_nam(mon),
X  				    compat == 2 ? "engagingly" : "seductively");
X  				else if (mattk->aatyp == AT_KICK)
X--- 1157,1164 ----
X  				if (!u.uswallow &&
X  				    (compat = could_seduce(&youmonst,
X  							    mon, mattk)))
X! 				You("%s %s %s.",
X! 				    mon->mcansee ? "smile at" : "talk to",
X  				    Blind ? "it" : mon_nam(mon),
X  				    compat == 2 ? "engagingly" : "seductively");
X  				else if (mattk->aatyp == AT_KICK)
X***************
X*** 1262,1271 ****
X  	    if(mhit && !rn2(6)) {
X  		if (kicked) {
X  		    if (uarmf)
X! 			(void) rust_dmg(uarmf, xname(uarmf), 1, TRUE);
X  		} else corrode_weapon();
X  	    }
X  	    break;
X  	  case AD_MAGM:
X  	    /* wrath of gods for attacking Oracle */
X  	    if(Antimagic) {
X--- 1285,1315 ----
X  	    if(mhit && !rn2(6)) {
X  		if (kicked) {
X  		    if (uarmf)
X! 			(void) rust_dmg(uarmf, xname(uarmf), 3, TRUE);
X  		} else corrode_weapon();
X  	    }
X  	    break;
X+ 	  case AD_STON:
X+ 	    if(mhit)
X+ 	      if (!kicked)
X+ 		if (!uwep && !uarmg
X+ #ifdef POLYSELF
X+ 		    && !resists_ston(uasmon)
X+ #endif
X+ 		   ) {
X+ 		    You("turn to stone...");
X+ 		    done_in_by(mon);
X+ 		    return 2;
X+ 		}
X+ 	    break;
X+ 	  case AD_RUST:
X+ 	    if(mhit)
X+ 	      if (kicked) {
X+ 		if (uarmf)
X+ 		    (void) rust_dmg(uarmf, xname(uarmf), 1, TRUE);
X+ 	      } else
X+ 		corrode_weapon();
X+ 	    break;
X  	  case AD_MAGM:
X  	    /* wrath of gods for attacking Oracle */
X  	    if(Antimagic) {
X***************
X*** 1287,1296 ****
X  
X  	    switch(ptr->mattk[i].adtyp) {
X  
X! 	      case AD_PLYS:		/* specifically floating eye */
X! 		if(canseemon(mon)) {
X! 
X! 		    tmp = -d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X  		    if(mon->mcansee) {
X  			if(Reflecting & W_AMUL) {
X  			    makeknown(AMULET_OF_REFLECTION);
X--- 1331,1343 ----
X  
X  	    switch(ptr->mattk[i].adtyp) {
X  
X! 	      case AD_PLYS:
X! 		tmp = -d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X! 		if(ptr == &mons[PM_FLOATING_EYE]) {
X! 		    if (!canseemon(mon)) {
X! 			tmp = 0;
X! 			break;
X! 		    }
X  		    if(mon->mcansee) {
X  			if(Reflecting & W_AMUL) {
X  			    makeknown(AMULET_OF_REFLECTION);
X***************
X*** 1308,1313 ****
X--- 1355,1364 ----
X  			pline("%s cannot defend itself.", Amonnam(mon,"blind"));
X  			if(!rn2(500)) change_luck(-1);
X  		    }
X+ 		} else { /* gelatinous cube */
X+ 		    You("are frozen by %s!", mon_nam(mon));
X+ 		    nomul(tmp);
X+ 		    tmp = 0;
X  		}
X  		break;
X  	      case AD_COLD:		/* brown mold or blue jelly */
X***************
X*** 1350,1361 ****
X  		if(monnear(mon, u.ux, u.uy)) {
X  		    tmp = d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X  		    if(Fire_resistance) {
X!   			shieldeff(u.ux, u.uy);
X  			You("feel mildly warm.");
X! #ifdef POLYSELF
X! #ifdef GOLEMS
X  			ugolemeffects(AD_FIRE, tmp);
X- #endif /* GOLEMS */
X  #endif
X  			tmp = 0;
X  			break;
X--- 1401,1410 ----
X  		if(monnear(mon, u.ux, u.uy)) {
X  		    tmp = d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X  		    if(Fire_resistance) {
X! 			shieldeff(u.ux, u.uy);
X  			You("feel mildly warm.");
X! #if defined(POLYSELF) && defined(GOLEMS)
X  			ugolemeffects(AD_FIRE, tmp);
X  #endif
X  			tmp = 0;
X  			break;
X***************
X*** 1364,1369 ****
X--- 1413,1432 ----
X  		    mdamageu(mon, tmp);
X  		}
X  		break;
X+ 	      case AD_ELEC:
X+ 		tmp = d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X+ 		if(Shock_resistance) {
X+ 		    shieldeff(u.ux, u.uy);
X+ 		    You("feel a mild tingle.");
X+ #if defined(POLYSELF) && defined(GOLEMS)
X+ 		    ugolemeffects(AD_ELEC, tmp);
X+ #endif
X+ 		    tmp = 0;
X+ 		    break;
X+ 		}
X+ 		You("are jolted with electricity!");
X+ 		mdamageu(mon, tmp);
X+ 		break;
X  	      default:
X  		break;
X  	    }
X***************
X*** 1398,1401 ****
X--- 1461,1487 ----
X  		pline("Wait!  That's %s!", defmonnam(mtmp));
X  	}
X  	wakeup(mtmp);	/* clears mtmp->mimic */
X+ }
X+ 
X+ static void
X+ nohandglow()
X+ {
X+ 	if (!u.umconf) return; /* for safety */
X+ 	if (u.umconf == 1) {
X+ 		if (Blind)
X+ 			Your("%s stop tingling.", makeplural(body_part(HAND)));
X+ 		else
X+ 			Your("%s stop glowing %s.",
X+ 				makeplural(body_part(HAND)),
X+ 				Hallucination ? hcolor() : red);
X+ 	} else {
X+ 		if (Blind)
X+ 			pline("The tingling in your %s lessens.",
X+ 				makeplural(body_part(HAND)));
X+ 		else
X+ 			Your("%s no longer glow so brightly %s.",
X+ 				makeplural(body_part(HAND)),
X+ 				Hallucination ? hcolor() : red);
X+ 	}
X+ 	u.umconf--;
X  }
X*** src/Old/unixmain.c	Mon Feb 19 19:06:32 1990
X--- src/unixmain.c	Sun Feb 11 11:29:09 1990
X***************
X*** 7,16 ****
X  
X  #include <signal.h>
X  #include <pwd.h>
X  
X  char SAVEF[PL_NSIZ + 11] = "save/";	/* save/99999player */
X  
X! char *hname = 0;		/* name of the game (argv[0] of call) */
X  char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X  int hackpid = 0;				/* current pid */
X  int locknum = 0;				/* max num of players */
X--- 7,19 ----
X  
X  #include <signal.h>
X  #include <pwd.h>
X+ #ifndef O_RDONLY
X+ #include <fcntl.h>
X+ #endif
X  
X  char SAVEF[PL_NSIZ + 11] = "save/";	/* save/99999player */
X  
X! const char *hname = 0;		/* name of the game (argv[0] of call) */
X  char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X  int hackpid = 0;				/* current pid */
X  int locknum = 0;				/* max num of players */
X***************
X*** 233,239 ****
X  #ifdef COMPRESS
X  	Strcpy(old,SAVEF);
X  	Strcat(SAVEF,".Z");
X! 	if((fd = open(SAVEF,0)) >= 0) {
X   	    (void) close(fd);
X  	    Strcpy(cmd, COMPRESS);
X  	    Strcat(cmd, " -d ");	/* uncompress */
X--- 236,242 ----
X  #ifdef COMPRESS
X  	Strcpy(old,SAVEF);
X  	Strcat(SAVEF,".Z");
X! 	if((fd = open(SAVEF,O_RDONLY)) >= 0) {
X   	    (void) close(fd);
X  	    Strcpy(cmd, COMPRESS);
X  	    Strcat(cmd, " -d ");	/* uncompress */
X***************
X*** 246,252 ****
X  	}
X  	Strcpy(SAVEF,old);
X  #endif
X! 	if((fd = open(SAVEF,0)) >= 0 &&
X  	   (uptodate(fd) || unlink(SAVEF) == 666)) {
X  #ifdef WIZARD
X  		/* Since wizard is actually flags.debug, restoring might
X--- 249,256 ----
X  	}
X  	Strcpy(SAVEF,old);
X  #endif
X! 	if((fd = open(SAVEF,O_RDONLY)) >= 0 &&
X! 	   /* if not up-to-date, quietly unlink file via false condition */
X  	   (uptodate(fd) || unlink(SAVEF) == 666)) {
X  #ifdef WIZARD
X  		/* Since wizard is actually flags.debug, restoring might
X***************
X*** 254,261 ****
X  		 */
X  		boolean remember_wiz_mode = wizard;
X  #endif
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X! 		pline("Restoring old save file...");
X  		(void) fflush(stdout);
X  		if(!dorecover(fd))
X  			goto not_recovered;
X--- 258,266 ----
X  		 */
X  		boolean remember_wiz_mode = wizard;
X  #endif
X+ 		(void) chmod(SAVEF,0);	/* disallow parallel restores */
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X! 		pline("Restoring save file...");
X  		(void) fflush(stdout);
X  		if(!dorecover(fd))
X  			goto not_recovered;
X***************
X*** 274,279 ****
X--- 279,297 ----
X  			pline("Do you want to keep the save file? ");
X  			if(yn() == 'n')
X  				(void) unlink(SAVEF);
X+ 			else {
X+ 			    (void) chmod(SAVEF,FCMASK); /* back to readable */
X+ # ifdef COMPRESS
X+ 			    Strcpy(cmd, COMPRESS);
X+ 			    Strcat(cmd, " ");
X+ #  ifdef COMPRESS_OPTIONS
X+ 			    Strcat(cmd, COMPRESS_OPTIONS);
X+ 			    Strcat(cmd, " ");
X+ #  endif
X+ 			    Strcat(cmd,SAVEF);
X+ 			    (void) system(cmd);
X+ # endif
X+ 			}
X  		}
X  #endif
X  		flags.move = 0;
X***************
X*** 382,390 ****
X  
X  	    if(dir == NULL)
X  		dir = ".";
X! 	    if((fd = open(RECORD, 2)) < 0) {
X! 		Printf("Warning: cannot write %s/%s", dir, RECORD);
X! 		getret();
X  	    } else
X  		(void) close(fd);
X  	}
X--- 400,411 ----
X  
X  	    if(dir == NULL)
X  		dir = ".";
X! 	    if((fd = open(RECORD, O_RDWR)) < 0) {
X! 		if((fd = open(RECORD, O_CREAT|O_RDWR, FCMASK)) < 0) {
X! 		    Printf("Warning: cannot write %s/%s", dir, RECORD);
X! 		    getret();
X! 		} else
X! 		    (void) close(fd);
X  	    } else
X  		(void) close(fd);
X  	}
X*** src/Old/unixtty.c	Mon Feb 19 19:06:57 1990
X--- src/unixtty.c	Sun Jan 21 13:58:48 1990
X***************
X*** 115,121 ****
X  /* reset terminal to original state */
X  void
X  settty(s)
X! char *s;
X  {
X  	clear_screen();
X  	end_screen();
X--- 115,121 ----
X  /* reset terminal to original state */
X  void
X  settty(s)
X! const char *s;
X  {
X  	clear_screen();
X  	end_screen();
X***************
X*** 192,200 ****
X  /*VARARGS1*/
X  
X  void
X! error VA_DECL(char *,s)
X  	VA_START(s);
X! 	VA_INIT(s, char *);
X  	if(settty_needed)
X  		settty(NULL);
X  	Vprintf(s,VA_ARGS);
X--- 192,200 ----
X  /*VARARGS1*/
X  
X  void
X! error VA_DECL(const char *,s)
X  	VA_START(s);
X! 	VA_INIT(s, const char *);
X  	if(settty_needed)
X  		settty(NULL);
X  	Vprintf(s,VA_ARGS);
X*** src/Old/version.c	Mon Feb 19 19:07:51 1990
X--- src/version.c	Mon Feb 12 18:47:37 1990
X***************
X*** 5,11 ****
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! #ifdef MSDOS
X  # include	"patchlev.h"
X  #else
X  # include	"patchlevel.h"
X--- 5,11 ----
X  #include	"hack.h"
X  #include	"date.h"
X  #ifndef BETA
X! #if defined(MSDOS) && !defined(AMIGA)
X  # include	"patchlev.h"
X  #else
X  # include	"patchlevel.h"
X***************
X*** 51,53 ****
X--- 51,222 ----
X  		datestring);
X  	return 0;
X  }
X+ 
X+ #define Next_opt(x) if (next_opt(x)) goto quit;
X+ #define Page_line(x) if (page_line(x)) goto quit;
X+ 
X+ int
X+ doextversion()
X+ {
X+ 	set_pager(0);
X+ 	(void)page_line("");
X+ 	Page_line("Options compiled into this version of NetHack");
X+ 	Page_line("(in no particular order):");
X+ 	Page_line("");
X+ #ifdef POLYSELF
X+ 	Next_opt("self-polymorphing, ");
X+ #endif
X+ #ifdef THEOLOGY
X+ 	Next_opt("theology, ");
X+ #endif
X+ #ifdef SOUNDS
X+ 	Next_opt("sounds, ");
X+ #endif
X+ #ifdef KICK
X+ 	Next_opt("kicking, ");
X+ #endif
X+ #ifdef THRONES
X+ 	Next_opt("thrones, ");
X+ #endif
X+ #ifdef FOUNTAINS
X+ 	Next_opt("fountains, ");
X+ #endif
X+ #ifdef SINKS
X+ 	Next_opt("sinks, ");
X+ #endif
X+ #ifdef ALTARS
X+ 	Next_opt("altars, ");
X+ #endif
X+ #ifdef WALLIFIED_MAZE
X+ 	Next_opt("fancy mazes, ");
X+ #endif
X+ #ifdef REINCARNATION
X+ 	Next_opt("Rogue level, ");
X+ #endif
X+ #ifdef STRONGHOLD
X+ 	Next_opt("special levels, ");
X+ #endif
X+ #ifdef ORACLE
X+ 	Next_opt("oracle, ");
X+ #endif
X+ #ifdef MEDUSA
X+ 	Next_opt("Medusa, ");
X+ #endif
X+ #ifdef KOPS
X+ 	Next_opt("Kops, ");
X+ #endif
X+ #ifdef ARMY
X+ 	Next_opt("armies, ");
X+ #endif
X+ #ifdef WORM
X+ 	Next_opt("long worms, ");
X+ #endif
X+ #ifdef GOLEMS
X+ 	Next_opt("golems, ");
X+ #endif
X+ #ifdef INFERNO
X+ 	Next_opt("inferno, ");
X+ #endif
X+ #ifdef SEDUCE
X+ 	Next_opt("seduction, ");
X+ #endif
X+ #ifdef TOLKIEN
X+ 	Next_opt("Tolkien extras, ");
X+ #endif
X+ #ifdef PROBING
X+ 	Next_opt("wand of probing, ");
X+ #endif
X+ #ifdef WALKIES
X+ 	Next_opt("leashes, ");
X+ #endif
X+ #ifdef SHIRT
X+ 	Next_opt("Hawaiian shirt, ");
X+ #endif
X+ #ifdef MUSIC
X+ 	Next_opt("music, ");
X+ #endif
X+ #ifdef TUTTI_FRUTTI
X+ 	Next_opt("fruits, ");
X+ #endif
X+ #ifdef SPELLS
X+ 	Next_opt("spells, ");
X+ #endif
X+ #ifdef NAMED_ITEMS
X+ 	Next_opt("named items, ");
X+ #endif
X+ #ifdef ELBERETH
X+ 	Next_opt("Elbereth, ");
X+ #endif
X+ #ifdef EXPLORE_MODE
X+ 	Next_opt("explore mode, ");
X+ #endif
X+ #ifdef HARD
X+ 	Next_opt("HARD, ");
X+ #endif
X+ #ifdef REDO
X+ 	Next_opt("redo-commands, ");
X+ #endif
X+ #ifdef CLIPPING
X+ 	Next_opt("screen clipping, ");
X+ #endif
X+ #ifdef TEXTCOLOR
X+ 	Next_opt("color, ");
X+ #endif
X+ #ifdef DGK
X+ 	Next_opt("Don Kneller's enhancements, ");
X+ #endif
X+ #ifdef OVERLAY
X+ 	Next_opt("overlays, ");
X+ #endif
X+ #ifdef SHELL
X+ 	Next_opt("shell command, ");
X+ #endif
X+ #ifdef MAIL
X+ 	Next_opt("mail, ");
X+ #endif
X+ #ifdef NEWS
X+ 	Next_opt("news file, ");
X+ #endif
X+ #ifdef COM_COMPL
X+ 	Next_opt("command line completion, ");
X+ #endif
X+ #ifdef AMIGA_WBENCH
X+ 	Next_opt("Amiga WorkBench support, ");
X+ #endif
X+ #ifdef WIZARD
X+ 	Next_opt("wizard mode, ");
X+ #endif
X+ #ifdef LOGFILE
X+ 	Next_opt("logfile, ");
X+ #endif
X+ #ifdef TERMLIB
X+ 	Next_opt("termcap file, ");
X+ #endif
X+ #ifdef TERMINFO
X+ 	Next_opt("terminfo, ");
X+ #endif
X+ #ifdef ANSI_DEFAULT
X+ 	Next_opt("ANSI default terminal, ");
X+ #endif
X+ #ifdef COMPRESS
X+ 	Next_opt("compress bones/level/save files, ");
X+ #endif
X+ 	Next_opt("basic NetHack features");
X+ 	Next_opt("");
X+ 	set_pager(1);
X+ 	return 0;
X+ quit:
X+ 	(void) next_opt("\033");
X+ 	set_pager(2);
X+ 	return 0;
X+ }
X+ 
X+ #ifdef MSDOS
X+ int
X+ comp_times(filetime)
X+ long filetime;
X+ {
X+ 	if(filetime < compiletime) return (1);
X+ 	else return (0);
X+ }
X+ #endif
X*** src/Old/weapon.c	Mon Feb 19 19:08:10 1990
X--- src/weapon.c	Thu Jan 25 22:14:52 1990
X***************
X*** 9,14 ****
X--- 9,16 ----
X   */
X  #include	"hack.h"
X  
X+ #ifdef OVLB
X+ 
X  static const char kebabable[] = { S_XORN, S_DRAGON, S_NAGA, S_GIANT, 0 };
X  
X  /*
X***************
X*** 168,173 ****
X--- 170,178 ----
X  	return;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  #define	Oselect(x)	if((otmp = m_carrying(mtmp, x))) return(otmp);
X  
X  #ifdef TOLKIEN
X***************
X*** 352,357 ****
X--- 357,365 ----
X  	else return(sbon+ACURR(A_DEX)-14);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  int
X  dbon() {	/* damage bonus for strength */
X  #ifdef POLYSELF
X***************
X*** 367,369 ****
X--- 375,379 ----
X  	else if(ACURR(A_STR) < 118) return(5);	/* up to 18/99 */
X  	else return(6);
X  }
X+ 
X+ #endif /* OVL1 */
X*** src/Old/were.c	Mon Feb 19 19:08:33 1990
X--- src/were.c	Thu Jan 25 22:14:54 1990
X***************
X*** 4,9 ****
X--- 4,13 ----
X  
X  #include	"hack.h"
X  
X+ static int FDECL(counter_were,(int));
X+ 
X+ #ifdef OVL0
X+ 
X  void
X  were_change(mon)
X  register struct monst *mon;
X***************
X*** 22,27 ****
X--- 26,34 ----
X  	    } else if(!rn2(30) || Protection_from_shape_changers) new_were(mon);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  static int
X  counter_were(pm)
X  int pm;
X***************
X*** 108,110 ****
X--- 115,119 ----
X  	(void) polymon(u.ulycn);
X  }
X  #endif
X+ 
X+ #endif /* OVLB */
X*** src/Old/wield.c	Mon Feb 19 19:08:53 1990
X--- src/wield.c	Sun Jan 21 13:58:49 1990
X***************
X*** 65,71 ****
X  	    You("wield the cockatrice corpse in your bare %s.",
X  			makeplural(body_part(HAND)));
X  	    You("turn to stone...");
X! 	    killer="cockatrice corpse";
X  	    done(STONING);
X  	} else if(uarms && bimanual(wep))
X  	    You("cannot wield a two-handed %s and hold a shield.",
X--- 65,72 ----
X  	    You("wield the cockatrice corpse in your bare %s.",
X  			makeplural(body_part(HAND)));
X  	    You("turn to stone...");
X! 	    killer_format = KILLED_BY;
X! 	    killer="touching a cockatrice corpse";
X  	    done(STONING);
X  	} else if(uarms && bimanual(wep))
X  	    You("cannot wield a two-handed %s and hold a shield.",
X***************
X*** 114,120 ****
X  	else if (uwep->spe > -6) {
X  		Your("%s!", aobjnam(uwep, "corrode"));
X  		uwep->spe--;
X! 	} else	Your("%s quite rusted now.", aobjnam(uwep, "look"));
X  }
X  
X  int
X--- 115,121 ----
X  	else if (uwep->spe > -6) {
X  		Your("%s!", aobjnam(uwep, "corrode"));
X  		uwep->spe--;
X! 	} else	Your("%s quite rusted now.", aobjnam(uwep, Blind ? "feel" : "look"));
X  }
X  
X  int
X***************
X*** 124,132 ****
X  {
X  	register const char *color = Hallucination ? hcolor() :
X  				     (amount < 0) ? black : blue;
X! 	register char *xtime;
X  
X! 	if(!uwep || (uwep->olet != WEAPON_SYM && uwep->otyp != PICK_AXE)) {
X  		char buf[36];
X  
X  		Sprintf(buf, "Your %s %s.", makeplural(body_part(HAND)),
X--- 125,134 ----
X  {
X  	register const char *color = Hallucination ? hcolor() :
X  				     (amount < 0) ? black : blue;
X! 	register const char *xtime;
X  
X! 	if(!uwep || (uwep->olet != WEAPON_SYM && uwep->otyp != PICK_AXE
X! 			&& uwep->otyp != UNICORN_HORN)) {
X  		char buf[36];
X  
X  		Sprintf(buf, "Your %s %s.", makeplural(body_part(HAND)),
X***************
X*** 145,151 ****
X  
X  	if(uwep->otyp == CRYSKNIFE && amount < 0) {
X  		uwep->otyp = WORM_TOOTH;
X! 		Your("weapon looks duller now.");
X  		return(1);
X  	}
X  #endif
X--- 147,153 ----
X  
X  	if(uwep->otyp == CRYSKNIFE && amount < 0) {
X  		uwep->otyp = WORM_TOOTH;
X! 		Your("weapon seems duller now.");
X  		return(1);
X  	}
X  #endif
X*** src/Old/wizard.c	Mon Feb 19 19:09:10 1990
X--- src/wizard.c	Tue Feb 13 18:41:41 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)wizard.c	3.0	88/04/11
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)wizard.c	3.0	90/01/09
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,13 ****
X--- 8,15 ----
X  
X  #include "hack.h"
X  
X+ #ifdef OVLB
X+ 
X  #ifdef HARD
X  /*	TODO:	Expand this list.	*/
X  static const int nasties[] = {
X***************
X*** 20,30 ****
X  	};
X  #endif /* HARD */
X  
X! /*	TODO:	investigate this. */
X! static const char wizapp[] = {
X! 	S_HUMAN, S_DEMON, S_VAMPIRE, S_DRAGON, S_TROLL, S_UMBER,
X! 	S_XORN, S_XAN, S_COCKATRICE, S_EYE, S_NAGA, S_TRAPPER,
X! 	/* '1' /* Historical reference */ };
X  
X  /* If he has found the Amulet, make the wizard appear after some time */
X  void
X--- 22,38 ----
X  	};
X  #endif /* HARD */
X  
X! static const unsigned wizapp[] = {
X! 	PM_HUMAN, PM_WATER_DEMON, PM_VAMPIRE,
X! 	PM_RED_DRAGON, PM_TROLL, PM_UMBER_HULK,
X! 	PM_XORN, PM_XAN, PM_COCKATRICE,
X! 	PM_FLOATING_EYE,
X! 	PM_GUARDIAN_NAGA,
X! 	PM_TRAPPER
X! };
X! 
X! #endif /* OVLB */
X! #ifdef OVL0
X  
X  /* If he has found the Amulet, make the wizard appear after some time */
X  void
X***************
X*** 39,51 ****
X  		    if(u.uhave_amulet) {
X  			mtmp->msleep = 0;
X  			if(dist(mtmp->mx,mtmp->my) > 2)
X! 			    pline(
X!     "You get the creepy feeling that somebody noticed your taking the Amulet."
X  			    );
X  			return;
X  		    }
X  }
X  
X  int
X  mon_has_amulet(mtmp)
X  register struct monst *mtmp;
X--- 47,62 ----
X  		    if(u.uhave_amulet) {
X  			mtmp->msleep = 0;
X  			if(dist(mtmp->mx,mtmp->my) > 2)
X! 			    You(
X!     "get the creepy feeling that somebody noticed your taking the Amulet."
X  			    );
X  			return;
X  		    }
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  int
X  mon_has_amulet(mtmp)
X  register struct monst *mtmp;
X***************
X*** 86,91 ****
X--- 97,105 ----
X  			    /* teleport to it and pick it up */
X  			    remove_monster(mtmp->mx, mtmp->my);
X  			    place_monster(mtmp, otmp->ox, otmp->oy);
X+ 			    if (cansee(mtmp->mx, mtmp->my))
X+ 				pline("%s picks up %s.", Monnam(mtmp),
X+ 								xname(otmp));
X  			    freeobj(otmp);
X  			    mpickobj(mtmp, otmp);
X  			    pmon(mtmp);
X***************
X*** 100,106 ****
X  	/* secondary goal - stayin' alive */
X  
X  	/* if wounded, hole up on or near the stairs (to block them) */
X! 	if(mtmp->mhp < 20 + rnd(10))
X  	    if (mtmp->mx != xupstair && mtmp->my != yupstair)
X  		mnearto(mtmp,xupstair,yupstair,TRUE);
X  
X--- 114,121 ----
X  	/* secondary goal - stayin' alive */
X  
X  	/* if wounded, hole up on or near the stairs (to block them) */
X! 	/* unless, of course, there are no stairs (e.g. endlevel */
X! 	if(mtmp->mhp < 20 + rnd(10) && (xupstair || yupstair))
X  	    if (mtmp->mx != xupstair && mtmp->my != yupstair)
X  		mnearto(mtmp,xupstair,yupstair,TRUE);
X  
X***************
X*** 131,138 ****
X  
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X  		mtmp->msleep = 0;
X! 		if(mtmp->mfroz && !rn2(5))
X! 			mtmp->mfroz = 0;
X  	}
X  }
X  
X--- 146,155 ----
X  
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon) {
X  		mtmp->msleep = 0;
X! 		if(!mtmp->mcanmove && !rn2(5)) {
X! 			mtmp->mfrozen = 0;
X! 			mtmp->mcanmove = 1;
X! 		}
X  	}
X  }
X  
X***************
X*** 148,153 ****
X--- 165,171 ----
X  			mtmp2->minvent->spe = -1;
X  		}
X  		unpmon(mtmp2);
X+ 		mtmp2->m_ap_type = M_AP_MONSTER;
X  		mtmp2->mappearance = wizapp[rn2(SIZE(wizapp))];
X  		pmon(mtmp2);
X  	}
X***************
X*** 262,308 ****
X  
X  const char *random_malediction[] = {
X  	"Hell shall soon claim thy remains,",
X! 	"I chortle at thee, pathetic",
X! 	"Prepare to die,",
X  	"Resistance is useless,",
X  	"Surrender or die, thou",
X! 	"There shall be no mercy, yon",
X  	"Thou shalt repent of thy cunning,",
X  	"Thou art as a flea to me,",
X  	"Thou art doomed,",
X  	"Thy fate is sealed,",
X  	"Verily, thou shalt be one dead"
X! /*	"Go play leapfrog with a unicorn,", */
X  };
X  
X! /* Insult the player */
X  void
X  cuss(mtmp)
X  register struct monst	*mtmp;
X  {
X! 	switch (rn2(5)) {
X! 	    case 0: pline("%s casts aspersions on your ancestry.",
X! 			  Monnam(mtmp));
X! 		    break;
X! 	    case 1: pline("%s laughs fiendishly.", /* typical bad guy action */
X! 			  Monnam(mtmp));
X! 		    break;
X! 	    default:
X! 		    if (u.uhave_amulet && !rn2(SIZE(random_insult)))
X! 			pline("\"Relinquish the amulet, %s!\"",
X! 			      random_insult[rn2(SIZE(random_insult))]);
X! 		    else if (u.uhp < 5 && !rn2(2))	/* Panic */
X! 			pline(rn2(2) ?
X! 				"\"Even now thy life force ebbs, %s!\"" :
X! 				"\"Savor thy breath, %s, it be thine last!\"",
X! 			      random_insult[rn2(SIZE(random_insult))]);
X! 		    else if (mtmp->mhp < 5 && !rn2(2))	/* Parthian shot */
X! 			pline(rn2(2) ?
X! 				"\"I shall return.\"" :
X! 				"\"I'll be back.\"");
X! 		    else
X! 			pline("\"%s %s!\"",
X! 			      random_malediction[rn2(SIZE(random_malediction))],
X! 			      random_insult[rn2(SIZE(random_insult))]);
X  	}
X  }
X--- 280,357 ----
X  
X  const char *random_malediction[] = {
X  	"Hell shall soon claim thy remains,",
X! 	"I chortle at thee, thou pathetic",
X! 	"Prepare to die, thou ",
X  	"Resistance is useless,",
X  	"Surrender or die, thou",
X! 	"There shall be no mercy, thou",
X  	"Thou shalt repent of thy cunning,",
X  	"Thou art as a flea to me,",
X  	"Thou art doomed,",
X  	"Thy fate is sealed,",
X  	"Verily, thou shalt be one dead"
X! };
X! 
X! #ifdef SOUNDS
X! const char *demonic_malediction[] = {
X! 	"I first mistook thee for a statue, when I regarded thy head of stone.",
X! 	"Come here often?",
X! 	"Dost pain excite thee?  Wouldst thou prefer the whip?",
X! 	"Thinkest thou it shall tickle as I rip out thy lungs?",
X! 	"Eat slime and die!",
X! 	"Go ahead, fetch thy mama!  I shall wait.",
X! 	"Go play leapfrog with a herd of unicorns!",
X! 	"Hast thou been drinking, or art thou always so clumsy?",
X! 	"This time I shall let thee off with a spanking, but let it not happen again.",
X! 	"I've met smarter (and prettier) acid blobs.",
X! 	"Look!  Thy bootlace is undone!",
X! 	"Mercy!  Dost thou wish me to die of laughter?",
X! 	"Run away!  Live to flee another day!",	
X! 	"Thou hadst best fight better than thou canst dress!",
X! 	"Twixt thy cousin and thee, Medusa is the prettier.",
X! 	"Methinks thou wert unnaturally interested in yon corpse back there, eh, varlet?",
X! 	"Up thy nose with a rubber hose!",
X! 	"Verily, thy corpse could not smell worse!",
X! 	"Wait!  I shall polymorph into a grid bug to give thee a fighting chance!",
X! 	"Why search for the Amulet?  Thou wouldst but lose it, cretin.",
X  };
X+ #endif
X  
X! /* Insult or intimidate the player */
X  void
X  cuss(mtmp)
X  register struct monst	*mtmp;
X  {
X! #ifdef SOUNDS
X! 	if (mtmp->iswiz) {
X! #endif
X! 	    if (!rn2(5))  /* typical bad guy action */
X! 		pline("%s laughs fiendishly.", Monnam(mtmp));
X! 	    else 
X! 		if (u.uhave_amulet && !rn2(SIZE(random_insult)))
X! 		    pline("\"Relinquish the amulet, %s!\"",
X! 			  random_insult[rn2(SIZE(random_insult))]);
X! 		else if (u.uhp < 5 && !rn2(2))	/* Panic */
X! 		    pline(rn2(2) ?
X! 			  "\"Even now thy life force ebbs, %s!\"" :
X! 			  "\"Savor thy breath, %s, it be thine last!\"",
X! 			  random_insult[rn2(SIZE(random_insult))]);
X! 		else if (mtmp->mhp < 5 && !rn2(2))	/* Parthian shot */
X! 		    verbalize(rn2(2) ?
X! 			      "I shall return." :
X! 			      "I'll be back.");
X! 		else
X! 		    pline("\"%s %s!\"",
X! 			  random_malediction[rn2(SIZE(random_malediction))],
X! 			  random_insult[rn2(SIZE(random_insult))]);
X! #ifdef SOUNDS
X! 	} else {
X! 	    if (!rn2(5))
X! 		kludge("%s casts aspersions on your ancestry.", Monnam(mtmp));
X! 	    else
X! 		verbalize(demonic_malediction[rn2(SIZE(demonic_malediction))]);
X  	}
X+ #endif
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/worm.c	Mon Feb 19 19:09:31 1990
X--- src/worm.c	Sun Jan 28 19:32:59 1990
X***************
X*** 7,12 ****
X--- 7,36 ----
X  #ifdef WORM
X  #include "wseg.h"
X  
X+ static void FDECL(remseg,(struct monst *,struct wseg *));
X+ 
X+ /* Each tailed worm has a wormno.  This is used as an index for the following
X+  * arrays:
X+  * wsegs: the start of a a linked list of segments, located at the tail.
X+  * wheads: the end of a linked list of segments, located at the head.  Putting
X+  *	the tail of the list at the head of the worm and vice versa is an
X+  *	endless source of confusion, but necessary.  From now on, we will use
X+  *	"start" and "end" to refer to the list, and "head" and "tail" to refer
X+  *	to the worm.
X+  * wgrowtime: obvious.
X+  *
X+  * When a worm is moved, we add a new segment at the head (end of the list)
X+  * and (unless we want it to grow) delete the segment at the tail (beginning
X+  * of the list).  This new head segment is located in the same square as
X+  * the actual head of the worm (thus requiring a special case when setting
X+  * level.monsters upon worm movement).  If we do want to grow the worm, we
X+  * don't delete the tail segment, and we give the worm extra hit points,
X+  * which possibly go into its maximum.
X+  *
X+  * Non-moving worms (worm_nomove) shrink instead of grow as their tails keep
X+  * going while their heads are stopped short.  Delete the tail segment,
X+  * and remove hit points from the worm.
X+  */
X  struct wseg *wsegs[32] = DUMMY, *wheads[32] = DUMMY, *m_atseg = 0;
X  long wgrowtime[32] = DUMMY;
X  
X***************
X*** 193,199 ****
X--- 217,231 ----
X  		wsegs[tmp2] = wsegs[tmp];
X  		wgrowtime[tmp2] = 0;
X  	}
X+ 	/* do-loop: go from the tail to the head.  Segments close to the tail
X+ 	 * either die or become part of worm 2.  We stop at the hit segment
X+ 	 * and this loop never goes down the entire length of the worm.
X+ 	 */
X  	do {
X+ 	    /* The segment immediately next to (tailwards) the one hit, */
X+ 	    /* becoes the head of the new second worm.  Note: at this point, */
X+ 	    /* wtmp->nseg is the one you hit, wtmp is immediately tailwards, */
X+ 	    /* and wtmp->nseg->nseg is immediately headwards. */
X  	    if(wtmp->nseg->wx == x && wtmp->nseg->wy == y){
X  		if(tmp2) wheads[tmp2] = wtmp;
X  		wsegs[tmp] = wtmp->nseg->nseg;
X***************
X*** 202,208 ****
X  		if(tmp2) {
X  		    kludge("You cut %s in half.", mon_nam(mtmp));
X  		/* devalue the monster level of both halves of the worm */
X! 		    mtmp->m_lev = (mtmp->m_lev <= 2) ? 2 : mtmp->m_lev - 2;
X  		    mtmp2->m_lev = mtmp->m_lev;
X  		/* calculate the mhp on the new (lower) monster level */
X  		    mtmp2->mhpmax = mtmp2->mhp = d((int)mtmp2->m_lev, 8);
X--- 234,240 ----
X  		if(tmp2) {
X  		    kludge("You cut %s in half.", mon_nam(mtmp));
X  		/* devalue the monster level of both halves of the worm */
X! 		    mtmp->m_lev = (mtmp->m_lev <= 3) ? 2 : mtmp->m_lev - 2;
X  		    mtmp2->m_lev = mtmp->m_lev;
X  		/* calculate the mhp on the new (lower) monster level */
X  		    mtmp2->mhpmax = mtmp2->mhp = d((int)mtmp2->m_lev, 8);
X***************
X*** 219,226 ****
X--- 251,261 ----
X  		mtmp->mhp /= 2;
X  		return;
X  	    }
X+ 	/* Worm segments which are closer to the tail than the one you hit, */
X+ 	/* get either deleted or transferred from the old to new worms */
X  	    wtmp2 = wtmp->nseg;
X  	    if(!tmp2) remseg(mtmp, wtmp);
X+ 	    else place_worm_seg(mtmp2, wtmp->wx, wtmp->wy);
X  	    wtmp = wtmp2;
X  	} while(wtmp->nseg);
X  	panic("Cannot find worm segment");
X*** src/Old/worn.c	Mon Feb 19 19:09:52 1990
X--- src/worn.c	Mon Jan 22 21:02:41 1990
X***************
X*** 35,42 ****
X  register struct obj *obj;
X  long mask;
X  {
X! 	register struct worn *wp;
X! 	register struct obj *oobj;
X  
X  	for(wp = worn; wp->w_mask; wp++) if(wp->w_mask & mask) {
X  		oobj = *(wp->w_obj);
X--- 35,42 ----
X  register struct obj *obj;
X  long mask;
X  {
X! 	register const struct worn *wp;
X! 	register struct obj *oobj = 0;
X  
X  	for(wp = worn; wp->w_mask; wp++) if(wp->w_mask & mask) {
X  		oobj = *(wp->w_obj);
X***************
X*** 71,87 ****
X  	 */
X  	if (Inhell && !Fire_resistance) {
X  		pline(crispy);
X! 		killer = "loss of fire protection";
X  		done(BURNING);
X  		/* If we're here they survived with life saving, so put the
X  		 * weapon they just unwielded back in their hands...
X  		 */
X! 		if (oobj->otyp != DRAGON_SCALE_MAIL
X  				&& oobj->otyp != RIN_FIRE_RESISTANCE
X  #ifdef NAMED_ITEMS
X  				&& !defends(AD_FIRE, oobj)
X  #endif
X! 				&& oobj->corpsenm != PM_RED_DRAGON)
X  			impossible("lost FR from a non-FR item?");
X  		setworn(oobj, mask);
X  	}
X--- 71,88 ----
X  	 */
X  	if (Inhell && !Fire_resistance) {
X  		pline(crispy);
X! 		killer_format = NO_KILLER_PREFIX;
X! 		killer = self_pronoun("lost %s fire protection in hell","his");
X  		done(BURNING);
X  		/* If we're here they survived with life saving, so put the
X  		 * weapon they just unwielded back in their hands...
X  		 */
X! 		if (!oobj || (oobj->otyp != DRAGON_SCALE_MAIL
X  				&& oobj->otyp != RIN_FIRE_RESISTANCE
X  #ifdef NAMED_ITEMS
X  				&& !defends(AD_FIRE, oobj)
X  #endif
X! 				&& oobj->corpsenm != PM_RED_DRAGON))
X  			impossible("lost FR from a non-FR item?");
X  		setworn(oobj, mask);
X  	}
X***************
X*** 92,98 ****
X  setnotworn(obj)
X  register struct obj *obj;
X  {
X! 	register struct worn *wp;
X  
X  	if (!obj) return;
X  	for(wp = worn; wp->w_mask; wp++)
X--- 93,99 ----
X  setnotworn(obj)
X  register struct obj *obj;
X  {
X! 	register const struct worn *wp;
X  
X  	if (!obj) return;
X  	for(wp = worn; wp->w_mask; wp++)
X***************
X*** 111,117 ****
X  	 */
X  	if (Inhell && !Fire_resistance && obj->olet != AMULET_SYM) {
X  		pline(crispy);
X! 		killer = "loss of fire protection";
X  		done(BURNING);
X  		/* Survived with lifesaving, etc...; there's no general way
X  		 * to undo the setnotworn()--we can't re-wear/wield the
X--- 112,119 ----
X  	 */
X  	if (Inhell && !Fire_resistance && obj->olet != AMULET_SYM) {
X  		pline(crispy);
X! 		killer_format = NO_KILLER_PREFIX;
X! 		killer = self_pronoun("lost %s fire protection in hell","his");
X  		done(BURNING);
X  		/* Survived with lifesaving, etc...; there's no general way
X  		 * to undo the setnotworn()--we can't re-wear/wield the
X*** src/Old/search.c	Mon Feb 19 18:58:10 1990
X--- src/search.c	Sat Feb  3 21:37:33 1990
X***************
X*** 7,12 ****
X--- 7,16 ----
X  #  include "artifact.h"
X  #endif
X  
X+ static void FDECL(findone,(XCHAR_P,XCHAR_P,int *));
X+ 
X+ #ifdef OVLB
X+ 
X  static void
X  findone(zx,zy,num)
X  xchar zx,zy;
X***************
X*** 66,78 ****
X  	num = 0;
X  	for(zy = ly; zy <= hy; zy++)
X  		for(zx = lx; zx <= hx; zx++)
X! 			findone(zx,zy,&num);
X  	for(zy = ly2; zy <= hy2; zy++)
X  		for(zx = lx2; zx <= hx2; zx++)
X! 			findone(zx,zy,&num);
X  	return(num);
X  }
X  
X  int
X  dosearch()
X  {
X--- 70,87 ----
X  	num = 0;
X  	for(zy = ly; zy <= hy; zy++)
X  		for(zx = lx; zx <= hx; zx++)
X! 			if(isok(zx,zy))
X! 				findone(zx,zy,&num);
X  	for(zy = ly2; zy <= hy2; zy++)
X  		for(zx = lx2; zx <= hx2; zx++)
X! 			if(isok(zx,zy))
X! 				findone(zx,zy,&num);
X  	return(num);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  int
X  dosearch()
X  {
X***************
X*** 98,104 ****
X  			pline("What are you looking for?  The exit?");
X  	} else
X  	    for(x = u.ux-1; x < u.ux+2; x++)
X! 	      for(y = u.uy-1; y < u.uy+2; y++)
X  		if(x != u.ux || y != u.uy) {
X  		    if(levl[x][y].typ == SDOOR) {
X  #ifdef NAMED_ITEMS
X--- 107,114 ----
X  			pline("What are you looking for?  The exit?");
X  	} else
X  	    for(x = u.ux-1; x < u.ux+2; x++)
X! 	      for(y = u.uy-1; y < u.uy+2; y++) {
X! 		if(!isok(x,y)) continue;
X  		if(x != u.ux || y != u.uy) {
X  		    if(levl[x][y].typ == SDOOR) {
X  #ifdef NAMED_ITEMS
X***************
X*** 153,158 ****
X--- 163,169 ----
X  					    You("find %s posing as a statue.",
X  						  defmonnam(mtmp));
X  					delobj(otmp);
X+ 					newsym(x, y);
X  				      }
X  				    deltrap(trap);
X  				    return(1);
X***************
X*** 164,172 ****
X--- 175,187 ----
X  			    }
X  		    }
X  		}
X+ 	      }
X  	return(1);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  doidtrap() {
X  	register struct trap *trap;
X***************
X*** 180,186 ****
X  		    if(u.dz)
X  			if((u.dz < 0) != (is_maze_lev && trap->ttyp == TRAPDOOR))
X  			    continue;
X! 			pline("That is a%s.",traps[ Hallucination ? rn2(TRAPNUM-3)+2 :
X  			trap->ttyp]);
X  		    return 0;
X  		}
X--- 195,201 ----
X  		    if(u.dz)
X  			if((u.dz < 0) != (is_maze_lev && trap->ttyp == TRAPDOOR))
X  			    continue;
X! 			pline("That is a%s.",traps[ Hallucination ? rn2(TRAPNUM-3)+3 :
X  			trap->ttyp]);
X  		    return 0;
X  		}
X***************
X*** 188,193 ****
X--- 203,211 ----
X  	return 0;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  wakeup(mtmp)
X  register struct monst *mtmp;
X***************
X*** 198,203 ****
X--- 216,224 ----
X  	if(mtmp->mimic) seemimic(mtmp);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  /* NOTE: we must check if(mtmp->mimic) before calling this routine */
X  void
X  seemimic(mtmp)
X***************
X*** 204,210 ****
X--- 225,234 ----
X  register struct monst *mtmp;
X  {
X  	mtmp->mimic = 0;
X+ 	mtmp->m_ap_type = M_AP_NOTHING;
X  	mtmp->mappearance = 0;
X  	unpmon(mtmp);
X  	pmon(mtmp);
X  }
X+ 
X+ #endif /* OVLB */
X
END_OF_FILE
if test 54742 -ne `wc -c <'patch7.09'`; then
    echo shar: \"'patch7.09'\" unpacked with wrong size!
fi
# end of 'patch7.09'
echo shar: End of archive 13 \(of 30\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
