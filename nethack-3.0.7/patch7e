Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!snorkelwacker!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i005:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7e
Message-ID: <5219@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:30:49 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2287
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 5
Archive-name: NetHack3/Patch7e
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 30)."
# Contents:  patch7.15
# Wrapped by billr@saab on Wed Feb 21 10:04:26 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.15' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.15'\" to \"'patch7.15.orig'\"
  mv -f 'patch7.15' 'patch7.15.orig'
fi
echo shar: Extracting \"'patch7.15'\" \(56738 characters\)
sed "s/^X//" >'patch7.15' <<'END_OF_FILE'
X*** /dev/null	Mon Feb 19 21:20:23 1990
X--- mac/MD.rsrc.hqx	Thu Feb  8 17:43:51 1990
X***************
X*** 0 ****
X--- 1,39 ----
X+ (This file must be converted with BinHex 4.0)
X+ 
X+ :"de%,R*cFQ-!!!!!!!!!!!!"!!!!!!!!!!0JYHX!!!!!!3!!!!,d!!!"p!!!!'a
X+ 
X+ c1J!!!"3!%5T51NPZBfaeC'9c1L!!!!!!%J!4+P-k53G04#jbFh*M!J!!!!!!!!!
X+ 
X+ !!!!!!3!!M!"J!!!!!!Zc!!!!!!!!!!!!!!%!!)`!B!!!!)3!!!!!!!!!!!!!!!!
X+ 
X+ !!+(b#bi!!!!!!!!$B-`N!GJ!!!!F!f)!$%024%8!!J"U8%eMG!!'!)j%594-!!m
X+ 
X+ !iN&-8P3!$`'L58026J!!!Q*048j9!!)#EP088L!!"J+53dj86!!!!ZC*3diM!!%
X+ 
X+ #mP*05e)!!!-+4P*&4J!"!aC#6N4-!!!$,P""9%J!!!-k!!$rrb!!!!!!!-YF!!%
X+ 
X+ !!!!9!#J!+!$)!8!!!Irr!!!!!!!!!-J!!!!!cJ!)!!!!!!"d!$-!L!"["!*25`!
X+ 
X+ !!!!!G!#H!)J!fJ3'3f&ZBf9X!!!!!!!2!!m!(`"("J4NBA4K!!!!!!!3!%J!)!"
X+ 
X+ i"J4NBA4P!!!!!!!S!%J!1!#J"JK`CA*YEfjcG!!!!!!!%!#J!#!!k!B'FR9YEh*
X+ 
X+ c!!!!!!!S!!m!1!"("J9dFQ&`Fd%!!!!!!#J!S3!i!4%'$'pLDQ9MG#"ZB@ePF`!
X+ 
X+ !!!!!3!!3!&!!m!BGE@pZFh3JFQ9cEh9bBf8JB@jN)'CTE'8JD@0[ER02!!!!&3!
X+ 
X+ !!!!""!&h!!%!!!!!!!!!!2"J!!!!!1`!#J!!!!!![`%H!0%"EJ3%6h"PEJ!!!!!
X+ 
X+ !!!)l!&!#633'5'PNC'9Z!!!!!!$D!4m!l!&["!C$B@jMC@`!!!!!!#F"'J!k!A1
X+ 
X+ !!!!!!!!!4!%J!&B"F!3&4@TPBh4I!!!!!!"G!5!!E`&`"!9%FQPfCH!!!!!!!%-
X+ 
X+ !$!$e!4F!!!!!!!!!!`"Y!"8!R3!!!!!!!!#@!4X!P`&cJ!!!!!!!!!!#&!"P!R5
X+ 
X+ )!!!!!!!!!J!`!#B"4JJc8'aPBA0P)'a[Bf&dC9i`)'CTE'9H-5"H-Je[FL"`FQ9
X+ 
X+ cFb"$B@jMC@`JG'mJB@*[FR3Ze`!!!3!!!!,d!!!"p!!!!'`!35pd"B3!!!!F!&i
X+ 
X+ !!84-6dF!!3!54%P86!!"!#S!b!!!!!!!!!""e+6`B2rr!!!!k`""e03!b2rr!!!
X+ 
X+ !'3!!!!$`B2rr!!!""!""e,J09fKTBfJJEh"dD@pZ2d2M:
X*** /dev/null	Mon Feb 19 21:20:32 1990
X--- mac/MacAlert.c	Mon Feb 19 12:46:17 1990
X***************
X*** 0 ****
X--- 1,762 ----
X+ /*	SCCS Id: @(#)MacAlert.c		3.0	90/01/06
X+ /*      Copyright (c) Jon Watte  1989		*/ 
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ #include "hack.h"	/* */
X+ 
X+ /* UseMacAlert is like UseMacAlertText, but without the text parameter.
X+    This is so you can simply say "UseMacAlert(CAUTION)" or similar, if
X+    you use predefined alert numbers.
X+ */
X+ 
X+ 
X+ extern WindowPtr HackWindow;
X+ 
X+ 
X+ int
X+ UseMacAlert(MAno)
X+ int MAno;
X+ {
X+ 	return UseMacAlertText(MAno, 0L);
X+ }
X+ 
X+ 
X+ /* UseMacAlertText fetches a record in a resource of type MAlt, and uses
X+    this as a template calling MacAlert. This is so you can have ready-
X+    made resources, like ALRT templates, for your MacAlerts, which makes
X+    it easier to customize the program, and to translate it. It also
X+    makes for clearer code...
X+    
X+    If the txt argument is NULL, the text from the template is used,
X+    otherwise the sypplied text is used.
X+ */
X+ int
X+ UseMacAlertText(MAno, txt)
X+ int MAno;
X+ char * txt;
X+ {
X+ 	MAlrtHandle foo;
X+ 	MAlrtPtr bar;
X+ 	int item;
X+ 
X+ 	SetResLoad(1);
X+ 	foo = (MAlrtHandle) GetResource(MAtype, MAno);
X+ 	if(foo) {
X+ 		MoveHHi(foo);
X+ 		HLock(foo);
X+ 		bar = *foo;
X+ 		item = MacAlert(bar->width, bar->height, bar->PICTno,
X+ 			txt != 0L ? txt : bar->text, bar->but1, bar->but2, bar->but3,
X+ 			bar->but4, bar->def, bar->esc);
X+ 	} else {
X+ 		if(!flags.silent) SysBeep(20);
X+ 		item = -1;
X+ 	}
X+ 
X+ 	ReleaseResource(foo);
X+ 	DisposHandle(foo);
X+ 	return item;
X+ }
X+ 
X+ 
X+ /* This is the MacAlert function. It creates a new window, frames it
X+    (like a modal dialog) and tries to position the various buttons,
X+    text and picture in a reasonable way. The arguments are:
X+    
X+    width : width of the window. If less than a constant, it defaults
X+            to that constant.
X+    height: see width.
X+    PICTno: Resource ID of a PICT to display. If 0, no PICT is displayed.
X+    text  : the C string containing the relevant text to be displayed.
X+    but1 -: These are the button texts. Empty strings (they point at 0)
X+    - but4: makes that button go away. If all are empty, the default OK
X+            button text is used.
X+    def   : This is which button is default, starting button # 1.
X+    esc   : This is the button that corresponds to the ESC key.
X+ 
X+    The function returns the button hit, or maybe -1 on error.
X+ */
X+ int
X+ MacAlert(width, height, PICTno, text, but1, but2, but3, but4, def, esc)
X+ int width, height, PICTno;
X+ char * text,* but1, * but2, * but3, * but4;
X+ int def, esc;
X+ {
X+ 	PicHandle thePICT;
X+ 	char border[8];
X+ 	EventRecord theEvent;
X+ 	GrafPtr savedPort;
X+ 	WindowPtr theWindow, tmpWind;
X+ 	Rect bounds, textBox, brect[4];
X+ 	char hilite[4], * but[4], s1[2], s2[2];
X+ 	int nobutts, x, pool, spacing, heig, bwid[4],
X+ 		item, c, ret;
X+ 	long finalTicks;
X+ 
X+ 	memset(hilite, sizeof(hilite), 0);
X+ 	memset(bwid, sizeof(bwid), 0);
X+ 	SetCursor(&arrow);
X+ 	def--;
X+ 	esc--;
X+ 	GetPort(&savedPort);
X+ 
X+ 	if(PICTno)
X+ 		thePICT = (PicHandle) GetResource('PICT', PICTno);
X+ 	else
X+ 		thePICT = 0;
X+ 	if(thePICT) DetachResource(thePICT);
X+ 	bounds = (MAINGRAFPORT)->portRect;
X+ 
X+ 	but[0] = but1;
X+ 	but[1] = but2;
X+ 	but[2] = but3;
X+ 	but[3] = but4;
X+ 
X+ 	if(width > bounds.right) width = bounds.right;
X+ 	if(width < MIN_WIDTH) width = MIN_WIDTH;
X+ 	if(height > bounds.bottom) height = bounds.bottom;
X+ 	if(height < MIN_HEIGHT) height = MIN_HEIGHT;
X+ 
X+ 	InsetRect(&bounds, (int) ((bounds.right - width) >> 1), (int)
X+ 		((bounds.bottom - height) >> 1));
X+ 	theWindow = NewWindow(0L, &bounds, "", 1, plainDBox, 0L, 0, 0L);
X+ 	ShowWindow(theWindow);
X+ 	SelectWindow(theWindow);
X+ 	SetPort(theWindow);
X+ 	OffsetRect(&bounds, - bounds.left, - bounds.top);
X+ 
X+ 	nobutts = 0;
X+ 	if(but1[0]) nobutts=1;
X+ 	if(but2[0]) nobutts=2;
X+ 	if(but3[0]) nobutts=3;
X+ 	if(but4[0]) nobutts=4;
X+ 
X+ 	if(!nobutts) {
X+ 		but[0] = "OK";
X+ 		nobutts++;
X+ 	}
X+ 
X+ 	spacing = 0;
X+ 	for(x=0 ; x < nobutts; x++) {
X+ 		bwid[x] = TextWidth(but[x], 0, strlen(but[x])) + 2 * BUT_MARGIN;
X+ 		spacing += bwid[x] + BUT_SPACING;
X+ 	}
X+ 
X+ 	pool = bounds.right - 2 * BUT_MARGIN;
X+ 
X+ 	heig = 1;
X+ 	while(spacing / heig > pool - (nobutts - 1) * BUT_SPACING) {
X+ 		heig++;
X+ 	}
X+ 
X+ 	for(x=0; x<nobutts; x++) {
X+ 		bwid[x] = (int) ((float) bwid[x] / spacing * pool);
X+ 	}
X+ 
X+ 	pool = BUT_MARGIN + BUT_SPACING;
X+ 	heig = bounds.bottom - BUT_MARGIN - BUT_SPACING - BUT_HEIGHT * heig;
X+ 	for(x=0; x<nobutts; x++) {
X+ 		SetRect(&(brect[x]), pool, heig, pool + bwid[x], bounds.bottom -
X+ 			BUT_SPACING - BUT_MARGIN);
X+ 		pool += bwid[x] + BUT_SPACING;
X+ 		hilite[x] = 0;
X+ 	}
X+ 
X+ 	InsetRect(&bounds, 2, 2);
X+ 	textBox = bounds;
X+ 	if(thePICT) {
X+ 		textBox.left += (*thePICT)->picFrame.right;
X+ 	}
X+ 	textBox.left += 8;
X+ 	textBox.right -= 8;
X+ 	textBox.top += 8;
X+ 	textBox.bottom = heig - BUT_MARGIN;
X+ 	if(textBox.bottom < textBox.top + 15) {
X+ 		textBox.bottom = bounds.bottom - 8;
X+ 	}
X+ 
X+ 	goto mainLoop;
X+ 
X+ drawWindow:
X+ 	SetPort(theWindow);
X+ 	EraseRect(&(theWindow->portRect));
X+ 	PenNormal();
X+ 	PenSize(BORDER_WIDTH, BORDER_WIDTH);
X+ 	GetIndPattern((void *) border, 0, BORDER_PAT);
X+ 	PenPat(border);
X+ 	FrameRect(&bounds);
X+ 
X+ 	PenNormal();
X+ 
X+ 	if(thePICT) {
X+ 		HLock(thePICT);
X+ 		DrawPicture(thePICT, &((*thePICT)->picFrame));
X+ 		HUnlock(thePICT);
X+ 	}
X+ 
X+ 	PenNormal();
X+ 	TextFont(0);
X+ 	TextSize(12);
X+ 	TextBox(text, strlen(text), &textBox, teJustLeft);
X+ 
X+ 	for(x=0; x<nobutts; x++) {
X+ 		EraseRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X+ 		FrameRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X+ 		InsetRect(&(brect[x]), BUT_MARGIN, 3);
X+ 		TextBox(but[x], strlen(but[x]), &(brect[x]), teJustCenter);
X+ 		InsetRect(&(brect[x]), - BUT_MARGIN, - 3);
X+ 		if(hilite[x]) {
X+ 			InvertRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X+ 		}
X+ 		if(x == def) {
X+ 			PenSize(FRAME_WIDTH, FRAME_WIDTH);
X+ 			InsetRect(&(brect[x]), - FRAME_WIDTH - FRAME_OFFSET,
X+ 				- FRAME_WIDTH - FRAME_OFFSET);
X+ 			FrameRoundRect(&(brect[x]), FRAME_CORNER, FRAME_CORNER);
X+ 			InsetRect(&(brect[x]), FRAME_WIDTH + FRAME_OFFSET,
X+ 				FRAME_WIDTH + FRAME_OFFSET);
X+ 			PenNormal();
X+ 		}
X+ 	}
X+ 
X+ mainLoop:
X+ 	while(1) {
X+ 		if(WaitNextEvent(-1, &theEvent, 0L, 0L)) {
X+ 			switch(theEvent.what) {
X+ 
X+ 			case updateEvt :
X+ 				BeginUpdate((WindowPtr) theEvent.message);
X+ 				EndUpdate((WindowPtr) theEvent.message);
X+ 				goto drawWindow;
X+ 
X+ 			case mouseDown :
X+ 				if (FindWindow(theEvent.where, &tmpWind) < inContent ||
X+ 					tmpWind != theWindow) {
X+ 					if(!flags.silent) SysBeep(20);
X+ 					item = -1;
X+ 				} else {
X+ 					item = TrackThem(brect, hilite, nobutts);
X+ 				}
X+ 				if(item >= 0) {
X+ 					Delay(FLASH_TIME, &finalTicks);
X+ 					InvertRoundRect(&(brect[item]), BUT_CORNER, BUT_CORNER);
X+ 					ret = item + 1;
X+ 					goto getout;
X+ 				}
X+ 				break;
X+ 
X+ 			case keyDown :
X+ 				c = theEvent.message & 0xFF;
X+ 				if((c == 13) || (c == 3)) {
X+ 					if(def >= 0) {
X+ 						InvertRoundRect(&(brect[def]), BUT_CORNER, BUT_CORNER);
X+ 						Delay(FLASH_TIME, &finalTicks);
X+ 						InvertRoundRect(&(brect[def]), BUT_CORNER, BUT_CORNER);
X+ 						ret = def + 1;
X+ 						goto getout;
X+ 					}
X+ 				}
X+ 				if(c == 27) {
X+ 					if(esc >= 0) {
X+ 						InvertRoundRect(&(brect[esc]), BUT_CORNER, BUT_CORNER);
X+ 						Delay(FLASH_TIME, &finalTicks);
X+ 						InvertRoundRect(&(brect[esc]), BUT_CORNER, BUT_CORNER);
X+ 						ret = esc + 1;
X+ 						goto getout;
X+ 					}
X+ 				}
X+ 				for(x=0; x<nobutts; x++) {
X+ 					s1[0] = 1;
X+ 					s1[1] = c;
X+ 					s2[0] = 1;
X+ 					s2[1] = but[x][0];
X+ 					UprString(s1, 1);
X+ 					UprString(s2, 1);
X+ 					if(s1[1] == s2[1]) {
X+ 						InvertRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X+ 						Delay(FLASH_TIME, &finalTicks);
X+ 						InvertRoundRect(&(brect[x]), BUT_CORNER, BUT_CORNER);
X+ 						ret = x + 1;
X+ 						goto getout;
X+ 					}
X+ 				}
X+ 
X+ 				PenSize(FRAME_WIDTH, FRAME_WIDTH);
X+ 				InsetRect(&(brect[def]), - FRAME_WIDTH - FRAME_OFFSET,
X+ 					- FRAME_WIDTH - FRAME_OFFSET);
X+ 				PenMode(patXor);
X+ 				FrameRoundRect(&(brect[def]), FRAME_CORNER, FRAME_CORNER);
X+ 				InsetRect(&(brect[def]), FRAME_WIDTH + FRAME_OFFSET,
X+ 					FRAME_WIDTH + FRAME_OFFSET);
X+ 				PenNormal();
X+ 
X+ 				def++;
X+ 				def %= nobutts;
X+ 
X+ 				PenSize(FRAME_WIDTH, FRAME_WIDTH);
X+ 				InsetRect(&(brect[def]), - FRAME_WIDTH - FRAME_OFFSET,
X+ 					- FRAME_WIDTH - FRAME_OFFSET);
X+ 				FrameRoundRect(&(brect[def]), FRAME_CORNER, FRAME_CORNER);
X+ 				InsetRect(&(brect[def]), FRAME_WIDTH + FRAME_OFFSET,
X+ 					FRAME_WIDTH + FRAME_OFFSET);
X+ 				PenNormal();
X+ 
X+ 				break;
X+ 
X+ 			default:
X+ 				;
X+ 			}
X+ 		}
X+ 	}
X+ 
X+ getout:
X+ 	DisposeWindow(theWindow);
X+ 	if(thePICT) DisposHandle(thePICT);
X+ 	SetPort(savedPort);
X+ 	bounds = savedPort->portRect;
X+ 	InvalRect(&bounds);
X+ 
X+ 	return ret;
X+ }
X+ 
X+ 
X+ /* TrackThem is a help function to MacAlert, it tracks buttons,
X+    returns the button number (0 - (no_butts-1)) or -1 if no button
X+    was hit. */
X+ int
X+ TrackThem(b_rect, hi_lite, no_butts)
X+ Rect * b_rect;
X+ char * hi_lite;
X+ int no_butts;
X+ {
X+ Point p;
X+ int x, i;
X+ 
X+ 	while(Button()) {
X+ 		SystemTask();
X+ 		GetMouse(&p);
X+ 		for(x=0; x<no_butts; x++) {
X+ 			if(PtInRect(p, &(b_rect[x]))) {
X+ 				if(!hi_lite[x]) {
X+ 					hi_lite[x] = 1;
X+ 					InvertRoundRect(&(b_rect[x]), BUT_CORNER, BUT_CORNER);
X+ 				}
X+ 			} else {
X+ 				if(hi_lite[x]) {
X+ 					hi_lite[x] = 0;
X+ 					InvertRoundRect(&(b_rect[x]), BUT_CORNER, BUT_CORNER);
X+ 				}
X+ 			}
X+ 		}
X+ 	}
X+ 
X+ 	i = -1;
X+ 	for(x=0; x<no_butts; x++) {
X+ 		if(hi_lite[x]) i=x;
X+ 	}
X+ 
X+ 	return i;
X+ }
X+ 
X+ 
X+ /* #defines for the mini-pager */
X+ 
X+ #define QUIT_BUT 0
X+ #define TOP_BUT 1
X+ #define MORE_BUT 2
X+ #define MORE_TEXT	20
X+ #define LITTLE_MORE_TEXT 20
X+ #define TOP_TEXT	-2
X+ #define QUIT_PAGER	-1
X+ #define NULL_EVT	-3
X+ 
X+ 
X+ static Rect rectSave;
X+ static int window_inited = 0;
X+ 
X+ int more_disabled;
X+ 
X+ 
X+ void
X+ draw_box(char * whence, size_t length, Rect * where, int strip)
X+ {
X+ Point mark;
X+ size_t bar = 0;
X+ GrafPtr aPort;
X+ 
X+ 	TextFont(4);
X+ 	TextSize(9);
X+ 	GetPort(&aPort);
X+ 	ClipRect(where);
X+ 
X+ 	mark.h = where->left + 3;
X+ 	mark.v = where->top + 11;
X+ 
X+ 	while(length-- && mark.v < where->bottom) {
X+ 		MoveTo(mark.h, mark.v);
X+ 
X+ 		switch(whence[bar]) {
X+ 
X+ 		case 0x9:
X+ 			mark.h += 45;
X+ 			mark.h -= mark.h % 48;
X+ 			mark.h += 3;
X+ 			break;
X+ 
X+ 		case 0x7:
X+ 			if(!flags.silent) {
X+ 				if(!flags.silent) SysBeep(20);
X+ 			}
X+ 			break;
X+ 
X+ 		case 0xC:
X+ 			EraseRect(where);
X+ 			mark.h = where->left + 3;
X+ 			mark.v = where->top + 11;
X+ 			break;
X+ 
X+ 		case 0xA:
X+ 		case 0xD:
X+ 			if(strip) bar++;
X+ 			mark.h = where->left + 3;
X+ 			mark.v += 11;
X+ 			MoveTo(mark.h, mark.v);
X+ 			break;
X+ 
X+ 		default:
X+ 			if(PtInRect(mark, where))
X+ 				DrawChar(whence[bar]);
X+ 			mark.h += 6;
X+ 			break;
X+ 		}
X+ 		bar++;
X+ 	}
X+ 	ClipRect(&(aPort->portRect));
X+ }
X+ 
X+ 
X+ void
X+ draw_btns(Rect * buttons)
X+ {
X+ int i;
X+ 
X+ 	PenNormal();
X+ 
X+ 	TextFont(0);	/* System Font: usually Chicago */
X+ 	TextSize(12);	/* 12 pt */
X+ 	for(i=0; i<3; i++) {
X+ 		EraseRect(&(buttons[i]));
X+ 		FrameRoundRect(&(buttons[i]), BUT_CORNER, BUT_CORNER);
X+ 		MoveTo(buttons[i].left + 5, buttons[i].top + 13);
X+ 		DrawText("Quit TopMore", i * 4, 4);
X+ 	}
X+ 	if(more_disabled) {
X+ 		PenPat(patBic);
X+ 		PenPat(gray);
X+ 		PaintRoundRect(&(buttons[MORE_BUT]), BUT_CORNER, BUT_CORNER);
X+ 		PenNormal();
X+ 	}
X+ }
X+ 
X+ 
X+ static char lite[3] = { 0, 0, 0, };
X+ 
X+ 
X+ int
X+ how_scroll(Rect * btns, GrafPtr port)
X+ {
X+ EventRecord theEvent;
X+ int hit;
X+ long finalTicks;
X+ 
X+ 	while(!WaitNextEvent(everyEvent, &theEvent, 0L, 0L));
X+ 	SetPort(port);
X+ 	ClipRect(&(port->portRect));
X+ 
X+ 	switch(theEvent.what) {
X+ 
X+ 	case keyDown:
X+ 		switch(theEvent.message & 0xFF) {
X+ 
X+ 		case 0x20:
X+ 		case 'M':
X+ 		case 'm':
X+ 			if(!more_disabled) {
X+ 				InvertRoundRect(&(btns[MORE_BUT]), BUT_CORNER, BUT_CORNER);
X+ 				lite[MORE_BUT] = 1;
X+ 				return MORE_TEXT;
X+ 			} else if(!flags.silent) SysBeep(20);
X+ 			break;
X+ 
X+ 		case 0xD:
X+ 		case 0xA:
X+ 			if(!more_disabled) {
X+ 				InvertRoundRect(&(btns[MORE_BUT]), BUT_CORNER, BUT_CORNER);
X+ 				lite[MORE_BUT] = 1;
X+ 				return LITTLE_MORE_TEXT;
X+ 			} else if(!flags.silent) SysBeep(20);
X+ 			break;
X+ 
X+ 		case 'Q':
X+ 		case 'q':
X+ 		case 0x3:
X+ 		case 0x1B:
X+ 			InvertRoundRect(&(btns[QUIT_BUT]), BUT_CORNER, BUT_CORNER);
X+ 			return QUIT_PAGER;
X+ 
X+ 		case '.':		
X+ 			if(theEvent.modifiers & cmdKey) {
X+ 				InvertRoundRect(&(btns[QUIT_BUT]), BUT_CORNER, BUT_CORNER);
X+ 				return QUIT_PAGER;
X+ 			}
X+ 			break;
X+ 
X+ 		case 't':
X+ 		case 'T':
X+ 			InvertRoundRect(&(btns[TOP_BUT]), BUT_CORNER, BUT_CORNER);
X+ 			return TOP_TEXT;
X+ 
X+ 		default:
X+ 			if(!flags.silent) SysBeep(20);
X+ 		}
X+ 		break;
X+ 	case mouseDown:
X+ 		{
X+ 		WindowPtr xW;
X+ 		short part = FindWindow(theEvent.where, &xW);
X+ 			if(StripAddress(xW) != StripAddress(port)) {
X+ 				if(part == inDrag && theEvent.modifiers & cmdKey) {
X+ 				RgnHandle grayReg = GetGrayRgn();
X+ 				char hState = HGetState(grayReg);
X+ 					HLock(grayReg);
X+ 					DragWindow(xW, theEvent.where, &((*grayReg)->rgnBBox));
X+ 					HSetState(grayReg, hState);
X+ 				} else if(!flags.silent) SysBeep(20);
X+ 			} else {
X+ 				switch(part) {
X+ 	
X+ 				case inDrag:
X+ 					{
X+ 					RgnHandle grayReg = GetGrayRgn();
X+ 					char hState = HGetState(grayReg);
X+ 						HLock(grayReg);
X+ 						DragWindow(xW, theEvent.where, &((*grayReg)->rgnBBox));
X+ 						HSetState(grayReg, hState);
X+ 						rectSave = xW->portRect;
X+ 						LocalToGlobal((Point *) &(rectSave.top));
X+ 						LocalToGlobal((Point *) &(rectSave.bottom));
X+ 					}
X+ 					break;
X+ 	
X+ 				case inContent:
X+ 					hit = TrackThem(btns, lite, more_disabled ? 2 : 3);
X+ 					switch(hit) {
X+ 	
X+ 					case QUIT_BUT:
X+ 						return QUIT_PAGER;
X+ 	
X+ 					case TOP_BUT:
X+ 						return TOP_TEXT;
X+ 	
X+ 					case MORE_BUT:
X+ 						return MORE_TEXT;
X+ 	
X+ 					default:
X+ 						if(!flags.silent) SysBeep(20);
X+ 					}
X+ 					break;
X+ 	
X+ 				case inGoAway:
X+ 					if(TrackGoAway (xW, theEvent.where)) return QUIT_PAGER;
X+ 					break;
X+ 
X+ 				default:
X+ 					if(!flags.silent) SysBeep(20);
X+ 					break;
X+ 	
X+ 				}
X+ 			}
X+ 		}
X+ 		break;
X+ 
X+ 	case updateEvt:
X+ 		BeginUpdate((WindowPtr) theEvent.message);
X+ 		if(StripAddress(theEvent.message) ==
X+ 			StripAddress(FrontWindow())) {
X+ 			EndUpdate((WindowPtr) theEvent.message);
X+ 			return 0;
X+ 		} else if(StripAddress(HackWindow) ==
X+ 			StripAddress(theEvent.message)) {
X+ 			SetPort(HackWindow);
X+ 			docrt();
X+ 			SetPort(port);
X+ 		}
X+ 		EndUpdate((WindowPtr) theEvent.message);
X+ 		break;
X+ 
X+ 	default:
X+ 		break;
X+ 	}
X+ 	return NULL_EVT;
X+ }
X+ 
X+ 
X+ void
X+ display_data(char * buffer, size_t length, int strip, WindowPtr window)
X+ {
X+ Rect buttons[3], text_area, bounds;
X+ size_t b_index = 0;
X+ short pgEvent, bar, i;
X+ 
X+ 	more_disabled = 0;
X+ 	text_area = window->portRect;
X+ 	OffsetRect(&text_area, text_area.left, text_area.top);
X+ 	InsetRect(&text_area, 3, 3);
X+ 	bounds = text_area;
X+ 	text_area.bottom -= 30;
X+ 
X+ 	PenNormal();
X+ 
X+ 	buttons[QUIT_BUT].left = bounds.left;
X+ 	buttons[QUIT_BUT].top = bounds.bottom - 18;
X+ 	buttons[QUIT_BUT].right = bounds.left + 39;
X+ 	buttons[QUIT_BUT].bottom = bounds.bottom;
X+ 
X+ 	i = bounds.right;
X+ 
X+ 	buttons[MORE_BUT].left = i - 45;
X+ 	buttons[MORE_BUT].top = bounds.bottom - 18;
X+ 	buttons[MORE_BUT].right = i;
X+ 	buttons[MORE_BUT].bottom = bounds.bottom;
X+ 
X+ 	buttons[TOP_BUT].left = i - 90;
X+ 	buttons[TOP_BUT].top = bounds.bottom - 18;
X+ 	buttons[TOP_BUT].right = i - 50;
X+ 	buttons[TOP_BUT].bottom = bounds.bottom;
X+ 
X+ 	do {
X+ 		bar = 0;
X+ 		pgEvent = how_scroll(buttons, window);
X+ 		if(pgEvent > 0) bar = MORE_BUT;
X+ 		if(pgEvent == TOP_TEXT) {
X+ 			EraseRect(&text_area);
X+ 			more_disabled = 0;
X+ 			b_index = 0;
X+ 			bar = TOP_BUT;
X+ 			pgEvent = 0;
X+ 		}
X+ 		if(pgEvent == 0) {
X+ 			draw_btns(buttons);
X+ 			lite[TOP_BUT] = 0;
X+ 		}
X+ 		if(pgEvent == NULL_EVT) {
X+ 			pgEvent = 0;
X+ 		} else {
X+ 		int f = 0;
X+ 			if(pgEvent > 0) f = 1;
X+ 			while(pgEvent > 0 && b_index < length) {
X+ 				while(buffer[b_index] != '\r' && b_index < length) b_index++;
X+ 				if(buffer[b_index++] == '\r') pgEvent--;
X+ 				else break;
X+ 			}
X+ 			if(!pgEvent) {
X+ 				if(f) EraseRect(&text_area);
X+ 				draw_box(&(buffer[b_index]), length - b_index, &text_area, strip);
X+ 			} else if(pgEvent > 0) {
X+ 				PenMode(patOr);
X+ 				PenPat(gray);
X+ 				PaintRoundRect(&(buttons[MORE_BUT]), BUT_CORNER,
X+ 					BUT_CORNER);
X+ 				more_disabled = 1;
X+ 				PenNormal();
X+ 			}
X+ 			if(lite[bar])
X+ 				InvertRoundRect(&(buttons[bar]), BUT_CORNER, BUT_CORNER);
X+ 		}
X+ 		for(i=0; i<3; i++) lite[i] = 0;
X+ 
X+ 	} while (pgEvent >= 0);
X+ }
X+ 
X+ 
X+ int
X+ mac_more(FILE * fp, int strip)
X+ {
X+ size_t where, length, b_index;
X+ char ** buffer, c;
X+ WindowRecord pageWindow;
X+ WindowPtr oldWindow;
X+ GrafPtr oldPort;
X+ extern WindowPtr HackWindow;
X+ 
X+ 	GetPort(&oldPort);
X+ 	oldWindow = FrontWindow();
X+ 	InitCursor();
X+ 
X+ 	SelectWindow(HackWindow);
X+ 	SetPort(HackWindow);
X+ 	EraseRect(&(HackWindow->portRect));
X+ 	docrt();
X+ 	ValidRect(&(HackWindow->portRect));
X+ 		
X+ 	where = ftell(fp);
X+ 	fseek(fp, 0, SEEK_END);
X+ 	length = ftell(fp);
X+ 	fseek(fp, where, SEEK_SET);
X+ 
X+ 	if(length - where < 1)
X+ 		return -1;
X+ 	if((buffer = (char **) NewHandle(length)) == NULL)
X+ 		return -1;
X+ 	if(MemError()) {
X+ 		DisposHandle(buffer);
X+ 		return -1;
X+ 	}
X+ 
X+ 	MoveHHi(buffer);
X+ 	HLock(buffer);
X+ 
X+ 	fread(*buffer, sizeof(char), length - where, fp);
X+ 	c = (*buffer)[length - where - 1];
X+ 	if(!(c == 0xD || c == 0xA || c == 0)) {
X+ 		(*buffer)[length - where - 1] = 0;
X+ 	}
X+ 
X+ 	while(where < length) {
X+ 		c = (*buffer)[where];
X+ 		if(c == '\n' || c == 0xC || c == 0)
X+ 			c =(*buffer)[where] = '\r';
X+ 		where++;
X+ 	}
X+ 
X+ 	if(!window_inited) {
X+ 		rectSave = thePort->portRect;
X+ 		rectSave.left = rectSave.right - 490;
X+ 		rectSave.top = rectSave.bottom - 270;
X+ 		OffsetRect(&rectSave, 10 - (rectSave.left >> 1), 40 - (rectSave.top >> 1));
X+ 		window_inited = 1;
X+ 	}
X+ 
X+ 	(void) NewWindow(&pageWindow, &rectSave, "\011Hack-Info", TRUE, documentProc,
X+ 		0L, TRUE, 0L);
X+ 	SelectWindow(&pageWindow);
X+ 	SetPort(&pageWindow);
X+ 	ClipRect(&(pageWindow.port.portRect));
X+ 
X+ 	display_data(*buffer, length, strip, (WindowPtr) &pageWindow);
X+ 	HUnlock(buffer);
X+ 	DisposHandle(buffer);
X+ 
X+ 	Delay(FLASH_TIME, &where);
X+ 	CloseWindow(&pageWindow);
X+ 	SelectWindow(oldWindow);
X+ 	SetPort(oldWindow);
X+ 	if(StripAddress(oldWindow) == StripAddress(HackWindow)) {
X+ 		EraseRect(&(oldWindow->portRect));
X+ 		ValidRect(&(oldWindow->portRect));
X+ 		docrt();
X+ 	}
X+ 	SetPort(oldPort);
X+ 	return 0;
X+ }
X+ 
X*** mac/Old/mac.c	Mon Feb 19 21:22:25 1990
X--- mac/mac.c	Mon Feb 19 13:40:22 1990
X***************
X*** 11,16 ****
X--- 11,24 ----
X  WindowPtr	HackWindow;	/* points to Hack's window */
X  extern char	*keys[8];
X  extern short macflags;
X+ short cursorPos=0;
X+ short repDelay;
X+ long lastMD;
X+ struct line {
X+ 	struct line *next_line;
X+ 	char *line_text;
X+ } *mactexthead;
X+ short maclinect, macmaxlen;
X  
X  int
X  tgetch()
X***************
X*** 18,27 ****
X  {
X  	char	ch;
X  	EventRecord	theEvent;
X! 	Rect cursorRect;
X  	long	message,cursorTime,start;
X  	MenuHandle	theMenu;
X! 	short	keyCode;
X  	term_info	*t;
X  	boolean	noControlKey;
X  	GrafPtr	oldPort,oldPort1;
X--- 26,36 ----
X  {
X  	char	ch;
X  	EventRecord	theEvent;
X! 	Rect cursorRect,box,windowRect;
X  	long	message,cursorTime,start;
X  	MenuHandle	theMenu;
X! 	register short	keyCode;
X! 	short	temp;
X  	term_info	*t;
X  	boolean	noControlKey;
X  	GrafPtr	oldPort,oldPort1;
X***************
X*** 28,46 ****
X  	static char nextCommand;
X  	short aboutBox();
X  	char mButtonDown();
X  #define noEscapeKey	noControlKey
X  #define	clearKey	0x47
X  #define ESCAPEkey	0x1B
X  	
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	cursorRect.left = t->tcur_x * t->charWidth + Screen_Border;
X  	cursorRect.right = cursorRect.left + t->charWidth - 1;
X  	cursorRect.top = t->height * t->tcur_y + Screen_Border;
X  	cursorRect.bottom = cursorRect.top + t->height;
X! 	cursorTime = GetCaretTime()/2;
X! 	keyCode = 0;
X  	noControlKey = (t->system.keyBoardType <= envMacPlusKbd) ? TRUE : FALSE;
X! 	
X  	/* permit use of cursor keys and numeric keypad */
X  	/* does the same translation as in msdos.c but includes cursor keys */
X  	ch = '\0';
X--- 37,62 ----
X  	static char nextCommand;
X  	short aboutBox();
X  	char mButtonDown();
X+ 	Point	mouseLoc;
X+ 	WindowPtr	theWindow;
X+ 	void	doUpdate();
X  #define noEscapeKey	noControlKey
X  #define	clearKey	0x47
X  #define ESCAPEkey	0x1B
X  	
X  	t = (term_info *)GetWRefCon(HackWindow);
X+ 	mouseLoc.h = (macflags & fMoveWRTMouse) ? t->tcur_x : (u.ux-1);
X+ 	mouseLoc.v = (macflags & fMoveWRTMouse) ? t->tcur_y : (u.uy+1);
X  	cursorRect.left = t->tcur_x * t->charWidth + Screen_Border;
X  	cursorRect.right = cursorRect.left + t->charWidth - 1;
X  	cursorRect.top = t->height * t->tcur_y + Screen_Border;
X  	cursorRect.bottom = cursorRect.top + t->height;
X! 	cursorTime = GetCaretTime();
X  	noControlKey = (t->system.keyBoardType <= envMacPlusKbd) ? TRUE : FALSE;
X! 	box.left = mouseLoc.h * t->charWidth + Screen_Border;
X! 	box.right = box.left + t->charWidth;
X! 	box.top = mouseLoc.v * t->height + Screen_Border + t->height/2 - (t->charWidth/2);
X! 	box.bottom = box.top + t->charWidth;
X  	/* permit use of cursor keys and numeric keypad */
X  	/* does the same translation as in msdos.c but includes cursor keys */
X  	ch = '\0';
X***************
X*** 61,225 ****
X  	}
X  	GetPort(&oldPort);
X  	SetPort(HackWindow);
X! 	while (!ch) {
X! 		keyCode = 0;
X! 	    GetPort(&oldPort1);
X! 	    SetPort((GrafPtr)HackWindow);
X! 	    /* do cursor blinking */
X! 	    message = TickCount() + cursorTime;
X! 	    while (!WaitNextEvent(everyEvent, &theEvent, 10L, 0L)) {
X! 		/* wait until something occurs */
X! 		if (!Invisible) {
X! 		    if (TickCount() > message) {
X! 			InvertRect(&cursorRect);
X! 			message = TickCount() + cursorTime;
X! 			keyCode = !keyCode;
X! 		    }
X! 		}
X! 	    }
X! 	    if (keyCode)
X  		InvertRect(&cursorRect);
X! 	    SetPort(oldPort1);
X! 	    if (theEvent.what == keyDown || theEvent.what == autoKey) {
X! 		/* use raw key codes */
X! 		keyCode = (LoWord(theEvent.message) & keyCodeMask)>>8;
X! 		if (keyCode == 50 && noEscapeKey)
X! 		    ch = (char)ESCAPEkey;	/* ESC */
X! 		else if (keyCode == clearKey) {
X! 		    macflags = macflags ^ fToggleNumPad;
X! 		    SetWTitle(HackWindow,
X! 			    (macflags & fToggleNumPad)	? "\015NetHack [MOV]"
X! 							: "\015NetHack [NUM]");
X! 		} else if ((macflags & fToggleNumPad) &&
X! 				(keyCode>64 && keyCode<127))
X! 		    ch = t->keyMap[keyCode-65];
X! 		/* make the command key = control key on old Mac keyboards */
X! 		if ((theEvent.modifiers & cmdKey) && noControlKey) {
X! 		    ch = (char)(theEvent.message & 0x1F);
X! 		}
X! 		if ((theEvent.modifiers & shiftKey) && (ch)) {
X! 		    ch = (ch == '.') ? ':' : (char)toupper(ch);
X! 		}
X! 		if (theEvent.modifiers & optionKey) {
X! 		    for(start = 43; start < 56; start++) {
X! 			if (t->keyMap[start] == (char)(theEvent.message & 0xFFL)) {
X! 			    ch = t->keyMap[start - 13];
X! 			    break;
X! 			}
X! 		    }
X! 		}
X! 		/* not a cursor key or from the numeric keypad */
X! 		if (!ch && keyCode != clearKey) {
X! 		    ch = (char)(theEvent.message & 0xFF);
X! 		}
X! 	    } else {
X  		/* what other events to handle */
X! 		switch (theEvent.what) {		
X! 		    case nullEvent:
X! 			SetCursor(&ARROW_CURSOR);
X! 			break;
X! 		    case app4Evt:
X! #define	kSuspendResumeMessage 1  /* high byte of suspend/resume event message */
X! #define	SuspResIsResume(evtMessage)	((evtMessage) & 0x00000001)
X! 
X! 			switch (theEvent.message >> 24) {
X! 			    case kSuspendResumeMessage:
X! 				if (!SuspResIsResume(theEvent.message)) {
X! 				    /* ---------- SUSPEND EVENT ------------ */
X! 				    if (macflags & fZoomOnContextSwitch)	
X! 					SizeWindow(HackWindow,60,60,TRUE);
X! 				} else {
X! 				    /* ---------- RESUME EVENT ------------- */
X! 				    if (macflags & fZoomOnContextSwitch)	
X! 					SizeWindow(HackWindow,
X! 					 (t->maxCol * t->charWidth) + 2*Screen_Border,
X! 					 (t->maxRow * t->height) + 2*Screen_Border,
X! 					 TRUE);
X  				}
X  				break;
X! 			}
X! 			break;
X  		
X! 		    case updateEvt:
X! 			if (HackWindow == (WindowPtr)theEvent.message) {
X! #ifdef TEXTCOLOR
X! 			    if (t->system.hasColorQD) {
X! 				Rect	r;
X! 				GDHandle	gd;
X! 				
X! 				r = (**(*(WindowPeek)HackWindow).contRgn).rgnBBox;
X! 				LocalToGlobal(&r.top);
X! 				LocalToGlobal(&r.bottom);
X! 				gd = GetMaxDevice(&r);
X! 				HLock((Handle)gd);
X! 				t->inColor = (**(**gd).gdPMap).pixelSize > 1;
X! 				HUnlock((Handle)gd);
X! 			    }
X! #endif
X! 			    GetPort(&oldPort);
X! 			    SetPort((GrafPtr)HackWindow);
X! 			    BeginUpdate(HackWindow);
X! 			    t = (term_info *)GetWRefCon(HackWindow);
X! 			    if (t->inColor && macflags & fDoUpdate) {
X! 				keyCode = flags.toplin;
X! 				flags.toplin = 0;
X! 				docrt();
X! 				flags.toplin = keyCode;
X! 			    } else {
X! 				for (keyCode = 0;keyCode < t->maxRow; keyCode++) {
X! 				    MoveTo(Screen_Border,
X! 					    t->ascent + (keyCode * t->height)
X! 						    + Screen_Border);
X! 				    DrawText(&t->screen[keyCode][0], 0, t->maxCol);
X  				}
X! 			    }
X! 			    EndUpdate(HackWindow);
X! 			    SetPort(oldPort);
X! 			} 
X! 			break;
X  				
X! 		    case activateEvt:
X! 			if (HackWindow == (WindowPtr)theEvent.message) {
X! 			    if (theMenu = GetMHandle(editMenu)) {
X! 				if (theEvent.modifiers & activeFlag) {
X! 				    if (macflags & fDoUpdate) {
X! 					SetMenuBar(t->fullMBarHandle);
X! 					for (keyCode = fileMenu;
X! 					      keyCode <= extendMenu;keyCode++) {
X! 					    if (keyCode != editMenu)
X! 						EnableItem(GetMHandle(keyCode), 0);
X  					}
X- 					EnableItem(GetMHandle(appleMenu), 1);
X- 				    }
X- 				    DisableItem(theMenu, 0);
X- 				} else {
X- 				    EnableItem(theMenu, 0);
X- 				    if (macflags & fDoUpdate) {
X- 					SetMenuBar(t->shortMBarHandle);
X- 					for (keyCode = fileMenu;
X- 					      keyCode <= extendMenu;keyCode++) {
X- 					    if (keyCode != editMenu)
X- 						DisableItem(GetMHandle(keyCode), 0);
X- 					}
X- 					DisableItem(GetMHandle(appleMenu), 1);
X- 				    }
X  				}
X! 				DrawMenuBar();
X! 			    }
X! 			}
X! 			break;
X  				
X! 		    case mouseDown:
X! 			ch = mButtonDown(theEvent, t, &nextCommand);
X! 			break;
X! 		}
X! 	    }		
X  	}
X  	SetPort(oldPort);
X- 	ObscureCursor();
X  	return ((ch == '\r') ? '\n' : ch);
X  }
X  
X  char
X  mButtonDown(theEvent, t, nextCommand)
X  EventRecord	theEvent;
X--- 77,385 ----
X  	}
X  	GetPort(&oldPort);
X  	SetPort(HackWindow);
X! 	if (!(macflags & fDoNonKeyEvt)) {
X! 		cursorPos = -1;
X! 		SetCursor(&ARROW_CURSOR);
X! 	}
X! 	/* do cursor blinking */
X! 	message = TickCount() + cursorTime;
X! 	if (!EventAvail(keyDownMask|mDownMask|autoKeyMask,&theEvent)) {
X! 		keyCode = true;
X  		InvertRect(&cursorRect);
X! 	} else
X! 		keyCode = 0;
X! 	while (!ch) {
X! 		(void)WaitNextEvent(everyEvent, &theEvent, 0L, 0L);
X! 		if (theEvent.what == keyDown || theEvent.what == autoKey) {
X! 			ch = 0;
X! 			ObscureCursor();
X! 			/* use raw key codes */
X! 			temp = keyCode;
X! 			keyCode = (LoWord(theEvent.message) & keyCodeMask)>>8;
X!  			if (keyCode == clearKey) {
X! 				macflags = macflags ^ fToggleNumPad;
X! 				SetWTitle(HackWindow,
X! 					(macflags & fToggleNumPad)	? "\016NetHack [MOVE]"
X! 												: "\015NetHack [NUM]");
X! 				keyCode = temp;
X! 				ch = 0;
X! 				continue;
X! 			}
X! 			if (temp)
X! 				InvertRect(&cursorRect);
X! 			if ((macflags & fToggleNumPad) && (keyCode>0x40 &&keyCode < 0x5D) 
X! 				|| (keyCode > 0x7A && keyCode<0x7F)) {
X! 				ch = t->keyMap[keyCode-65];
X! 				if ((theEvent.modifiers & shiftKey) && (ch)) {
X! 					ch = (ch == '.') ? ':' : (char)toupper(ch);
X! 				}
X! 				if (ch)
X! 					break;
X! 			}
X! 			if (keyCode == 50 && noEscapeKey) {
X! 				ch = (char)ESCAPEkey;	/* ESC */
X! 				break;
X! 			}			/* make the command key = control key on old Mac keyboards */
X! 			if ((theEvent.modifiers & cmdKey) && noControlKey) {
X! 				ch = (char)(theEvent.message & 0x1F);
X! 				break;
X! 			}
X! 			if (theEvent.modifiers & optionKey) {
X! 				for(start = 43; start < 56; start++) {
X! 					if (t->keyMap[start] == (char)(theEvent.message & 0xFFL)) {
X! 						ch = t->keyMap[start - 13];
X! 						break;
X! 					}
X! 				}
X! 			}
X! 			/* not a cursor key or from the numeric keypad */
X! 			if (!ch) {
X! 				ch = (char)(theEvent.message & 0xFF);
X! 			}
X! 		} else {
X  		/* what other events to handle */
X! 			switch (theEvent.what) {		
X! 			case nullEvent:
X! 				GetPort(&oldPort1);
X! 				SetPort((GrafPtr)HackWindow);
X! 				/* wait until something occurs */
X! 				if (TickCount() > message) {
X! 					message = TickCount() + cursorTime;
X! 					if (!(macflags & fMoveWRTMouse)
X! 						|| (macflags & fMoveWRTMouse && !keyCode)) {
X! 						InvertRect(&cursorRect);
X! 						keyCode = !keyCode;
X! 					}
X! 				}
X! 				if (FrontWindow() == HackWindow && (macflags & fDoNonKeyEvt)) {
X! 					if ((FindWindow(theEvent.where,&theWindow) == inContent)
X! 						&& (macflags & fDoUpdate) && (HackWindow == theWindow)) {
X! 						
X! 						GetMouse(&mouseLoc);
X! 						if (PtInRect(mouseLoc,&box)) {
X! 							CursHandle theCurs;
X! 							
X! 							theCurs = GetCursor(3);
X! 							cursorPos = 8;
X! 							SetCursor(*theCurs);
X! 						} else {
X! 							PtToAngle(&box,mouseLoc,&temp);
X! 							if (temp >336 || temp < 23) {
X! 								temp = 0;
X! 							} else {
X! 								temp = (temp + 23)/45;
X! 							}
X! 							if (temp >=0 && temp <8 && cursorPos != temp) {
X! 								SetCursor(*t->cursor[temp]);
X! 								cursorPos = temp;
X! #ifdef THINK_C
X! 								repDelay = KeyThresh*2;
X! #else
X! 								repDelay = 42;
X! #endif
X! 								lastMD = theEvent.when;
X! 							}
X! 						}
X! 					} else if (cursorPos>=0) {
X! 						cursorPos = -1;
X! 						SetCursor(&ARROW_CURSOR);
X! 					}
X  				}
X+ 				if (StillDown() && cursorPos>=0 && cursorPos < 8
X+ 					&& TickCount() > lastMD+repDelay) {
X+ 					ch = mButtonDown(theEvent, t, &nextCommand);
X+ 					if (repDelay) {
X+ #ifdef THINK_C
X+ 						repDelay = KeyRepThresh*2;
X+ #else
X+ 						repDelay /= 3;
X+ #endif
X+ 					}
X+ 					lastMD = TickCount();
X+ 					/*return ch;*/
X+ 				}			
X+ 				SetPort(oldPort1);
X  				break;
X! 			case app4Evt:
X! #define	kSuspendResumeMessage	1		/* high byte of suspend/resume event message */
X! #define	kMouseMovedMessage		0xFA	/* high byte of mouse-moved event message */
X! #define	SuspResIsResume(evtMessage)		((evtMessage) & 0x00000001)
X! 
X! 				switch (theEvent.message >> 24) {
X! 					case kSuspendResumeMessage:
X! 						if (!SuspResIsResume(theEvent.message)) {
X! 						/* ---------- SUSPEND EVENT ------------ */
X! 							if (macflags & fZoomOnContextSwitch
X! 								&& !EmptyRect(&(**(HackWindow)->visRgn).rgnBBox))
X! 							{
X! 								InvalRect(&HackWindow->portRect);
X! 								SizeWindow(HackWindow,60,60,FALSE);
X! 							}
X! 						} else {
X! 						/* ---------- RESUME EVENT ------------- */
X! 							if (macflags & fZoomOnContextSwitch) {
X! 								SizeWindow(HackWindow,
X! 								 (t->maxCol * t->charWidth) + 2 * Screen_Border,
X! 								 (t->maxRow * t->height) + 2 * Screen_Border,
X! 								 TRUE);
X! 								SetPort(HackWindow);
X! 								InvalRect(&HackWindow->portRect);
X! 								if ((int) (theMenu = GetMHandle(editMenu))
X! 									&& FrontWindow() == HackWindow) {
X! 									SetMenuBar(t->fullMBarHandle);
X! 									for (temp = fileMenu;temp <= extendMenu;temp++) {
X! 									if (temp != editMenu)
X! 										EnableItem(GetMHandle(temp), 0);
X! 									}
X! 									EnableItem(GetMHandle(appleMenu), 1);
X! 									DisableItem(theMenu, 0);
X! 									DrawMenuBar();
X! 								}
X! 							}
X! 						}
X! 						break;
X! 				}
X! 				break;
X  		
X! 			case updateEvt:
X! 				if (HackWindow == (WindowPtr)theEvent.message) {
X! 					doUpdate(t);
X  				}
X! 				break;
X  				
X! 			case activateEvt:
X! 				if (HackWindow == (WindowPtr)theEvent.message) {
X! 					if (theMenu = GetMHandle(editMenu)) {
X! 						if (theEvent.modifiers & activeFlag) {
X! 							if (macflags & fDoUpdate) {
X! 								SetMenuBar(t->fullMBarHandle);
X! 								for (temp = fileMenu;temp <= extendMenu;temp++) {
X! 									if (temp != editMenu)
X! 										EnableItem(GetMHandle(temp), 0);
X! 								}
X! 								EnableItem(GetMHandle(appleMenu), 1);
X! 							}
X! 							DisableItem(theMenu, 0);
X! 						} else {
X! 							EnableItem(theMenu, 0);
X! 							if (macflags & fDoUpdate) {
X! 								SetMenuBar(t->shortMBarHandle);
X! 								for (temp = fileMenu;temp <= extendMenu;temp++) {
X! 									if (temp != editMenu)
X! 										DisableItem(GetMHandle(temp), 0);
X! 								}
X! 								DisableItem(GetMHandle(appleMenu), 1);
X! 							}
X! 						}
X! 						DrawMenuBar();
X  					}
X  				}
X! 				break;
X  				
X! 			case mouseDown:
X! 				ch = mButtonDown(theEvent, t, &nextCommand);
X! 				break;
X! 			}
X! 		}		
X  	}
X+ 	if (keyCode && ch && (theEvent.what != keyDown && theEvent.what != autoKey))
X+ 		InvertRect(&cursorRect);
X+ 
X  	SetPort(oldPort);
X  	return ((ch == '\r') ? '\n' : ch);
X  }
X  
X+ void
X+ doUpdate(t)
X+ term_info	*t;
X+ {
X+ 	short	temp;
X+ 	GrafPtr	oldPort;
X+ #ifdef TEXTCOLOR
X+ 	if (t->system.hasColorQD) {
X+ 		Rect	r;
X+ 		GDHandle	gd;
X+ 		
X+ 		r = (**(*(WindowPeek)HackWindow).contRgn).rgnBBox;
X+ 		LocalToGlobal(&r.top);
X+ 		LocalToGlobal(&r.bottom);
X+ 		gd = GetMaxDevice(&r);
X+ 		HLock((Handle)gd);
X+ 		t->inColor = (**(**gd).gdPMap).pixelSize > 1;
X+ 		HUnlock((Handle)gd);
X+ 	}
X+ #endif
X+ 	GetPort(&oldPort);
X+ 	SetPort((GrafPtr)HackWindow);
X+ 	BeginUpdate(HackWindow);
X+ 	if (t->inColor && (macflags & fDoUpdate) && !(macflags & 0x2000)) {
X+ 		char	*tmp;
X+ 		short	x,y;
X+ 		
X+ 		tmp = calloc(2*t->maxCol, sizeof(char));
X+ 		BlockMove(t->screen[0], tmp, t->maxCol);
X+ 		BlockMove(t->screen[1], &tmp[t->maxCol], t->maxCol);
X+ 		x = t->tcur_x;
X+ 		y = t->tcur_y;
X+ 		temp = flags.toplin;
X+ 		flags.toplin = 0;
X+ 		docrt();
X+ 		flags.toplin = temp;
X+ 		BlockMove(tmp, t->screen[0], t->maxCol);
X+ 		BlockMove(&tmp[t->maxCol], t->screen[1], t->maxCol);
X+ 		free(tmp);
X+ 		t->tcur_y = y;
X+ 		t->tcur_x = x;
X+ 	}
X+ 	if (macflags & fDoUpdate) {
X+ 		for (temp = 0;
X+ 			temp < ((t->inColor && !(macflags & fFullScrKluge))
X+ 				? 2 : t->maxRow);
X+ 			temp++) {
X+ 			if ((macflags & fScreenKluges) == fScreenKluges
X+ 				&& temp == t->maxRow-1){
X+ 				if(flags.standout)
X+ 					standoutbeg();
X+ 			}
X+ 			MoveTo(Screen_Border,
X+ 				t->ascent + (temp * t->height) + Screen_Border);
X+ 			DrawText(&t->screen[temp][0], 0, t->maxCol);
X+ 			if ((macflags & fScreenKluges) == fScreenKluges
X+ 				&& temp == t->maxRow-1){
X+ 				if(flags.standout)
X+ 					standoutend();
X+ 			}
X+ 		}
X+ 
X+ 		if (macflags & fDisplayKluge) {
X+ 			register struct line *tl;
X+ 			int curline, lth;
X+ 			
X+ 		    if(flags.toplin == 1) more();	/* ab@unido */
X+ 		    remember_topl();
X+ 		
X+ 		    lth = CO - macmaxlen - 2;		   /* Use full screen width */
X+ 		    if (maclinect < LI && lth >= 10) {		     /* in a corner */
X+ 				home ();
X+ 				cl_end ();
X+ 				flags.toplin = 0;
X+ 				curline = 1;
X+ 				for (tl = mactexthead; tl; tl = tl->next_line) {
X+ 				    curs (lth, curline);
X+ 				    if(curline > 1)
X+ 						cl_end ();
X+ 				    xputs(tl->line_text);
X+ 				    curx = curx + strlen(tl->line_text);
X+ 				    curline++;
X+ 				}
X+ 				curs (lth, curline);
X+ 			}
X+ 		}
X+ 	}
X+ 	EndUpdate(HackWindow);
X+ 	SetPort(oldPort);
X+ }
X+ 
X  char
X  mButtonDown(theEvent, t, nextCommand)
X  EventRecord	theEvent;
X***************
X*** 236,243 ****
X  	GrafPtr	oldPort;
X  
X  	ch = '\0';
X! 	if (macflags & fDoNonKeyEvt) 
X! 	switch (FindWindow(theEvent.where,&theWindow)) {
X  	    case inMenuBar:
X  
X  		SetCursor(&ARROW_CURSOR);
X--- 396,403 ----
X  	GrafPtr	oldPort;
X  
X  	ch = '\0';
X! 	if (macflags & fDoNonKeyEvt) {
X! 		switch (FindWindow(theEvent.where,&theWindow)) {
X  	    case inMenuBar:
X  
X  		SetCursor(&ARROW_CURSOR);
X***************
X*** 251,257 ****
X  			(void)SystemEdit((short)message - 1);
X  			break;
X  		    case appleMenu:
X! 			if (LoWord(message) > 2) {
X  			    GetItem(GetMHandle(HiWord(message)),LoWord(message),
X  					deskacc);
X  			    SetMenuBar(t->shortMBarHandle);
X--- 411,417 ----
X  			(void)SystemEdit((short)message - 1);
X  			break;
X  		    case appleMenu:
X! 			if (LoWord(message) > 1) {
X  			    GetItem(GetMHandle(HiWord(message)),LoWord(message),
X  					deskacc);
X  			    SetMenuBar(t->shortMBarHandle);
X***************
X*** 324,339 ****
X  		}
X  		menuBar = (ROM85 == -1) ? 20 : GetMBarHeight();
X  
X! 		SetRect(&boundsRect, Screen_Border, menuBar + Screen_Border,
X! 			SCREEN_BITS.bounds.right - Screen_Border,
X! 			SCREEN_BITS.bounds.bottom - Screen_Border);
X  		SetCursor(&ARROW_CURSOR);
X  		DragWindow(theWindow, theEvent.where, &boundsRect);
X  		break;
X  	
X! 	    case inContent:
X! 		SelectWindow(theWindow);
X  		break;
X  	}
X  	return ch;
X  }
X--- 484,557 ----
X  		}
X  		menuBar = (ROM85 == -1) ? 20 : GetMBarHeight();
X  
X! 		{
X! 		RgnHandle fooRgn = GetGrayRgn();
X! 			boundsRect = (*fooRgn)->rgnBBox;
X! 		}
X  		SetCursor(&ARROW_CURSOR);
X  		DragWindow(theWindow, theEvent.where, &boundsRect);
X  		break;
X  	
X! 	case inContent:
X! 		if (theWindow != FrontWindow()) {
X! 			SelectWindow(theWindow);
X! 		} else if (theWindow == HackWindow) {
X! 			Point	mouseLoc;
X! 			Rect	box;
X! 			short	temp;
X! 
X! 			if(flags.wantspace) {
X! 				ch = 0x20;
X! 			} else {
X! 				box.left = (u.ux-1) * t->charWidth + Screen_Border + (t->charWidth/2);
X! 				box.right = box.left + 1;
X! 				box.top = (u.uy+1) * t->height + Screen_Border + t->height/2;
X! 				box.bottom = box.top + 1;
X! 				GetMouse(&mouseLoc);
X! 				PtToAngle(&box,mouseLoc,&temp);
X! 				if (temp >337 || temp < 23) {
X! 					temp = 0;
X! 				} else {
X! 					temp = (temp + 23)/45;
X! 				}
X! 				switch(cursorPos) {
X! 					case 0:
X! 						ch = 'k';
X! 						break;
X! 					case 1:
X! 						ch = 'u';
X! 						break;
X! 					case 2:
X! 						ch = 'l';
X! 						break;
X! 					case 3:
X! 						ch = 'n';
X! 						break;
X! 					case 4:
X! 						ch = 'j';
X! 						break;
X! 					case 5:
X! 						ch = 'b';
X! 						break;
X! 					case 6:
X! 						ch = 'h';
X! 						break;
X! 					case 7:
X! 						ch ='y';
X! 						break;
X! 					case 8:
X! 						ch = '.';
X! 						break;
X! 				}
X! 				if ((theEvent.modifiers & shiftKey) && (ch)) {
X! 					ch = (ch == '.') ? ':' : (char)toupper(ch);
X! 				}
X! 			}
X! 		}			
X  		break;
X+ 		}
X+ 	} else {
X+ 		if(flags.wantspace) ch = 0x20;
X  	}
X  	return ch;
X  }
X***************
X*** 381,387 ****
X  {	
X  	EventRecord	theEvent;
X  	
X! 	return (EventAvail(keyDownMask, &theEvent));
X  }
X  #endif
X  
X--- 599,606 ----
X  {	
X  	EventRecord	theEvent;
X  	
X! 	SystemTask();
X! 	return (EventAvail(keyDownMask | mDownMask, &theEvent));
X  }
X  #endif
X  
X***************
X*** 410,415 ****
X--- 629,672 ----
X  	return 1;
X  }
X  
X+ static void
X+ checkScroll(t)
X+ term_info *t;
X+ {
X+ 	if (t->tcur_y >= t->maxRow-1) {
X+ 		short	temp;
X+ 		char	*s;
X+ 
X+ 		BlockMove((Ptr)t->screen[1], (Ptr)t->screen[0],
X+ 			(Size)((t->maxRow - 1) * t->maxCol));
X+ 		for (temp = 0, s = t->screen[t->maxRow - 1];
X+ 				temp < t->maxCol; temp++, s++) {
X+ 			*s = ' ';
X+ 		}
X+ 		{
X+ 			Pattern p, o;
X+ 			Rect	window;
X+ 			
X+ 			if (macflags & fInvertedScreen) {
X+ 				BlockMove((Ptr)&((GrafPtr)HackWindow)->bkPat, (Ptr)&o,
X+ 						sizeof(Pattern));
X+ 				GetIndPattern(&p, sysPatListID,1);
X+ 				BackPat(p);
X+ 			}
X+ 			window = HackWindow->portRect;
X+ 			InsetRect(&window, 4,4);
X+ 			window.top += t->height;
X+ 			ScrollRect(&window, 0, -t->height,
X+ 					((WindowPeek)HackWindow)->updateRgn);
X+ 			ValidRect(&window);
X+ 			if (macflags & fInvertedScreen) {
X+ 				BackPat(o);
X+ 			}
X+ 		}
X+ 		t->tcur_y = t->maxRow - 1;
X+ 	}
X+ }
X+ 
X  void
X  mput(s)
X  char	*s;
X***************
X*** 532,538 ****
X  	    
X  	    if (sLen) {
X  		while (stmp < (s + sLen)) {
X! 		    temp = (x + charleft - 1 < t->maxCol) ? charleft : t->maxCol - x;
X  		    savech = '\0';
X  		    c1 = stmp + temp;	/* point to the char after the end */
X  		    c = index(stmp, '\n');
X--- 789,795 ----
X  	    
X  	    if (sLen) {
X  		while (stmp < (s + sLen)) {
X! 		    temp = (x + charleft - 1 < t->maxCol - 1) ? charleft : t->maxCol - x;
X  		    savech = '\0';
X  		    c1 = stmp + temp;	/* point to the char after the end */
X  		    c = index(stmp, '\n');
X***************
X*** 556,577 ****
X  		    if (!savech) {
X  			    t->tcur_x += temp;
X  		    }
X! 		    if (t->tcur_x == t->maxCol || savech) {
X! 			t->tcur_x = 0;
X! 			if (savech != '\r')
X! 				y = (++t->tcur_y);
X! 				/* should probably check for overflow */
X! 		    }
X! 		    x = t->tcur_x;
X! 		    cur.h = Screen_Border;
X! 		    cur.v = y * t->height + t->ascent + Screen_Border;
X! 		    MoveTo(cur.h,cur.v);
X! 		}
X  	    }
X  	}
X! 	if (t->tcur_x >= t->maxCol) {
X  	    t->tcur_x = t->tcur_x % t->maxCol;
X  	    t->tcur_y++;
X  	}
X  	SetPort(prevPort);
X  }
X--- 813,840 ----
X  		    if (!savech) {
X  			    t->tcur_x += temp;
X  		    }
X! 
X! 		    if (t->tcur_x >= t->maxCol-1 || savech) {
X! 			    if (savech != '\r') {
X! 				    if (t->tcur_y >= t->maxRow-1) {
X! 					    checkScroll(t);
X! 				    } else {
X! 					    y = (++t->tcur_y);
X! 				    }
X! 			    }
X! 	
X! 			    x = t->tcur_x = 0;
X! 			    cur.h = Screen_Border;
X! 			    cur.v = y * t->height + t->ascent + Screen_Border;
X! 			    MoveTo(cur.h,cur.v);
X! 			}
X  	    }
X  	}
X! 	}
X! 	if (t->tcur_x >= t->maxCol-1) {
X  	    t->tcur_x = t->tcur_x % t->maxCol;
X  	    t->tcur_y++;
X+ 	    checkScroll(t);
X  	}
X  	SetPort(prevPort);
X  }
X***************
X*** 621,641 ****
X  	}
X  	if (c == '\007') {
X  		SysBeep(1);
X! 	} else if ((c != '\n') && (c != '\r')) {
X  		t->screen[y][x] = c;
X  		DrawText(&c, 0, 1);
X! 		if (!savech)
X  			t->tcur_x++;
X! 	} else {
X! 		t->tcur_x = 0;
X! 		if (t->tcur_y < t->maxRow) {
X! 			if (c == '\n')
X  				t->tcur_y++;
X  		}
X- 		cur.h = (t->tcur_x * t->charWidth) + Screen_Border;
X- 		cur.v = t->ascent + (t->tcur_y * t->height) + Screen_Border;
X- 		MoveTo(cur.h,cur.v);
X  	}
X  	SetPort(prevPort);	
X  	return 1;
X  }
X--- 884,917 ----
X  	}
X  	if (c == '\007') {
X  		SysBeep(1);
X! 	} else if ((c == '\n') || (c == '\r')) {
X! 		t->tcur_x = 0;
X! 		if (t->tcur_y >= t->maxRow && c == '\r') {
X! 			t->tcur_y = t->maxRow - 1;
X! 		} else if (c == '\n') {
X! 			if (t->tcur_y >= t->maxRow-1) {
X! 				checkScroll(t);
X! 			} else {
X! 				t->tcur_y++;
X! 			}
X! 		}
X! 	} else {
X  		t->screen[y][x] = c;
X  		DrawText(&c, 0, 1);
X! 		if (!savech) {
X  			t->tcur_x++;
X! 			if (t->tcur_x >= t->maxCol)
X! 			{
X! 				t->tcur_x = 0;
X  				t->tcur_y++;
X+ 				checkScroll(t);
X+ 			}
X  		}
X  	}
X+ 	cur.h = (t->tcur_x * t->charWidth) + Screen_Border;
X+ 	cur.v = t->ascent + (t->tcur_y * t->height) + Screen_Border;
X+ 	MoveTo(cur.h,cur.v);
X+ 
X  	SetPort(prevPort);	
X  	return 1;
X  }
X***************
X*** 742,747 ****
X--- 1018,1053 ----
X  	return 1;
X  }
X  
X+ DialogTHndl
X+ centreDlgBox(resNum, clip)
X+ short	resNum;
X+ Boolean	clip;
X+ {
X+ 	DialogTHndl	th = (DialogTHndl) GetResource('DLOG', resNum);
X+ 	Rect	rect;
X+ 	short	dv, dh;
X+ 
X+ 	/* centre dialog box on screen */
X+ 	if (th) {
X+ 		rect = SCREEN_BITS.bounds;
X+ 		HLock((Handle)th);
X+ 		dv = ((**th).boundsRect.bottom - (**th).boundsRect.top)/2;
X+ 		dv -= (clip) ? 20 : 0;
X+ 		dh = ((**th).boundsRect.right - (**th).boundsRect.left)/2;
X+ 	
X+ 		(**th).boundsRect.bottom =
X+ 				(rect.bottom + rect.top + MBarHeight)/2 + dv;
X+ 		(**th).boundsRect.top	 =
X+ 				(rect.bottom + rect.top + MBarHeight)/2 - dv;
X+ 		(**th).boundsRect.right	 = (rect.right + rect.left)/2 + dh;
X+ 		(**th).boundsRect.left	 = (rect.right + rect.left)/2 - dh;
X+ 		HUnlock((Handle)th);
X+ 	} else
X+ 		panic("Couldn't load dialog resource");	
X+ 
X+ 	return th;
X+ }
X+ 
X  short
X  aboutBox(prompt)
X  short	prompt;
X***************
X*** 757,777 ****
X  	GrafPtr	oldPort;
X  	EventRecord	theEvent;
X  	term_info	*t;
X! 	DialogTHndl	th = (DialogTHndl) GetResource('DLOG', 129);
X! 	short	dv, dh;
X  
X  	/* if about box on startup, centre about box on screen */
X  	if (!prompt) {
X! 		rect = SCREEN_BITS.bounds;
X! 		dv = ((**th).boundsRect.bottom - 40 - (**th).boundsRect.top)/2;
X! 		dh = ((**th).boundsRect.right - (**th).boundsRect.left)/2;
X! 
X! 		(**th).boundsRect.bottom =
X! 				(rect.bottom + rect.top + MBarHeight)/2 + dv;
X! 		(**th).boundsRect.top	 =
X! 				(rect.bottom + rect.top + MBarHeight)/2 - dv;
X! 		(**th).boundsRect.right	 = (rect.right + rect.left)/2 + dh;
X! 		(**th).boundsRect.left	 = (rect.right + rect.left)/2 - dh;
X  	}
X  
X  	GetPort(&oldPort);
X--- 1063,1073 ----
X  	GrafPtr	oldPort;
X  	EventRecord	theEvent;
X  	term_info	*t;
X! 	DialogTHndl	th;
X  
X  	/* if about box on startup, centre about box on screen */
X  	if (!prompt) {
X! 		th = centreDlgBox(129, TRUE);
X  	}
X  
X  	GetPort(&oldPort);
X***************
X*** 800,805 ****
X--- 1096,1102 ----
X  		}
X  	} else {
X  		while (!itemHit) {
X+ 			SystemTask();
X  			if (GetNextEvent(everyEvent,&theEvent))
X  				if (theEvent.what == mouseDown ||
X    			            theEvent.what == keyDown ||
X***************
X*** 807,813 ****
X  					itemHit = OK_BUTTON;
X  		}
X  	}
X! 	CloseDialog(theDialog);
X  	ReleaseResource((Handle)th);
X  	SetPort(oldPort);
X  	return (itemHit == MORE_INFO_BUTTON);
X--- 1104,1110 ----
X  					itemHit = OK_BUTTON;
X  		}
X  	}
X! 	DisposDialog(theDialog);
X  	ReleaseResource((Handle)th);
X  	SetPort(oldPort);
X  	return (itemHit == MORE_INFO_BUTTON);
X*** mac/Old/macfile.c	Mon Feb 19 21:23:03 1990
X--- mac/macfile.c	Thu Feb  8 17:45:37 1990
X***************
X*** 4,13 ****
X  
X  /*	Common routines to locate files using mac dialog boxes */
X  
X- /*#define MAKEDEFS_C	1	/* define when using makedefs */
X  #include "config.h"
X  #ifdef MACOS
X  
X  short
X  findNamedFile(filename,type,reply)
X  char	*filename;
X--- 4,13 ----
X  
X  /*	Common routines to locate files using mac dialog boxes */
X  
X  #include "config.h"
X  #ifdef MACOS
X  
X+ #define	LARGE_SFGETDLG	-4000
X  short
X  findNamedFile(filename,type,reply)
X  char	*filename;
X***************
X*** 24,30 ****
X  	
X  	name[0] = (char)strlen(filename);
X  	Strcpy((char *)&name[1], filename);
X! 	dialog = GetNewDialog(128,&storage,(WindowPtr)-1);
X  	
X  	if (type == 1)
X  		ParamText("\005 save","\004 for",name,"");
X--- 24,30 ----
X  	
X  	name[0] = (char)strlen(filename);
X  	Strcpy((char *)&name[1], filename);
X! 	SetResLoad(TRUE);
X  	
X  	if (type == 1)
X  		ParamText("\005 save","\004 for",name,"");
X***************
X*** 50,60 ****
X  	}
X  	reply->good = TRUE;
X  	do {
X! 		BringToFront((WindowPtr)dialog);
X! 		ShowWindow((WindowPtr)dialog);
X! 		DrawDialog(dialog);
X! 		SFGetFile(where,prompt,0L,numTypes,types,0L,reply);
X! 		HideWindow((WindowPtr)dialog);
X  		if (reply->good) {
X  			if ((type == 2 && 
X  				!strncmp((char *)&name[1],
X--- 50,56 ----
X  	}
X  	reply->good = TRUE;
X  	do {
X! 		SFPGetFile(where,prompt,0L,numTypes,types,0L,reply,LARGE_SFGETDLG,0L);
X  		if (reply->good) {
X  			if ((type == 2 && 
X  				!strncmp((char *)&name[1],
X***************
X*** 65,77 ****
X  			}
X  		}
X  	} while (!ok && reply->good);
X! 	CloseDialog(dialog);
X  	return ok;
X  }
X  
X! #ifndef MAKEDEFS_C
X  extern WindowPtr HackWindow;
X! 
X  /*	this function also gets called by topten() in topten.c to
X   *	locate the record file, but it doesn't matter at this point
X   *	since the game is over by now. If nethack ever restarts,
X--- 61,73 ----
X  			}
X  		}
X  	} while (!ok && reply->good);
X! 
X  	return ok;
X  }
X  
X! #ifdef CUSTOM_IO
X  extern WindowPtr HackWindow;
X! extern short macflags;
X  /*	this function also gets called by topten() in topten.c to
X   *	locate the record file, but it doesn't matter at this point
X   *	since the game is over by now. If nethack ever restarts,
X***************
X*** 83,109 ****
X  char	*fileName, *rdmode;
X  {
X  	term_info *t;
X- 	SFReply	reply;
X  	FILE	*fp;
X  		
X  	t = (term_info *)GetWRefCon(HackWindow);
X- 	if (t->auxFileVRefNum) {
X- 		SetVol(0L,t->auxFileVRefNum);
X- 	} else
X- 		SetVol(0L, t->recordVRefNum);
X  
X! 	reply.good = false;
X  	fp = fopen(fileName, rdmode);
X! 	if (!fp && findNamedFile(fileName,2,&reply)) {
X! 		if (reply.good) {
X! 			t->auxFileVRefNum = reply.vRefNum;
X  		}
X! 	}
X! 	if (!fp)
X  		fp = fopen(fileName, rdmode);
X! 	else if (!t->auxFileVRefNum && reply.good) {
X! 		(void)GetVol((StringPtr)&reply.fName,&t->auxFileVRefNum);
X  	}
X  	return fp;
X  }
X  #endif
X--- 79,117 ----
X  char	*fileName, *rdmode;
X  {
X  	term_info *t;
X  	FILE	*fp;
X  		
X  	t = (term_info *)GetWRefCon(HackWindow);
X  
X! 	SetVol(0L, t->recordVRefNum);
X  	fp = fopen(fileName, rdmode);
X! 	if (!fp) {		
X! 		SFReply	reply;
X! 
X! 		if (t->auxFileVRefNum) {
X! 			SetVol(0L,t->auxFileVRefNum);
X  		}
X! 		
X! 		reply.good = false;
X  		fp = fopen(fileName, rdmode);
X! 		if (!fp && findNamedFile(fileName,2,&reply)) {
X! 			if (reply.good) {
X! 				t->auxFileVRefNum = reply.vRefNum;
X! 			}
X! 		}
X! 		
X! 		if (!fp)
X! 			fp = fopen(fileName, rdmode);
X! 		else if (!t->auxFileVRefNum && reply.good) {
X! 			(void)GetVol((StringPtr)&reply.fName,&t->auxFileVRefNum);
X! 		}
X! 
X! 		SetPort(HackWindow);
X! 		if ((macflags & fDoUpdate) && !reply.good)
X! 			docrt();
X! 
X  	}
X+ 
X  	return fp;
X  }
X  #endif
X*** mac/Old/macinit.c	Mon Feb 19 21:23:16 1990
X--- mac/macinit.c	Fri Feb 16 19:04:35 1990
X***************
X*** 7,20 ****
X  #include	"hack.h"
X  
X  #ifdef MACOS
X  
X  /* Global variables */
X  extern WindowPtr	HackWindow;	/* points to NetHack's window */
X  char	*keys[8];
X  short macflags;
X  typedef struct defaultData {
X  	long	defaultFlags;
X! 	long	fontSize;
X  	Str255	fontName;
X  } defaultData;
X  #define	fDFZoomWindow	0x02L
X--- 7,28 ----
X  #include	"hack.h"
X  
X  #ifdef MACOS
X+ # ifdef THINK_C
X+ #include	<MemoryMgr.h>
X+ # else
X+ #include	<Memory.h>
X+ #define ApplLimit 0x130         /* application limit [pointer]*/
X+ # endif
X  
X  /* Global variables */
X  extern WindowPtr	HackWindow;	/* points to NetHack's window */
X  char	*keys[8];
X  short macflags;
X+ Boolean	lowMem;
X+ long	lowMemLimit;
X  typedef struct defaultData {
X  	long	defaultFlags;
X! 	long	lowMemLimit;
X  	Str255	fontName;
X  } defaultData;
X  #define	fDFZoomWindow	0x02L
X***************
X*** 39,49 ****
X--- 47,71 ----
X  	term_info	*t;
X  	
X  	/* standard Mac initialization */
X+ #ifdef THINK_C
X+ 	SetApplLimit((Ptr)ApplLimit - 8192);	/* an extra 8K for stack */
X+ #else
X+ 	SetApplLimit(*(long *)ApplLimit - 8192);
X+ #endif	
X  	MaxApplZone();
X+ 	UnloadSeg(mprintf);
X+ 	for (i = 2; i<9; i++) {
X+ 		temp = GetResource('CODE', i);
X+ 		HUnlock(temp);
X+ 		MoveHHi(temp);
X+ 		HLock(temp);
X+ 	}
X+ 	
X  	MoreMasters();
X  	MoreMasters();
X  	MoreMasters();
X  	MoreMasters();
X+ 	lowMem = (FreeMem() < 700 *1024) ? TRUE : FALSE;
X  	InitGraf(&MAINGRAFPORT);
X  	
X  	InitFonts();
X***************
X*** 56,62 ****
X  	
X  	/* Application-specific startup code */
X  	theMenu = NewMenu(appleMenu, "\001\024");	/*  apple menu  */
X! 	AppendMenu(theMenu,"\030About NetHack 3.0g\311;(-");
X  	AddResMenu(theMenu, 'DRVR');
X  	InsertMenu(theMenu, 0);
X  	DisableItem(theMenu,0);
X--- 78,89 ----
X  	
X  	/* Application-specific startup code */
X  	theMenu = NewMenu(appleMenu, "\001\024");	/*  apple menu  */
X! 	{
X! 		char	tmp[256];
X! 		sprintf(&tmp[1],"About NetHack %s\311;(-", VERSION);
X! 		tmp[0] = (char)strlen(&tmp[1]);
X! 		AppendMenu(theMenu,tmp);
X! 	}
X  	AddResMenu(theMenu, 'DRVR');
X  	InsertMenu(theMenu, 0);
X  	DisableItem(theMenu,0);
X***************
X*** 93,99 ****
X  	macflags = (fToggleNumPad | fDoNonKeyEvt);
X  	
X  	/* Set font to monaco, user-defined font or to Hackfont if available */
X! 	size = 9;
X  	strcpy((char *)&font[0], "\006Monaco");
X  	
X  	temp = GetResource(HACK_DATA, DEFAULT_DATA);
X--- 120,130 ----
X  	macflags = (fToggleNumPad | fDoNonKeyEvt);
X  	
X  	/* Set font to monaco, user-defined font or to Hackfont if available */
X! 	if ((SCREEN_BITS.bounds.bottom - SCREEN_BITS.bounds.top) >400
X! 		&& (SCREEN_BITS.bounds.right - SCREEN_BITS.bounds.left) > 580)
X! 		size = 12;
X! 	else
X! 		size = 9;
X  	strcpy((char *)&font[0], "\006Monaco");
X  	
X  	temp = GetResource(HACK_DATA, DEFAULT_DATA);
X***************
X*** 100,106 ****
X  	if (temp) {
X  		HLock(temp);
X  		dD = (defaultData *)(*temp);
X! 		size = (short)dD->fontSize;
X  		strncpy((char *)&font[0], (char *)&dD->fontName[0],
X  					(short)dD->fontName[0] + 1);
X  		if (dD->defaultFlags & fDFZoomWindow)
X--- 131,137 ----
X  	if (temp) {
X  		HLock(temp);
X  		dD = (defaultData *)(*temp);
X! 		lowMemLimit = dD->lowMemLimit;
X  		strncpy((char *)&font[0], (char *)&dD->fontName[0],
X  					(short)dD->fontName[0] + 1);
X  		if (dD->defaultFlags & fDFZoomWindow)
X***************
X*** 171,176 ****
X--- 202,212 ----
X  		SysBeep(1);
X  	}
X  
X+ 	/* Some tweaking to allow for intl. ADB keyboard (unknown) */
X+ 	if (t->system.machineType > envMacPlus && !t->system.keyBoardType) {
X+ 		t->system.keyBoardType = envStandADBKbd;
X+ 	}
X+ 
X  #define	KEY_MAP	103
X  	temp = GetResource(HACK_DATA, KEY_MAP);
X  	if (temp) {
X***************
X*** 198,207 ****
X  
X  	/* give time for Multifinder to bring NetHack window to front */
X  	for(tempFont = 0; tempFont<10; tempFont++) {
X! 		(void)GetNextEvent(everyEvent,&theEvent);
X  	}
X  
X! 	HackWindow = NewWindow(0L, &boundsRect, "\015NetHack [MOV]",
X  			TRUE, noGrowDocProc, (WindowPtr)-1, FALSE, (long)t);
X  
X  	t->inColor = 0;
X--- 234,244 ----
X  
X  	/* give time for Multifinder to bring NetHack window to front */
X  	for(tempFont = 0; tempFont<10; tempFont++) {
X! 		SystemTask();
X! 		(void)GetNextEvent(nullEvent,&theEvent);
X  	}
X  
X! 	HackWindow = NewWindow(0L, &boundsRect, "\016NetHack [MOVE]",
X  			TRUE, noGrowDocProc, (WindowPtr)-1, FALSE, (long)t);
X  
X  	t->inColor = 0;
X***************
X*** 253,258 ****
X--- 290,299 ----
X  		panic("Can't get OBJECT resource data.");
X  	}
X  	
X+ 	for (i = 0; i<8; i++) {
X+ 		t->cursor[i] = GetCursor(100+i);
X+ 	}
X+ 	
X  	(void)aboutBox(0);	
X  	return 0;
X  }
X***************
X*** 325,328 ****
X--- 366,460 ----
X  	free((char *)level.monsters);
X  }
X  #endif /* SMALLDATA */
X+ 
X+ #define	OPTIONS			"Nethack prefs"
X+ 
X+ # ifdef AZTEC
X+ #undef OMASK
X+ #define OMASK	O_RDONLY
X+ # else
X+ #undef OMASK
X+ #define OMASK	(O_RDONLY | O_BINARY )
X+ # endif
X+ 
X+ int
X+ read_config_file()
X+ {
X+ 
X+ 	int optfd;
X+ 	optfd = 0;
X+ 	if ( (optfd = open(OPTIONS, OMASK)) > (int)NULL){
X+ 		read_opts(optfd);
X+ 		(void) close(optfd);
X+ 	}
X+ }
X+ 
X+ int
X+ write_opts()
X+ {
X+ 	int fd;
X+ 	short temp_flags;
X+ 
X+ 	if((fd = open(OPTIONS, O_WRONLY | O_BINARY)) <= 0) {
X+ 		OSErr	result;
X+ 		char	*tmp;
X+ 		
X+ 		tmp = CtoPstr(OPTIONS);
X+ 		result = Create((StringPtr)tmp, (short)0, CREATOR, AUXIL_TYPE);
X+ 	 	if (result == noErr)
X+ 	 		fd = open(OPTIONS, O_WRONLY | O_BINARY);
X+ 	 }
X+ 
X+ 	if (fd < 0)
X+ 		pline("can't create options file!");
X+ 	else {
X+ 		write(fd, &flags, sizeof(flags));
X+ 	
X+ 		write(fd, plname, PL_NSIZ);
X+ 	
X+ 		write(fd, dogname, 63);
X+ 	
X+ 		write(fd, catname, 63);
X+ 		
X+ 		temp_flags = (macflags & fZoomOnContextSwitch) ? 1 : 0;
X+ 		write(fd, &temp_flags, sizeof(short));
X+ 	
X+ #ifdef TUTTI_FRUTTI
X+ 		write(fd, pl_fruit, PL_FSIZ);
X+ #endif
X+ 		write(fd, inv_order, strlen(inv_order)+1);
X+ 		close(fd);
X+ 	}
X+ 	return 0;
X+ }
X+ 
X+ int
X+ read_opts(fd)
X+ int fd;
X+ {	char tmp_order[20];
X+ 	short	temp_flags;
X+ 	
X+ 	read(fd, (char *)&flags, sizeof(flags));
X+ 
X+ 	read(fd, plname, PL_NSIZ);
X+ 
X+ 	read(fd, dogname, 63);
X+ 	
X+ 	read(fd, catname, 63);
X+ 	
X+ 	read(fd, &temp_flags, sizeof(short));
X+ 	if (temp_flags & 0x01)
X+ 		macflags |= fZoomOnContextSwitch;
X+ 	else
X+ 		macflags &= ~fZoomOnContextSwitch;
X+ 
X+ #ifdef TUTTI_FRUTTI
X+ 	read(fd, pl_fruit, PL_FSIZ);
X+ #endif
X+ 	read(fd,tmp_order,strlen(inv_order)+1);
X+ 	if(strlen(tmp_order) == strlen(inv_order))
X+ 		strcpy(inv_order,tmp_order);
X+ 	return 0;
X+ }
X+ 
X  #endif /* MACOS */
X
END_OF_FILE
if test 56738 -ne `wc -c <'patch7.15'`; then
    echo shar: \"'patch7.15'\" unpacked with wrong size!
fi
# end of 'patch7.15'
echo shar: End of archive 5 \(of 30\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
