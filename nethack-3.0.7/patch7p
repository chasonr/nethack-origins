Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!swrinde!zaphod.mps.ohio-state.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i016:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7p
Message-ID: <5230@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:59:17 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2277
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 16
Archive-name: NetHack3/Patch7p
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 30)."
# Contents:  patch7.21
# Wrapped by billr@saab on Wed Feb 21 10:04:37 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.21' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.21'\" to \"'patch7.21.orig'\"
  mv -f 'patch7.21' 'patch7.21.orig'
fi
echo shar: Extracting \"'patch7.21'\" \(53640 characters\)
sed "s/^X//" >'patch7.21' <<'END_OF_FILE'
X*** src/Old/timeout.c	Mon Feb 19 19:02:27 1990
X--- src/timeout.c	Thu Jan 25 22:14:40 1990
X***************
X*** 1,9 ****
X! /*	SCCS Id: @(#)timeout.c	3.0	87/07/06
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X  
X  /* He is being petrified - dialogue by inmet!tower */
X  static const char *stoned_texts[] = {
X  	"You are slowing down.",		/* 5 */
X--- 1,16 ----
X! /*	SCCS Id: @(#)timeout.c	3.0	89/11/20
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X  
X+ #ifdef OVERLAY
X+ extern void NDECL(stoned_dialog), NDECL(vomiting_dialog), NDECL(choke_dialog);
X+ extern void FDECL(hatch_it, (struct obj*));
X+ #endif
X+ 
X+ #ifdef OVLB
X+ 
X  /* He is being petrified - dialogue by inmet!tower */
X  static const char *stoned_texts[] = {
X  	"You are slowing down.",		/* 5 */
X***************
X*** 13,19 ****
X  	"You are a statue."			/* 1 */
X  };
X  
X! static void
X  stoned_dialogue() {
X  	register long i = (Stoned & TIMEOUT);
X  
X--- 20,26 ----
X  	"You are a statue."			/* 1 */
X  };
X  
X! XSTATIC void
X  stoned_dialogue() {
X  	register long i = (Stoned & TIMEOUT);
X  
X***************
X*** 34,40 ****
X  	"You suddenly vomit!"			/* 0 */
X  };
X  
X! static void
X  vomiting_dialogue() {
X  	register long i = (Vomiting & TIMEOUT) / 3L;
X  
X--- 41,47 ----
X  	"You suddenly vomit!"			/* 0 */
X  };
X  
X! XSTATIC void
X  vomiting_dialogue() {
X  	register long i = (Vomiting & TIMEOUT) / 3L;
X  
X***************
X*** 42,48 ****
X  	   i >= 0 && i < SIZE(vomiting_texts))
X  		pline(vomiting_texts[SIZE(vomiting_texts) - i]);
X  
X! 	switch(i) {
X  
X  	    case 0:	vomit(); morehungry(20); break;
X  	    case 2:	make_confused(HConfusion + d(2,4), FALSE);
X--- 49,55 ----
X  	   i >= 0 && i < SIZE(vomiting_texts))
X  		pline(vomiting_texts[SIZE(vomiting_texts) - i]);
X  
X! 	switch((int)i) {
X  
X  	    case 0:	vomit(); morehungry(20); break;
X  	    case 2:	make_confused(HConfusion + d(2,4), FALSE);
X***************
X*** 59,65 ****
X  	"You suffocate."
X  };
X  
X! static void
X  choke_dialogue()
X  {
X  	register long i = (Strangled & TIMEOUT);
X--- 66,72 ----
X  	"You suffocate."
X  };
X  
X! XSTATIC void
X  choke_dialogue()
X  {
X  	register long i = (Strangled & TIMEOUT);
X***************
X*** 69,74 ****
X--- 76,84 ----
X  			hcolor() : blue);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  timeout()
X  {
X***************
X*** 105,112 ****
X  		if(upp->p_tofn) (*upp->p_tofn)();
X  		else switch(upp - u.uprops){
X  		case STONED:
X! 			if (!killer) killer = "cockatrice";
X! 			done(STONING);
X  			break;
X  		case VOMITING:
X  			make_vomiting(0L, TRUE);
X--- 115,124 ----
X  		if(upp->p_tofn) (*upp->p_tofn)();
X  		else switch(upp - u.uprops){
X  		case STONED:
X! 			if (!killer) {
X! 				killer_format = KILLED_BY_AN;
X! 				killer = "cockatrice";
X! 			} done(STONING);
X  			break;
X  		case VOMITING:
X  			make_vomiting(0L, TRUE);
X***************
X*** 113,118 ****
X--- 125,131 ----
X  			break;
X  		case SICK:
X  			You("die from your illness.");
X+ 			killer_format = KILLED_BY_AN;
X  			killer = u.usick_cause;
X  			done(POISONING);
X  			break;
X***************
X*** 155,160 ****
X--- 168,174 ----
X  			}
X  			break;
X  		case STRANGLED:
X+ 			killer_format = KILLED_BY;
X  			killer = "strangulation";
X  			done(DIED);
X  			break;
X***************
X*** 191,199 ****
X  	}
X  }
X  
X! static const char slithy[] = { S_SNAKE, S_NAGA, S_WORM, 0 };
X  
X! static void
X  hatch_it(otmp)		/* hatch the egg "otmp" if possible */
X  register struct obj *otmp;
X  {
X--- 205,214 ----
X  	}
X  }
X  
X! #endif /* OVL0 */
X! #ifdef OVLB
X  
X! XSTATIC void
X  hatch_it(otmp)		/* hatch the egg "otmp" if possible */
X  register struct obj *otmp;
X  {
X***************
X*** 215,227 ****
X  
X  		if(Blind)
X  		    You("feel something %s from your pack!",
X! 			  (index(slithy, mtmp->data->mlet)) ?
X! 			      "slither" : "drop");
X  		else
X! 		    pline("%s just %s out of your pack!",
X! 			  An(mtmp->data->mname),
X! 			  (index(slithy, mtmp->data->mlet)) ?
X! 			      "slithered" : "dropped");
X  
X  #ifdef POLYSELF
X  		if (yours) {
X--- 230,240 ----
X  
X  		if(Blind)
X  		    You("feel something %s from your pack!",
X! 			locomotion(mtmp->data, "drop"));
X  		else
X! 		    You("see %s %s out of your pack!",
X! 			an(mtmp->data->mname),
X! 			locomotion(mtmp->data, "drop"));
X  
X  #ifdef POLYSELF
X  		if (yours) {
X***************
X*** 240,245 ****
X--- 253,261 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  hatch_eggs()	    /* hatch any eggs that have been too long in pack */
X  {
X***************
X*** 264,266 ****
X--- 280,284 ----
X  	}
X  */
X  }
X+ 
X+ #endif /* OVL1 */
X*** src/Old/topl.c	Mon Feb 19 19:02:45 1990
X--- src/topl.c	Mon Feb 19 10:18:54 1990
X***************
X*** 2,21 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #define NEED_VARARGS
X  #include "hack.h"
X  
X! char toplines[BUFSIZ];
X  xchar tlx, tly;			/* set by pline; used by addtopl */
X! static boolean no_repeat = FALSE;
X  
X! struct topl {
X  	struct topl *next_topl;
X  	char *topl_text;
X  } *old_toplines, *last_redone_topl;
X  #define	OTLMAX	20		/* max nr of old toplines remembered */
X  
X! static void
X  redotoplin() {
X  	home();
X  	if(index(toplines, '\n')) cl_end();
X--- 2,35 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #define NEED_VARARGS /* Uses ... */	/* comment line for pre-compiled headers */
X  #include "hack.h"
X  
X! VSTATIC char toplines[BUFSIZ];
X! 
X! #ifndef OVLB
X! OSTATIC boolean no_repeat;
X! #else /* OVLB */
X! XSTATIC boolean no_repeat = FALSE;
X! #endif /* OVLB */
X! 
X! extern xchar tlx, tly;
X! #ifdef OVLB
X  xchar tlx, tly;			/* set by pline; used by addtopl */
X! #endif /* OVLB */
X  
X! OSTATIC void NDECL(redotoplin);
X! OSTATIC void FDECL(xmore,(const char *));
X! VSTATIC struct topl {
X  	struct topl *next_topl;
X  	char *topl_text;
X  } *old_toplines, *last_redone_topl;
X+ 
X  #define	OTLMAX	20		/* max nr of old toplines remembered */
X  
X! #ifdef OVL1
X! 
X! XSTATIC void
X  redotoplin() {
X  	home();
X  	if(index(toplines, '\n')) cl_end();
X***************
X*** 35,40 ****
X--- 49,57 ----
X  		more();
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  doredotopl(){
X  	if(last_redone_topl)
X***************
X*** 48,53 ****
X--- 65,73 ----
X  	return 0;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  remember_topl() {
X  	register struct topl *tl;
X***************
X*** 74,80 ****
X  }
X  
X  void
X! addtopl(s) char *s; {
X  	curs(tlx,tly);
X  	if(tlx + strlen(s) > CO) putsym('\n');
X  	putstr(s);
X--- 94,102 ----
X  }
X  
X  void
X! addtopl(s)
X! const char *s;
X! {
X  	curs(tlx,tly);
X  	if(tlx + strlen(s) > CO) putsym('\n');
X  	putstr(s);
X***************
X*** 83,91 ****
X  	flags.toplin = 1;
X  }
X  
X! static void
X  xmore(s)
X! char *s;	/* allowed chars besides space/return */
X  {
X  	if(flags.toplin) {
X  		curs(tlx, tly);
X--- 105,116 ----
X  	flags.toplin = 1;
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVL2
X! 
X! XSTATIC void
X  xmore(s)
X! const char *s;	/* allowed chars besides space/return */
X  {
X  	if(flags.toplin) {
X  		curs(tlx, tly);
X***************
X*** 104,109 ****
X--- 129,135 ----
X  		cl_end();
X  		docorner(1, tly-1);
X  		tlx = tly = 1;
X+ 		curs(tlx, tly);
X  	}
X  	flags.toplin = 0;
X  }
X***************
X*** 113,125 ****
X  	xmore("");
X  }
X  
X  void
X  cmore(s)
X! register char *s;
X  {
X  	xmore(s);
X  }
X  
X  void
X  clrlin(){
X  	if(flags.toplin) {
X--- 139,157 ----
X  	xmore("");
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  void
X  cmore(s)
X! register const char *s;
X  {
X  	xmore(s);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  clrlin(){
X  	if(flags.toplin) {
X***************
X*** 134,143 ****
X  	flags.toplin = 0;
X  }
X  
X! /*VARARGS1*/
X! /* Note the modified mstatusline has 9 arguments KAA */
X  
X! /* Also note that these declarations rely on knowledge of the internals
X   * of the variable argument handling stuff in "tradstdc.h"
X   */
X  
X--- 166,176 ----
X  	flags.toplin = 0;
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVLB
X  
X! /*VARARGS1*/
X! /* Note that these declarations rely on knowledge of the internals
X   * of the variable argument handling stuff in "tradstdc.h"
X   */
X  
X***************
X*** 272,284 ****
X  /*ARGSUSED*/
X  /*VARARGS2*/
X  void
X! kludge  VA_DECL2(char *, str, char *, arg)
X  #ifdef VA_NEXT
X  	char *other1, *other2, *other3;
X  #endif
X  	VA_START(arg);
X! 	VA_INIT(str, char *);
X! 	VA_INIT(arg, char *);
X  #ifdef VA_NEXT
X  	VA_NEXT(other1, char *);
X  	VA_NEXT(other2, char *);
X--- 305,317 ----
X  /*ARGSUSED*/
X  /*VARARGS2*/
X  void
X! kludge  VA_DECL2(const char *, str, const char *, arg)
X  #ifdef VA_NEXT
X  	char *other1, *other2, *other3;
X  #endif
X  	VA_START(arg);
X! 	VA_INIT(str, const char *);
X! 	VA_INIT(arg, const char *);
X  #ifdef VA_NEXT
X  	VA_NEXT(other1, char *);
X  	VA_NEXT(other2, char *);
X***************
X*** 294,299 ****
X--- 327,335 ----
X  	VA_END();
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  putsym(c)
X  char c;
X***************
X*** 325,330 ****
X--- 361,369 ----
X  	while(*s) putsym(*s++);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X  char
X  yn_function(resp, def)
X  const char *resp;
X***************
X*** 356,367 ****
X  	return q;
X  }
X  
X  /*VARARGS1*/
X  void
X! impossible VA_DECL(char *, s)
X  	VA_START(s);
X! 	VA_INIT(s, char *);
X  	vpline(s,VA_ARGS);
X  	pline("Program in disorder - perhaps you'd better Quit.");
X  	VA_END();
X  }
X--- 395,411 ----
X  	return q;
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  /*VARARGS1*/
X  void
X! impossible VA_DECL(const char *, s)
X  	VA_START(s);
X! 	VA_INIT(s, const char *);
X  	vpline(s,VA_ARGS);
X  	pline("Program in disorder - perhaps you'd better Quit.");
X  	VA_END();
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/trap.c	Mon Feb 19 19:03:58 1990
X--- src/trap.c	Mon Feb 19 10:17:41 1990
X***************
X*** 1,14 ****
X! /*	SCCS Id: @(#)trap.c	3.0	89/11/10
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X  #include	"edog.h"
X- #include	"trapname.h"
X  
X! void domagictrap();
X! static boolean thitm();
X  
X  /* Generic rust-armor function.  Returns TRUE if a message was printed;
X   * "print", if set, means to print a message (and thus to return TRUE) even
X   * if the item could not be rusted; otherwise a message is printed and TRUE is
X--- 1,45 ----
X! /*	SCCS Id: @(#)trap.c	3.0	89/11/20
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X  #include	"edog.h"
X  
X! #ifdef OVLB
X  
X+ const char *traps[] = {
X+ 	"",
X+ 	" monster trap",
X+ 	" statue trap",
X+ 	" bear trap",
X+ 	"n arrow trap",
X+ 	" dart trap",
X+ 	" trapdoor",
X+ 	" teleportation trap",
X+ 	" pit",
X+ 	" sleeping gas trap"
X+ 	," magic trap"
X+ 	," squeaky board"
X+ 	," web"
X+ 	," spiked pit"
X+ 	," level teleporter"
X+ #ifdef SPELLS
X+ 	,"n anti-magic field" 
X+ #endif
X+ 	," rust trap"
X+ #ifdef POLYSELF
X+ 	," polymorph trap"
X+ #endif
X+ 	," land mine"
X+ };
X+ 
X+ #endif /* OVLB */
X+ 
X+ void NDECL(domagictrap);
X+ OSTATIC boolean FDECL(thitm, (int, struct monst *, struct obj *, int));
X+ 
X+ #ifdef OVLB
X+ 
X  /* Generic rust-armor function.  Returns TRUE if a message was printed;
X   * "print", if set, means to print a message (and thus to return TRUE) even
X   * if the item could not be rusted; otherwise a message is printed and TRUE is
X***************
X*** 17,28 ****
X  boolean
X  rust_dmg(otmp, ostr, type, print)
X  register struct obj *otmp;
X! register char *ostr;
X  int type;
X  boolean print;
X  {
X  	static const char *gook[] = { "slag", "rust", "rot", "corrosion" };
X  	static const char *action[] = { "smolder", "rust", "rot", "corrode" };
X  	boolean vulnerable = FALSE;
X  	boolean plural;
X  
X--- 48,60 ----
X  boolean
X  rust_dmg(otmp, ostr, type, print)
X  register struct obj *otmp;
X! register const char *ostr;
X  int type;
X  boolean print;
X  {
X  	static const char *gook[] = { "slag", "rust", "rot", "corrosion" };
X  	static const char *action[] = { "smolder", "rust", "rot", "corrode" };
X+ 	static const char *msg[] =  { "burnt", "rusted", "rotten", "corroded" };
X  	boolean vulnerable = FALSE;
X  	boolean plural;
X  
X***************
X*** 54,60 ****
X  			otmp->spe--;
X  			adj_abon(otmp, -1);
X  		}
X! 	} else Your("%s look%s quite rusted.", ostr, plural ? "" : "s");
X  	return(TRUE);
X  }
X  
X--- 86,93 ----
X  			otmp->spe--;
X  			adj_abon(otmp, -1);
X  		}
X! 	} else Your("%s %s%s quite %s.", ostr, Blind ? "feel" : "look",
X! 					     plural ? "" : "s", msg[type]);
X  	return(TRUE);
X  }
X  
X***************
X*** 65,70 ****
X--- 98,112 ----
X  	register struct trap *ttmp;
X  	register struct permonst *ptr;
X  
X+ 	if (ttmp = t_at(x,y)) {
X+ 		if (u.utrap &&
X+ 		  ((u.utraptype == TT_BEARTRAP && typ != BEAR_TRAP) ||
X+ 		  (u.utraptype == TT_WEB && typ != WEB) ||
X+ 		  (u.utraptype == TT_PIT && typ != PIT && typ != SPIKED_PIT)))
X+ 			u.utrap = 0;
X+ 		ttmp->ttyp = typ;
X+ 		return ttmp;
X+ 	}
X  	ttmp = newtrap();
X  	ttmp->ttyp = typ;
X  	ttmp->tx = x;
X***************
X*** 71,81 ****
X  	ttmp->ty = y;
X  	switch(typ) {
X  	    case MONST_TRAP:	    /* create a monster in "hiding" */
X  		if(rn2(5) && (ptr = mkclass(S_PIERCER)))
X  			ttmp->pm = monsndx(ptr);
X! 		else
X  			ttmp->pm = rndmonnum();
X  		break;
X  	    case STATUE_TRAP:	    /* create a "living" statue */
X  		ttmp->pm = rndmonnum();
X  		(void) mkcorpstat(STATUE, &mons[ttmp->pm], x, y);
X--- 113,131 ----
X  	ttmp->ty = y;
X  	switch(typ) {
X  	    case MONST_TRAP:	    /* create a monster in "hiding" */
X+ 	    {	int tryct = 0;
X  		if(rn2(5) && (ptr = mkclass(S_PIERCER)))
X  			ttmp->pm = monsndx(ptr);
X! 		else do {
X  			ttmp->pm = rndmonnum();
X+ 		} while ((noattacks(&mons[ttmp->pm]) ||
X+ 			!mons[ttmp->pm].mmove) && ++tryct < 100);
X+ 		if (tryct == 100) {
X+ 			free((genericptr_t)ttmp);
X+ 			return(struct trap *)0;
X+ 		}
X  		break;
X+ 	    }
X  	    case STATUE_TRAP:	    /* create a "living" statue */
X  		ttmp->pm = rndmonnum();
X  		(void) mkcorpstat(STATUE, &mons[ttmp->pm], x, y);
X***************
X*** 111,119 ****
X  #ifdef POLYSELF
X  		 || is_flyer(uasmon)
X  #endif
X! 		)) &&
X! 	       !(IS_DOOR(levl[x][y].typ) &&
X! 		     (levl[x][y].doormask & (D_LOCKED | D_CLOSED)));
X  	return(tmp1 && tmp2 && tmp3);
X  #else
X  	return( isok(x,y) &&
X--- 161,167 ----
X  #ifdef POLYSELF
X  		 || is_flyer(uasmon)
X  #endif
X! 		)) && !closed_door(x,y);
X  	return(tmp1 && tmp2 && tmp3);
X  #else
X  	return( isok(x,y) &&
X***************
X*** 129,138 ****
X  #ifdef POLYSELF
X  		  || is_flyer(uasmon)
X  #endif
X! 		  )) &&
X! 		!(IS_DOOR(levl[x][y].typ) &&
X! 		     (levl[x][y].doormask & (D_LOCKED | D_CLOSED)))
X! 	);
X  #endif
X  	/* Note: gold is permitted (because of vaults) */
X  }
X--- 177,183 ----
X  #ifdef POLYSELF
X  		  || is_flyer(uasmon)
X  #endif
X! 		  )) && !closed_door(x,y));
X  #endif
X  	/* Note: gold is permitted (because of vaults) */
X  }
X***************
X*** 189,199 ****
X  		case BEAR_TRAP:
X  		    if(Levitation
X  #ifdef POLYSELF
X! 			|| is_flyer(uasmon)
X! #endif
X! 			) {
X  			You("%s over a bear trap.",
X  			      Levitation ? "float" : "fly");
X  			break;
X  		    }
X  #ifdef POLYSELF
X--- 234,246 ----
X  		case BEAR_TRAP:
X  		    if(Levitation
X  #ifdef POLYSELF
X! 				|| is_flyer(uasmon)) {
X  			You("%s over a bear trap.",
X  			      Levitation ? "float" : "fly");
X+ #else
X+ 				) {
X+ 			You("float over a bear trap.");
X+ #endif
X  			break;
X  		    }
X  #ifdef POLYSELF
X***************
X*** 253,266 ****
X  		case TRAPDOOR:
X  		    if(is_maze_lev
X  #ifdef STRONGHOLD
X! 		 	 && (dlevel > stronghold_level)
X! #endif /* STRONGHOLD /**/
X  		      ) {
X  	pline("A trap door in the ceiling opens and a rock falls on your %s!",
X  				body_part(HEAD));
X  			if(uarmh)
X  			    pline("Fortunately, you are wearing a helmet!");
X! 			losehp(uarmh ? 2 : d(2,10),"falling rock");
X  			(void) mksobj_at(ROCK, u.ux, u.uy);
X  			fobj->quan = 1;
X  			fobj->owt = weight(fobj);
X--- 300,313 ----
X  		case TRAPDOOR:
X  		    if(is_maze_lev
X  #ifdef STRONGHOLD
X! 			 && (dlevel > stronghold_level)
X! #endif
X  		      ) {
X  	pline("A trap door in the ceiling opens and a rock falls on your %s!",
X  				body_part(HEAD));
X  			if(uarmh)
X  			    pline("Fortunately, you are wearing a helmet!");
X! 			losehp(uarmh ? 2 : d(2,10),"falling rock", KILLED_BY_AN);
X  			(void) mksobj_at(ROCK, u.ux, u.uy);
X  			fobj->quan = 1;
X  			fobj->owt = weight(fobj);
X***************
X*** 276,285 ****
X  			pline("A trap door opens up under you!");
X  			if(Levitation || u.ustuck || dlevel == MAXLEVEL
X  #ifdef POLYSELF
X! 					|| is_flyer(uasmon)
X  #endif
X  #ifdef ENDGAME
X! 					|| dlevel == ENDLEVEL
X  #endif
X  							) {
X  			    You("don't fall in.");
X--- 323,332 ----
X  			pline("A trap door opens up under you!");
X  			if(Levitation || u.ustuck || dlevel == MAXLEVEL
X  #ifdef POLYSELF
X! 				|| is_flyer(uasmon) || u.umonnum == PM_WUMPUS
X  #endif
X  #ifdef ENDGAME
X! 				|| dlevel == ENDLEVEL
X  #endif
X  							) {
X  			    You("don't fall in.");
X***************
X*** 290,295 ****
X--- 337,343 ----
X  			    You("are jerked back by your pet!");
X  			else {
X  #endif
X+ 			    if(in_shop(u.ux, u.uy)) shopdig(1);
X  			    unsee();
X  			    (void) fflush(stdout);
X  			    goto_level(newlevel, FALSE, TRUE);
X***************
X*** 301,307 ****
X  		case DART_TRAP:
X  		    pline("A little dart shoots out at you!");
X  		    if(thitu(7,rnd(3),(struct obj *)0,"little dart")) {
X! 			if(!rn2(6)) poisoned("dart",A_CON,"poison dart");
X  		    } else {
X  			(void) mksobj_at(DART, u.ux, u.uy);
X  			fobj->quan = 1;
X--- 349,355 ----
X  		case DART_TRAP:
X  		    pline("A little dart shoots out at you!");
X  		    if(thitu(7,rnd(3),(struct obj *)0,"little dart")) {
X! 			if(!rn2(6)) poisoned("dart",A_CON,"poison dart",10);
X  		    } else {
X  			(void) mksobj_at(DART, u.ux, u.uy);
X  			fobj->quan = 1;
X***************
X*** 343,349 ****
X  		    break;
X  		case RUST_TRAP:
X  #ifdef POLYSELF
X! #ifdef GOLEMS
X  		    if (u.umonnum == PM_IRON_GOLEM) {
X  			pline("A gush of water hits you!");
X  			You("are covered with rust!");
X--- 391,397 ----
X  		    break;
X  		case RUST_TRAP:
X  #ifdef POLYSELF
X! # ifdef GOLEMS
X  		    if (u.umonnum == PM_IRON_GOLEM) {
X  			pline("A gush of water hits you!");
X  			You("are covered with rust!");
X***************
X*** 350,356 ****
X  			rehumanize();
X  			break;
X  		    } else
X! #endif /* GOLEMS */
X  		    if (u.umonnum == PM_GREMLIN && rn2(3)) {
X  			pline("A gush of water hits you!");
X  			if(mtmp = cloneu()) {
X--- 398,404 ----
X  			rehumanize();
X  			break;
X  		    } else
X! # endif /* GOLEMS */
X  		    if (u.umonnum == PM_GREMLIN && rn2(3)) {
X  			pline("A gush of water hits you!");
X  			if(mtmp = cloneu()) {
X***************
X*** 415,421 ****
X  #endif
X  			u.utrap = rn1(6,2);
X  		    u.utraptype = TT_PIT;
X! 		    losehp(rnd(6),"fall into a pit");
X  		    selftouch("Falling, you");
X  		    break;
X  		case SPIKED_PIT:
X--- 463,469 ----
X  #endif
X  			u.utrap = rn1(6,2);
X  		    u.utraptype = TT_PIT;
X! 		    losehp(rnd(6),"fell into a pit", NO_KILLER_PREFIX);
X  		    selftouch("Falling, you");
X  		    break;
X  		case SPIKED_PIT:
X***************
X*** 435,453 ****
X  #endif
X  			u.utrap = rn1(6,2);
X  		    u.utraptype = TT_PIT;
X! 		    losehp(rnd(10),"fall onto iron spikes");
X! 		    if(!rn2(6)) poisoned("spikes",A_STR,"poison spikes");
X  		    selftouch("Falling, you");
X  		    break;
X  		case LEVEL_TELEP:
X! 		{   int oldl = dlevel;
X  
X! 		    pline("You have %s onto a level teleport trap!",
X  #ifdef POLYSELF
X! 			is_flyer(uasmon) ? "flown" :
X! 			(Levitation || nolimbs(uasmon)) ? "moved" : "stepped");
X  #else
X! 			Levitation ? "moved" : "stepped");
X  #endif
X  		    if(Antimagic) {
X  			pru();
X--- 483,503 ----
X  #endif
X  			u.utrap = rn1(6,2);
X  		    u.utraptype = TT_PIT;
X! 		    losehp(rnd(10),"fell into a pit of iron spikes",
X! 			NO_KILLER_PREFIX);
X! 		    if(!rn2(6)) poisoned("spikes",A_STR,"fall onto poison spikes",8);
X  		    selftouch("Falling, you");
X  		    break;
X  		case LEVEL_TELEP:
X! 
X! 		    {	int oldl = dlevel;
X  
X! 		    You("%s onto a level teleport trap!",
X! 			  Levitation ? "float" :
X  #ifdef POLYSELF
X! 			  locomotion(uasmon, "step"));
X  #else
X! 			  "step");
X  #endif
X  		    if(Antimagic) {
X  			pru();
X***************
X*** 502,508 ****
X  		case MGTRP:	    /* A magic trap. */
X  		    if (!rn2(30)) {
X  			You("are caught in a magical explosion!");
X! 			losehp(rnd(10), "magical explosion");
X  #ifdef SPELLS
X  			Your("body absorbs some of the magical energy!");
X  			u.uen = (u.uenmax += 2);
X--- 552,558 ----
X  		case MGTRP:	    /* A magic trap. */
X  		    if (!rn2(30)) {
X  			You("are caught in a magical explosion!");
X! 			losehp(rnd(10), "magical explosion", KILLED_BY_AN);
X  #ifdef SPELLS
X  			Your("body absorbs some of the magical energy!");
X  			u.uen = (u.uenmax += 2);
X***************
X*** 515,521 ****
X  						) newsym(u.ux,u.uy);
X  		    } else domagictrap();
X  		    break;
X! 		case SQBRD:	    /* Stepped on a squeaky board. */
X  		    if (Levitation
X  #ifdef POLYSELF
X  			|| is_flyer(uasmon)
X--- 565,571 ----
X  						) newsym(u.ux,u.uy);
X  		    } else domagictrap();
X  		    break;
X! 		case SQBRD:	    /* stepped on a squeaky board */
X  		    if (Levitation
X  #ifdef POLYSELF
X  			|| is_flyer(uasmon)
X***************
X*** 524,541 ****
X  			if (Hallucination) You("notice a crease in the linoleum.");
X  			else You("notice a loose board below you.");
X  		    } else {
X! 			pline("A board underfoot gives off a loud squeak!");
X  			wake_nearby();
X  		    }
X  		    break;
X  		case WEB: /* Our luckless player has stumbled into a web. */
X  
X! 		    pline("You've %s into a spider web!",
X! 			  Levitation ? "floated" :
X  #ifdef POLYSELF
X! 			  is_flyer(uasmon) ? "flown" :
X  #endif
X- 			  "stumbled");
X  		    u.utraptype = TT_WEB;
X  
X  		    /* Time stuck in the web depends on your strength. */
X--- 574,592 ----
X  			if (Hallucination) You("notice a crease in the linoleum.");
X  			else You("notice a loose board below you.");
X  		    } else {
X! 			pline("A board beneath you squeaks loudly.");
X  			wake_nearby();
X  		    }
X  		    break;
X  		case WEB: /* Our luckless player has stumbled into a web. */
X  
X! 		    You("%s into a spider web!",
X! 			  Levitation ? "float" :
X  #ifdef POLYSELF
X! 			  locomotion(uasmon, "stumble"));
X! #else
X! 			  "stumble");
X  #endif
X  		    u.utraptype = TT_WEB;
X  
X  		    /* Time stuck in the web depends on your strength. */
X***************
X*** 556,584 ****
X  		    break;
X  
X  		case LANDMINE: {
X! #		ifndef LINT
X  		    register struct monst *mtmp = fmon;
X! #		endif /* LINT */
X  
X  		    if (Levitation
X  #ifdef POLYSELF
X! 						|| is_flyer(uasmon)
X  #endif
X  								) {
X! 			You("see a trigger in a pile of soil below you!");
X  			if (rn2(3)) break;
X  			pline("KAABLAMM!!!  The air currents set it off!");
X  		    } else {
X! #ifdef POLYSELF
X! 			pline("KAABLAMM!!!  You %s a land mine!",
X! 				nolimbs(uasmon) ? "encountered" : "stepped on");
X! #else
X! 			pline("KAABLAMM!!!  You stepped on a land mine!");
X! #endif
X  			set_wounded_legs(LEFT_SIDE, 40 + rnd(35));
X  			set_wounded_legs(RIGHT_SIDE, 40 + rnd(35));
X  		    }
X! 		    losehp(rnd(16), "land mine");
X  		    /* wake everything on the level */
X  		    while(mtmp) {
X  			if(mtmp->msleep) mtmp->msleep = 0;
X--- 607,630 ----
X  		    break;
X  
X  		case LANDMINE: {
X! #ifndef LINT
X  		    register struct monst *mtmp = fmon;
X! #endif
X  
X  		    if (Levitation
X  #ifdef POLYSELF
X! 					|| is_flyer(uasmon)
X  #endif
X  								) {
X! 			You("see a trigger in a pile of soil below you.");
X  			if (rn2(3)) break;
X  			pline("KAABLAMM!!!  The air currents set it off!");
X  		    } else {
X! 			pline("KAABLAMM!!!  You triggered a land mine!");
X  			set_wounded_legs(LEFT_SIDE, 40 + rnd(35));
X  			set_wounded_legs(RIGHT_SIDE, 40 + rnd(35));
X  		    }
X! 		    losehp(rnd(16), "land mine", KILLED_BY_AN);
X  		    /* wake everything on the level */
X  		    while(mtmp) {
X  			if(mtmp->msleep) mtmp->msleep = 0;
X***************
X*** 594,601 ****
X  	}
X  }
X  
X  #ifdef WALKIES
X! static boolean
X  teleport_pet(mtmp)
X  register struct monst *mtmp;
X  {
X--- 640,654 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ 
X  #ifdef WALKIES
X! 
X! OSTATIC boolean FDECL(teleport_pet, (struct monst *));
X! 
X! #ifdef OVLB
X! 
X! XSTATIC boolean
X  teleport_pet(mtmp)
X  register struct monst *mtmp;
X  {
X***************
X*** 618,625 ****
X--- 671,698 ----
X  	}
X  	return TRUE;
X  }
X+ 
X+ #endif /* OVLB */
X+ 
X  #endif
X  
X+ #ifdef OVLB
X+ 
X+ XSTATIC void
X+ seetrap(trap)
X+ 
X+ 	register struct trap *trap;
X+ {
X+ 	if(!trap->tseen) {
X+ 
X+ 	    trap->tseen = 1;
X+ 	    newsym(trap->tx, trap->ty);
X+ 	}
X+ }
X+ 
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  int
X  mintrap(mtmp)
X  register struct monst *mtmp;
X***************
X*** 651,660 ****
X  			if(mtmp->data->msize > MZ_SMALL &&
X  			   !amorphous(mtmp->data)) {
X  				mtmp->mtrapped = 1;
X! 				if(in_sight)
X  				  pline("%s is caught in a bear trap!",
X  					Monnam(mtmp));
X! 				else
X  				    if((mtmp->data == &mons[PM_OWLBEAR]
X  					|| mtmp->data == &mons[PM_BUGBEAR])
X  					&& flags.soundok)
X--- 724,734 ----
X  			if(mtmp->data->msize > MZ_SMALL &&
X  			   !amorphous(mtmp->data)) {
X  				mtmp->mtrapped = 1;
X! 				if(in_sight) {
X  				  pline("%s is caught in a bear trap!",
X  					Monnam(mtmp));
X! 				  seetrap(trap);
X! 				} else
X  				    if((mtmp->data == &mons[PM_OWLBEAR]
X  					|| mtmp->data == &mons[PM_BUGBEAR])
X  					&& flags.soundok)
X***************
X*** 663,681 ****
X  			break;
X  #ifdef POLYSELF
X  		case POLY_TRAP:
X! 		    if(!resist(mtmp, WAND_SYM, 0, NOTELL))
X  			(void) newcham(mtmp, (struct permonst *)0);
X  		    break;
X  #endif
X  		case RUST_TRAP:
X  			if(in_sight)
X! 				pline("A gush of water hits %s!", mon_nam(mtmp));
X  #ifdef GOLEMS
X  			if (mtmp->data == &mons[PM_IRON_GOLEM]) {
X! 				if (in_sight) pline("%s falls to pieces!",
X! 								Monnam(mtmp));
X  				else if(mtmp->mtame)
X! 				     pline("May %s rust in peace.",
X  								mon_nam(mtmp));
X  				mondied(mtmp);
X  				trapkilled = TRUE;
X--- 737,759 ----
X  			break;
X  #ifdef POLYSELF
X  		case POLY_TRAP:
X! 		    if(!resist(mtmp, WAND_SYM, 0, NOTELL)) {
X  			(void) newcham(mtmp, (struct permonst *)0);
X+ 			seetrap(trap);
X+ 		    }
X  		    break;
X  #endif
X  		case RUST_TRAP:
X  			if(in_sight)
X! 			    pline("A gush of water hits %s!", mon_nam(mtmp));
X! 			if(cansee(mtmp->mx,mtmp->my))
X! 			    seetrap(trap);
X  #ifdef GOLEMS
X  			if (mtmp->data == &mons[PM_IRON_GOLEM]) {
X! 				if (in_sight)
X! 				    pline("%s falls to pieces!", Monnam(mtmp));
X  				else if(mtmp->mtame)
X! 				    pline("May %s rust in peace.",
X  								mon_nam(mtmp));
X  				mondied(mtmp);
X  				trapkilled = TRUE;
X***************
X*** 693,717 ****
X  			break;
X  		case PIT:
X  		case SPIKED_PIT:
X! 			/* there should be a mtmp/data -> floating */
X! 			if(!is_flyer(mtmp->data) /* ab */
X! 			   && mtmp->data != &mons[PM_WUMPUS] /* 3. */) {
X  				if (!passes_walls(mtmp->data))
X! 				  mtmp->mtrapped = 1;
X! 				if(in_sight)
X! 				  pline("%s falls into a pit!", Monnam(mtmp));
X  				if(thitm(0, mtmp, (struct obj *)0,
X! 				  rnd((tt==PIT) ? 6 : 10)))
X! 				  trapkilled = TRUE;
X  			}
X  			break;
X  		case SLP_GAS_TRAP:
X  			if(!resists_sleep(mtmp->data) &&
X! 			   !mtmp->msleep && !mtmp->mfroz) {
X! 				mtmp->msleep = 1;
X  				if(in_sight)
X  				  pline("%s suddenly falls asleep!",
X  					Monnam(mtmp));
X  			}
X  			break;
X  		case TELEP_TRAP:
X--- 771,800 ----
X  			break;
X  		case PIT:
X  		case SPIKED_PIT:
X! 			/* TO DO: there should be a mtmp/data -> floating */
X! 			if(!is_flyer(mtmp->data) &&
X! 			   mtmp->data != &mons[PM_WUMPUS]) {
X  				if (!passes_walls(mtmp->data))
X! 				    mtmp->mtrapped = 1;
X! 				if(in_sight) {
X! 				    pline("%s falls into a pit!", Monnam(mtmp));
X! 				    seetrap(trap);
X! 				}
X  				if(thitm(0, mtmp, (struct obj *)0,
X! 					 rnd((tt==PIT) ? 6 : 10)))
X! 				    trapkilled = TRUE;
X  			}
X  			break;
X  		case SLP_GAS_TRAP:
X  			if(!resists_sleep(mtmp->data) &&
X! 			   !mtmp->msleep && mtmp->mcanmove) {
X! 				mtmp->mcanmove = 0;
X! 				mtmp->mfrozen = rnd(25);
X  				if(in_sight)
X  				  pline("%s suddenly falls asleep!",
X  					Monnam(mtmp));
X+ 				if(cansee(mtmp->mx,mtmp->my))
X+ 				    seetrap(trap);
X  			}
X  			break;
X  		case TELEP_TRAP:
X***************
X*** 724,732 ****
X  			     */
X  			    if (trap->once) vloc(mtmp);
X  			    else rloc(mtmp);
X! 			    if(in_sight && !cansee(mtmp->mx,mtmp->my))
X  				pline("%s suddenly disappears!",
X  					Monnam(mtmp));
X  #ifdef WALKIES
X  			}
X  #endif
X--- 807,817 ----
X  			     */
X  			    if (trap->once) vloc(mtmp);
X  			    else rloc(mtmp);
X! 			    if(in_sight && !cansee(mtmp->mx,mtmp->my)) {
X  				pline("%s suddenly disappears!",
X  					Monnam(mtmp));
X+ 				seetrap(trap);
X+ 			    }
X  #ifdef WALKIES
X  			}
X  #endif
X***************
X*** 735,740 ****
X--- 820,826 ----
X  			otmp = mksobj(ARROW, FALSE);
X  			otmp->quan = 1;
X  			otmp->owt = weight(otmp);
X+ 			if(in_sight) seetrap(trap);
X  			if(thitm(8, mtmp, otmp, 0)) trapkilled = TRUE;
X  			break;
X  		case DART_TRAP:
X***************
X*** 742,747 ****
X--- 828,834 ----
X  			otmp->quan = 1;
X  			if (!rn2(6)) otmp->opoisoned = 1;
X  			otmp->owt = weight(otmp);
X+ 			if(in_sight) seetrap(trap);
X  			if(thitm(7, mtmp, otmp, 0)) trapkilled = TRUE;
X  			break;
X  		case TRAPDOOR:
X***************
X*** 753,762 ****
X--- 840,851 ----
X  				otmp = mksobj(ROCK, FALSE);
X  				otmp->quan = 1;
X  				otmp->owt = weight(otmp);
X+ 				if(in_sight) seetrap(trap);
X  				if(thitm(0, mtmp, otmp, d(2, 10)))
X  					trapkilled = TRUE;
X  				break;
X  			}
X+ 			if (mtmp->data == &mons[PM_WUMPUS]) break;
X  			tdoor = TRUE;
X  			/* Fall through */
X  		case LEVEL_TELEP:
X***************
X*** 765,771 ****
X  				&& !mtmp->wormno
X  			    /* long worms with tails mustn't change levels */
X  #endif
X! 			    ){
X  #ifdef WALKIES
X  			    if(teleport_pet(mtmp)) {
X  #endif
X--- 854,860 ----
X  				&& !mtmp->wormno
X  			    /* long worms with tails mustn't change levels */
X  #endif
X! 			    ) {
X  #ifdef WALKIES
X  			    if(teleport_pet(mtmp)) {
X  #endif
X***************
X*** 786,793 ****
X  				    }
X  				    fall_down(mtmp, newlev);
X  				}
X! 				if(in_sight)
X  		pline("Suddenly, %s disappears out of sight.", mon_nam(mtmp));
X  				return(2);	/* no longer on this level */
X  #ifdef WALKIES
X  			    }
X--- 875,884 ----
X  				    }
X  				    fall_down(mtmp, newlev);
X  				}
X! 				if(in_sight) {
X  		pline("Suddenly, %s disappears out of sight.", mon_nam(mtmp));
X+ 				    seetrap(trap);
X+ 				}
X  				return(2);	/* no longer on this level */
X  #ifdef WALKIES
X  			    }
X***************
X*** 804,834 ****
X  			register struct monst *ztmp = fmon;
X  
X  			if(is_flyer(mtmp->data)) break;
X! 			/* Stepped on a squeaky board. */
X! 			if (in_sight)
X! 			   pline("%s steps on a squeaky board.", Monnam(mtmp));
X! 			else
X  			   You("hear a distant squeak.");
X! 			/* Wake up nearby monsters. */
X! 		       while(ztmp) {
X! 			 if(dist2(mtmp->mx,mtmp->my,ztmp->mx,ztmp->my) < 40)
X! 			       if(ztmp->msleep) ztmp->msleep = 0;
X! 			 ztmp = ztmp->nmon;
X! 		       }
X  			break;
X  		}
X  	       case WEB:
X! 		       /* Monster in a web. */
X! 			/* in_sight check and confused bear by Eric Backus */
X! 		       if(mtmp->data->mlet != S_SPIDER) {
X! 			 if(in_sight)
X! 				pline("%s is caught in a web!", Monnam(mtmp));
X! 			  else
X! 			    if(mtmp->data == &mons[PM_OWLBEAR])
X! 			      You("hear the roaring of a confused bear!");
X! 			 mtmp->mtrapped = 1;
X! 		       }
X! 		      break;
X  #ifdef SPELLS
X  		case ANTI_MAGIC:	break;
X  #endif
X--- 895,926 ----
X  			register struct monst *ztmp = fmon;
X  
X  			if(is_flyer(mtmp->data)) break;
X! 			/* stepped on a squeaky board */
X! 			if (in_sight) {
X! 			    pline("A board beneath %s squeaks loudly.", mon_nam(mtmp));
X! 			    seetrap(trap);
X! 			} else
X  			   You("hear a distant squeak.");
X! 			/* wake up nearby monsters */
X! 			while(ztmp) {
X! 			    if(dist2(mtmp->mx,mtmp->my,ztmp->mx,ztmp->my) < 40)
X! 				if(ztmp->msleep) ztmp->msleep = 0;
X! 			    ztmp = ztmp->nmon;
X! 			}
X  			break;
X  		}
X  	       case WEB:
X! 			/* Monster in a web. */
X! 			if(mtmp->data->mlet != S_SPIDER) {
X! 			    if(in_sight)
X! 				pline("%s is caught in a web.", Monnam(mtmp));
X! 			    else /* Eric Backus */
X! 				if(mtmp->data == &mons[PM_OWLBEAR] ||
X! 					mtmp->data == &mons[PM_BUGBEAR])
X! 				    You("hear the roaring of a confused bear!");
X! 			    mtmp->mtrapped = 1;
X! 			}
X! 			break;
X  #ifdef SPELLS
X  		case ANTI_MAGIC:	break;
X  #endif
X***************
X*** 838,845 ****
X  			if(rn2(3))
X  				break; /* monsters usually don't set it off */
X  			if(in_sight)
X! 				pline("KAABLAMM!!!  %s steps on a land mine!",
X! 				      Monnam(mtmp));
X  			else if (flags.soundok)
X  				pline("Kaablamm!  You hear an explosion in the distance!");
X  			deltrap(t_at(mtmp->mx, mtmp->my));
X--- 930,937 ----
X  			if(rn2(3))
X  				break; /* monsters usually don't set it off */
X  			if(in_sight)
X! 			    pline("KAABLAMM!!!  %s triggers a land mine!",
X! 				  Monnam(mtmp));
X  			else if (flags.soundok)
X  				pline("Kaablamm!  You hear an explosion in the distance!");
X  			deltrap(t_at(mtmp->mx, mtmp->my));
X***************
X*** 854,860 ****
X  			break;
X  		}
X  		default:
X! 			impossible("Some monster encountered a strange trap of type %d.",tt);
X  	    }
X  	}
X  	if(trapkilled) return 2;
X--- 946,952 ----
X  			break;
X  		}
X  		default:
X! 			impossible("Some monster encountered a strange trap of type %d.", tt);
X  	    }
X  	}
X  	if(trapkilled) return 2;
X***************
X*** 861,869 ****
X  	else return mtmp->mtrapped;
X  }
X  
X  void
X  selftouch(arg)
X! char *arg;
X  {
X  	if(uwep && (uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE)
X  #ifdef POLYSELF
X--- 953,964 ----
X  	else return mtmp->mtrapped;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  selftouch(arg)
X! const char *arg;
X  {
X  	if(uwep && (uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE)
X  #ifdef POLYSELF
X***************
X*** 872,878 ****
X  	){
X  		pline("%s touch the cockatrice corpse.", arg);
X  		You("turn to stone...");
X! 		killer = "cockatrice corpse accident";
X  		done(STONING);
X  	}
X  }
X--- 967,974 ----
X  	){
X  		pline("%s touch the cockatrice corpse.", arg);
X  		You("turn to stone...");
X! 		killer_format = KILLED_BY;
X! 		killer = "touching a cockatrice corpse";
X  		done(STONING);
X  	}
X  }
X***************
X*** 988,993 ****
X--- 1084,1091 ----
X  	unsee();
X  	u.utrap = 0;
X  	u.ustuck = 0;
X+ 	u.ux0 = u.ux;
X+ 	u.uy0 = u.uy;
X  	u.ux = nux;
X  	u.uy = nuy;
X  #ifdef POLYSELF
X***************
X*** 1013,1019 ****
X--- 1111,1121 ----
X  	struct trap *trap;
X  #ifdef SPELLS
X  	boolean castit = FALSE;
X+ # ifdef __GNULINT__
X+ 	register int sp_no = 0;
X+ # else
X  	register int sp_no;
X+ # endif
X  #endif
X  
X  	trap = t_at(u.ux, u.uy);
X***************
X*** 1034,1040 ****
X  		if (trap)
X  #ifdef POLYSELF
X  			You("%s onto the teleportation trap.",
X! 			    nolimbs(uasmon) ? "slither" : "jump");
X  #else
X  			You("jump onto the teleportation trap.");
X  #endif
X--- 1136,1142 ----
X  		if (trap)
X  #ifdef POLYSELF
X  			You("%s onto the teleportation trap.",
X! 			    locomotion(uasmon, "jump"));
X  #else
X  			You("jump onto the teleportation trap.");
X  #endif
X***************
X*** 1188,1195 ****
X  #endif
X  		if(newlevel <= -10) {
X  			You("arrive in heaven.");
X! 			pline("\"You are here a bit early, but we'll let you in.\"");
X! 			killer = "visit to heaven";
X  			done(DIED);
X  		} else	if (newlevel == -9) {
X  			You("feel deliriously happy. ");
X--- 1290,1298 ----
X  #endif
X  		if(newlevel <= -10) {
X  			You("arrive in heaven.");
X! 			verbalize("Thou art early, but we'll admit thee.");
X! 			killer_format = NO_KILLER_PREFIX;
X! 			killer = "went to heaven prematurely";
X  			done(DIED);
X  		} else	if (newlevel == -9) {
X  			You("feel deliriously happy. ");
X***************
X*** 1219,1225 ****
X  		pline("Unfortunately, you don't know how to fly.");
X  		You("plummet a few thousand feet to your death.");
X  		dlevel = 0;
X! 		killer = "long fall";
X  		done(DIED);
X  #ifdef WIZARD
X  		return;  
X--- 1322,1330 ----
X  		pline("Unfortunately, you don't know how to fly.");
X  		You("plummet a few thousand feet to your death.");
X  		dlevel = 0;
X! 		killer_format = NO_KILLER_PREFIX;
X! 		killer =
X!     self_pronoun("teleported out of the dungeon and fell to %s death","his");
X  		done(DIED);
X  #ifdef WIZARD
X  		return;  
X***************
X*** 1284,1303 ****
X  			} else {
X  				num = rnd(6);
X  				u.uhpmax -= num;
X! 				losehp(num,"burst of flame");
X  				break;
X  			}
X  		      }
X  
X  	     /* odd feelings */
X! 	     case 13:   pline("A shiver runs up and down your spine!");
X!              /* TO DO: What if you're polymorphed into something spineless? */
X  			break;
X  	     case 14:	You(Hallucination ?
X  				"hear the moon howling at you." :
X  				"hear distant howling.");
X  			break;
X! 	     case 15:   You("suddenly yearn for your distant homeland.");
X  			break;
X  	     case 16:   Your("pack shakes violently!");
X  			break;
X--- 1389,1410 ----
X  			} else {
X  				num = rnd(6);
X  				u.uhpmax -= num;
X! 				losehp(num,"burst of flame", KILLED_BY_AN);
X  				break;
X  			}
X  		      }
X  
X  	     /* odd feelings */
X! 	     case 13:	pline("A shiver runs up and down your %s!",
X! 			      body_part(SPINE));
X  			break;
X  	     case 14:	You(Hallucination ?
X  				"hear the moon howling at you." :
X  				"hear distant howling.");
X  			break;
X! 	     case 15:	You("suddenly yearn for %s.",
X! 				Hallucination ? "Cleveland" :
X! 						"your distant homeland");
X  			break;
X  	     case 16:   Your("pack shakes violently!");
X  			break;
X***************
X*** 1344,1356 ****
X  
X  	/* Scrolls and potions get affected by the water */
X  	for(obj = invent; obj; obj = obj->nobj) {
X! 		if(obj->olet == SCROLL_SYM && rn2(12) > u.uluck
X  #ifdef MAIL
X  			&& obj->otyp != SCR_MAIL
X  #endif
X  								)
X  			obj->otyp = SCR_BLANK_PAPER;
X! 		if(obj->olet == POTION_SYM && rn2(12) > u.uluck) {
X  			if (obj->spe == -1) {
X  				obj->otyp = POT_WATER;
X  				obj->blessed = obj->cursed = 0;
X--- 1451,1463 ----
X  
X  	/* Scrolls and potions get affected by the water */
X  	for(obj = invent; obj; obj = obj->nobj) {
X! 		if(obj->olet == SCROLL_SYM && rn2(12) > Luck
X  #ifdef MAIL
X  			&& obj->otyp != SCR_MAIL
X  #endif
X  								)
X  			obj->otyp = SCR_BLANK_PAPER;
X! 		if(obj->olet == POTION_SYM && rn2(12) > Luck) {
X  			if (obj->spe == -1) {
X  				obj->otyp = POT_WATER;
X  				obj->blessed = obj->cursed = 0;
X***************
X*** 1378,1389 ****
X  #ifdef WIZARD
X  	wizard ||
X  #endif
X! 	rn2(3) < u.uluck+2) {
X  		You("attempt a teleport spell.");	/* utcsri!carroll */
X  		(void) dotele();
X  		if(!is_pool(u.ux,u.uy)) return;
X  	}
X  	You("drown.");
X  	killer = levl[u.ux][u.uy].typ == POOL ? "pool of water" : "moat";
X  	done(DROWNING);
X  }
X--- 1485,1497 ----
X  #ifdef WIZARD
X  	wizard ||
X  #endif
X! 	rn2(3) < Luck+2) {
X  		You("attempt a teleport spell.");	/* utcsri!carroll */
X  		(void) dotele();
X  		if(!is_pool(u.ux,u.uy)) return;
X  	}
X  	You("drown.");
X+ 	killer_format = KILLED_BY_AN;
X  	killer = levl[u.ux][u.uy].typ == POOL ? "pool of water" : "moat";
X  	done(DROWNING);
X  }
X***************
X*** 1519,1528 ****
X  	register struct obj *otmp,*otmp2;
X  	char	buf[80];
X  
X! 	if(rn2(13+u.uluck) > 7) return;
X  
X  	otmp = obj;
X! 	switch(rn2(13-u.uluck)) {	/* which trap? */
X  		case 23:
X  		case 22:
X  		case 21:
X--- 1627,1638 ----
X  	register struct obj *otmp,*otmp2;
X  	char	buf[80];
X  
X! 	if(Luck > -13 && rn2(13+Luck) > 7) return;
X  
X  	otmp = obj;
X! 	switch(rn2(20) ? ((Luck >= 13) ? 0 : rn2(13-Luck)) : rn2(26)) {
X! 		case 25:
X! 		case 24:
X  		case 23:
X  		case 22:
X  		case 21:
X***************
X*** 1536,1542 ****
X  			    delobj(otmp);
X  			}
X  
X! 			losehp(d(6,6), buf);
X  			wake_nearby();
X  			return;
X  		case 20:
X--- 1646,1652 ----
X  			    delobj(otmp);
X  			}
X  
X! 			losehp(d(6,6), buf, KILLED_BY_AN);
X  			wake_nearby();
X  			return;
X  		case 20:
X***************
X*** 1545,1562 ****
X  		case 17:
X  			pline("A cloud of noxious gas billows from the %s.",
X  			      xname(obj));
X! 			poisoned("gas cloud", A_STR, "cloud of poison gas");
X  			break;
X  		case 16:
X  		case 15:
X  		case 14:
X  		case 13:
X  			pline("A tower of flame erupts from the %s",
X  			      xname(obj));
X  			if(Fire_resistance) {
X  			    shieldeff(u.ux, u.uy);
X  			    You("don't seem to be affected.");
X! 			} else	losehp(d(4, 6), "tower of flame");
X  			destroy_item(SCROLL_SYM, AD_FIRE);
X  #ifdef SPELLS
X  			destroy_item(SPBOOK_SYM, AD_FIRE);
X--- 1655,1679 ----
X  		case 17:
X  			pline("A cloud of noxious gas billows from the %s.",
X  			      xname(obj));
X! 			poisoned("gas cloud", A_STR, "cloud of poison gas",15);
X  			break;
X  		case 16:
X  		case 15:
X  		case 14:
X  		case 13:
X+ 			You("feel a needle prick your %s.",body_part(bodypart));
X+ 			poisoned("needle", A_CON, "poison needle",10);
X+ 			break;
X+ 		case 12:
X+ 		case 11:
X+ 		case 10:
X+ 		case 9:
X  			pline("A tower of flame erupts from the %s",
X  			      xname(obj));
X  			if(Fire_resistance) {
X  			    shieldeff(u.ux, u.uy);
X  			    You("don't seem to be affected.");
X! 			} else	losehp(d(4, 6), "tower of flame", KILLED_BY_AN);
X  			destroy_item(SCROLL_SYM, AD_FIRE);
X  #ifdef SPELLS
X  			destroy_item(SPBOOK_SYM, AD_FIRE);
X***************
X*** 1563,1589 ****
X  #endif
X  			destroy_item(POTION_SYM, AD_FIRE);
X  			break;
X! 		case 12:
X! 		case 10:
X! 		case 9:
X  			You("are jolted by a surge of electricity!");
X  			if(Shock_resistance)  {
X  			    shieldeff(u.ux, u.uy);
X  			    You("don't seem to be affected.");
X! 			} else	losehp(d(4, 4), "electric shock");
X  			destroy_item(RING_SYM, AD_ELEC);
X  			destroy_item(WAND_SYM, AD_ELEC);
X  			break;
X! 		case 8:
X! 		case 7:
X! 		case 6:
X  			pline("Suddenly you are frozen in place!");
X  			nomovemsg = "You can move again.";
X  			multi = -d(5, 6);
X  			break;
X! 		case 5:
X! 		case 4:
X! 		case 3:
X  			pline("A cloud of %s gas billows from the %s",
X  			      hcolor(), xname(obj));
X  			if(!Stunned)
X--- 1680,1706 ----
X  #endif
X  			destroy_item(POTION_SYM, AD_FIRE);
X  			break;
X! 		case 8:
X! 		case 7:
X! 		case 6:
X  			You("are jolted by a surge of electricity!");
X  			if(Shock_resistance)  {
X  			    shieldeff(u.ux, u.uy);
X  			    You("don't seem to be affected.");
X! 			} else	losehp(d(4, 4), "electric shock", KILLED_BY_AN);
X  			destroy_item(RING_SYM, AD_ELEC);
X  			destroy_item(WAND_SYM, AD_ELEC);
X  			break;
X! 		case 5:
X! 		case 4:
X! 		case 3:
X  			pline("Suddenly you are frozen in place!");
X  			nomovemsg = "You can move again.";
X  			multi = -d(5, 6);
X  			break;
X! 		case 2:
X! 		case 1:
X! 		case 0:
X  			pline("A cloud of %s gas billows from the %s",
X  			      hcolor(), xname(obj));
X  			if(!Stunned)
X***************
X*** 1594,1607 ****
X  			make_stunned(HStun + rn1(7, 16),FALSE);
X  			make_hallucinated(Hallucination + rn1(5, 16),FALSE);
X  			break;
X! 		default:
X! 			You("feel a needle prick your %s.",body_part(bodypart));
X! 			poisoned("needle", A_CON, "a poisoned needle");
X  			break;
X  	}
X  	otmp->otrapped = 0;		/* these traps are one-shot things */
X  }
X  
X  void
X  wake_nearby() {			/* Wake up nearby monsters. */
X  	register struct monst *mtmp;
X--- 1711,1726 ----
X  			make_stunned(HStun + rn1(7, 16),FALSE);
X  			make_hallucinated(Hallucination + rn1(5, 16),FALSE);
X  			break;
X! 		default: impossible("bad chest trap");
X  			break;
X  	}
X+ 	bot(); 			/* to get immediate botl re-display */
X  	otmp->otrapped = 0;		/* these traps are one-shot things */
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  void
X  wake_nearby() {			/* Wake up nearby monsters. */
X  	register struct monst *mtmp;
X***************
X*** 1614,1619 ****
X--- 1733,1741 ----
X  	}
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL0
X+ 
X  struct trap *
X  t_at(x,y)
X  register int x, y;
X***************
X*** 1626,1631 ****
X--- 1748,1756 ----
X  	return((struct trap *)0);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  deltrap(trap)
X  register struct trap *trap;
X***************
X*** 1643,1662 ****
X  
X  void
X  b_trapped(item)		/* used for doors. can be used */
X! register char *item;    /* for anything else that opens */
X  {
X  	register int dmg = rnd(5+(dlevel < 5 ? dlevel : 2+dlevel/2));
X  
X  	pline("KABOOM!!  The %s was booby-trapped!", item);
X! 	if(u.ulevel < 4 && dlevel < 3 && !rn2(3)) 
X  		You("are shaken, but luckily unhurt.");		
X! 	else losehp(dmg, "explosion");
X  	make_stunned(HStun + dmg, TRUE);
X  }
X  
X  /* Monster is hit by trap. */
X  /* Note: doesn't work if both obj and d_override are null */
X! static boolean
X  thitm(tlev, mon, obj, d_override)
X  register int tlev;
X  register struct monst *mon;
X--- 1768,1787 ----
X  
X  void
X  b_trapped(item)		/* used for doors. can be used */
X! register const char *item;    /* for anything else that opens */
X  {
X  	register int dmg = rnd(5+(dlevel < 5 ? dlevel : 2+dlevel/2));
X  
X  	pline("KABOOM!!  The %s was booby-trapped!", item);
X! 	if(u.ulevel < 4 && dlevel < 3 && !rnl(3))
X  		You("are shaken, but luckily unhurt.");		
X! 	else losehp(dmg, "explosion", KILLED_BY_AN);
X  	make_stunned(HStun + dmg, TRUE);
X  }
X  
X  /* Monster is hit by trap. */
X  /* Note: doesn't work if both obj and d_override are null */
X! XSTATIC boolean
X  thitm(tlev, mon, obj, d_override)
X  register int tlev;
X  register struct monst *mon;
X***************
X*** 1719,1721 ****
X--- 1844,1848 ----
X  		!strncmp(nomovemsg,"You regain con", 15) ||
X  		!strncmp(nomovemsg,"You are consci", 15)));
X  }
X+ 
X+ #endif /* OVLB */
X*** others/Old/pcunix.c	Mon Feb 19 23:35:44 1990
X--- others/pcunix.c	Mon Feb  5 18:45:43 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pcunix.c	3.0	88/07/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pcunix.c	3.0	89/12/29
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 14,26 ****
X   */
X  
X  #include "hack.h"	/* mainly for index() which depends on BSD */
X- #ifdef TOS
X- #ifndef OLD_TOS
X- #include <errno.h>
X- #else
X- #include <error.h>
X- #endif /* OLD_TOS */
X- #endif
X  
X  #ifndef MACOS
X  #include	<sys/types.h>
X--- 14,19 ----
X***************
X*** 27,36 ****
X  #include	<sys/stat.h>
X  #endif
X  
X! #ifndef OLD_TOS
X! # ifndef MACOS
X! static struct stat buf, hbuf;
X  # endif
X  
X  void
X  setrandom()
X--- 20,33 ----
X  #include	<sys/stat.h>
X  #endif
X  
X! #ifdef OVLB
X! 
X! #ifndef MACOS
X! static struct stat buf;
X! # ifdef WANT_GETHDATE
X! static struct stat hbuf;
X  # endif
X+ #endif
X  
X  void
X  setrandom()
X***************
X*** 96,107 ****
X  	return(getlt()->tm_hour == 0);
X  }
X  
X! # ifndef MACOS
X  void
X  gethdate(name)
X  char *name;
X  {
X! #  if defined(TOS) && !defined(__GNUC__)
X  /* old version - for people short of space */
X  /*
X  /* register char *np;
X--- 93,104 ----
X  	return(getlt()->tm_hour == 0);
X  }
X  
X! #ifndef MACOS
X  void
X  gethdate(name)
X  char *name;
X  {
X! # ifdef WANT_GETHDATE
X  /* old version - for people short of space */
X  /*
X  /* register char *np;
X***************
X*** 141,152 ****
X  	path = np + 1;
X      }
X      error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X! #  endif /* TOS && __GNUC__ */
X  }
X  
X  int
X! uptodate(fd) {
X! #  if defined(TOS) && !defined(__GNUC__) /* no fstat yet */
X      if(fstat(fd, &buf)) {
X  	pline("Cannot get status of saved level? ");
X  	return(0);
X--- 138,151 ----
X  	path = np + 1;
X      }
X      error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X! # endif /* WANT_GETHDATE */
X  }
X  
X  int
X! uptodate(fd)
X! int fd;
X! {
X! # ifdef WANT_GETHDATE
X      if(fstat(fd, &buf)) {
X  	pline("Cannot get status of saved level? ");
X  	return(0);
X***************
X*** 155,177 ****
X  	pline("Saved level is out of date. ");
X  	return(0);
X      }
X! #  endif
X      return(1);
X  }
X! # endif	/* MACOS /* */
X! #endif /* OLD_TOS /* */
X  
X  void
X  regularize(s)
X! 	/* normalize file name - we don't like .'s, /'s, :'s [Mac], or spaces */
X  register char *s;
X  {
X  	register char *lp;
X  
X  	while((lp=index(s, '.')) || (lp=index(s, '/')) || (lp=index(s,' '))
X! #ifdef MACOS
X! 			|| (lp=index(s, ':'))
X  #endif
X- 								)
X- 		*lp = '_';
X  }
X--- 154,203 ----
X  	pline("Saved level is out of date. ");
X  	return(0);
X      }
X! # else
X! #  if defined(MSDOS) && !defined(NO_FSTAT)
X!     if(fstat(fd, &buf)) {
X! 	if(moves > 1) pline("Cannot get status of saved level? ");
X! 	else pline("Cannot get status of saved game");
X! 	return(0);
X!     } 
X!     if(comp_times(buf.st_mtime)) { 
X! 	if(moves > 1) pline("Saved level is out of date");
X! 	else pline("Saved game is out of date. ");
X! 	return(0);
X!     }
X! #  endif  /* MSDOS /* */
X! # endif /* WANT_GETHDATE */
X      return(1);
X  }
X! #endif	/* MACOS /* */
X  
X  void
X  regularize(s)
X! /*
X!  * normalize file name - we don't like .'s, /'s, :'s [Mac], or spaces,
X!  * and in msdos / OS/2 we really get picky
X!  */
X  register char *s;
X  {
X  	register char *lp;
X  
X+ #ifdef MSDOS
X+ 	for (lp = s; *lp; lp++)
X+ 		if (*lp <= ' ' || *lp == '"' || (*lp >= '*' && *lp <= ',') ||
X+ 		    *lp == '.' || *lp == '/' || (*lp >= ':' && *lp <= '?') ||
X+ # ifdef OS2
X+ 		    *lp == '&' || *lp == '(' || *lp == ')' ||
X+ # endif
X+ 		    *lp == '|' || *lp >= 127 || (*lp >= '[' && *lp <= ']'))
X+                         *lp = '_';
X+ #else
X  	while((lp=index(s, '.')) || (lp=index(s, '/')) || (lp=index(s,' '))
X! # ifdef MACOS
X! 	   || (lp=index(s, ':'))
X! # endif
X! 		) *lp = '_';
X  #endif
X  }
X+ 
X+ #endif /* OVLB */
X*** others/Old/random.c	Mon Feb 19 23:35:59 1990
X--- others/random.c	Fri Feb 16 23:01:50 1990
X***************
X*** 15,22 ****
X   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X   */
X  
X! #if defined(LIBC_SCCS) && !defined(lint)
X  static char sccsid[] = "@(#)random.c	5.5 (Berkeley) 7/6/88";
X  #endif /* LIBC_SCCS and not lint */
X  
X  #include <stdio.h>
X--- 15,34 ----
X   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X   */
X  
X! /* Several minor changes were made for the NetHack distribution to satisfy
X!  * non-BSD compilers (by definition BSD compilers do not need to compile
X!  * this file for NetHack).  These changes consisted of:
X!  *	- changing the sccsid conditions to nested ifdefs from defined()s
X!  *	to accommodate stupid preprocessors
X!  *	- giving srandom() type void instead of allowing it to default to int
X!  *	- making the first return in initstate() return a value consistent
X!  *	with its type (instead of no value)
X!  */
X! 
X! #ifdef LIBC_SCCS
X! # ifndef lint
X  static char sccsid[] = "@(#)random.c	5.5 (Berkeley) 7/6/88";
X+ # endif
X  #endif /* LIBC_SCCS and not lint */
X  
X  #include <stdio.h>
X***************
X*** 182,187 ****
X--- 194,200 ----
X   * values produced by this routine.
X   */
X  
X+ void
X  srandom( x )
X  
X      unsigned		x;
X***************
X*** 236,242 ****
X  	if(  n  <  BREAK_1  )  {
X  	    if(  n  <  BREAK_0  )  {
X  		fprintf( stderr, "initstate: not enough state (%d bytes) with which to do jack; ignored.\n", n );
X! 		return;
X  	    }
X  	    rand_type = TYPE_0;
X  	    rand_deg = DEG_0;
X--- 249,255 ----
X  	if(  n  <  BREAK_1  )  {
X  	    if(  n  <  BREAK_0  )  {
X  		fprintf( stderr, "initstate: not enough state (%d bytes) with which to do jack; ignored.\n", n );
X! 		return (char *)0;
X  	    }
X  	    rand_type = TYPE_0;
X  	    rand_deg = DEG_0;
X*** others/Old/trampoli.c	Mon Feb 19 23:37:13 1990
X--- others/trampoli.c	Wed Feb  7 18:39:42 1990
X***************
X*** 39,44 ****
X--- 39,50 ----
X  #undef domonability
X  #endif /* POLYSELF */
X  
X+ #ifdef EXPLORE_MODE
X+ #undef enter_explore_mode
X+ 
X+ int enter_explore_mode() { return enter_explore_mode_(); }
X+ #endif
X+ 
X  #undef timed_occupation
X  
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X***************
X*** 131,137 ****
X  int Boots_off()   { return Boots_off_();   }
X  int Gloves_off()  { return Gloves_off_();  }
X  int Helmet_off()  { return Helmet_off_();  }
X! /* int Armor_on()    { return Armor_on_();    } */
X  int Boots_on()    { return Boots_on_();    }
X  int Gloves_on()   { return Gloves_on_();   }
X  int Helmet_on()   { return Helmet_on_();   }
X--- 137,143 ----
X  int Boots_off()   { return Boots_off_();   }
X  int Gloves_off()  { return Gloves_off_();  }
X  int Helmet_off()  { return Helmet_off_();  }
X! int Armor_on()    { return Armor_on_();    }
X  int Boots_on()    { return Boots_on_();    }
X  int Gloves_on()   { return Gloves_on_();   }
X  int Helmet_on()   { return Helmet_on_();   }
X***************
X*** 173,180 ****
X--- 179,188 ----
X  
X  
X  /* ### end.c ### */
X+ #undef done1
X  #undef done2
X  
X+ int done1() { return done1_(); }
X  int done2() { return done2_(); }
X  
X  
X***************
X*** 241,246 ****
X--- 249,259 ----
X  int forcelock() { return forcelock_(); }
X  int picklock()  { return picklock_();  }
X  
X+ /* ### mondata.c ### */
X+ #undef canseemon
X+ 
X+ boolean canseemon(x) struct monst *x; { return canseemon_(x); }
X+ 
X  
X  /* ### o_init.c ### */
X  #undef dodiscovered
X***************
X*** 290,296 ****
X  #undef in_container
X  #undef out_container
X  
X! int ck_bag()  { return ck_bag_();  }
X  int ck_container(obj)  struct obj *obj; { return ck_container_(obj); }
X  int doloot() { return doloot_(); }
X  int in_container(obj)  struct obj *obj; { return in_container_(obj); }
X--- 303,309 ----
X  #undef in_container
X  #undef out_container
X  
X! int ck_bag(obj) struct obj *obj; { return ck_bag_(obj);  }
X  int ck_container(obj)  struct obj *obj; { return ck_container_(obj); }
X  int doloot() { return doloot_(); }
X  int in_container(obj)  struct obj *obj; { return in_container_(obj); }
X***************
X*** 398,405 ****
X--- 411,420 ----
X  
X  /* ### version.c ### */
X  #undef doversion
X+ #undef doextversion
X  
X  int doversion() { return doversion_(); }
X+ int doextversion() { return doextversion_(); }
X  
X  
X  /* ### wield.c ### */
X
END_OF_FILE
if test 53640 -ne `wc -c <'patch7.21'`; then
    echo shar: \"'patch7.21'\" unpacked with wrong size!
fi
# end of 'patch7.21'
echo shar: End of archive 16 \(of 30\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
