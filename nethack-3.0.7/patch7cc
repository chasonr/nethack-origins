Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!brutus.cs.uiuc.edu!zaphod.mps.ohio-state.edu!think!mintaka!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i029:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7cc
Message-ID: <5243@tekred.CNA.TEK.COM>
Date: 24 Feb 90 01:11:07 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2063
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 29
Archive-name: NetHack3/Patch7cc
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 29 (of 30)."
# Contents:  include/monflag.h others/Makefile.ovl others/pcmain.c
#   src/vault.c
# Wrapped by billr@saab on Wed Feb 21 10:04:53 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/monflag.h' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'include/monflag.h'\" to \"'include/monflag.h.orig'\"
  mv -f 'include/monflag.h' 'include/monflag.h.orig'
fi
echo shar: Extracting \"'include/monflag.h'\" \(5432 characters\)
sed "s/^X//" >'include/monflag.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)monflag.h	3.0	89/11/21
X/* NetHack may be freely redistributed.  See license for details. */
X/* Copyright (c) 1989 Mike Threepoint */
X
X#ifndef MONFLAG_H
X#define MONFLAG_H
X
X#define MS_SILENT	0	/* makes no sound */
X#define MS_SQEEK	1	/* squeaks, as a rodent */
X#define MS_SQAWK	2	/* squawks, as a bird */
X#define MS_HISS 	3	/* hisses */
X#define MS_BUZZ 	4	/* buzzes (killer bee) */
X#define MS_GRUNT	5	/* grunts (or speaks own language) */
X#define MS_GROWL	6	/* growls */
X#define MS_BARK 	7	/* if full moon, may howl */
X#define MS_MEW		8	/* mews or hisses */
X#define MS_ROAR 	9	/* roars */
X#define MS_NEIGH	10	/* neighs, as an equine */
X#define MS_WAIL 	11	/* wails, as a tortured soul */
X#define MS_GURGLE	12	/* gurgles, as liquid or through saliva */
X#define MS_BURBLE	13	/* burbles (jabberwock) */
X#define MS_SHRIEK	15	/* wakes up others */
X#define MS_LAUGH	17	/* grins, smiles, giggles, and laughs */
X#define MS_MUMBLE	18	/* says something or other */
X#define MS_IMITATE	19	/* imitates others (leocrotta) */
X#define MS_SEDUCE	20	/* "Hello, sailor." (Nymphs) */
X#define MS_VAMPIRE	21	/* vampiric seduction, Vlad's exclamations */
X#define MS_ORC		MS_GRUNT	/* intelligent brutes */
X#ifdef INFERNO
X#define MS_BRIBE	25	/* asks for money, or berates you */
X#endif
X#define MS_CUSS 	26	/* berates (demons) or intimidates (Wiz) */
X#define MS_NURSE	27	/* "Take off your shirt, please." */
X#define MS_DJINNI	28	/* "Thank you for freeing me!" */
X#define MS_HUMANOID	29	/* generic traveling companion */
X#define MS_GUARD	30	/* "Please drop that gold and follow me." */
X#define MS_SELL 	31	/* demand payment, complain about shoplifters */
X#ifdef ORACLE
X#define MS_ORACLE	32	/* do a consultation */
X#endif
X#ifdef ALTARS
X#define MS_PRIEST	33	/* ask for contribution; do cleansing */
X#endif
X#ifdef KOPS
X#define MS_ARREST	34	/* "Stop in the name of the law!" (Kops) */
X#endif
X#ifdef ARMY
X#define MS_SOLDIER	35	/* army expressions */
X#endif
X
X#define M1_FLY		0x00000001L	/* can fly or float */
X#define M1_SWIM 	0x00000002L	/* can traverse water */
X#define M1_AMORPHOUS	0x00000004L	/* can flow under doors */
X#define M1_WALLWALK	0x00000008L	/* can phase thru rock */
X#define M1_TUNNEL	0x00000010L	/* can tunnel thru rock */
X#define M1_NEEDPICK	0x00000020L	/* needs pick to tunnel */
X#define M1_CONCEAL	0x00000040L	/* hides under objects */
X#define M1_HIDE 	0x00000080L	/* mimics, blends in with ceiling */
X#define M1_NOEYES	0x00000100L	/* no eyes to gaze into or blind */
X#define M1_NOHANDS	0x00000200L	/* no hands to handle things */
X#define M1_NOLIMBS	0x00000600L	/* no arms/legs to kick/wear on */
X#define M1_NOPOLY	0x00000800L	/* players mayn't poly into one */
X#define M1_HUMANOID	0x00001000L	/* has humanoid body */
X#define M1_ANIMAL	0x00002000L	/* has animal body */
X#define M1_SLITHY	0x00004000L	/* has serpent body */
X#define M1_THICK_HIDE	0x00008000L	/* has thick hide or scales */
X#define M1_FIRE_RES	0x00010000L	/* resists fire */
X#define M1_SLEE_RES	0x00020000L	/* resists sleep */
X#define M1_COLD_RES	0x00040000L	/* resists cold */
X#define M1_ELEC_RES	0x00080000L	/* resists electricity */
X#define M1_STON_RES	0x00100000L	/* resists stoning */
X#define M1_ACID 	0x00200000L	/* acidic to eat */
X#define M1_POIS_RES	0x00400000L	/* resists poison */
X#define M1_POIS 	0x00800000L	/* poisonous to eat */
X#define M1_REGEN	0x01000000L	/* regenerates hit points */
X#define M1_SEE_INVIS	0x02000000L	/* can see invisible creatures */
X#define M1_TPORT	0x04000000L	/* can teleport */
X#define M1_TPORT_CONTROL 0x08000000L	/* controls where it teleports to */
X#define M1_GREEDY	0x10000000L	/* likes gold */
X#define M1_JEWELS	0x20000000L	/* likes gems */
X#define M1_COLLECT	0x40000000L	/* picks up weapons and food */
X#define M1_MAGIC	0x80000000L	/* picks up magic items */
X
X#define M2_UNDEAD	0x00000001L	/* walking dead */
X#define M2_WERE 	0x00000002L	/* lycanthrope */
X#define M2_ELF		0x00000010L	/* is an elf */
X#define M2_DWARF	0x00000020L	/* is a dwarf */
X#define M2_GIANT	0x00000040L	/* is a giant */
X#define M2_ORC		0x00000080L	/* is an orc */
X#define M2_HUMAN	0x00000100L	/* is a human */
X#define M2_DEMON	0x00000200L	/* is a demon */
X#define M2_MERC 	0x00000400L	/* is a guard or soldier */
X#define M2_FEM		0x00000800L	/* characteristically female */
X#define M2_WANDER	0x00001000L	/* wanders randomly */
X#define M2_STALK	0x00002000L	/* follows you to other levels */
X#define M2_DOMESTIC	0x00004000L	/* can be tamed by feeding */
X#define M2_HOSTILE	0x00010000L	/* always starts hostile */
X#define M2_PEACEFUL	0x00020000L	/* always starts peaceful */
X#define M2_NASTY	0x00040000L	/* extra-nasty monster (more xp) */
X#define M2_STRONG	0x00080000L	/* strong (or big) monster */
X#define M2_CARNIVORE	0x00100000L	/* eats corpses */
X#define M2_HERBIVORE	0x00200000L	/* eats fruits */
X#define M2_OMNIVORE	0x00300000L	/* eats both */
X#define M2_METALLIVORE	0x00400000L	/* eats metal */
X#define M2_EGGS 	0x01000000L	/* lays eggs */
X#define M2_ROCKTHROW	0x04000000L	/* throws boulders */
X#define M2_PNAME	0x20000000L	/* monster name is a proper name */
X#define M2_LORD 	0x40000000L	/* a lord to its kind */
X#define M2_PRINCE	0x80000000L	/* an overlord to its kind */
X
X#define MZ_TINY		0		/* < 2' */
X#define MZ_SMALL 	1		/* 2-4' */
X#define MZ_MEDIUM	2		/* 4-7' */
X#define MZ_HUMAN	MZ_MEDIUM	/* human-sized */
X#define MZ_LARGE 	3		/* 7-12' */
X#define MZ_HUGE		4		/* 12-25' */
X#define MZ_GIGANTIC	7		/* off the scale */
X
X#endif /* MONFLAG_H */
END_OF_FILE
if test 5432 -ne `wc -c <'include/monflag.h'`; then
    echo shar: \"'include/monflag.h'\" unpacked with wrong size!
fi
# end of 'include/monflag.h'
if test -f 'others/Makefile.ovl' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'others/Makefile.ovl'\" to \"'others/Makefile.ovl.orig'\"
  mv -f 'others/Makefile.ovl' 'others/Makefile.ovl.orig'
fi
echo shar: Extracting \"'others/Makefile.ovl'\" \(19154 characters\)
sed "s/^X//" >'others/Makefile.ovl' <<'END_OF_FILE'
X#	SCCS Id: @(#)Makefile.ovl	3.0	90/02/08
X#	PC NetHack 3.0 Makefile for Microsoft(tm) "C" 5.1 -- Pierre Martineau
X#	Overlay Arrangement -- Stephen Spackman, Pierre Martineau, Norm Meluch
X#	Multiple Compilation Hack and so forth -- Stephen Spackman
X#
X#	 Other things that have to be reconfigured are in config.h, pcconf.h,
X#	 (for other targets: unixconf.h, tosconf.h), and possibly system.h.
X#
X#	 Nota Bene: OVERLAY *must* be defined in pcconf.h to use this makefile!
X#	 Also: Rename this file to "makefile", some targets rely on it.
X# -----------------------------------------------------------------------------
X#	 In addition to your C compiler,
X#
X#	 if you want to change	you will need a
X#	 files with suffix	workalike for
X#	   .y			  yacc
X#	   .l			  lex
X#	   .asm 		  masm
X#
X# *****************************************************************************
X# ************************ Compiler Info **************************************
X# *****************************************************************************
X# Large memory model, register bug, remove stack probes:
XCC	= cl /c
XLINK	= link
XMODEL	= L
XASM	= masm
X# $(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.
XMAKEBIN = make
X# For those of us who have these on PC.
X# YACC	 = yacc
X# LEX	 = lex
XYACC	= bison -y
XLEX	= flex
X# Standard file names may vary in PC installations.
XYTABC	= y_tab.c
XYTABH	= y_tab.h
XLEXYYC	= lexyy.c
X# /Gt22 is currently about the largest value that keeps the initialised data
X# segment below 64K (and keeps the linker happy).
X# 286 or higher machines can use the /G2 CFLAG option for better performance.
XCFLAGS	= /A$(MODEL) /Os /Oa /Gs /Gt22 /Zp1 /W0 /I$(INCL)
X#
XLFLAGS	= /noi /seg:512 /map /st:4096 /cp:5000
X#
XAFLAGS	= /MX 
X#
X# *****************************************************************************
X# ********* Directories (makedefs hardcodes these, don't change them) *********
X# *****************************************************************************
X#
XINCL	= ..\include
XAUX	= ..\auxil
XSRC	= ..\src
XOTHERS	= ..\others
XOBJ	= $(SRC)\o
X#
X# *****************************************************************************
X# ************************ Local Variables ************************************
X# *****************************************************************************
X#
X# The game name
XGAME	 = nethack
X#
X# The default make target (so just typing 'make' is useful)
XDEFAULT  : $(GAME)
X#
X# The game directory
X# make sure GAMEDIR exists!
XGAMEDIR  = ..
X#
X# The game filename
XGAMEFILE = $(GAMEDIR)\$(GAME).exe
X#
X# Target environment prefix
XTARG	 = pc
X#
X# Overlay manager object file.
XOVLMGR	 = ovlmgr.obj
X#
X# Termcap routines.
XTERMCAPS = $(SRC)\termlib.lib
X#
X###############################################################################
X# Switch the following lines if you have made changes in ovlmgr.asm
X(OBJ)\$(OVLMGR):
X#$(OBJ)\$(OVLMGR): ; copy $(OTHERS)\$(OVLMGR) $(OBJ)\$(OVLMGR)
X###############################################################################
X# If you have yacc and lex programs and make any changes, comment out the
X# upper two targets and uncomment the lower two.
X#do_yacc: yacc_msg
X#do_lex:  lex_msg
Xdo_yacc: yacc_act
Xdo_lex:  lex_act
X###############################################################################
X# Optional high-quality BSD random number generation routines (see pcconf.h).
X# Set to nothing if not used.
XRANDOM	 = $(OBJ)\random.o
X# RANDOM =
X###############################################################################
X# Optional C library specifier for those with non-standard libraries or
X# a multiple-target library setup.
X# CLIB	   = llibcer /nod
XCLIB	 =
X###############################################################################
X# If TERMLIB is NOT #defined in the source, comment out the lower line and
X# uncomment the upper. Don't forget to copy the $(TERMCAPS) file to the
X# $(SRC) directory if you have uncommented the lower line.
X#TERMLIB =
XTERMLIB = $(TERMCAPS)
X###############################################################################
X
X# nothing below this line should have to be changed
X
XROOT =	$(OBJ)\$(OVLMGR) $(OBJ)\trampoli.o $(OBJ)\main.o $(OBJ)\msdos.o \
X	$(OBJ)\mkroom.0 $(OBJ)\random.o $(OBJ)\rnd.01 $(OBJ)\mkobj.0 \
X	$(OBJ)\invent.0 $(OBJ)\decl.o
X
XOVL01 = $(OBJ)\track.0 $(OBJ)\monmove.01 $(OBJ)\cmd.0 $(OBJ)\dbridge.0 \
X	$(OBJ)\dog.0 $(OBJ)\engrave.01 $(OBJ)\mon.01 $(OBJ)\priest.0 \
X	$(OBJ)\shk.0 $(OBJ)\trap.01 $(OBJ)\mthrowu.0 \
X	$(OBJ)\mondata.01 $(OBJ)\mhitu.1 $(OBJ)\monst.o $(OBJ)\objects.o
XOVL02 = $(OBJ)\dogmove.0 $(OBJ)\apply.0
XOVL03 = $(OBJ)\makemon.0
XOVL04 = $(OBJ)\shk.12b
XOVL05 = $(OBJ)\hack.0
XOVL06 = $(OBJ)\alloc.o
XOVL07 = $(OBJ)\attrib.0 $(OBJ)\allmain.1
XOVL08 = $(OBJ)\attrib.2b $(OBJ)\exper.o
XOVL09 = $(OBJ)\cmd.2b $(OBJ)\getline.2 $(OBJ)\pray.o $(OBJ)\write.o
XOVL10 = $(OBJ)\dbridge.12b
XOVL11 = $(OBJ)\do_name.0
XOVL12 = $(OBJ)\getline.b
XOVL13 = $(OBJ)\invent.1
XOVL14 = $(OBJ)\makemon.1
XOVL15 = $(OBJ)\makemon.2b
XOVL16 = $(OBJ)\allmain.0 $(OBJ)\cmd.1 $(OBJ)\do.0 $(OBJ)\pickup.0 \
X	$(OBJ)\vault.0 $(OBJ)\wizard.0 $(OBJ)\artifact.0 $(OBJ)\timeout.0 \
X	$(OBJ)\attrib.1 $(OBJ)\eat.0 $(OBJ)\engrave.2 $(OBJ)\getline.01 \
X	$(OBJ)\mail.0 $(OBJ)\pri.1 $(OBJ)\prisym.1 $(OBJ)\sounds.0 \
X	$(OBJ)\track.1 $(OBJ)\hack.1
XOVL17 = $(OBJ)\hack.2
XOVL18 = $(OBJ)\mcastu.o $(OBJ)\demon.o
XOVL19 = $(OBJ)\mhitm.12b
XOVL20 = $(OBJ)\mhitm.0 $(OBJ)\mhitu.0 $(OBJ)\weapon.01
XOVL21 = $(OBJ)\mkobj.12b
XOVL22 = $(OBJ)\mon.2b $(OBJ)\trap.2
XOVL23 = $(OBJ)\monmove.2b $(OBJ)\steal.2b
XOVL24 = $(OBJ)\mthrowu.1
XOVL25 = $(OBJ)\mthrowu.2b
XOVL26 = $(OBJ)\objnam.01 $(OBJ)\pager.0 $(OBJ)\polyself.0 $(OBJ)\mondata.2
XOVL27 = $(OBJ)\objnam.2b
XOVL28 = $(OBJ)\pager.12b
XOVL29 = $(OBJ)\pri.0 $(OBJ)\prisym.0 $(OBJ)\termcap.0 $(OBJ)\topl.0
XOVL30 = $(OBJ)\pri.b $(OBJ)\topl.12
XOVL31 = $(OBJ)\priest.12b
XOVL32 = $(OBJ)\worm.o
XOVL33 = $(OBJ)\were.0
XOVL34 = $(OBJ)\prisym.2
XOVL35 = $(OBJ)\prisym.b
XOVL36 = $(OBJ)\read.0
XOVL37 = $(OBJ)\read.12b $(OBJ)\spell.o
XOVL38 = $(OBJ)\rnd.2b $(OBJ)\topl.b
XOVL39 = $(OBJ)\search.12b
XOVL40 = $(OBJ)\search.0 $(OBJ)\uhitm.0 $(OBJ)\weapon.2b
XOVL41 = $(OBJ)\steal.01
XOVL42 = $(OBJ)\termcap.1 $(OBJ)\unix.0
XOVL43 = $(OBJ)\termcap.2b
XOVL44 = $(OBJ)\timeout.12b $(OBJ)\mondata.b
XOVL45 = $(OBJ)\potion.0 $(OBJ)\artifact.1
XOVL46 = $(OBJ)\were.12b $(OBJ)\wizard.12b
XOVL47 = $(OBJ)\polyself.12b
XOVL48 = $(OBJ)\pickup.12b
XOVL49 = $(OBJ)\lock.o $(OBJ)\trap.b
XOVL50 = $(OBJ)\invent.2b
XOVL51 = $(OBJ)\hack.b
XOVL52 = $(OBJ)\eat.12b $(OBJ)\potion.12b
XOVL53 = $(OBJ)\dog.1 $(OBJ)\dogmove.12b
XOVL54 = $(OBJ)\dokick.o $(OBJ)\dothrow.o
XOVL55 = $(OBJ)\do.12b
XOVL56 = $(OBJ)\apply.12b
XOVL57 = $(OBJ)\dog.2b $(OBJ)\sounds.12b
XOVL58 = $(OBJ)\do_wear.01 $(OBJ)\mhitu.2b
XOVL59 = $(OBJ)\sit.o $(OBJ)\artifact.2b $(OBJ)\do_name.12b $(OBJ)\vault.12b \
X	$(OBJ)\fountain.o $(OBJ)\music.o $(OBJ)\rumors.o $(OBJ)\shknam.0
XOVL60 = $(OBJ)\worn.o $(OBJ)\wield.o $(OBJ)\do_wear.2b
XOVL61 = $(OBJ)\zap.o $(OBJ)\pri.2
XOVL62 = $(OBJ)\unix.12b $(OBJ)\mail.12b $(OBJ)\tty.o $(OBJ)\version.o \
X	$(OBJ)\options.o $(OBJ)\o_init.o $(OBJ)\allmain.2b $(OBJ)\engrave.b \
X	$(OBJ)\end.o $(OBJ)\save.o $(OBJ)\restore.o $(OBJ)\u_init.o \
X	$(OBJ)\topten.o $(OBJ)\shknam.12b $(OBJ)\rip.o
XOVL63 = $(OBJ)\bones.o $(OBJ)\mklev.o $(OBJ)\mkmaze.o $(OBJ)\mkroom.12b \
X	$(OBJ)\sp_lev.o $(OBJ)\track.2b $(OBJ)\extralev.o
X
X# *****************************************************************************
X# ************************* Make Objects **************************************
X# *****************************************************************************
X
XMOBJ = $(OVL01) $(OVL02) $(OVL03) $(OVL04) $(OVL05) $(OVL06) $(OVL07) $(OVL08)\
X       $(OVL09) $(OVL10) $(OVL11) $(OVL12) $(OVL13) $(OVL14) $(OVL15) $(OVL16)\
X       $(OVL17) $(OVL18) $(OVL19) $(OVL20) $(OVL21) $(OVL22) $(OVL23) $(OVL24)\
X       $(OVL25) $(OVL26) $(OVL27) $(OVL28) $(OVL29) $(OVL30) $(OVL31) $(OVL32)\
X       $(OVL33) $(OVL34) $(OVL35) $(OVL36) $(OVL37) $(OVL38) $(OVL39) $(OVL40)\
X       $(OVL41) $(OVL42) $(OVL43) $(OVL44) $(OVL45) $(OVL46) $(OVL47) $(OVL48)\
X       $(OVL49) $(OVL50) $(OVL51) $(OVL52) $(OVL53) $(OVL54) $(OVL55) $(OVL56)\
X       $(OVL57) $(OVL58) $(OVL59) $(OVL60) $(OVL61) $(OVL62)
X
XVOBJ =	$(ROOT) $(MOBJ)
X
XHOBJ =	$(VOBJ) $(OVL63)
X
X# object files for makedefs
XMAKEOBJS    =	$(OBJ)\makedefs.o $(OBJ)\alloc.o    $(OBJ)\monst.o    \
X		$(OBJ)\objects.o  $(OBJ)\panic.o
X
XOVERLAYS = ($(OVL01)) ($(OVL02)) ($(OVL03)) ($(OVL04)) ($(OVL05)) ($(OVL06)) \
X	   ($(OVL07)) ($(OVL08)) ($(OVL09)) ($(OVL10)) ($(OVL11)) ($(OVL12)) \
X	   ($(OVL13)) ($(OVL14)) ($(OVL15)) ($(OVL16)) ($(OVL17)) ($(OVL18)) \
X	   ($(OVL19)) ($(OVL20)) ($(OVL21)) ($(OVL22)) ($(OVL23)) ($(OVL24)) \
X	   ($(OVL25)) ($(OVL26)) ($(OVL27)) ($(OVL28)) ($(OVL29)) ($(OVL30)) \
X	   ($(OVL31)) ($(OVL32)) ($(OVL33)) ($(OVL34)) ($(OVL35)) ($(OVL36)) \
X	   ($(OVL37)) ($(OVL38)) ($(OVL39)) ($(OVL40)) ($(OVL41)) ($(OVL42)) \
X	   ($(OVL43)) ($(OVL44)) ($(OVL45)) ($(OVL46)) ($(OVL47)) ($(OVL48)) \
X	   ($(OVL49)) ($(OVL50)) ($(OVL51)) ($(OVL52)) ($(OVL53)) ($(OVL54)) \
X	   ($(OVL55)) ($(OVL56)) ($(OVL57)) ($(OVL58)) ($(OVL59)) ($(OVL60)) \
X	   ($(OVL61)) ($(OVL62)) ($(OVL63))
X
X# object files for special levels compiler
XSPLEVOBJS   =	$(OBJ)\lev_comp.o $(OBJ)\lev_lex.o  $(OBJ)\lev_main.o \
X		$(OBJ)\alloc.o	  $(OBJ)\monst.o    $(OBJ)\objects.o  \
X		$(OBJ)\panic.o
X
X# *****************************************************************************
X# ************************** Header Objects ***********************************
X# *****************************************************************************
X
XTRAP_H	   = $(INCL)\trap.h
XPERMONST_H = $(INCL)\permonst.h    $(INCL)\monflag.h
XPCCONF_H   = $(INCL)\$(TARG)conf.h $(INCL)\extern.h   $(INCL)\msdos.h \
X	     $(INCL)\system.h
XGLOBAL_H   = $(PCCONF_H)	   $(INCL)\coord.h    $(INCL)\global.h
XCONFIG_H   = $(GLOBAL_H)	   $(INCL)\config.h   $(INCL)\tradstdc.h
XYOU_H	   = $(PERMONST_H)	   $(INCL)\attrib.h   $(INCL)\mondata.h \
X	     $(INCL)\monst.h	   $(INCL)\you.h      $(INCL)\youprop.h
XDECL_H	   = $(YOU_H)		   $(INCL)\decl.h     $(INCL)\obj.h \
X	     $(INCL)\onames.h	   $(INCL)\pm.h       $(INCL)\spell.h
XHACK_H	   = $(CONFIG_H)	   $(DECL_H)	      $(TRAP_H) \
X	     $(INCL)\flag.h	   $(INCL)\gold.h     $(INCL)\mkroom.h \
X	     $(INCL)\monsym.h	   $(INCL)\objclass.h $(INCL)\rm.h \
X	     $(INCL)\trampoli.h
X
X# *****************************************************************************
X# ************************ File Dependencies **********************************
X# *****************************************************************************
X
X# Due to an NDMake inadequacy these must accord with a topological sort of the
X# generated-from relation... output on the left, input on the right. Trust me.
X.SUFFIXES: .exe .0 .01 .012 .1 .12 .12b .2 .2b .b .o .c .y .l .obj .asm
X
X.c.o:
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X.c.0:
X	$(CC) $(CFLAGS) /DOVL0 /NT$*.0 /Fo$(OBJ)\$*.0 $*.c
X.c.01:
X	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /NT$*.01 /Fo$(OBJ)\$*.01 $*.c
X.c.012:
X	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /DOVL2 /NT$*.012 /Fo$(OBJ)\$*.012 $*.c
X.c.1:
X	$(CC) $(CFLAGS) /DOVL1 /NT$*.1 /Fo$(OBJ)\$*.1 $*.c
X.c.12:
X	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /NT$*.12 /Fo$(OBJ)\$*.12 $*.c
X.c.12b:
X	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /DOVLB /NT$*.12b /Fo$(OBJ)\$*.12b $*.c
X.c.2:
X	$(CC) $(CFLAGS) /DOVL2 /NT$*.2 /Fo$(OBJ)\$*.2 $*.c
X.c.2b:
X	$(CC) $(CFLAGS) /DOVL2 /DOVLB /NT$*.2b /Fo$(OBJ)\$*.2b $*.c
X.c.b:
X	$(CC) $(CFLAGS) /DOVLB /NT$*.b /Fo$(OBJ)\$*.b $*.c
X.asm.obj:
X	$(ASM) $(AFLAGS) $*.asm,$(OBJ)\$*.obj ;
X
X$(GAME): $(GAMEFILE)
X
X$(GAME).exe: $(GAMEFILE)
X
X$(GAMEFILE): $(OBJ) $(HOBJ)
X	@echo Loading....
X	$(LINK) $(ROOT) $(OVERLAYS),$(GAMEFILE),$(GAME),$(CLIB) $(TERMLIB) $(LFLAGS) ;
X	@echo Nethack is up to date.
X
X$(OBJ):
X	if not exist .\$(OBJ)\*.* mkdir $(OBJ)
X
X#	The following 3 modules vary depending on what OS you are using.
X
X$(OBJ)\main.o:	$(HACK_H) $(TARG)main.c
X	$(CC) $(CFLAGS)  /Fo.\$(OBJ)\main.o $(TARG)main.c
X
X$(OBJ)\tty.o:	$(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X	$(CC) $(CFLAGS)  /Fo.\$(OBJ)\tty.o  $(TARG)tty.c
X
X$(OBJ)\unix.0:	$(HACK_H) $(TARG)unix.c
X	$(CC) $(CFLAGS)  /DOVL0 /Fo.\$(OBJ)\unix.0 $(TARG)unix.c
X$(OBJ)\unix.12b:	$(HACK_H) $(TARG)unix.c
X	$(CC) $(CFLAGS)  /DOVL1 /DOVL2 /DOVLB /Fo.\$(OBJ)\unix.12b $(TARG)unix.c
X
X$(OBJ)\makedefs.o:	$(INCL)\config.h $(INCL)\permonst.h $(INCL)\objclass.h
X
Xmakedefs.exe:	$(MAKEOBJS)
X	$(LINK) $(LFLAGS) $(MAKEOBJS), makedefs.exe,, $(CLIB);
X
X#	Targets for the special levels compiler
X
Xlev_comp.c: lev_comp.y
X	$(MAKEBIN) do_yacc
X
Xlev_lex.c:  lev_comp.l
X	$(MAKEBIN) do_lex
X
Xyacc_msg:
X	@echo lev_comp.y has changed. To update lev_comp.c and lev_comp.h run YACC.
X
Xyacc_act:
X	$(YACC) -d lev_comp.y
X	copy $(YTABC) lev_comp.c
X	copy $(YTABH) $(INCL)\lev_comp.h
X	del $(YTABC)
X	del $(YTABH)
X
Xlex_msg:
X	@echo lev_comp.l has changed. To update lev_lex.c run LEX.
X
Xlex_act:
X	$(LEX) lev_comp.l
X	copy $(LEXYYC) lev_lex.c
X	del $(LEXYYC)
X
X#	This is stupid but since the default rule does not work here ...
X
X$(OBJ)\lev_comp.o:	$(HACK_H)   $(INCL)\sp_lev.h	lev_comp.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X$(OBJ)\lev_lex.o:	$(HACK_H)   $(INCL)\sp_lev.h	$(INCL)\lev_comp.h \
X			lev_lex.c
X	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $*.c
X
Xlev_comp.exe:	$(SPLEVOBJS)
X	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe,, $(CLIB);
X
X# *****************************************************************************
X# *************************  Makedefs Stuff ***********************************
X# *****************************************************************************
X#	The following include files depend on makedefs to be created.
X#	date.h should be remade any time any of the source or include code
X#	is modified.
X
X$(INCL)\date.h: $(VOBJ) makedefs.exe
X	.\makedefs -v
X
X$(INCL)\trap.h: 	makedefs.exe
X	.\makedefs -t
X
X$(INCL)\onames.h:	makedefs.exe
X	.\makedefs -o
X
X$(INCL)\pm.h:		makedefs.exe
X	.\makedefs -p
X
Xdata:	$(AUX)\data.bas makedefs.exe
X	.\makedefs -d
X
Xrumors: $(AUX)\rumors.tru $(AUX)\rumors.fal makedefs.exe
X	.\makedefs -r
X
X# *****************************************************************************
X# ************************ Secondary targets **********************************
X# *****************************************************************************
X
Xall:	install
X
Xinstall:	$(OBJ) lev_comp.exe $(GAMEFILE) auxil.tag install.tag
X	@echo Don't forget to check HACKDIR in nethack.cnf.
X	@echo Done.
X
X
X#	Watch Out!  This make cleans out the game & bones dirs!
X#	This will delete any config file you have and overwrite it
X#	with the default.
X#	Since the game options may have changed since your last install,
X#	you should say yes to clean the directory.
X
Xinstall.tag:
X	copy $(OTHERS)\termcap		$(GAMEDIR)
X	copy $(AUX)\*.			$(GAMEDIR)
X	copy $(OTHERS)\nethack.cnf	$(GAMEDIR)
X	echo install done > install.tag
X
Xspec_lev.tag: lev_comp.exe $(AUX)\castle.des $(AUX)\endgame.des $(AUX)\tower.des
X	lev_comp $(AUX)\castle.des
X	lev_comp $(AUX)\endgame.des
X	lev_comp $(AUX)\tower.des
X	copy castle $(GAMEDIR)
X	copy endgame $(GAMEDIR)
X	copy tower? $(GAMEDIR)
X	del castle
X	del endgame
X	del tower?
X	echo spec_lev done > spec_lev.tag
X
Xauxil.tag:	spec_lev.tag	data	rumors
X	echo special levels created > auxil.tag
X
Xclean:
X	del $(OBJ)\*.o
X	del $(OBJ)\*.0
X	del $(OBJ)\*.01
X	del $(OBJ)\*.012
X	del $(OBJ)\*.1
X	del $(OBJ)\*.12
X	del $(OBJ)\*.12b
X	del $(OBJ)\*.2
X	del $(OBJ)\*.2b
X	del $(OBJ)\*.b
X	del $(OBJ)\*.obj
X	rmdir $(OBJ)
X
Xspotless: clean
X	del $(INCL)\date.h
X	del $(INCL)\onames.h
X	del $(INCL)\pm.h
X	if exist makedefs.exe del makedefs.exe
X	if exist lev_comp.exe del lev_comp.exe
X	del castle
X	del endgame
X	del tower?
X	del *.bak
X	del *.tag
X	del *.map
X	del *.txt
X	del $(AUX)\data
X	del $(AUX)\rumors
X
X# *****************************************************************************
X# ************************* Other dependencies ********************************
X# *****************************************************************************
X# Other dependencies
X#
X# I deleted that line.	;-}
X
X$(OBJ)\allmain.o:	$(HACK_H)
X$(OBJ)\alloc.o: 	$(CONFIG_H)
X$(OBJ)\apply.o: 	$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\artifact.o:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\attrib.o:	$(HACK_H)
X$(OBJ)\bones.o: 	$(HACK_H)
X$(OBJ)\cmd.o:		$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\dbridge.o:	$(HACK_H)
X$(OBJ)\decl.o:		$(HACK_H)
X$(OBJ)\demon.o: 	$(HACK_H)
X$(OBJ)\do.o:		$(HACK_H)
X$(OBJ)\do_name.o:	$(HACK_H)
X$(OBJ)\do_wear.o:	$(HACK_H)
X$(OBJ)\dog.o:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\dogmove.o:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\edog.h
X$(OBJ)\dokick.o:	$(HACK_H)
X$(OBJ)\dothrow.o:	$(HACK_H)
X$(OBJ)\eat.o:		$(HACK_H)
X$(OBJ)\end.o:		$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\engrave.o:	$(HACK_H)
X$(OBJ)\exper.o: 	$(HACK_H)
X$(OBJ)\extralev.o:	$(HACK_H)
X$(OBJ)\fountain.o:	$(HACK_H)
X$(OBJ)\getline.o:	$(HACK_H)   $(INCL)\func_tab.h
X$(OBJ)\hack.o:		$(HACK_H)
X$(OBJ)\invent.o:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\ioctl.o: 	$(HACK_H)
X$(OBJ)\lev_main.o:	$(HACK_H)   $(INCL)\sp_lev.h
X$(OBJ)\lock.o:		$(HACK_H)
X$(OBJ)\makemon.o:	$(HACK_H)
X$(OBJ)\mail.o:		$(HACK_H)
X$(OBJ)\mcastu.o:	$(HACK_H)
X$(OBJ)\mhitm.o: 	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\mhitu.o: 	$(HACK_H)   $(INCL)\artifact.h	 $(INCL)\edog.h
X$(OBJ)\mklev.o: 	$(HACK_H)
X$(OBJ)\mkmaze.o:	$(HACK_H)
X$(OBJ)\mkobj.o: 	$(HACK_H)
X$(OBJ)\mkroom.o:	$(HACK_H)
X$(OBJ)\mon.o:		$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X$(OBJ)\mondata.o:	$(HACK_H)   $(INCL)\eshk.h	 $(INCL)\epri.h
X$(OBJ)\monmove.o:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\artifact.h
X$(OBJ)\monst.o: 	$(CONFIG_H) $(PERMONST_H)	 $(INCL)\eshk.h     \
X			$(INCL)\epri.h $(INCL)\vault.h
X$(OBJ)\msdos.o: 	$(HACK_H)
X$(OBJ)\mthrowu.o:	$(HACK_H)
X$(OBJ)\music.o: 	$(HACK_H)
X$(OBJ)\o_init.o:	$(HACK_H)   $(INCL)\onames.h
X$(OBJ)\objects.o:	$(CONFIG_H) $(INCL)\obj.h	 $(INCL)\objclass.h \
X			$(INCL)\prop.h
X$(OBJ)\objnam.o:	$(HACK_H)
X$(OBJ)\options.o:	$(HACK_H)
X$(OBJ)\pager.o: 	$(HACK_H)
X$(OBJ)\panic.o: 	$(CONFIG_H)
X$(OBJ)\pickup.o:	$(HACK_H)
X$(OBJ)\polyself.o:	$(HACK_H)
X$(OBJ)\potion.o:	$(HACK_H)
X$(OBJ)\pray.o:		$(HACK_H)
X$(OBJ)\pri.o:		$(HACK_H)
X$(OBJ)\priest.o:	$(HACK_H)   $(INCL)\mfndpos.h	 $(INCL)\eshk.h \
X			$(INCL)\epri.h
X$(OBJ)\prisym.o:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\random.o:
X$(OBJ)\read.o:		$(HACK_H)
X$(OBJ)\restore.o:	$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\rip.o:		$(HACK_H)
X$(OBJ)\rnd.o:		$(HACK_H)
X$(OBJ)\rumors.o:	$(HACK_H)
X$(OBJ)\save.o:		$(HACK_H)   $(INCL)\lev.h	 $(INCL)\wseg.h
X$(OBJ)\search.o:	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\shk.o:		$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\shknam.o:	$(HACK_H)   $(INCL)\eshk.h
X$(OBJ)\sit.o:		$(HACK_H)
X$(OBJ)\sounds.o:	$(HACK_H)   $(INCL)\edog.h	 $(INCL)\eshk.h
X$(OBJ)\sp_lev.o:	$(HACK_H)   $(INCL)\sp_lev.h
X$(OBJ)\spell.o: 	$(HACK_H)
X$(OBJ)\steal.o: 	$(HACK_H)
X$(OBJ)\termcap.o:	$(HACK_H)
X$(OBJ)\timeout.o:	$(HACK_H)
X$(OBJ)\topl.o:		$(HACK_H)
X$(OBJ)\topten.o:	$(HACK_H)
X$(OBJ)\track.o: 	$(HACK_H)
X$(OBJ)\trampoli.o:	$(HACK_H)
X$(OBJ)\trap.o:		$(HACK_H)   $(INCL)\edog.h
X$(OBJ)\u_init.o:	$(HACK_H)
X$(OBJ)\uhitm.o: 	$(HACK_H)   $(INCL)\artifact.h
X$(OBJ)\vault.o: 	$(HACK_H)   $(INCL)\vault.h
X$(OBJ)\version.o:	$(HACK_H)   $(INCL)\date.h
X$(OBJ)\weapon.o:	$(HACK_H)
X$(OBJ)\were.o:		$(HACK_H)
X$(OBJ)\wield.o: 	$(HACK_H)
X$(OBJ)\wizard.o:	$(HACK_H)
X$(OBJ)\worm.o:		$(HACK_H)   $(INCL)\wseg.h
X$(OBJ)\worn.o:		$(HACK_H)
X$(OBJ)\write.o: 	$(HACK_H)
X$(OBJ)\zap.o:		$(HACK_H)
END_OF_FILE
if test 19154 -ne `wc -c <'others/Makefile.ovl'`; then
    echo shar: \"'others/Makefile.ovl'\" unpacked with wrong size!
fi
# end of 'others/Makefile.ovl'
if test -f 'others/pcmain.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'others/pcmain.c'\" to \"'others/pcmain.c.orig'\"
  mv -f 'others/pcmain.c' 'others/pcmain.c.orig'
fi
echo shar: Extracting \"'others/pcmain.c'\" \(19050 characters\)
sed "s/^X//" >'others/pcmain.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)pcmain.c	3.0	90/01/19
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X/* main.c - PC, ST, and Amiga NetHack */
X#include "hack.h"
X
X#ifndef NO_SIGNAL
X#include <signal.h>
X#endif
X#include <ctype.h>
X#ifdef DGK
X#ifndef AMIGA
X#include <sys\stat.h>
X#endif
X#endif
X#ifdef MACOS
Xextern WindowPtr	HackWindow;
Xextern short *switches;
Xextern short macflags;
Xpascal boolean FDECL(startDlogFProc, (DialogPtr, EventRecord *, short *));
X#define msmsg mprintf
X#endif
X
X#if !defined(MACOS) && !defined(LATTICE)
Xchar orgdir[PATHLEN];
X#endif
Xchar SAVEF[FILENAME];
X#ifdef MSDOS
Xchar SAVEP[FILENAME];
X#endif
X
Xconst char *hname = "NetHack";	/* used for syntax messages */
X#if !defined(AMIGA) && !defined(MACOS)
Xchar obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X#endif
Xint hackpid;		/* not used anymore, but kept in for save files */
X
X#if defined(DGK)
Xstruct finfo	zfinfo = ZFINFO;
Xint i;
X#endif /* DGK */
X
X#ifdef __TURBOC__	/* tell Turbo C to make a bigger stack */
Xextern unsigned _stklen = 0x2000;	/* 8K */
Xextern unsigned char _osmajor;
X#endif
X
X#ifdef TOS
Xextern long compiletime;
Xboolean run_from_desktop = TRUE;	/* should we pause before exiting?? */
X# ifdef __GNUC__
Xlong _stksize = 16*1024;
X# endif
X#endif
X
X#ifdef MACOS
X#  ifdef AZTEC
X#define OMASK	O_RDONLY
X#  else
X#define OMASK	(O_RDONLY | O_BINARY )
X#  endif
X# else
X#define OMASK	O_RDONLY
X#endif
X
X#ifdef MACOS
XBoolean justscores;
X#endif
X
X#ifdef AMIGA_WBENCH
Xextern int FromWBench;
X#endif
X
Xconst char *classes = "ABCEHKPRSTVW";
X
Xint
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	extern int x_maze_max, y_maze_max;
X	register int fd;
X	register char *dir;
X#ifndef AMIGA
X	int (*funcp)();
X#endif
X#ifdef TOS
X	long clock;
X# ifdef __GNUC__
X	extern int _unixmode;
X	_unixmode = 0;
X# endif
X#endif
X#ifdef __TURBOC__
X	if (_osmajor >= 3) hname = argv[0];	/* DOS 3.0+ */
X#endif
X#ifdef TOS
X	if (*argv[0]) {			/* only a CLI can give us argv[0] */
X		hname = argv[0];
X		run_from_desktop = FALSE;
X	}
X#endif
X#ifdef MACOS
X	AppFile	theFile;
X	short	message,numFiles;
X	SFReply	reply;
X
X	initterm(24,80);
X	ObscureCursor();
X# ifdef SMALLDATA
X	init_decl();
X# endif
X	/* user might have started up with a save file, so check */
X	CountAppFiles(&message,&numFiles);
X	if (!message && numFiles) {
X		message = 1;
X
X		while(message <= numFiles) {
X			GetAppFiles(message,&theFile);
X			ClrAppFiles(message);
X			if ((theFile.fType == SAVE_TYPE)||(theFile.fType == EXPLORE_TYPE))
X				break;
X			message++;
X		}
X		if ((theFile.fType == SAVE_TYPE)||(theFile.fType == EXPLORE_TYPE)) {
X			(void)strncpy(SAVEF, (char *)&theFile.fName[1],
X						(int)theFile.fName[0]);
X			(void)strncpy(plname, (char *)&theFile.fName[1],
X						(int)theFile.fName[0]);
X			SetVol(0,theFile.vRefNum);
X			SAVEF[(int)theFile.fName[0]] = '\0';
X			numFiles = 1;
X		} else
X			numFiles = 0;
X	}
X	switches = (short *)malloc((NROFOBJECTS+2) * sizeof(long));
X	for (fd = 0; fd < (NROFOBJECTS + 2); fd++)
X		switches[fd] = fd;
X#endif
X
X
X	/*
X	 *  Initialize screen I/O before anything is displayed.
X	 *
X	 *  startup() must be called before initoptions()
X	 *    due to ordering of graphics settings
X	 *  and before error(), due to use of termcap strings.
X	 */
X	gettty();
X#if !defined(AMIGA) && !defined(MACOS)
X	setbuf(stdout,obuf);
X#endif
X	startup();
X#if !defined(AMIGA) && !defined(MACOS)
X	/* Save current directory and make sure it gets restored when
X	 * the game is exited.
X	 */
X	if (getcwd(orgdir, sizeof orgdir) == NULL)
X		error("NetHack: current directory path too long");
X	funcp = (int (*)())exit; /* Kludge to get around LINT_ARGS of signal. */
X# ifndef NO_SIGNAL
X	signal(SIGINT, (SIG_RET_TYPE) funcp);	/* restore original directory */
X# endif
X#endif /* AMIGA || MACOS */
X
X#ifndef MACOS
X	if ((dir = getenv("HACKDIR")) != NULL) {
X		Strcpy(hackdir, dir);
X# ifdef CHDIR
X		chdirx (dir, 1);
X# endif
X	}
X#if defined(AMIGA) && defined(CHDIR)
X	/*
X	 * If we're dealing with workbench, change the directory.  Otherwise
X	 * we could get "Insert disk in drive 0" messages. (Must be done
X	 * before initoptions())....
X	 */
X	if(argc == 0)
X		chdirx(HACKDIR, 1);
X#endif
X
X# if defined(DGK)
X	/* zero "fileinfo" array to prevent crashes on level change */
X	for (i = 0 ; i <= MAXLEVEL; i++) {
X		fileinfo[i] = zfinfo;
X	}
X# endif /* DGK */
X
X	initoptions();
X#ifdef AMIGA_WBENCH
X	ami_wbench_init(argc,argv);
X#endif
X# if defined(TOS) && defined(TEXTCOLOR)
X	if (flags.IBMBIOS && flags.use_color)
X		set_colors();
X# endif
X	if (!hackdir[0])
X#if !defined(LATTICE) && !defined(AMIGA)
X		Strcpy(hackdir, orgdir);
X#else
X		Strcpy(hackdir, HACKDIR);
X#endif
X	if(argc > 1) {
X	    if (!strncmp(argv[1], "-d", 2)) {
X		argc--;
X		argv++;
X		dir = argv[0]+2;
X		if(*dir == '=' || *dir == ':') dir++;
X		if(!*dir && argc > 1) {
X			argc--;
X			argv++;
X			dir = argv[0];
X		}
X		if(!*dir)
X		    error("Flag -d must be followed by a directory name.");
X		Strcpy(hackdir, dir);
X	    } else
X
X	/*
X	 * Now we know the directory containing 'record' and
X	 * may do a prscore().
X	 */
X	    if (!strncmp(argv[1], "-s", 2)) {
X# ifdef CHDIR
X		chdirx(hackdir,0);
X# endif
X		prscore(argc, argv);
X		exit(0);
X	    }
X	}
X#else
X	initoptions();
X#endif	/* MACOS /* */
X
X	/*
X	 * It seems you really want to play.
X	 */
X	setrandom();
X	cls();
X#ifdef TOS
X	if ((unsigned long)time(&clock) < (unsigned long)compiletime)
X		error("Your clock is incorrectly set!");
X#endif
X	u.uhp = 1;	/* prevent RIP on early quits */
X	u.ux = FAR;	/* prevent nscr() */
X
X	/*
X	 * Find the creation date of this game,
X	 * so as to avoid restoring outdated savefiles.
X	 */
X	/* gethdate(hname); */
X
X	/*
X	 * We cannot do chdir earlier, otherwise gethdate will fail.
X	 */
X#ifdef CHDIR
X	chdirx(hackdir,1);
X#endif
X
X#ifndef MACOS
X	/*
X	 * Process options.
X	 */
X	while(argc > 1 && argv[1][0] == '-'){
X		argv++;
X		argc--;
X		switch(argv[0][1]){
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X# ifndef EXPLORE_MODE
X		case 'X':
X# endif
X		case 'D':
X# ifdef WIZARD
X			/* Must have "name" set correctly by NETHACK.CNF,
X			 * NETHACKOPTIONS, or -u
X			 * before this flag to enter wizard mode. */
X#  ifdef KR1ED
X			if(!strcmp(plname, WIZARD_NAME)) {
X#  else
X			if(!strcmp(plname, WIZARD)) {
X#  endif
X				wizard = TRUE;
X				break;
X			}
X			/* otherwise fall thru to discover */
X# endif
X# ifdef EXPLORE_MODE
X		case 'X':
X			discover = TRUE;
X# endif
X			break;
X#endif
X#ifdef NEWS
X		case 'n':
X			flags.nonews = TRUE;
X			break;
X#endif
X		case 'u':
X			if(argv[0][2])
X			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X			else if(argc > 1) {
X			  argc--;
X			  argv++;
X			  (void) strncpy(plname, argv[0], sizeof(plname)-1);
X			} else
X				Printf("Player name expected after -u\n");
X			break;
X#ifdef DGK
X		/* Player doesn't want to use a RAM disk
X		 */
X		case 'r':
X			ramdisk = FALSE;
X			break;
X#endif
X		default:
X			if (index(classes, toupper(argv[0][1]))) {
X				/* allow -T for Tourist, etc. */
X				(void) strncpy(pl_character, argv[0]+1,
X					       sizeof(pl_character)-1);
X				break;
X			} else Printf("\nUnknown switch: %s\n", argv[0]);
X		case '?':
XPrintf("\nUsage: %s [-d dir] -s [-[%s]] [maxrank] [name]...", hname, classes);
XPrintf("\n       or");
XPrintf("\n       %s [-d dir] [-u name] [-[%s]]", hname, classes);
X#if defined(WIZARD) || defined(EXPLORE_MODE)
X			Printf(" [-[DX]]");
X#endif
X#ifdef NEWS
X			Printf(" [-n]");
X#endif
X#ifdef DGK
X			Printf(" [-r]");
X#endif
X			putchar('\n');
X			return 0;
X		}
X	}
X#ifdef AMIGA_WBENCH
X	ami_wbench_args();
X#endif
X#ifdef DGK
X	set_lock_and_bones();
X	copybones(FROMPERM);
X#endif
X#ifdef WIZARD
X	if (wizard)
X		Strcpy(plname, "wizard");
X	else
X#endif
X	if (!*plname)
X		askname();
X	plnamesuffix();		/* strip suffix from name; calls askname() */
X				/* again if suffix was whole name */
X				/* accepts any suffix */
X#ifndef DGK
X	Strcpy(lock,plname);
X	Strcat(lock,".99");
X#endif
X#endif /* MACOS */
X	start_screen();
X
X	/*
X	 * Initialisation of the boundaries of the mazes
X	 * Both boundaries have to be even.
X	 */
X
X	x_maze_max = COLNO-1;
X	if (x_maze_max % 2)
X		x_maze_max--;
X	y_maze_max = ROWNO-1;
X	if (y_maze_max % 2)
X		y_maze_max--;
X
X	/* initialize static monster strength array */
X	init_monstr();
X#ifdef MACOS
X	if (!numFiles) {
X		askname();
X		if(justscores){
X			prscore(1,&classes);
X			exit(0);
X		}
X#endif
X#if defined(AMIGA) || defined(MACOS)
X# ifdef AMIGA_WBENCH
X	if(!FromWBench)
X# endif
X	(void) strncat(SAVEF, plname, 31-4);
X#else
X	{
X		int ix = strlen(SAVEF);
X		(void)strncat(SAVEF, plname, 8);
X		regularize(SAVEF+ix);
X	}
X#endif
X#ifndef MACOS
X# ifdef AMIGA_WBENCH
X	if(!FromWBench)
X# endif
X	Strcat(SAVEF, ".sav");
X#else
X	}
X	Strcpy(lock,plname);
X	Strcat(lock,".99");
X#endif
X	cls();
X	if (
X#ifdef DGK
X# ifdef AMIGA_WBENCH
X	    (FromWBench?1:saveDiskPrompt(1)) &&
X# else
X	    saveDiskPrompt(1) &&
X# endif
X#endif /* DGK */
X#ifdef AMIGA_WBENCH
X	    ((fd=ami_wbench_getsave(OMASK)) >=0) &&
X#else
X	    ((fd = open(SAVEF, OMASK)) >= 0) &&
X#endif
X	   /* if not up-to-date, quietly unlink file via false condition */
X	   (uptodate(fd) || unlink(SAVEF) == 666)) {
X#ifdef WIZARD
X		/* Since wizard is actually flags.debug, restoring might
X		 * overwrite it.
X		 */
X		boolean remember_wiz_mode = wizard;
X#endif
X#ifndef NO_SIGNAL
X		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X#endif
X		pline("Restoring save file...");
X		(void) fflush(stdout);
X		if(!dorecover(fd))
X			goto not_recovered;
X#ifdef WIZARD
X		if(!wizard && remember_wiz_mode) wizard = TRUE;
X#endif
X		pline("Hello %s, welcome to NetHack!", plname);
X		/* get shopkeeper set properly if restore is in shop */
X		(void) inshop();
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X#if defined(EXPLORE_MODE) || defined(WIZARD)
X		if (discover || wizard) {
X			pline("Do you want to keep the save file? ");
X			if(yn() == 'n'){
X				(void) unlink(SAVEF);
X#ifdef AMIGA_WBENCH
X				ami_wbench_unlink(SAVEF);
X#endif
X			}
X		}
X#endif
X		flags.move = 0;
X	} else {
Xnot_recovered:
X		newgame();
X		/* give welcome message before pickup messages */
X		pline("Hello %s, welcome to NetHack!", plname);
X#ifdef EXPLORE_MODE
X		if (discover)
X			You("are in non-scoring discovery mode.");
X#endif
X		flags.move = 0;
X		set_wear();
X		pickup(1);
X		read_engr_at(u.ux,u.uy);
X	}
X	
X#ifdef MACOS
X	{
X		short	i;
X		MenuHandle	theMenu;
X		Rect	screen;
X		
X		theMenu = GetMHandle(appleMenu);
X		EnableItem(theMenu, 0);
X		EnableItem(theMenu, 1);
X		theMenu = GetMHandle(fileMenu);
X		EnableItem(theMenu,0);
X		for (i = inventMenu;i <= extendMenu; i++) {
X			theMenu = GetMHandle(i);
X			EnableItem(theMenu, 0);
X		}
X		DrawMenuBar();
X		macflags |= fDoUpdate;
X		SetPort(HackWindow);
X		screen = HackWindow->portRect;
X		ValidRect(&screen);
X		
X	}
X#endif
X			
X	flags.moonphase = phase_of_the_moon();
X	if(flags.moonphase == FULL_MOON) {
X		You("are lucky!  Full moon tonight.");
X		if(!u.uluck) change_luck(1);
X	} else if(flags.moonphase == NEW_MOON) {
X		pline("Be careful!  New moon tonight.");
X	}
X
X	initrack();
X#ifndef NO_SIGNAL
X	(void) signal(SIGINT, SIG_IGN);
X#endif
X#ifdef OS2
X	gettty(); /* somehow ctrl-P gets turned back on during startup ... */
X#endif
X
X	moveloop();
X#ifdef MACOS 
X	/* Help for Mac compilers */
X	free_decl();
X#endif
X	return 0;
X}
X
X
X/*
X * plname is filled either by an option (-u Player  or  -uPlayer) or
X * explicitly (by being the wizard) or by askname.
X * It may still contain a suffix denoting pl_character.
X */
Xvoid
Xaskname() {
X#ifndef MACOS
X	register int c, ct;
X
X	Printf("\nWho are you? ");
X	(void) fflush(stdout);
X	ct = 0;
X	while((c = Getchar()) != '\n') {
X		if(c == EOF) error("End of input\n");
X		/* some people get confused when their erase char is not ^H */
X		if(c == '\b') {
X			if(ct) {
X				ct--;
X#ifdef MSDOS
X				msmsg("\b \b");
X#endif
X			}
X			continue;
X		}
X		if(ct < sizeof(plname)-1) {
X#if defined(MSDOS)
X			msmsg("%c", c);
X#endif
X			plname[ct++] = c;
X		}
X	}
X	plname[ct] = 0;
X	if(ct == 0) askname();
X}
X#else /* MACOS */
X/* Macintosh startup Dialog written by Andy Swanson 10/20/89
X		modified for to include a few more options 12/17/89 */
X	DialogPtr asknameDlog;
X	DialogTHndl	th, centreDlgBox();
X	int kind;
X	Rect box;
X	Handle knob;
X	Boolean Done;
X	int chtype = 0,Hit,i;
X	Str255 ptemp;
X	char *p;
X#define OK 1
X#define NAME_TEXT 3
X#define RADIO_MIN 5
X#define RADIO_MAX 17
X#define CAVEPERSON 7
X#define CLERGY 11
X#define VALKYRIE 15
X#define ANY 17
X#define WIZ 18
X#define EXP 19
X#define FEM 20
X#define NEWS_BOX 21
X#define SCORES 22
X#define setCheckBox(a,b,c) {GetDItem(a,b,&kind,&knob,&box);SetCtlValue(knob,c?1:0);}
X#define changeRadio(a,b,c) {setCheckBox(a,b,FALSE); setCheckBox(a,c,TRUE);}
X#define Disable(b) {GetDItem(asknameDlog,b,&kind,&knob,&box);HiliteControl(knob,255);}
X#define Enable(b) {GetDItem(asknameDlog,b,&kind,&knob,&box);HiliteControl(knob,0);}
X#define Hide(b)  {GetDItem(asknameDlog,b,&kind,&knob,&box);HideControl(knob);\
X			SetDItem(asknameDlog,b,kind+128,knob,&box);}
X	justscores = FALSE;
X	if(p=strrchr((char *)plname, '-')){
X		*p = 0;
X		if(('a'<= p[1]) && ('z'>= p[1]))p[1] += 'A' - 'a';
X		pl_character[0] = p[1];
X		pl_character[1] = 0;
X		if(chtype = (int)index(classes,p[1]))
X			chtype -= (int)(classes)-1;
X		if(p[1] == 'V')
X			flags.female = TRUE;
X	}
X	if(chtype != 0) chtype += 4;
X	else chtype = 17;
X#ifdef THINKC4
X	if(!*plname && (p = getlogin()))
X		(void) strncpy((char *)&plname,p,sizeof(plname)-1);
X#endif
X	th = centreDlgBox(131, FALSE);
X	
X	asknameDlog = GetNewDialog(131,0,-1);
X	
X	ReleaseResource((Handle)th);
X	if(*plname){
X		GetDItem(asknameDlog,NAME_TEXT,&kind,&knob,&box);
X		strncpy((char*)ptemp,(char*)&plname,255);
X		CtoPstr((char*)ptemp);
X		SetIText(knob,ptemp);
X	}
X	GetDItem(asknameDlog,chtype,&kind,&knob,&box);
X	SetCtlValue(knob,1);
X	if(flags.female){
X		setCheckBox(asknameDlog,FEM,TRUE);
X		changeDgenders(asknameDlog,TRUE);
X	}
X#ifdef NEWS
X	setCheckBox(asknameDlog,NEWS_BOX,!flags.nonews);
X#else
X	Hide(NEWS_BOX);
X#endif
X#ifdef WIZARD
X	wizard = FALSE;
X# ifdef KR1ED
X	if (strcmp(plname,WIZARD_NAME)) {
X# else
X	if (strcmp(plname,WIZARD)) {
X# endif
X#else
X	{
X#endif
X		Hide(WIZ);
X	}
X#ifdef EXPLORE_MODE
X	setCheckBox(asknameDlog,EXP,discover);
X#else
X		Hide(EXP);
X#endif
X	SelIText(asknameDlog, NAME_TEXT, 0, 32767);
X	ShowWindow(asknameDlog);
X	Done = FALSE;
X	while (!Done){
X		ModalDialog(startDlogFProc, &Hit);
X		if(Hit == OK){
X			Done = TRUE;
X			GetDItem(asknameDlog,NAME_TEXT,&kind,&knob,&box);
X			GetIText(knob,&ptemp);
X			PtoCstr((char*)ptemp);
X			(void) strncpy((char*)&plname,(char*)ptemp,sizeof(plname)-1);
X			pl_character[0]=classes[chtype-5];
X			pl_character[1]=0;
X			HideWindow(asknameDlog);
X		} else if((Hit >= RADIO_MIN) && (Hit <= RADIO_MAX)){
X			extern int lastDlgBut;
X			
X			changeRadio(asknameDlog,chtype,Hit);
X			lastDlgBut = chtype = Hit;
X			if ((chtype == VALKYRIE) && !flags.female) {
X				flags.female = TRUE;
X				setCheckBox(asknameDlog,FEM,flags.female);
X				changeDgenders(asknameDlog,TRUE);
X			}
X		} else if(Hit == WIZ) {
X			wizard = !wizard;
X			setCheckBox(asknameDlog,WIZ,wizard);
X		} else if(Hit == EXP) {
X			discover = !discover;
X			setCheckBox(asknameDlog,EXP,discover);
X		} else if(Hit == FEM) {
X			flags.female = !flags.female;
X			setCheckBox(asknameDlog,FEM,flags.female);
X			if(chtype == VALKYRIE) {
X				chtype = ANY;
X				changeRadio(asknameDlog,VALKYRIE,ANY);
X			}
X			changeDgenders(asknameDlog,flags.female);
X		} else if(Hit == NEWS_BOX) {
X			flags.nonews = !flags.nonews;
X			setCheckBox(asknameDlog,NEWS_BOX,!flags.nonews);
X		} else if(Hit == SCORES) {
X			justscores = !justscores;
X			setCheckBox(asknameDlog,SCORES,justscores);
X			if(justscores) for (i=RADIO_MIN;i<SCORES;i++) {
X				Disable(i);
X				}
X			else for (i=RADIO_MIN;i<SCORES;i++)
X				Enable(i);
X		}
X	}
X	DisposDialog(asknameDlog);
X}
X
X
X#define RADIO_STRING "ABCEHKPRSTVWL"
Xint	lastDlgBut = ANY;
X
X/* The filterProc for handling character selection from keyboard
X   by h+@nada.kth.se                                             */
Xpascal boolean
XstartDlogFProc(theDialog, theEvent, itemHit)
XDialogPtr theDialog;
XEventRecord * theEvent;
Xshort * itemHit;
X{
X	int x, c;
X
X	if(theEvent->what == keyDown) {
X		c = theEvent->message & 0xFF;
X#ifdef BETA /* We don't want this is no shipped version */
X		if(c == '#') Debugger();
X#endif
X		if(c == 10 || c == 13 || c == 3) { /* Accept */
X			*itemHit = OK;
X			return TRUE;
X		}
X		if(c == '\t' || c == ' ') { /* Select */
X			lastDlgBut++;
X			if(lastDlgBut > RADIO_MAX) lastDlgBut = RADIO_MIN;
X			*itemHit = lastDlgBut;
X			return TRUE;
X		}
X		if(theEvent->modifiers & cmdKey) {
X			if(c >= 'a' && c <= 'z') c &= 0x5F; /* Uppercase */
X			switch(c) {
X			case 'F' :
X				*itemHit = FEM;
X				return TRUE;
X			case 'X' :
X				*itemHit = EXP;
X				return TRUE;
X			case 'N' :
X				*itemHit = NEWS_BOX;
X				return TRUE;
X			case 'J' :
X				*itemHit = SCORES;
X				return TRUE;
X			default :
X				for(x=0; RADIO_STRING[x]; x++) {
X					if(c == RADIO_STRING[x]) {
X						*itemHit = x + RADIO_MIN;
X						return TRUE;
X					}
X				}
X			}
X			theEvent->what = nullEvent;
X		}
X	}
X
X	return FALSE;
X}
X
X
XchangeDgenders(Dlog,fem)
XDialogPtr Dlog;
XBoolean fem;
X{	int kind;
X	Rect box;
X	Handle knob;
X	Str255 ptemp;
X	if(fem){
X		GetDItem(Dlog,CAVEPERSON,&kind,&knob,&box);
X		strncpy((char*)ptemp,"Cave-Woman",255);
X		CtoPstr((char*)ptemp);
X		SetCTitle(knob,ptemp);
X		GetDItem(Dlog,CLERGY,&kind,&knob,&box);
X		strncpy((char*)ptemp,"Priestess",255);
X		CtoPstr((char*)ptemp);
X		SetCTitle(knob,ptemp);
X	} else {
X		GetDItem(Dlog,CAVEPERSON,&kind,&knob,&box);
X		strncpy((char*)ptemp,"Cave-Man",255);
X		CtoPstr((char*)ptemp);
X		SetCTitle(knob,ptemp);
X		GetDItem(Dlog,CLERGY,&kind,&knob,&box);
X		strncpy((char*)ptemp,"Priest",255);
X		CtoPstr((char*)ptemp);
X		SetCTitle(knob,ptemp);
X	}
X}
X#endif /* MACOS */
X
X
X#ifdef CHDIR
Xvoid
Xchdirx(dir, wr)
Xchar *dir;
Xboolean wr;
X{
X#ifdef AMIGA
X	static char thisdir[] = "";
X#else
X	static char thisdir[] = ".";
X#endif
X	if(dir && chdir(dir) < 0) {
X		error("Cannot chdir to %s.", dir);
X	}
X
X	/* Change the default drive as well.
X	 */
X#ifndef AMIGA
X	chdrive(dir);
X#endif
X
X	/* warn the player if we can't write the record file */
X	/* perhaps we should also test whether . is writable */
X	/* unfortunately the access systemcall is worthless */
X	if(wr) {
X	    register int fd;
X
X	    if(dir == NULL)
X		dir = thisdir;
X#ifdef OS2_CODEVIEW  /* explicit path on opening for OS/2 */
X	    {
X	    char tmp[PATHLEN];
X
X	    Strcpy(tmp, dir);
X	    append_slash(tmp);
X	    Strcat(tmp, RECORD);
X	    if((fd = open(tmp, O_RDWR)) < 0) {
X#else
X	    if((fd = open(RECORD, O_RDWR)) < 0) {
X#endif
X#ifdef DGK
X# ifndef OS2_CODEVIEW
X		char tmp[PATHLEN];
X
X		Strcpy(tmp, dir);
X		append_slash(tmp);
X# endif
X		/* try to create empty record */
X
X# ifdef OS2_CODEVIEW
X		if((fd = open(tmp, O_CREAT|O_RDWR, S_IREAD|S_IWRITE)) < 0) {
X		    msmsg("Warning: cannot write %s\n", tmp);
X# else
X# ifdef AZTEC_C
X		/* Aztec doesn't use the third argument */
X		if((fd = open(RECORD, O_CREAT|O_RDWR)) < 0) {
X		    msmsg("Warning: cannot write %s%s\n", tmp, RECORD);
X# else
X  		if((fd = open(RECORD, O_CREAT|O_RDWR, S_IREAD|S_IWRITE)) < 0) {
X		    msmsg("Warning: cannot write %s%s\n", tmp, RECORD);
X# endif
X# endif
X		    getreturn("to continue");
X		} else
X		    (void) close(fd);
X#else
X		Printf("Warning: cannot write %s/%s", dir, RECORD);
X		getret();
X#endif
X	    } else
X		(void) close(fd);
X#ifdef OS2_CODEVIEW
X	    }
X#endif
X	}
X}
X#endif /* CHDIR /**/
END_OF_FILE
if test 19050 -ne `wc -c <'others/pcmain.c'`; then
    echo shar: \"'others/pcmain.c'\" unpacked with wrong size!
fi
# end of 'others/pcmain.c'
if test -f 'src/vault.c' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'src/vault.c'\" to \"'src/vault.c.orig'\"
  mv -f 'src/vault.c' 'src/vault.c.orig'
fi
echo shar: Extracting \"'src/vault.c'\" \(11389 characters\)
sed "s/^X//" >'src/vault.c' <<'END_OF_FILE'
X/*	SCCS Id: @(#)vault.c	3.0	88/10/25
X/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#include "hack.h"
X#include "vault.h"
X
Xstatic void FDECL(restfakecorr,(struct monst *));
XOSTATIC boolean FDECL(in_vault,(int,int));
XOSTATIC struct monst *NDECL(findgd);
Xstatic boolean FDECL(in_fcorridor, (struct monst *,int,int));
X
X#ifdef OVLB
X
Xstatic void
Xrestfakecorr(grd) 
Xregister struct monst *grd;
X{
X	register int fcx, fcy, fcbeg;
X	register struct rm *crm;
X
X	while((fcbeg = EGD(grd)->fcbeg) < EGD(grd)->fcend) {
X		fcx = EGD(grd)->fakecorr[fcbeg].fx;
X		fcy = EGD(grd)->fakecorr[fcbeg].fy;
X		if((u.ux == fcx && u.uy == fcy) || cansee(fcx,fcy) ||
X		   m_at(fcx,fcy))
X			return;
X		crm = &levl[fcx][fcy];
X		crm->typ = EGD(grd)->fakecorr[fcbeg].ftyp;
X		if(!crm->typ) crm->seen = 0;
X		newsym(fcx,fcy);
X		if(cansee(fcx,fcy)) prl(fcx,fcy);
X		EGD(grd)->fcbeg++;
X	}
X	/* it seems he left the corridor - let the guard disappear */
X	mongone(grd);
X}
X
Xstatic boolean
Xin_fcorridor(grd, x, y)
Xregister struct monst *grd;
Xint x, y; 
X{
X	register int fci;
X
X	for(fci = EGD(grd)->fcbeg; fci < EGD(grd)->fcend; fci++)
X		if(x == EGD(grd)->fakecorr[fci].fx &&
X				y == EGD(grd)->fakecorr[fci].fy)
X			return(TRUE);
X	return(FALSE);
X}
X
XXSTATIC 
Xstruct monst *
Xfindgd() {
X
X	register struct monst *mtmp;
X
X	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X	    if(mtmp->isgd && EGD(mtmp)->gdlevel == dlevel)
X		return(mtmp);
X	return((struct monst *)0);
X}
X
X#endif /* OVLB */
X#ifdef OVL0
X
XXSTATIC
Xboolean
Xin_vault(x, y)
Xint x, y;
X{
X    register int roomno = inroom(x, y);
X
X    if(roomno < 0) return(FALSE);
X    return(rooms[roomno].rtype == VAULT);
X}
X
Xvoid
Xinvault() {
X
X#ifdef BSD_43_BUG
X    int dummy;		/* hack to avoid schain botch */
X#endif
X    struct monst *guard;
X
X    if(!in_vault(u.ux, u.uy)) {
X	u.uinvault = 0;
X	return;
X    }
X
X    guard = findgd();
X    if(++u.uinvault % 30 == 0 && !guard) { /* if time ok and no guard now. */
X	char buf[BUFSZ];
X	register int x, y, dd, gx, gy;
X
X	/* first find the goal for the guard */
X	for(dd = 1; (dd < ROWNO || dd < COLNO); dd++) {
X	  for(y = u.uy-dd; y <= u.uy+dd; y++) {
X	    if(y < 0 || y > ROWNO-1) continue;
X	    for(x = u.ux-dd; x <= u.ux+dd; x++) {
X	      if(y != u.uy-dd && y != u.uy+dd && x != u.ux-dd)
X		x = u.ux+dd;
X	      if(x < 0 || x > COLNO-1) continue;
X	      if(levl[x][y].typ == CORR) goto fnd;
X	    }
X	  }
X	}
X	impossible("Not a single corridor on this level??");
X	tele();
X	return;
Xfnd:
X	gx = x; gy = y;
X
X	/* next find a good place for a door in the wall */
X	x = u.ux; y = u.uy;
X	while(levl[x][y].typ == ROOM) {
X		register int dx,dy;
X
X		dx = (gx > x) ? 1 : (gx < x) ? -1 : 0;
X		dy = (gy > y) ? 1 : (gy < y) ? -1 : 0;
X		if(abs(gx-x) >= abs(gy-y))
X			x += dx;
X		else
X			y += dy;
X	}
X
X	/* make something interesting happen */
X	if(!(guard = makemon(&mons[PM_GUARD], x, y))) return;
X	guard->isgd = 1;
X	guard->mpeaceful = 1;
X	EGD(guard)->gddone = 0;
X	EGD(guard)->ogx = x;
X	EGD(guard)->ogy = y;
X	EGD(guard)->gdlevel = dlevel;
X	EGD(guard)->warncnt = 0;
X
X	if(!cansee(guard->mx, guard->my)) {
X		mongone(guard);
X		return;
X	}
X
X	reset_faint();			/* if fainted - wake up */
X	pline("Suddenly one of the Vault's guards enters!");
X	pmon(guard);
X	stop_occupation();		/* if occupied, stop it *now* */
X	do {
X		pline("\"Hello stranger, who are you?\" - ");
X		getlin(buf);
X	} while (!letter(buf[0]));
X
X	if(!strcmp(buf, "Croesus") || !strcmp(buf, "Kroisos")) {
X		verbalize("Oh, yes, of course.  Sorry to have disturbed you.");
X		mongone(guard);
X		return;
X	}
X	clrlin();
X	verbalize("I don't know you.");
X	if(!u.ugold)
X	    verbalize("Please follow me.");
X	else {
X	    verbalize("Most likely all that gold was stolen from this vault.");
X	    verbalize("Please drop that gold and follow me.");
X	}
X	EGD(guard)->gdx = gx;
X	EGD(guard)->gdy = gy;
X	EGD(guard)->fcbeg = 0;
X	EGD(guard)->fakecorr[0].fx = x;
X	EGD(guard)->fakecorr[0].fy = y;
X	EGD(guard)->fakecorr[0].ftyp = levl[x][y].typ;
X	levl[x][y].typ = DOOR;
X	levl[x][y].doormask = D_NODOOR;
X	EGD(guard)->fcend = 1;
X	EGD(guard)->warncnt = 1;
X    }
X}
X
X#endif /* OVL0 */
X#ifdef OVLB
X
X/*
X * return  1: he moved,  0: he didn't,  -1: let m_move do it,  -2: died
X */
Xint
Xgd_move(grd)
Xregister struct monst *grd;
X{
X	int x, y, nx, ny, m, n;
X	int dx, dy, gx, gy, i, fci;
X	uchar typ;
X	struct fakecorridor *fcp;
X	register struct rm *crm;
X	register struct gold *gold;
X	register boolean goldincorridor = FALSE;
X
X#ifdef __GNULINT__
X	m = n = 0;
X#endif
X	if(EGD(grd)->gdlevel != dlevel) return(-1);
X	if(!grd->mpeaceful && in_vault(grd->mx, grd->my) &&
X			!in_vault(u.ux, u.uy)) {
X		rloc(grd);
X		goto letknow;
X	}
X	if(!grd->mpeaceful) return(-1);
X	if(abs(EGD(grd)->ogx - grd->mx) > 1 || 
X			abs(EGD(grd)->ogy - grd->my) > 1)
X		return(-1);	/* teleported guard - treat as monster */
X	if(EGD(grd)->fcend == 1) {
X	    if(in_vault(u.ux, u.uy) && 
X			(u.ugold || um_dist(grd->mx, grd->my, 1))) {
X		if(EGD(grd)->warncnt == 3)
X			pline("\"Again, %sfollow me!\"", 
X				u.ugold ? "drop that gold and " : "");
X		if(EGD(grd)->warncnt == 6) {
X			register int m = grd->mx, n = grd->my;
X			verbalize("You've been warned, knave!");
X			mnexto(grd);
X			levl[m][n].typ = EGD(grd)->fakecorr[0].ftyp;
X			newsym(m,n);
X			if(cansee(m,n)) prl(m,n);
X			grd->mpeaceful = 0;
X			return(-1);
X		}
X		/* not fair to get mad when (s)he's fainted */
X		if(!is_fainted()) EGD(grd)->warncnt++;
X		return(0);
X	    }
X	    if(!in_vault(u.ux,u.uy) && u.ugold) { /* player teleported */
X		register int m = grd->mx, n = grd->my;
X		rloc(grd);
X		levl[m][n].typ = EGD(grd)->fakecorr[0].ftyp;
X		newsym(m,n);
X		if(!Blind) prl(m,n);
X		grd->mpeaceful = 0;
Xletknow:
X		if(!cansee(grd->mx, grd->my))
X		    You("hear the shrill sound of a guard's whistle.");
X		else
X		    You(um_dist(grd->mx, grd->my, 2) ?
X			"see an angry %s approaching." :
X			"are confronted by an angry %s.",
X			lmonnam(grd)+4);
X		return(-1);
X	    }
X	}
X	if(u.ugold && (in_fcorridor(grd, u.ux, u.uy) || /*cover 'blind' spot*/
X		    (EGD(grd)->fcend > 1 && in_vault(u.ux, u.uy)))) {
X		if(EGD(grd)->warncnt < 6) {
X			EGD(grd)->warncnt = 6;
X			verbalize("Drop all your gold, scoundrel!");
X			return(0);
X		} else {
X			verbalize("So be it, rogue!");
X			grd->mpeaceful = 0;
X			return(-1);
X		}	
X	} 
X	for(fci = EGD(grd)->fcbeg; fci < EGD(grd)->fcend; fci++)
X	    if(g_at(EGD(grd)->fakecorr[fci].fx, EGD(grd)->fakecorr[fci].fy)){
X		m = EGD(grd)->fakecorr[fci].fx;
X		n = EGD(grd)->fakecorr[fci].fy;
X		goldincorridor = TRUE; 
X	    }
X	if(goldincorridor && !EGD(grd)->gddone) {
X		x = grd->mx;
X		y = grd->my;
X		if(m == x && n == y) mpickgold(grd);
X		else if(m == u.ux && n == u.uy) {
X		    gold = g_at(u.ux, u.uy);
X 		    grd->mgold += gold->amount;
X		    freegold(gold);
X		} else {
X		    /* just for insurance... */
X		    if(MON_AT(m, n) && m != grd->mx && n != grd->my) {
X			verbalize("Out of my way, scum!");
X			rloc(m_at(m, n));
X		    }
X		    remove_monster(grd->mx, grd->my);
X		    place_monster(grd, m, n);
X		    pmon(grd);
X		    mpickgold(grd);
X		}
X		pline("The %s%s picks the gold.", lmonnam(grd)+4,
X				grd->mpeaceful ? " calms down and" : "");
X		if(x != grd->mx || y != grd->my) {
X		    remove_monster(grd->mx, grd->my);
X		    place_monster(grd, x, y);
X		    pmon(grd);
X		}
X		goldincorridor = FALSE;
X		if(!grd->mpeaceful) return(-1);
X		else {
X		    EGD(grd)->warncnt = 5;
X		    return(0);
X		}
X	}
X	if(um_dist(grd->mx, grd->my, 1) || EGD(grd)->gddone) {
X		restfakecorr(grd);
X		return(0);	/* didn't move */
X	}
X	x = grd->mx;
X	y = grd->my;
X	/* look around (hor & vert only) for accessible places */
X	for(nx = x-1; nx <= x+1; nx++) for(ny = y-1; ny <= y+1; ny++) {
X	  if((nx == x || ny == y) && (nx != x || ny != y) && isok(nx, ny)) {
X
X	    typ = (crm = &levl[nx][ny])->typ;
X	    if(!IS_STWALL(typ) && !IS_POOL(typ)) {
X
X		for(i = EGD(grd)->fcbeg; i < EGD(grd)->fcend; i++)
X		    if(EGD(grd)->fakecorr[i].fx == nx && 
X				EGD(grd)->fakecorr[i].fy == ny)
X			goto nextnxy;
X
X		if((i = inroom(nx,ny)) >= 0 && rooms[i].rtype == VAULT)
X			continue;
X
X		/* seems we found a good place to leave him alone */
X		EGD(grd)->gddone = 1;
X		if(ACCESSIBLE(typ)) goto newpos;
X#ifdef STUPID
X		if (typ == SCORR)
X		    crm->typ = CORR;
X		else
X		    crm->typ = DOOR;
X#else
X		crm->typ = (typ == SCORR) ? CORR : DOOR;
X#endif
X		if(crm->typ == DOOR) crm->doormask = D_NODOOR;
X		goto proceed;
X	    }
X	  }
Xnextnxy:	;
X	}
X	nx = x;
X	ny = y;
X	gx = EGD(grd)->gdx;
X	gy = EGD(grd)->gdy;
X	dx = (gx > x) ? 1 : (gx < x) ? -1 : 0;
X	dy = (gy > y) ? 1 : (gy < y) ? -1 : 0;
X	if(abs(gx-x) >= abs(gy-y)) nx += dx; else ny += dy;
X
X	while((typ = (crm = &levl[nx][ny])->typ) != 0) {
X	/* in view of the above we must have IS_WALL(typ) or typ == POOL */
X	/* must be a wall here */
X		if(isok(nx+nx-x,ny+ny-y) && !IS_POOL(typ) &&
X		    SPACE_POS(levl[nx+nx-x][ny+ny-y].typ)){
X			crm->typ = DOOR;
X			crm->doormask = D_NODOOR;
X			goto proceed;
X		}
X		if(dy && nx != x) {
X			nx = x; ny = y+dy;
X			continue;
X		}
X		if(dx && ny != y) {
X			ny = y; nx = x+dx; dy = 0;
X			continue;
X		}
X		/* I don't like this, but ... */
X		crm->typ = DOOR;
X		crm->doormask = D_NODOOR;
X		goto proceed;
X	}
X	crm->typ = CORR;
Xproceed:
X	if(cansee(nx,ny)) {
X		mnewsym(nx,ny);
X		prl(nx,ny);
X	}
X	fcp = &(EGD(grd)->fakecorr[EGD(grd)->fcend]);
X	if(EGD(grd)->fcend++ == FCSIZ) panic("fakecorr overflow");
X	fcp->fx = nx;
X	fcp->fy = ny;
X	fcp->ftyp = typ;
Xnewpos:
X	if(EGD(grd)->gddone) {
X		/* The following is a kluge.  We need to keep     */
X		/* the guard around in order to be able to make   */
X		/* the fake corridor disappear as the player      */
X		/* moves out of it, but we also need the guard    */
X		/* out of the way.  We send the guard to never-   */
X		/* never land.  We set ogx ogy to mx my in order  */
X		/* to avoid a check at the top of this function.  */
X		/* At the end of the process, the guard is killed */
X		/* in restfakecorr().				  */
X		remove_monster(grd->mx, grd->my);
X		place_monster(grd, 0, 0);
X		EGD(grd)->ogx = grd->mx;
X		EGD(grd)->ogy = grd->my;
X		restfakecorr(grd);
X		if(in_fcorridor(grd, u.ux, u.uy) || cansee(grd->mx, grd->my))
X		    pline("Suddenly, the guard disappears.");
X		return(-2);
X	}
X	EGD(grd)->ogx = grd->mx;	/* update old positions */
X	EGD(grd)->ogy = grd->my;
X	remove_monster(grd->mx, grd->my);
X	place_monster(grd, nx, ny);
X	pmon(grd);
X	restfakecorr(grd);
X	return(1);
X}
X
X/* Routine when dying or quitting with a vault guard around */
Xvoid
Xpaygd() {
X
X	struct monst *guard;
X	register int i;
X	int gx,gy;
X	char buf[BUFSZ];
X
X	guard = findgd();
X	if (!u.ugold || !guard) return;
X
X	if (u.uinvault) {
X	    Your("%ld zorkmid%s goes into the Magic Memory Vault.",
X		u.ugold, plur(u.ugold));
X	    mkgold(u.ugold, u.ux, u.uy);
X	    u.ugold = 0L;
X	} else {
X	    if(guard->mpeaceful) { /* he has no "right" to your gold */
X		mongone(guard);
X		return;
X	    }
X	    mnexto(guard);
X	    pmon(guard);
X	    pline("%s remits your gold to the vault.", Monnam(guard));
X	    for(i=0; i<=nroom; i++)
X		if (rooms[i].rtype==VAULT) break;
X	    if (i > nroom) {
X		impossible("no vault?");
X		return;
X	    }
X	    gx = rooms[i].lx + rn2(2);
X	    gy = rooms[i].ly + rn2(2);
X	    mkgold(u.ugold, gx, gy);
X	    u.ugold = 0L;
X	    Sprintf(buf,
X		"To Croesus: here's the gold recovered from the %s %s...",
X		player_mon()->mname, plname);
X	    make_engr_at(gx, gy, buf);
X	}
X	mongone(guard);
X}
X
Xboolean
Xgd_sound() {  /* prevent "You hear footsteps.." when inappropriate */
X	register struct monst *grd = findgd();
X
X	return(grd == (struct monst *)0);
X}
X
X#endif /* OVLB */
END_OF_FILE
if test 11389 -ne `wc -c <'src/vault.c'`; then
    echo shar: \"'src/vault.c'\" unpacked with wrong size!
fi
# end of 'src/vault.c'
echo shar: End of archive 29 \(of 30\).
cp /dev/null ark29isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
