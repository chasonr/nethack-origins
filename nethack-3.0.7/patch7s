Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!zaphod.mps.ohio-state.edu!think!mintaka!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i019:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7s
Message-ID: <5233@tekred.CNA.TEK.COM>
Date: 24 Feb 90 01:01:59 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1969
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 19
Archive-name: NetHack3/Patch7s
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 30)."
# Contents:  patch7.13
# Wrapped by billr@saab on Wed Feb 21 10:04:40 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.13' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.13'\" to \"'patch7.13.orig'\"
  mv -f 'patch7.13' 'patch7.13.orig'
fi
echo shar: Extracting \"'patch7.13'\" \(53324 characters\)
sed "s/^X//" >'patch7.13' <<'END_OF_FILE'
X*** /dev/null	Mon Feb 19 16:50:00 1990
X--- amiga/NHScore.uu	Sun Feb 11 12:22:05 1990
X***************
X*** 0 ****
X--- 1,44 ----
X+ begin 644 NetHackScore.info
X+ MXQ   0      ) !) %  *P &  ,  0 C!#  (P9(                    
X+ M    !/X (P&P "*'P    ,H    ^             )Q       !0 "H  @ !
X+ MH4@#                                                /______X
X+ M!X   /\\__]__?_\  #_'/_^?_W__P  _PSP?!_Y__\  ?\DYSY_^_S_@ #_
X+ M,. ^?_G^?X  _SCG_F_]_S^  '\\\'\?_/^_@  ?______X_OX          
X+ M '^     '_______@    !_______P     _______\     (&#@Q'!^    
X+ M $_.3F,G/@    #@S\YG(#P     _DY.9^?X     <#@X,/P>     /_____
X+ M__     #_______@    !_______X     _______\     /______^     
X+ M      '_@  '_______"_P  #_______GWX  !YS___Q_[Y^   ^<___^?]\
X+ M_   /G.#\'G/?_@  #X#^><YGT?X   ^<\'G^#\/\   /G,YYSF??^   !YS
X+ MA/!QSS^    /______^?    !_______S                           
X+ M                                                          !_
X+ M______S_P   P      '^'P  0##  "  @ #  $ XP !@ (  ( # /,/@^ &
X+ M  #  @#;&,& ! , 0 , SQ_!@ 8!@$ ! ,<8 9 " ,!  8###X#@ P! 0 #@
X+ M      ' 0$  /________X!     (       0    &       ,    !     
X+ M  "     WY\?.X^!@    + QL9S8P0    $?,#&8W\(    # ;&QF!@&    
X+ M C\?'SP/A     0       @    ,       8    "       $    !      
X+ M "     P      !@  ?_______X 0  8       ] ,  ,       8(&  "&,
X+ M   . $&!  !!C   !@"# P  08Q\#X8P@ 8  $'\!AC&8,0$  !!C#X8!\" 
X+ M"   08S&&,9@@!@  &&,>P^.,,!P   P      !@P   &       ,X    ?_
X+ M______X                                                  %  
X+ M*@ "  &DD ,                                                _
X+ M______@'@   _SS__W_]__P  /\<__Y__ /_  #_#/!\'_@ /P !_R3G/G_X
X+ M  >  /\PX#Y_^     #_..?^;_P     ?SSP?Q_\X    !_______C@     
X+ M        8#     ?_____@      '_____X      #______       @8.#$
X+ M< ,     3\Y.8R<#     .#/SF<@(P    #^3DYGY_L    !P.#@P_!_@   
X+ M ________.    /______^     '_______@    #_______P     ______
X+ M_X           ?^   ?______\+_   /______^??@  'G/___'_OAX  #YS
X+ M___Y_WS<   ^<X/P><]#N   /@/YYSF?3O@  #YSP>?X/P'P   ^<SGG.9]_
X+ MX   'G.$\''//X    _______Y\    '_______,                    
X+ M                                                            
X+ M     '_______/_   #       ?X?  ! ,,  ( "  ,  0#C  &  _P @ , 
X+ M\P^#X 8#P, " -L8P8 $ #A  P#/'\& !@ 'P $ QQ@!D (  '@!@,,/@. #
X+ M   & .       <   @ _________X#(    @     0 "    8     $_\@  
X+ M $      C^0   #?GQ\[C\.(    L#&QG-CC<    1\P,9C?WX    ,!L;&8
X+ M& <    "/Q\?/ ^'@   !       '.    P      !@    (       0    
X+ M$       (    #       &  !________@!  !@      #T P  P      !@
X+ M@8  (8P   X 08$  $&,   & (/#  !!C'P/AC"#A@  0?P&&,9@S@0  $&,
X+ M/A@'P( (  !!C,88QF" &   88Q[#XXPP'   #       &#    8       S
X+ M@   !________@                                              
X+ @ !!(86-K17AE.DYE=$AA8VL     "     930T]210  
X+  
X+ end
X*** /dev/null	Mon Feb 19 16:50:11 1990
X--- amiga/NHinfo.uu	Sat Jan 20 16:42:21 1990
X***************
X*** 0 ****
X--- 1,43 ----
X+ begin 644 NetHack.info
X+ MXQ   0     "$@ 2 %  *P &  ,  0 C>P  (WN@                    
X+ M     R(              @X    '             )Q       !0 "H  @ !
X+ M@;@#      #_____________^/____QC___X__@____\8___^/_X#____&/_
X+ M__C_^,/___QC___X__CP___\8___^/_X_#___&/___C_^/\/__QC___X__C_
X+ MP__\8___^/_X__#__&    #_^/_\/_Q@    __C__P_\8___^/_X___#_&/_
X+ M__C_^/__\/QC___X__C___P  !__^/_X___\   '__C_^/__^ !CX'_X__C_
X+ M__ 08_@?^/_X___P_&/^#_C_____\/___X________/____'____________
X+ MX____________^/________\  ?#________^  !C_________!_P!______
X+ M___P__ _________^   /_________X #A____________\/____________
X+ M#____________P?___________^'____________A________/___X?_____
X+ M__@/__^/_______\ __\#________@#_X#_________ '@#__________@ ?
X+ M______________________________\             !P    .<   '  ? 
X+ M   #G   !P '\    YP   < !SP   .<   '  </   #G   !P ' \   YP 
X+ M  < !P#P  .<   '  < /  #G   !P '  \  Y____\ !P #P .?____  < 
X+ M / #G   !P '   \ YP   < !P  #P.<   '  <   ,     !P '        
X+ M  < !P   !*<   '  <    /G   !P '     YP   <                 
X+ M                                                            
X+ M                                                            
X+ M                                                            
X+ M                                                            
X+ M                                                         %  
X+ M*@ "  &%  ,      /_____________X_____&/___C_^#____QC___X__@/
X+ M___\8___^/_XP____&/___C_^/#___QC___X__C\/__\8___^/_X_P___&/_
X+ M__C_^/_#__QC___X__C_\/_\8    /_X__P__&    #_^/__#_QC___X__C_
X+ M_\/\8___^/_X___P_&/___C_^/___   '__X__C___@   ?_^/_X__^  &/@
X+ M?_C_^/_  !!C^!_X__C^  #\8_X/^/__^   ____C_____,!D____\?____X
X+ M !_____C____^  ?____X_____P /_P !\/____^&'_X  &/_____QO_\'_ 
X+ M'_________#_\#_________X   __________@ .'____________P______
X+ M______\/____________!____________X?___________^'_______\____
X+ MA_______^ ___X________P#__P/_______^ /_@/________\ > /______
X+ M___^ !_______________________________P             '     YP 
X+ M  < !\    .<   '  ?P   #G   !P '/    YP   < !P\   .<   '  <#
X+ MP  #G   !P ' /   YP   < !P \  .<   '  < #P #G____P '  /  Y__
X+ M__\ !P  \ .<   '  <  #P#G   !P '   / YP   < !P   P     '  < 
X+ M        !P '    $IP   < !P    ^<   '  <    #G   !P          
X+ M      ,!@                        ?^           !_            
X+ M'            !@            8            &            #P     
X+ M      #G                                                    
X+ M                                                            
X+ K                                                            
X+  
X+ end
X*** /dev/null	Mon Feb 19 16:50:28 1990
X--- amiga/NewGame.uu	Sun Feb 11 12:22:18 1990
X***************
X*** 0 ****
X--- 1,44 ----
X+ begin 644 NewGame.info
X+ MXQ   0      D0 2 %  *P &  ,  0 BTP  (P&8                    
X+ M    !/X (M-@         3<    '             )Q       !0 "H  @ !
X+ M@^@#      #_____________^/____QC___X__@____\8___^/_X#____&/_
X+ M__C_^,/___QC___X__CP___\8___^/_X_#___&/___C_^/\/__QC___X__C_
X+ MP__\8___^/_X__#__&    #_^/_\/_Q@    __C__P_\8___^/_X___#_&/_
X+ M__C_^/__\/QC___X__C___P  !__^/_X___\   '__C_^/__^ !CX'_X__C_
X+ M__ 08_@?^/_X___P_&/^#_C_____\/___X________/____'____\#______
X+ MX_____.?_____^/____SG__\  ?#____\Y__^  !C_____.?__!_P!______
X+ M___P__ _____^#__^   /_____.?__X #A_____P'_____\/____\_______
X+ M#_____@______P?___________^'____YY______A____^2?_/___X?____D
X+ MG_@/__^/____\S_\ __\#_____,__@#_X#_________ '@#__________@ ?
X+ M______________________________\             !P    .<   '  ? 
X+ M   #G   !P '\    YP   < !SP   .<   '  </   #G   !P ' \   YP 
X+ M  < !P#P  .<   '  < /  #G   !P '  \  Y____\ !P #P .?____  < 
X+ M / #G   !P '   \ YP   < !P  #P.<   '  <   ,     !P '        
X+ M  < !P   !*<   '  <    /G   !P '     YP   <                 
X+ M            #\            Q@           ,8           #&      
X+ M      Q@                        !\            Q@           /
X+ MX           #             ?                         &&      
X+ M     !M@           ;8           #,            S             
X+ M                                                         %  
X+ M*@ "  &7< ,      /_____________X_____&/___C_^#____QC___X__@/
X+ M___\8___^/_XP____&/___C_^/#___QC___X__C\/__\8___^/_X_P___&/_
X+ M__C_^/_#__QC___X__C_\/_\8    /_X__P__&    #_^/__#_QC___X__C_
X+ M_\/\8___^/_X___P_&/___C_^/___   '__X__C___@   ?_^/_X__^  &/@
X+ M?_C_^/_  !!C^!_X__C^  #\8_X/^/__^   ____C_____,!D____\?____X
X+ M !_____C____^  ?____X_____P /_P !\/____\ '_X  &/_____ #_\'_ 
X+ M'_____S\__#_\#______!__X   ______G/__@ .'_____X#_____P_____^
X+ M?_____\/_____P?_____!____________X?____^>?____^'_____DG\____
X+ MA_____Y)^ ___X______,_P#__P/_____S/^ /_@/________\ > /______
X+ M___^ !_______________________________P             '     YP 
X+ M  < !\    .<   '  ?P   #G   !P '/    YP   < !P\   .<   '  <#
X+ MP  #G   !P ' /   YP   < !P \  .<   '  < #P #G____P '  /  Y__
X+ M__\ !P  \ .<   '  <  #P#G   !P '   / YP   < !P   P     '  < 
X+ M        !P '    $IP   < !P    ^<   '  <    #G   !P          
X+ M      ,!@                                                   
X+ M             P$           ,;            ^            ;P     
X+ M      '_           !@            /@                        !
X+ MA@           ;8           &V            S            ,P     
X+ M                                                            
X+ 2 !!(86-K17AE.DYE=$AA8VL 
X+  
X+ end
X*** amiga/Old/amidos.c	Mon Feb 19 16:50:52 1990
X--- amiga/amidos.c	Wed Jan 31 19:26:06 1990
X***************
X*** 3,9 ****
X  /* An assortment of imitations of cheap plastic MSDOS functions.
X   */
X  
X! #include <libraries/dos.h>
X  
X  #undef TRUE
X  #undef FALSE
X--- 3,10 ----
X  /* An assortment of imitations of cheap plastic MSDOS functions.
X   */
X  
X! #define NEED_VARARGS
X! #include "hack.h"
X  
X  #undef TRUE
X  #undef FALSE
X***************
X*** 10,25 ****
X  #undef COUNT
X  #undef NULL
X  
X! #define NEED_VARARGS
X! #include "hack.h"
X  
X  extern char Initialized;
X  
X! struct FileLock *Lock(), *CurrentDir(); /* Cheating - BCPL pointers */
X! struct FileHandle *Open();              /* Cheating - BCPL pointer */
X! long Read(), Write(), IoErr(), AvailMem();
X! void *malloc();
X! char *rindex(), *index();
X  
X  int Enable_Abort = 0;	/* for stdio package */
X  
X--- 11,65 ----
X  #undef COUNT
X  #undef NULL
X  
X! #include <libraries/dos.h>
X! #ifdef LATTICE
X! #include <proto/exec.h>
X! #include <proto/dos.h>
X! #endif
X  
X+ /* Prototypes for functions defined in amidos.c */
X+ void NDECL (flushout);
X+ int NDECL (getpid);
X+ int FDECL (abs, (int x));
X+ int NDECL (tgetch);
X+ int NDECL (dosh);
X+ long FDECL (freediskspace, (char *path));
X+ long FDECL (filesize, (char *file));
X+ void FDECL (eraseall, (char *path,
X+               char *files));
X+ char *FDECL (CopyFile, (char *from,
X+                char *to));
X+ void FDECL (copybones, (int mode));
X+ void NDECL (playwoRAMdisk);
X+ int FDECL (saveDiskPrompt, (int start));
X+ void NDECL (gameDiskPrompt);
X+ void NDECL (read_config_file);
X+ void NDECL (set_lock_and_bones);
X+ void FDECL (append_slash, (char *name));
X+ void FDECL (getreturn, (char *str));
X+ void VDECL (msmsg, (char *fmt, ...));
X+ FILE * FDECL (fopenp, (char *name,
X+                       char *mode));
X+ int FDECL (chdir, (char *dir));
X+ void FDECL (msexit, (int code));
X+ static boolean NDECL (record_exists);
X+ static int FDECL (strcmpi, (register char *a, register char *b));
X+ 
X  extern char Initialized;
X  
X! #ifdef AZTEC_C
X! struct DateStamp *FDECL(DateStamp, (struct DateStamp *));
X! BPTR FDECL(Lock, (char *, long));
X! BPTR FDECL(CurrentDir, (BPTR));
X! BPTR FDECL(Open, (char *, long));
X! long FDECL(Read, (BPTR, char *, long));
X! long FDECL(Write, (BPTR, char *, long));
X! long NDECL(IoErr);
X! long FDECL(AvailMem, (long));
X! void *FDECL(malloc, (unsigned int));
X! char *FDECL(rindex, (char *, int));
X! char *FDECL(index, (char *, int));
X! #endif
X  
X  int Enable_Abort = 0;	/* for stdio package */
X  
X***************
X*** 52,58 ****
X      while (pid == 0) {
X  	struct DateStamp dateStamp;
X  	pid = rnd(30000);
X! 	pid += DateStamp(&dateStamp);    /* More or less random */
X  	pid ^= (short) (dateStamp.ds_Days >> 16) ^
X  	       (short) (dateStamp.ds_Days)       ^
X  	       (short) (dateStamp.ds_Minute)     +
X--- 92,98 ----
X      while (pid == 0) {
X  	struct DateStamp dateStamp;
X  	pid = rnd(30000);
X! 	pid += (short) DateStamp(&dateStamp);    /* More or less random */
X  	pid ^= (short) (dateStamp.ds_Days >> 16) ^
X  	       (short) (dateStamp.ds_Days)       ^
X  	       (short) (dateStamp.ds_Minute)     +
X***************
X*** 60,66 ****
X  	pid %= 30000;
X      }
X  
X!     return pid;
X  }
X  
X  #ifndef getlogin
X--- 100,106 ----
X  	pid %= 30000;
X      }
X  
X!     return (int)pid;
X  }
X  
X  #ifndef getlogin
X***************
X*** 139,146 ****
X  	    fileName[0] = '\0';
X      }
X  
X!     if (infoData = malloc(sizeof(*infoData))) {
X! 	struct FileLock *fileLock;  /* Cheating */
X  	if (fileLock = Lock(fileName, SHARED_LOCK)) {
X  	    if (Info(fileLock, infoData)) {
X  		/* We got a kind of DOS volume, since we can Lock it. */
X--- 179,186 ----
X  	    fileName[0] = '\0';
X      }
X  
X!     if (infoData = malloc(sizeof(struct InfoData))) {
X! 	BPTR fileLock;
X  	if (fileLock = Lock(fileName, SHARED_LOCK)) {
X  	    if (Info(fileLock, infoData)) {
X  		/* We got a kind of DOS volume, since we can Lock it. */
X***************
X*** 174,184 ****
X  filesize(file)
X  char *file;
X  {
X!     register struct FileLock *fileLock;
X      register struct FileInfoBlock *fileInfoBlock;
X      register long size = 0;
X  
X!     if (fileInfoBlock = malloc(sizeof(*fileInfoBlock))) {
X  	if (fileLock = Lock(file, SHARED_LOCK)) {
X  	    if (Examine(fileLock, fileInfoBlock)) {
X  		size = fileInfoBlock->fib_Size;
X--- 214,224 ----
X  filesize(file)
X  char *file;
X  {
X!     register BPTR fileLock;
X      register struct FileInfoBlock *fileInfoBlock;
X      register long size = 0;
X  
X!     if (fileInfoBlock = malloc(sizeof(struct FileInfoBlock))) {
X  	if (fileLock = Lock(file, SHARED_LOCK)) {
X  	    if (Examine(fileLock, fileInfoBlock)) {
X  		size = fileInfoBlock->fib_Size;
X***************
X*** 201,209 ****
X  {
X      char buf[FILENAME];
X      short i;
X!     struct FileLock *fileLock, *dirLock;
X  
X!     if (dirLock = Lock(path)) {
X  	dirLock = CurrentDir(dirLock);
X  
X  	strcpy(buf, files);
X--- 241,249 ----
X  {
X      char buf[FILENAME];
X      short i;
X!     BPTR fileLock, dirLock;
X  
X!     if (dirLock = Lock(path ,SHARED_LOCK)) {
X  	dirLock = CurrentDir(dirLock);
X  
X  	strcpy(buf, files);
X***************
X*** 227,233 ****
X  char *CopyFile(from, to)
X  char *from, *to;
X  {
X!     register struct FileHandle *fromFile, *toFile;
X      register char *buffer;
X      register long size;
X      char *error = NULL;
X--- 267,273 ----
X  char *CopyFile(from, to)
X  char *from, *to;
X  {
X!     register BPTR fromFile, toFile;
X      register char *buffer;
X      register long size;
X      char *error = NULL;
X***************
X*** 257,263 ****
X  copybones(mode)
X  int mode;
X  {
X!     struct FileLock *fileLock;
X      char from[FILENAME], to[FILENAME];
X      char *frompath, *topath, *status;
X      short i;
X--- 297,303 ----
X  copybones(mode)
X  int mode;
X  {
X!     BPTR fileLock;
X      char from[FILENAME], to[FILENAME];
X      char *frompath, *topath, *status;
X      short i;
X***************
X*** 336,342 ****
X  {
X      extern int saveprompt;
X      char buf[BUFSIZ], *bp;
X!     struct FileLock *fileLock;
X  
X      if (saveprompt) {
X  	/* Don't prompt if you can find the save file */
X--- 376,382 ----
X  {
X      extern int saveprompt;
X      char buf[BUFSIZ], *bp;
X!     BPTR fileLock;
X  
X      if (saveprompt) {
X  	/* Don't prompt if you can find the save file */
X***************
X*** 413,419 ****
X  {
X      char    tmp_ramdisk[PATHLEN], tmp_levels[PATHLEN];
X      char    buf[BUFSZ], *bufp;
X!     FILE    *fp, *fopenp();
X      extern  char plname[];
X      extern  int saveprompt;
X  
X--- 453,459 ----
X  {
X      char    tmp_ramdisk[PATHLEN], tmp_levels[PATHLEN];
X      char    buf[BUFSZ], *bufp;
X!     FILE    *fp;
X      extern  char plname[];
X      extern  int saveprompt;
X  
X***************
X*** 567,574 ****
X--- 607,629 ----
X  msmsg VA_DECL(char *, fmt)
X      VA_START(fmt);
X      VA_INIT(fmt, char *);
X+ #ifdef LATTICE
X+ 	{
X+ 	extern struct Screen *HackScreen;
X+ 	char buf[100];
X+ 	vsprintf(buf,fmt,VA_ARGS);
X+ 	if(HackScreen){
X+ 		WindowFPuts(buf);
X+ 		WindowFlush();
X+ 	} else {
X+ 		fprintf(stdout,buf);
X+ 		fflush(stdout);
X+ 	}
X+ 	}
X+ #else
X      vprintf(fmt, VA_ARGS);
X      (void) fflush(stdout);
X+ #endif
X      VA_END();
X  }
X  
X***************
X*** 583,589 ****
X  {
X      char buf[BUFSIZ], *bp, *pp, lastch;
X      FILE *fp;
X!     register struct FileLock *theLock;
X  
X      /* Try the default directory first.  Then look along PATH.
X       */
X--- 638,644 ----
X  {
X      char buf[BUFSIZ], *bp, *pp, lastch;
X      FILE *fp;
X!     register BPTR theLock;
X  
X      /* Try the default directory first.  Then look along PATH.
X       */
X***************
X*** 622,631 ****
X   *  Assumes -1 is not a valid lock, since 0 is valid.
X   */
X  
X! #define NO_LOCK     ((struct FileLock *) -1)
X  
X  char orgdir[1];
X! static struct FileLock *OrgDirLock = NO_LOCK;
X  
X  chdir(dir)
X  char *dir;
X--- 677,686 ----
X   *  Assumes -1 is not a valid lock, since 0 is valid.
X   */
X  
X! #define NO_LOCK     ((BPTR) -1)
X  
X  char orgdir[1];
X! static BPTR OrgDirLock = NO_LOCK;
X  
X  chdir(dir)
X  char *dir;
X***************
X*** 641,647 ****
X  	 * Go to some new place. If still at the original
X  	 * directory, save the FileLock.
X  	 */
X! 	struct FileLock *newDir;
X  
X  	if (newDir = Lock(dir, SHARED_LOCK)) {
X  	    if (OrgDirLock == NO_LOCK) {
X--- 696,702 ----
X  	 * Go to some new place. If still at the original
X  	 * directory, save the FileLock.
X  	 */
X! 	BPTR newDir;
X  
X  	if (newDir = Lock(dir, SHARED_LOCK)) {
X  	    if (OrgDirLock == NO_LOCK) {
X***************
X*** 702,708 ****
X   *  memcmp - used to compare two struct symbols, in lev.c
X   */
X  
X! #ifndef memcmp
X  memcmp(a, b, size)
X  register unsigned char *a, *b;
X  register int size;
X--- 757,763 ----
X   *  memcmp - used to compare two struct symbols, in lev.c
X   */
X  
X! #if defined(AZTEC_C) && !defined(memcmp)
X  memcmp(a, b, size)
X  register unsigned char *a, *b;
X  register int size;
X***************
X*** 713,729 ****
X      }
X  
X      return 0;		/* equal */
X- }
X- #endif
X- 
X- #ifndef memcpy
X- char *
X- memcpy(dest, source, size)
X- register char *dest;
X- char *source;
X- int size;
X- {
X-     movmem(source, dest, size);
X-     return dest;
X  }
X  #endif
X--- 768,772 ----
X*** amiga/Old/amimenu.c	Mon Feb 19 16:51:45 1990
X--- amiga/amimenu.c	Thu Dec 28 17:27:08 1989
X***************
X*** 7,13 ****
X  
X  #define TEXT(nam,str) \
X  static struct IntuiText nam = \
X!   {0,1,JAM2,0,0,(struct TextAttr*)NULL,(UBYTE*)str,(struct IntuiText*)NULL}
X  
X  	/* Commands */
X  	TEXT(T_HELP,  "?   Display help menu");
X--- 7,13 ----
X  
X  #define TEXT(nam,str) \
X  static struct IntuiText nam = \
X!   {0,1,JAM2,0,0,0L,(UBYTE*)str,0L}
X  
X  	/* Commands */
X  	TEXT(T_HELP,  "?   Display help menu");
X***************
X*** 64,70 ****
X  	TEXT(T_E,     "E   Engrave msg on floor");
X  
X  #define IFLAGS ITEMENABLED|ITEMTEXT|HIGHCOMP
X! #define IDATA(cmd,str,off) 0,off,WDT,9,IFLAGS,0,(APTR)&str,NULL,cmd,(struct MenuItem*)NULL,0
X  
X  /* Commands */
X  
X--- 64,70 ----
X  	TEXT(T_E,     "E   Engrave msg on floor");
X  
X  #define IFLAGS ITEMENABLED|ITEMTEXT|HIGHCOMP
X! #define IDATA(cmd,str,off) 0,off,WDT,9,IFLAGS,0,(APTR)&str,NULL,cmd,0L,0
X  
X  /* Commands */
X  
X*** amiga/Old/amitcap.c	Mon Feb 19 16:51:59 1990
X--- amiga/amitcap.c	Wed Jan 31 19:25:16 1990
X***************
X*** 4,11 ****
X--- 4,25 ----
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X+ 
X  #include "hack.h"       /* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X  
X+ #ifdef LATTICE
X+ #undef TRUE
X+ #undef FALSE
X+ #undef COUNT
X+ #undef NULL
X+ #include <proto/dos.h>
X+ #endif
X+ 
X+ #ifndef LATTICE
X+ extern void FDECL(Delay, (unsigned long));
X+ #endif
X+ extern void NDECL(Initialize);
X+ 
X  static char HO[] = "\233H";         /* Home         CSI H */
X  static char CL[] = "\f";            /* Clear        FF */
X  static char CE[] = "\233K";         /* Erase EOL    CSI K */
X***************
X*** 17,23 ****
X  static char ME[] = "\2330m";        /* Reverse off  CSI 0 m */
X  
X  #ifdef TEXTCOLOR
X! static char SO[] = "\23333m";       /* Standout: Color #3 (orange) */
X  static char SE[] = "\2330m";
X  #else
X  static char SO[] = "\2337m";        /* Inverse video */
X--- 31,37 ----
X  static char ME[] = "\2330m";        /* Reverse off  CSI 0 m */
X  
X  #ifdef TEXTCOLOR
X! static char SO[] = "\23337m";       /* Use colormap entry #7 (red) */
X  static char SE[] = "\2330m";
X  #else
X  static char SO[] = "\2337m";        /* Inverse video */
X***************
X*** 25,33 ****
X  #endif
X  
X  #ifdef TEXTCOLOR
X! /* color maps */
X! static int foreg[8] = { 2, 3, 1, 3, 3, 3, 3, 0 };
X! static int backg[8] = { 1, 2, 2, 0, 1, 1, 1, 1 };
X  #endif
X  
X  void
X--- 39,50 ----
X  #endif
X  
X  #ifdef TEXTCOLOR
X! /*
X!  * Map our amiga-specific colormap into the colormap specified in color.h.
X!  * See amiwind.c for the amiga specific colormap.
X!  */
X! static int foreg[16] = { 0, 7, 4, 2, 6, 5, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
X! static int backg[16] = { 1, 0, 0, 0, 0, 0, 0, 0, 1, 7, 4, 2, 6, 5, 3, 1 };
X  #endif
X  
X  void
X***************
X*** 35,71 ****
X  {
X  #ifdef TEXTCOLOR
X      register int c;
X! #endif  
X! 
X      (void) Initialize();        /* This opens screen, window, console, &c */
X- 
X      CO = COLNO;
X      LI = ROWNO+3;               /* used in pri.c and pager.c */
X  
X      set_whole_screen();
X- 
X      CD = "\233J";               /* used in pager.c */
X  
X  #ifdef TEXTCOLOR
X      /*
X!      * We need 5 different 'colors', but in a 4-color screen we really
X!      * cannot make these available, even more so because we use the user's
X!      * preferred Workbench colors. Instead, we use different combinations
X!      * of the 4 possible colors. For orientation: default colors are
X!      * white (1) on blue (0), and a orange (3) cursor on a black (2) character.
X!      *
X!      * "Black": Black on White
X!      * "Red":	Orange on Black
X!      * "Green": White on Black
X!      * "Yellow": Orange on Blue
X!      * "Blue":	Orange on White
X!      * "Magenta": White on Black
X!      * "Cyan":	White on Black
X!      * "White": Blue on White
X       */
X!     for (c = 0; c < SIZE(HI_COLOR); c++) {
X! 	HI_COLOR[c] = (char *) alloc(sizeof("E0;33;44m"));
X! 	Sprintf(HI_COLOR[c], "\2333%d;4%dm", foreg[c], backg[c]);
X      }
X  
X      HI = "\2331m";              /* Bold (hilight) */
X--- 52,76 ----
X  {
X  #ifdef TEXTCOLOR
X      register int c;
X! #endif
X      (void) Initialize();        /* This opens screen, window, console, &c */
X      CO = COLNO;
X      LI = ROWNO+3;               /* used in pri.c and pager.c */
X  
X      set_whole_screen();
X      CD = "\233J";               /* used in pager.c */
X  
X  #ifdef TEXTCOLOR
X      /*
X!      * Perform amiga to color.h colormap conversion - Please note that the
X!      * console device can only handle 8 foreground and 8 background colors
X!      * while color.h defines 8 basic and 8 hilite colors.  Hilite colors
X!      * are handled as inverses.  For instance, a hilited green color will
X!      * appear as green background with a black foreground.
X       */
X!     for (c = 0; c < SIZE(hilites); c++) {
X!         hilites[c] = (char *) alloc(sizeof("E0;33;44m"));
X!         Sprintf(hilites[c], "\2333%d;4%dm", foreg[c], backg[c]);
X      }
X  
X      HI = "\2331m";              /* Bold (hilight) */
X*** amiga/Old/amitty.c	Mon Feb 19 16:52:15 1990
X--- amiga/amitty.c	Sun Feb 18 16:32:01 1990
X***************
X*** 46,53 ****
X  	VA_INIT(s, char *);
X  	end_screen();
X  	putchar('\n');
X! 	vprintf(s,VA_ARGS);
X  	putchar('\n');
X  	VA_END();
X! 	abort(1);
X  }
X--- 46,57 ----
X  	VA_INIT(s, char *);
X  	end_screen();
X  	putchar('\n');
X! 
X!         {char buf[180];
X! 	vsprintf(buf,s,VA_ARGS);
X!         printf(buf);
X!         }	/* Overloaded */
X  	putchar('\n');
X  	VA_END();
X! 	Abort(0L);
X  }
X*** amiga/Old/amiunix.c	Mon Feb 19 16:52:27 1990
X--- amiga/amiunix.c	Thu Dec 28 17:27:19 1989
X***************
X*** 26,31 ****
X--- 26,33 ----
X  
X  extern time_t time();
X  
X+ static struct tm *NDECL(getlt);
X+ 
X  void
X  setrandom()
X  {
X*** /dev/null	Mon Feb 19 16:52:37 1990
X--- amiga/amiwbench.c	Fri Feb 16 19:05:02 1990
X***************
X*** 0 ****
X--- 1,534 ----
X+ /*    SCCS Id: @(#)amiwbench.c - Amiga Workbench interface  3.0   */
X+ /* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1990	  */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ #include "hack.h"
X+ 
X+ #undef TRUE
X+ #undef FALSE
X+ #undef COUNT
X+ #undef NULL
X+ 
X+ #ifdef LATTICE
X+ #include <proto/exec.h>
X+ #include <proto/dos.h>
X+ #include <proto/icon.h>
X+ #endif
X+ 
X+ #include <workbench/startup.h>
X+ #include <workbench/workbench.h>
X+ #include <exec/memory.h>
X+ #include <ctype.h>
X+ 
X+ #ifdef LATTICE
X+ #include <string.h>
X+ #undef strlen			/* grrr */
X+ #endif
X+ 
X+ #define ALLOC_SIZE		((long)sizeof(struct FileInfoBlock))
X+ 
X+ #ifdef AZTEC_C
X+ /*
X+  * Change when manx becomes ANSI complient
X+  */
X+ BPTR FDECL(CurrentDir,(BPTR));
X+ BPTR FDECL(ParentDir, (BPTR));
X+ BPTR FDECL(Lock, (char *, long));
X+ void *FDECL(AllocMem, (long, long));
X+ void FDECL(FreeMem, (void *, long));
X+ unsigned short FDECL(Examine, (BPTR, struct FileInfoBlock *));
X+ struct Library *FDECL(OpenLibrary,(char *, long));
X+ struct DiskObject *FDECL(GetDiskObject, (char *));
X+ 
X+ extern struct Library *IconBase;
X+ #endif
X+ 
X+ #ifdef AMIGA_WBENCH
X+ static void FDECL(ami_wb_findme,(char *,char *,struct WBArg *));
X+ static int FDECL(buildPath,(LONG,struct FileInfoBlock *,char *));
X+ static void FDECL(insert,(char *,char *));
X+ 
X+ BOOL FromWBench=0;		/* if FALSE, this file is a big NOP */
X+ static BOOL FromTool=0;		/* or from Project (ergo nothing to restore) */
X+ static char argline[80];	/* fake command line from ToolTypes */
X+ static BOOL TTparse=0;		/* parsing tooltypes? */
X+ static BOOL KillIcon=FALSE;	/* delayed expunge of user's icon */
X+ static char iconname[PATHLEN+5];
X+ static char origicon[PATHLEN+5];
X+ static char savefname[PL_NSIZ];		/* name from name of save file */
X+ 
X+ extern const char *classes;	/* liberated from pcmain */
X+ extern char *PATH;
X+ 
X+ /* Called after NetHack.cnf (and maybe NETHACKOPTIONS) are read.
X+  * If this is a request to show the score file, do it here and quit.
X+  */
X+ void ami_wbench_init(argc,argv)
X+ int argc;
X+ char *argv[];
X+ {
X+ 	struct WBStartup *wbs=(struct WBStartup *)argv;
X+ 	struct WBArg *wa;
X+ 	int	ia;			/* arg of active icon */
X+ 	int	x,doscore=0;
X+ 	char 	*p,*lp;
X+ 	BPTR	olddir;			/* starting directory */
X+ 	struct DiskObject *dobj;
X+ 	char	*scorearg;
X+ 	char	tmp_ramdisk[PATHLEN];
X+ 	char	tmp_levels[PATHLEN];
X+ 
X+ 	FromWBench=(argc==0);
X+ 	if(!FromWBench)return;			/* nothing if from CLI */
X+ 
X+ 	/*
X+ 	 * "NULL" out arrays
X+ 	 */
X+ 	tmp_ramdisk[0] = '\0';
X+ 	tmp_levels[0]  = '\0';
X+ 
X+ 	IconBase=OpenLibrary("icon.library",33L);
X+ 	if(!IconBase)error("icon.library missing!");
X+ 
X+ 	wa=wbs->sm_ArgList;
X+ 	if(wbs->sm_NumArgs>2)error("You can only play one game at a time!");
X+ 	ia=wbs->sm_NumArgs-1;
X+ 	strcpy(savefname,wa[ia].wa_Name);
X+ 	if(!strncmp(index(savefname,'.'),".sav",4)){
X+ 		*index(savefname,'.')='\0';
X+ 	} else {
X+ 		savefname[0]='\0';	/* don't override if not save file */
X+ 	}
X+ 
X+ 	olddir=CurrentDir(wa[ia].wa_Lock);   /* where the icon is */
X+ 
X+ 	dobj=GetDiskObject(wa[ia].wa_Name);
X+ 	(void)CurrentDir(olddir);		/* and back */
X+ 	if(!dobj){
X+ 		error("Sorry, I can't find your icon!");
X+ 	}
X+ 
X+ 	FromTool=(dobj->do_Type==WBTOOL)?1:
X+ 			(dobj->do_Type==WBPROJECT)?0:
X+ 			(error("Sorry, I don't recognize this icon type!"),1);
X+ 
X+ 	ami_wb_findme(SAVEF,SAVEP,&wa[ia]);
X+ 	strcpy(origicon,SAVEF);
X+ 	strcat(origicon,".info");
X+ 
X+ 	argline[0]='\0';
X+ 	for(x=0;p=dobj->do_ToolTypes[x];x++){
X+ 		lp=index(p,'=');
X+ 		if(!lp++){
X+ 			if((strncmp(p,"SCORES",6)==0) ||
X+ 			   (strncmp(p,"SCORE",5)==0)){
X+ 				doscore=1;
X+ 				scorearg=malloc(strlen(p)+1);
X+ 				strcpy(scorearg,p);
X+ 			} else {
X+ 				TTparse=TRUE;
X+ 				parseoptions(p,(boolean)TRUE);
X+ 				TTparse=FALSE;
X+ 			}
X+ 		} else {
X+ 			while(*lp && isspace(*lp))lp++;
X+ 				/* vars and lengths below match amidos.c,
X+ 				 * but there is no SAVE - you put the
X+ 				 * icon where you want it, and GRAPHICS
X+ 				 * just doesn't belong		*/
X+ 			if(!strncmp(p,"OPTIONS",4)){
X+ 				TTparse=TRUE;
X+ 				parseoptions(lp,(boolean)TRUE);
X+ 				TTparse=FALSE;
X+ 			} else
X+ 			if(lp[0]=='#'){
X+ 				/* for perversity's sake, a comment */
X+ 			} else
X+ 			if(!strncmp(p,"HACKDIR",4)){
X+ 				strncpy(hackdir,lp,PATHLEN);
X+ 			} else
X+ 			if(!strncmp(p,"RAMDISK",3)){
X+ 				strncpy(tmp_ramdisk,lp,PATHLEN);
X+ 			} else
X+ 			if(!strncmp(p,"LEVELS",4)){
X+ 				strncpy(tmp_levels,lp,PATHLEN);
X+ 			} else
X+ 			if(!strncmp(p,"PATH",4)){
X+ 				strncpy(PATH,lp,PATHLEN);
X+ 			} else
X+ 				/* new things */
X+ 			if((strncmp(p,"CMDLINE",7)==0)||
X+ 			   (strncmp(p,"COMMANDLINE",11)==0)){
X+ 				strncpy(argline,lp,79);
X+ 			} else
X+ 			{
X+ 				msmsg("Bad ToolTypes line: '%s'\n",p);
X+ 				getreturn("to continue");
X+ 			}
X+ 		}
X+ 	}
X+ 		/* cleanup - from amidos.c, except we only change things
X+ 		 * that are explicitly changed, since we already
X+ 		 * did this once to get the defaults (in amidos.c)	*/
X+ 	if(plname[0])plnamesuffix();	/* from amidos.c */
X+ 	if(tmp_levels[0])strcpy(permbones,tmp_levels);
X+ 	if(tmp_ramdisk[0]){
X+ 		strcpy(levels,tmp_ramdisk);
X+ 		strcpy(bones,levels);
X+ 		if(strcmp(permbones,levels))
X+ 			ramdisk=TRUE;
X+ 	} else {
X+ 		if(tmp_levels[0]){
X+ 			strcpy(levels,tmp_levels);
X+ 			strcpy(bones,levels);
X+ 		}
X+ 	}
X+ 
X+ 	FreeDiskObject(dobj);	/* we'll get it again later if we need it */
X+ 
X+ 	if(doscore){
X+ 		long ac;
X+ 		char *p;
X+ 		char **av=calloc(1,50*sizeof(char *));
X+ #ifdef CHDIR
X+ 		chdirx(hackdir,0);
X+ #endif
X+ 		av[0]="NetHack";			/* why not? */
X+ 		for(ac=1,p=scorearg;*p;ac++){
X+ 			av[ac]=p;
X+ 			while(*p && !isspace(*p))p++;
X+ 			if(!*p)break;
X+ 			*p++='\0';
X+ 			while(*p && isspace(*p))p++;
X+ 			if(ac==1)sprintf(av[ac],"-s");	/* overwrite SCORES */
X+ 		}
X+ 		prscore(ac+1,av);
X+ 		exit(0);		/* overloaded */
X+ 	}
X+ 
X+ 			/* if the user started us from the tool icon,
X+ 			 * we can't save the game in the same place
X+ 			 * we started from, so pick up the plname
X+ 			 * and hope for the best.
X+ 			 */
X+ 	if(FromTool){
X+ 		strcat(SAVEF,plname);
X+ 		strcat(SAVEP,plname);
X+ 	}
X+ }
X+ 
X+ /* Simulate the command line (-s is already done, although this is
X+  * not exactly the way it should be). Note that we only handle flags
X+  * that are not otherwise available in NetHack.cnf		*/
X+ void ami_wbench_args(){
X+ 	char *p=argline;
X+ 	if(!FromWBench)return;
X+ 	if(!argline)return;
X+ 
X+ 	while(*p){
X+ 		switch(*p++){
X+ 		case '-':	break;
X+ #ifdef NEWS
X+ 		case 'n':	flags.nonews = TRUE;
X+ #endif
X+ #if defined(WIZARD) || defined(EXPLORE_MODE)
X+ # ifndef EXPLORE_MODE
X+ 		case 'X':
X+ # endif
X+ 		case 'D':
X+ # ifdef WIZARD
X+ #  ifdef KR1ED
X+ 			if(!strcmp(plname,WIZARD_NAME)){
X+ #  else
X+ 			if(!strcmp(plname,WIZARD)){
X+ #  endif
X+ 				wizard=TRUE;break;
X+ 			}
X+ 			/* else fall through */
X+ # endif
X+ # ifdef EXPLORE_MODE
X+ 		case 'X':	discover=TRUE;
X+ # endif
X+ 				break;
X+ #endif
X+ #ifdef DGK
X+ 		case 'r':	/* no ram disk */
X+ 			ramdisk=FALSE;
X+ 			break;
X+ #endif
X+ 		default:
X+ 			p--;
X+ 			if(index(classes,toupper(*p))){
X+ 				char *t=pl_character;
X+ 				int cnt=sizeof(pl_character)-1;
X+ 				while(cnt && *p && !isspace(*p))*t++=*p++,cnt--;
X+ 				*t=0;
X+ 			} else {
X+ 				Printf("Unknown switch: %s\n",p);
X+ 				return;
X+ 			}
X+ 		}
X+ 	}
X+ }
X+ 
X+ 
X+ /* IF (from workbench) && (currently parsing ToolTypes)
X+  * THEN print error message and return 0
X+  * ELSE return 1
X+  */
X+ ami_wbench_badopt(oopsline)
X+ char *oopsline;
X+ {
X+ 	if(!FromWBench)return 1;
X+ 	if(!TTparse)return 1;
X+ 	Printf("Bad Syntax in OPTIONS in ToolTypes: %s.",oopsline);
X+ 	return 0;
X+ }
X+ 
X+ /* Construct (if necessary) and fill in icon for given save file */
X+ void ami_wbench_iconwrite(base)
X+ char *base;
X+ {
X+ 	BPTR lock;
X+ 	char tmp[PATHLEN+5];
X+ 
X+ 	if(!FromWBench)return;
X+ 
X+ 	strcpy(tmp,base);
X+ 	strcat(tmp,".info");
X+ 	if(FromTool){				/* user clicked on main icon */
X+ 		(void)CopyFile(DEFAULT_ICON,tmp);
X+ 	} else {				/* from project */
X+ 		lock=Lock(tmp,ACCESS_READ);
X+ 		if(lock==0){	/* maybe our name changed - try to get
X+ 				 * original icon */
X+ 		    if(!Rename(origicon,tmp)){
X+ 				/* nope, build a new icon */
X+ 			lock=Lock(DEFAULT_ICON,ACCESS_READ);
X+ 			if(lock==0)return;		/* no icon today */
X+ 			UnLock(lock);
X+ 			(void)CopyFile(DEFAULT_ICON,tmp);
X+ 		    }
X+ 		} else UnLock(lock);
X+ 	}
X+ 	KillIcon=FALSE;
X+ 
X+ /*	dobj=GetDiskObject(base);
X+ 	anything we need to change?  I don't think so.
X+ 	PutDiskObject(base,dobj);
X+ 	FreeDiskObject(dobj);
X+ */
X+ }
X+ 
X+ /* How much disk space will we need for the icon? */
X+ int ami_wbench_iconsize(base)
X+ char *base;
X+ {
X+ 	struct FileInfoBlock *fib;
X+ 	BPTR lock;
X+ 	int	rv;
X+ 	char tmp[PATHLEN+5];
X+ 
X+ 	if(!FromWBench)return(0);
X+ 	strcpy(tmp,base);
X+ 	strcat(tmp,".info");
X+ 	lock=Lock(tmp,ACCESS_READ);
X+ 	if(lock==0){	/* check the default */
X+ 		lock=Lock(DEFAULT_ICON,ACCESS_READ);
X+ 		if(lock==0)return(0);
X+ 	}
X+ 	fib = (struct FileInfoBlock *)AllocMem(ALLOC_SIZE, MEMF_CLEAR);
X+ 	if(!Examine(lock,fib)){
X+ 		UnLock(lock);
X+ 		FreeMem(fib, ALLOC_SIZE);
X+ 		return(0);			/* if no icon, there
X+ 						 * never will be one */
X+ 	}
X+ 	rv=fib->fib_Size+strlen(plname);	/* guessing */
X+ 	UnLock(lock);
X+ 	FreeMem(fib, ALLOC_SIZE);
X+ 	return(rv);
X+ }
X+ 
X+ /* Delete the icon associated with the given file (NOT the file itself! */
X+ /* (Don't worry if the icon doesn't exist */
X+ void ami_wbench_unlink(base)
X+ char *base;
X+ {
X+ 	if(!FromWBench)return;
X+ 
X+ 	strcpy(iconname,base);
X+ 	strcat(iconname,".info");
X+ 	KillIcon=TRUE;			/* don't do it now - this way the user
X+ 					 * gets back whatever picture we had
X+ 					 * when we started if the game is
X+ 					 * saved again			 */
X+ /*	unlink(tmp); */
X+ }
X+ 
X+ /* Check for a saved game.
X+ IF not a saved game -> -1
X+ IF can't open SAVEF -> -1
X+ ELSE -> fd for reading SAVEF */
X+ int ami_wbench_getsave(mode)
X+ int mode;
X+ {
X+ 	BPTR lock;
X+ 	struct FileInfoBlock *fib;
X+ 
X+ 	if(!FromWBench)return(open(SAVEF,mode));
X+ 			/* if the file will be created anyway, skip the
X+ 			 * checks and just do it			*/
X+ 	if(mode & O_CREAT)return(open(SAVEF,mode));
X+ 	if(FromTool)return(-1);		/* otherwise, by definition, there
X+ 					 * isn't a save file (even if a
X+ 					 * file of the right name exists) */
X+ 	if(savefname[0])
X+ 		strncpy(plname,savefname,PL_NSIZ-1); /* restore poly'd name */
X+ 	lock=Lock(SAVEF,ACCESS_READ);
X+ 	fib = (struct FileInfoBlock *)AllocMem(ALLOC_SIZE, MEMF_CLEAR);
X+ 	if(lock && Examine(lock,fib)){
X+ 		if(fib->fib_Size>100){	/* random number << save file size */
X+ 			UnLock(lock);
X+                         FreeMem(fib,ALLOC_SIZE);
X+ 			return(open(SAVEF,mode));
X+ 		} else {
X+ 				/* this is a dummy file we need because
X+ 				 * workbench won't duplicate an icon with no
X+ 				 * "real" data attached - try to get rid of it.
X+ 				 */
X+ 			UnLock(lock);
X+ 			unlink(SAVEF);
X+ 			FreeMem(fib,ALLOC_SIZE);
X+ 			return(-1);
X+ 		}
X+ 	}
X+ 	FreeMem(fib,ALLOC_SIZE);
X+ 	return(-1);		/* give up */
X+ }
X+ 
X+ #ifdef notdef
X+ /* cleanup */
X+ void ami_wbench_cleanup(){
X+ 	if(!FromWBench)return;
X+ 	if(KillIcon){
X+ 		unlink(iconname);
X+ 	} else {
X+ 		if(!FromTool){	/* game started and ended in one session */
X+ 			char buf[PATHLEN+5];
X+ 			strcpy(buf,SAVEF);
X+ 			strcat(buf,".info");
X+ 			unlink(buf);
X+ 		}
X+ 	}
X+ }
X+ #endif
X+ 
X+ /* get printable version of where we came from */
X+ static void ami_wb_findme(bufp,dirp,wa)
X+ 	char *bufp,*dirp;
X+ 	struct WBArg *wa;
X+ 	{
X+ 	BPTR dir;
X+ 	struct FileInfoBlock *fib;
X+ 	char *p;
X+ 	int len;
X+ 
X+ 	dir=wa->wa_Lock;
X+ 
X+ 	fib = (struct FileInfoBlock *)AllocMem(ALLOC_SIZE,MEMF_CLEAR);
X+ 	buildPath(dir,fib,dirp);
X+ 	strcat(dirp,"/");
X+ 	strcpy(bufp,dirp);
X+ 	if(FromTool){
X+ 		/* do nothing - filename will be added later */
X+ 	} else {
X+ 		strcat(bufp,wa->wa_Name);
X+ 	};
X+ 	/* I know this looks redundent, but its not since we may add
X+ 	 * a slash after returning from buildPath
X+ 	 */
X+ 	p=index(bufp,':');
X+ 	if(!p){
X+ 		p=index(bufp,'/');
X+ 		if(p)*p=':';
X+ 	}
X+ 	p=index(dirp,':');
X+ 	if(!p){
X+ 		p=index(dirp,'/');
X+ 		if(p)*p=':';
X+ 	}
X+ 	/* We found the icon - but we need the main file. */
X+ 	len=strlen(bufp);
X+ 	if(len<5)return;			/* who knows? */
X+ 	if(strcmp(".info",&bufp[len-5]))return; /* who knows? */
X+ 	bufp[len-5]='\0';
X+         FreeMem(fib, ALLOC_SIZE);
X+ }
X+ 
X+ /* Carolyn Scheppner - CATS, AmigaMail II-34 */
X+ static int
X+ buildPath(inlock,fib,buf)
X+ LONG inlock;
X+ struct FileInfoBlock *fib;       	/* ASSUMED LONGWORD BOUNDARY!! */
X+ char *buf;
X+ 	{
X+ 	int i;
X+ 	LONG lock,oldlock;
X+ 	BOOL MyOldLock = FALSE;
X+ 
X+ 	buf[0]='\0';
X+ 	lock=inlock;
X+ 
X+ 	while(lock){
X+ 		if(Examine(lock,fib)){
X+ 			if(fib->fib_FileName[0]>' '){
X+ 				if(buf[0])insert(buf,"/");
X+ 				insert(buf,fib->fib_FileName);
X+ 			}
X+ 		}
X+ 		oldlock=lock;
X+ 		lock=ParentDir(lock);
X+ 		if(MyOldLock) UnLock(oldlock);
X+ 		else MyOldLock=TRUE;
X+ 	}
X+ 	if(fib->fib_FileName[0]>' '){
X+ 		for(i=0;i<(strlen(buf));i++){
X+ 			if(buf[i]=='/'){
X+ 				buf[i]=':';
X+ 				break;
X+ 			}
X+ 		}
X+ 	}
X+ 	else insert(buf,"RAM:");
X+ 	return((int)strlen(buf));
X+ }
X+ static void
X+ insert(buf,s)
X+ char *buf,*s;
X+ {
X+ 	char tmp[256];
X+ 	strcpy(tmp,buf);
X+ 	strcpy(buf,s);
X+ 	strcpy(&buf[strlen(s)],tmp);
X+ }
X+ 
X+ #if 0 /* CopyFile should be OK */
X+ static void copyicon(from,to)
X+ char *from,*to;
X+ {
X+ 	int df,dt;
X+ 	char buf[512];
X+ 	int len=512;
X+ 
X+ 	df=open(from,O_RDONLY);
X+ 	dt=open(to,O_WRONLY,0);
X+ 	while(len=512){
X+ 		len=read(df,buf,len);
X+ 		write(dt,buf,len);
X+ 	}
X+ 	close(df);
X+ 	close(dt);
X+ }
X+ #endif
X+ #endif /* AMIGA_WBENCH */
X*** amiga/Old/amiwind.c	Mon Feb 19 16:52:53 1990
X--- amiga/amiwind.c	Thu Feb 15 19:05:25 1990
X***************
X*** 8,14 ****
X   *  screens, windows, menus, and input via IntuiMessages.
X   */
X  
X! #define MANX			/* Define for the Manx compiler */
X  
X  #include <exec/types.h>
X  #include <exec/alerts.h>
X--- 8,19 ----
X   *  screens, windows, menus, and input via IntuiMessages.
X   */
X  
X! #include "hack.h"
X! 
X! #undef TRUE
X! #undef FALSE
X! #undef COUNT
X! #undef NULL
X  
X  #include <exec/types.h>
X  #include <exec/alerts.h>
X***************
X*** 19,46 ****
X  #include <intuition/intuition.h>
X  #include <libraries/dosextens.h>
X  
X! #undef TRUE			/* All these are also defined in */
X! #undef FALSE			/* the Amiga system include files */
X! #undef COUNT
X! #undef NULL
X! 
X! #include "hack.h"
X! 
X! #include "amimenu.c"
X  
X  /*  First, external declarations... */
X  
X- struct Library *OpenLibrary();
X- struct Screen *OpenScreen();
X- struct Window *OpenWindow();
X- struct TextFont *OpenDiskFont(), *OpenFont();
X- struct IntuiMessage *GetMsg();
X- struct MenuItem *ItemAddress();
X- struct Process *FindTask();         /* Cheating */
X- long DeadKeyConvert(), OpenDevice(), CloseDevice();
X- struct MsgPort *CreatePort();
X  extern struct Library *IconBase;
X! void abort();
X  
X  /*  Now our own variables */
X  
X--- 24,88 ----
X  #include <intuition/intuition.h>
X  #include <libraries/dosextens.h>
X  
X! #ifdef LATTICE
X! #include <dos.h>
X! #include <proto/exec.h>
X! #include <proto/graphics.h>
X! #include <proto/intuition.h>
X! #include <proto/diskfont.h>
X! #include <proto/console.h>
X! #endif
X! 
X! #include "Amiga:amimenu.c"
X! 
X! /*
X!  * Versions we need of various libraries.  We can't use LIBRARY_VERSION
X!  * as defined in <exec/types.h> because some of the libraries we need
X!  * don't have that version number in the 1.2 ROM.
X!  */
X! 
X! #define INTUITION_VERSION 33L
X! #define GRAPHICS_VERSION  33L
X! #define DISKFONT_VERSION  34L
X! #define ICON_VERSION	  34L
X  
X  /*  First, external declarations... */
X  
X  extern struct Library *IconBase;
X! struct Library *ConsoleDevice;
X! 
X! #ifdef AZTEC_C
X! void FDECL(Alert, (long, char *));
X! void NDECL(Forbid);
X! void NDECL(Permit);
X! struct Process *FDECL(FindTask, (char *));
X! struct Library *FDECL(OpenLibrary, (char *, long));
X! void FDECL(CloseLibrary, (struct Library *));
X! struct Message *FDECL(GetMsg, (struct MsgPort *));
X! void FDECL(ReplyMsg, (struct Message *));
X! long FDECL(OpenDevice, (char *, long, struct IORequest *, long));
X! void FDECL(CloseDevice, (struct IORequest *));
X! long FDECL(DoIO, (struct IORequest *));
X! struct TextFont *FDECL(OpenDiskFont, (struct TextAttr *));
X! struct TextFont *FDECL(OpenFont, (struct TextAttr *));
X! void FDECL(CloseFont, (struct TextFont *));
X! void FDECL(LoadRGB4, (struct ViewPort *, unsigned short *, long));
X! long FDECL(SetFont, (struct RastPort *, struct TextFont*));
X! struct MsgPort *FDECL(CreatePort, (char *, long));
X! void FDECL(DeletePort, (struct MsgPort *));
X! struct Screen *FDECL(OpenScreen, (struct NewScreen *));
X! struct Window *FDECL(OpenWindow, (struct NewWindow *));
X! void FDECL(CloseWindow, (struct Window *));
X! void FDECL(SetMenuStrip, (struct Window *, struct Menu *));
X! void FDECL(ClearMenuStrip, (struct Window *));
X! struct MenuItem *FDECL(ItemAddress, (struct Menu *, long));
X! long FDECL(RawKeyConvert, (struct InputEvent *, char *, long, struct KeyMap *));
X! #endif
X! 
X! static int NDECL(BufferGetchar);
X! static void FDECL(ConvertKey, (register struct IntuiMessage *));
X! static void FDECL(ProcessMessage, (register struct IntuiMessage *));
X! void NDECL(Initialize);
X  
X  /*  Now our own variables */
X  
X***************
X*** 56,62 ****
X  struct Library *DiskfontBase;
X  #endif
X  
X! struct Device *ConsoleDevice;
X  
X  #define CSI	    '\x9b'
X  #define NO_CHAR     -1
X--- 98,104 ----
X  struct Library *DiskfontBase;
X  #endif
X  
X! extern struct Library *ConsoleDevice;
X  
X  #define CSI	    '\x9b'
X  #define NO_CHAR     -1
X***************
X*** 103,109 ****
X--- 145,166 ----
X  #define BARHEIGHT	11
X  #define WINDOWHEIGHT	192
X  #define WIDTH		640
X+ 
X+ #ifdef TEXTCOLOR
X+ #define DEPTH       3
X+ static unsigned short palette[] = {
X+ 	0x0000,	/* Black   */
X+ 	0x0DDD, /* White   */
X+     	0x0C75, /* Brown   */
X+ 	0x0B08,	/* Cyan    */
X+ 	0x00B0,	/* Green   */
X+ 	0x0F08,	/* Magenta */
X+ 	0x055F,	/* Blue    */
X+ 	0x0F00,	/* Red     */
X+ };
X+ #else
X  #define DEPTH		2
X+ #endif
X  
X  struct NewScreen NewHackScreen = {
X      0, 0, WIDTH, BARHEIGHT + WINDOWHEIGHT, DEPTH,
X***************
X*** 161,167 ****
X   *  RawKeyConvert those events???
X   */
X  
X! int ConvertKey(message)
X  register struct IntuiMessage *message;
X  {
X      static struct InputEvent theEvent;
X--- 218,224 ----
X   *  RawKeyConvert those events???
X   */
X  
X! static void ConvertKey(message)
X  register struct IntuiMessage *message;
X  {
X      static struct InputEvent theEvent;
X***************
X*** 210,216 ****
X  
X  #ifdef BETA
X      if (!ConsoleDevice) { /* Should never happen */
X! 	abort(AG_IOError | AO_ConsoleDev);
X  	return;
X      }
X  #endif
X--- 267,273 ----
X  
X  #ifdef BETA
X      if (!ConsoleDevice) { /* Should never happen */
X! 	Abort(AG_IOError | AO_ConsoleDev);
X  	return;
X      }
X  #endif
X***************
X*** 251,257 ****
X   *  ahead of input demands, when the user types ahead.
X   */
X  
X! static char ProcessMessage(message)
X  register struct IntuiMessage *message;
X  {
X      switch(message->Class) {
X--- 308,314 ----
X   *  ahead of input demands, when the user types ahead.
X   */
X  
X! static void ProcessMessage(message)
X  register struct IntuiMessage *message;
X  {
X      switch(message->Class) {
X***************
X*** 262,268 ****
X  
X  	    thismenu = message->Code;
X  	    while (thismenu != MENUNULL) {
X! 		item = ItemAddress(&HackMenu, (ULONG) thismenu);
X  		if (KbdBuffered < KBDBUFFER)
X  		    BufferQueueChar(item->Command); /* Unused: No COMMSEQ */
X  		thismenu = item->NextSelect;
X--- 319,325 ----
X  
X  	    thismenu = message->Code;
X  	    while (thismenu != MENUNULL) {
X! 		item = ItemAddress(HackMenu, (ULONG) thismenu);
X  		if (KbdBuffered < KBDBUFFER)
X  		    BufferQueueChar(item->Command); /* Unused: No COMMSEQ */
X  		thismenu = item->NextSelect;
X***************
X*** 283,289 ****
X  	}
X  #endif
X      }
X!     ReplyMsg(message);
X  }
X  
X  /*
X--- 340,346 ----
X  	}
X  #endif
X      }
X!     ReplyMsg((struct Message *) message);
X  }
X  
X  /*
X***************
X*** 299,308 ****
X      register struct IntuiMessage *message;
X  
X      while( (KbdBuffered < KBDBUFFER / 2) &&
X! 	    (message = GetMsg(HackWindow->UserPort)) )
X  	ProcessMessage(message);
X  
X!     return KbdBuffered;
X  }
X  
X  /*
X--- 356,365 ----
X      register struct IntuiMessage *message;
X  
X      while( (KbdBuffered < KBDBUFFER / 2) &&
X! 	    (message = (struct IntuiMessage *) GetMsg(HackWindow->UserPort)) )
X  	ProcessMessage(message);
X  
X!     return (int) KbdBuffered;
X  }
X  
X  /*
X***************
X*** 326,332 ****
X  {
X  #ifdef BETA
X      if (!ConsoleDevice) { /* Should never happen */
X! 	abort(AG_IOError | AO_ConsoleDev);
X  	return;
X      }
X  #endif
X--- 383,389 ----
X  {
X  #ifdef BETA
X      if (!ConsoleDevice) { /* Should never happen */
X! 	Abort(AG_IOError | AO_ConsoleDev);
X  	return;
X      }
X  #endif
X***************
X*** 335,341 ****
X  	ConsoleIO.io_Command = CMD_WRITE;
X  	ConsoleIO.io_Data = (APTR)ConsoleBuffer;
X  	ConsoleIO.io_Length = Buffered;
X! 	DoIO(&ConsoleIO);
X  	Buffered = 0;
X      }
X  }
X--- 392,398 ----
X  	ConsoleIO.io_Command = CMD_WRITE;
X  	ConsoleIO.io_Data = (APTR)ConsoleBuffer;
X  	ConsoleIO.io_Length = Buffered;
X! 	DoIO((struct IORequest *) &ConsoleIO);
X  	Buffered = 0;
X      }
X  }
X***************
X*** 362,373 ****
X  void WindowFPuts(string)
X  char *string;
X  {
X!     register int len = _BUILTIN_strlen(string);
X  
X      if (len + Buffered >= CONBUFFER)
X  	WindowFlush();
X  
X!     _BUILTIN_strcpy(ConsoleBuffer + Buffered, string);
X      Buffered += len;
X  }
X  
X--- 419,430 ----
X  void WindowFPuts(string)
X  char *string;
X  {
X!     register int len = strlen(string);
X  
X      if (len + Buffered >= CONBUFFER)
X  	WindowFlush();
X  
X!     strcpy(ConsoleBuffer + Buffered, string);
X      Buffered += len;
X  }
X  
X***************
X*** 389,413 ****
X   *  flushing the existing characters first, if necessary.
X   */
X  
X  void WindowPrintf(fmt, args, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
X  char *fmt;
X  long args, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9;
X  {
X! #ifdef MANX	    /* Efficient but not portable */
X      format(WindowPutchar, fmt, &args);
X  #else
X      WindowFlush();  /* Don't know if all will fit */
X- # ifdef __STDC__    /* Cheap and portable way */
X-     vsprintf(ConsoleBuffer, fmt, &args);
X- # else		    /* Expensive... */
X      sprintf(ConsoleBuffer, fmt, args, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
X- # endif
X      ConsoleIO.io_Command = CMD_WRITE;
X      ConsoleIO.io_Data = (APTR)ConsoleBuffer;
X      ConsoleIO.io_Length = -1;
X!     DoIO(&ConsoleIO);
X  #endif
X  }
X  
X  /*
X   *  Clean up everything. But before we do, ask the user to hit return
X--- 446,482 ----
X   *  flushing the existing characters first, if necessary.
X   */
X  
X+ /*VARARGS1*/
X+ #if defined(USE_STDARG) || defined(USE_VARARGS)
X+ void
X+ WindowPrintf VA_DECL(char *, fmt)
X+     VA_START(fmt);
X+     VA_INIT(fmt, char *);
X+     WindowFlush();  /* Don't know if all will fit */
X+     vsprintf(ConsoleBuffer, fmt, VA_ARGS);
X+     ConsoleIO.io_Command = CMD_WRITE;
X+     ConsoleIO.io_Data = (APTR)ConsoleBuffer;
X+     ConsoleIO.io_Length = -1;
X+     DoIO((struct IORequest *) &ConsoleIO);
X+     VA_END();
X+ }
X+ #else
X  void WindowPrintf(fmt, args, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
X  char *fmt;
X  long args, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9;
X  {
X! # ifdef AZTEC_C 	/* Efficient but not portable */
X      format(WindowPutchar, fmt, &args);
X  #else
X      WindowFlush();  /* Don't know if all will fit */
X      sprintf(ConsoleBuffer, fmt, args, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
X      ConsoleIO.io_Command = CMD_WRITE;
X      ConsoleIO.io_Data = (APTR)ConsoleBuffer;
X      ConsoleIO.io_Length = -1;
X!     DoIO((struct IORequest *) &ConsoleIO);
X  #endif
X  }
X+ #endif
X  
X  /*
X   *  Clean up everything. But before we do, ask the user to hit return
X***************
X*** 424,430 ****
X  	if (cu->cu_XCCP != 1 || cu->cu_YCCP != 1)
X  	    getret();
X  
X! 	CloseDevice(&ConsoleIO);
X  	ConsoleDevice = NULL;
X      }
X      if (ConsoleIO.io_Message.mn_ReplyPort)
X--- 493,499 ----
X  	if (cu->cu_XCCP != 1 || cu->cu_YCCP != 1)
X  	    getret();
X  
X! 	CloseDevice((struct IORequest *) &ConsoleIO);
X  	ConsoleDevice = NULL;
X      }
X      if (ConsoleIO.io_Message.mn_ReplyPort)
X***************
X*** 432,442 ****
X      if (HackWindow) {
X  	register struct IntuiMessage *msg;
X  
X! 	FindTask(NULL)->pr_WindowPtr = (APTR) pr_WindowPtr;
X  	ClearMenuStrip(HackWindow);
X  	Forbid();
X! 	while (msg = GetMsg(HackWindow->UserPort))
X! 	    ReplyMsg(msg);
X  	CloseWindow(HackWindow);
X  	Permit();
X  	HackWindow = NULL;
X--- 501,511 ----
X      if (HackWindow) {
X  	register struct IntuiMessage *msg;
X  
X! 	((struct Process *) FindTask(NULL))->pr_WindowPtr = (APTR) pr_WindowPtr;
X  	ClearMenuStrip(HackWindow);
X  	Forbid();
X! 	while (msg = (struct IntuiMessage *) GetMsg(HackWindow->UserPort))
X! 	    ReplyMsg((struct Message *) msg);
X  	CloseWindow(HackWindow);
X  	Permit();
X  	HackWindow = NULL;
X***************
X*** 445,454 ****
X  	CloseScreen(HackScreen);
X  	HackScreen = NULL;
X      }
X!     /* if (IconBase) {
X  	CloseLibrary(IconBase);
X  	IconBase = NULL;
X!     } */
X  #ifdef HACKFONT
X      if (HackFont) {
X  	CloseFont(HackFont);
X--- 514,523 ----
X  	CloseScreen(HackScreen);
X  	HackScreen = NULL;
X      }
X!     if (IconBase) {
X  	CloseLibrary(IconBase);
X  	IconBase = NULL;
X!     }
X  #ifdef HACKFONT
X      if (HackFont) {
X  	CloseFont(HackFont);
X***************
X*** 471,477 ****
X      Initialized = 0;
X  }
X  
X! void abort(rc)
X  long rc;
X  {
X  #ifdef CHDIR
X--- 540,546 ----
X      Initialized = 0;
X  }
X  
X! void Abort(rc)
X  long rc;
X  {
X  #ifdef CHDIR
X***************
X*** 483,498 ****
X  	getret();
X      } else
X  	Alert(rc, 0L);
X      CleanUp();
X  #undef exit
X!     exit(rc);
X! }
X! 
X! /*  Used by library routines, and the debugger */
X! 
X! void _abort()
X! {
X!     abort(-10L);
X  }
X  
X  /*
X--- 552,575 ----
X  	getret();
X      } else
X  	Alert(rc, 0L);
X+ #ifdef LATTICE
X+ 	{
X+ /*	__emit(0x4afc);		/* illegal instruction */
X+ 	__emit(0x40fc);		/* divide by */
X+ 	__emit(0x0000);		/*  #0	*/
X+ 		/* NOTE: don't move CleanUp() above here - */
X+ 		/* it is too likely to kill the system     */
X+ 		/* before it can get the SnapShot out, if  */
X+ 		/* there is something really wrong.	   */
X+ __builtin_printf("abort botch");				/* (KL)TEMP */
X+ 	}
X+ #endif
X      CleanUp();
X  #undef exit
X! #ifdef AZTEC_C
X!     _abort();
X! #endif
X!     exit((int) rc);
X  }
X  
X  /*
X***************
X*** 504,517 ****
X      if (Initialized)
X  	return;
X  
X!     if ( (IntuitionBase = OpenLibrary("intuition.library", LIBRARY_VERSION))
X  	  == NULL)
X! 	abort(AG_OpenLib | AO_Intuition);
X  
X  #ifdef HACKFONT
X  
X!     if ( (GfxBase = OpenLibrary("graphics.library", LIBRARY_VERSION)) == NULL)
X! 	abort(AG_OpenLib | AO_GraphicsLib);
X  
X      /*
X       *	Force our own font to be loaded, if possible.
X--- 581,594 ----
X      if (Initialized)
X  	return;
X  
X!     if ( (IntuitionBase = OpenLibrary("intuition.library", INTUITION_VERSION))
X  	  == NULL)
X! 	Abort(AG_OpenLib | AO_Intuition);
X  
X  #ifdef HACKFONT
X  
X!     if ( (GfxBase = OpenLibrary("graphics.library", GRAPHICS_VERSION)) == NULL)
X! 	Abort(AG_OpenLib | AO_GraphicsLib);
X  
X      /*
X       *	Force our own font to be loaded, if possible.
X***************
X*** 522,528 ****
X       */
X  
X      if ((HackFont = OpenFont(&Hack80)) == NULL) {
X! 	if (DiskfontBase = OpenLibrary("diskfont.library", LIBRARY_VERSION)) {
X  	    Hack80.ta_Name -= SIZEOF_DISKNAME;
X  	    HackFont = OpenDiskFont(&Hack80);
X  	    Hack80.ta_Name += SIZEOF_DISKNAME;
X--- 599,605 ----
X       */
X  
X      if ((HackFont = OpenFont(&Hack80)) == NULL) {
X! 	if (DiskfontBase = OpenLibrary("diskfont.library", DISKFONT_VERSION)) {
X  	    Hack80.ta_Name -= SIZEOF_DISKNAME;
X  	    HackFont = OpenDiskFont(&Hack80);
X  	    Hack80.ta_Name += SIZEOF_DISKNAME;
X***************
X*** 532,539 ****
X      }
X  #endif
X  
X!     /* if ( (IconBase = OpenLibrary("icon.library", LIBRARY_VERSION)) == NULL)
X! 	abort(AG_OpenLib | AO_IconLib); */
X  
X      /*
X       *	Now Intuition is supposed to use our HackFont for the screen,
X--- 609,616 ----
X      }
X  #endif
X  
X!     /* if ( (IconBase = OpenLibrary("icon.library", ICON_VERSION)) == NULL)
X! 	Abort(AG_OpenLib | AO_IconLib); */
X  
X      /*
X       *	Now Intuition is supposed to use our HackFont for the screen,
X***************
X*** 541,556 ****
X       *	So, we need to do a SetFont() a bit later on.
X       */
X      if ( (HackScreen = OpenScreen(&NewHackScreen)) == NULL)
X! 	abort(AN_OpenScreen & ~AT_DeadEnd);
X  
X      NewHackWindow.Screen = HackScreen;
X  
X      if ( (HackWindow = OpenWindow(&NewHackWindow)) == NULL)
X! 	abort(AN_OpenWindow & ~AT_DeadEnd);
X  
X!     SetMenuStrip(HackWindow, &HackMenu);
X      {
X! 	register struct Process *myProcess = FindTask(NULL);
X  	pr_WindowPtr = (struct Window *)myProcess->pr_WindowPtr;
X  	myProcess->pr_WindowPtr = (APTR) HackWindow;
X      }
X--- 618,637 ----
X       *	So, we need to do a SetFont() a bit later on.
X       */
X      if ( (HackScreen = OpenScreen(&NewHackScreen)) == NULL)
X! 	Abort(AN_OpenScreen & ~AT_DeadEnd);
X! 
X! #ifdef TEXTCOLOR
X!     LoadRGB4(&HackScreen->ViewPort, palette, 8L);
X! #endif
X  
X      NewHackWindow.Screen = HackScreen;
X  
X      if ( (HackWindow = OpenWindow(&NewHackWindow)) == NULL)
X! 	Abort(AN_OpenWindow & ~AT_DeadEnd);
X  
X!     SetMenuStrip(HackWindow, HackMenu);
X      {
X! 	register struct Process *myProcess = (struct Process *) FindTask(NULL);
X  	pr_WindowPtr = (struct Window *)myProcess->pr_WindowPtr;
X  	myProcess->pr_WindowPtr = (APTR) HackWindow;
X      }
X***************
X*** 562,571 ****
X      ConsoleIO.io_Data = (APTR) HackWindow;
X      ConsoleIO.io_Length = sizeof(*HackWindow);
X      ConsoleIO.io_Message.mn_ReplyPort = CreatePort(NULL, 0L);
X!     if (OpenDevice("console.device", 0L, &ConsoleIO, 0L) != 0)
X! 	abort(AG_OpenDev | AO_ConsoleDev);
X  
X!     ConsoleDevice = ConsoleIO.io_Device;
X  
X      Buffered = 0;
X      KbdBuffered = 0;
X--- 643,652 ----
X      ConsoleIO.io_Data = (APTR) HackWindow;
X      ConsoleIO.io_Length = sizeof(*HackWindow);
X      ConsoleIO.io_Message.mn_ReplyPort = CreatePort(NULL, 0L);
X!     if (OpenDevice("console.device", 0L, (struct IORequest *) &ConsoleIO, 0L) != 0)
X! 	Abort(AG_OpenDev | AO_ConsoleDev);
X  
X!     ConsoleDevice = (struct Library *) ConsoleIO.io_Device;
X  
X      Buffered = 0;
X      KbdBuffered = 0;
X
END_OF_FILE
if test 53324 -ne `wc -c <'patch7.13'`; then
    echo shar: \"'patch7.13'\" unpacked with wrong size!
fi
# end of 'patch7.13'
echo shar: End of archive 19 \(of 30\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
