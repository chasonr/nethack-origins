Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!brutus.cs.uiuc.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i015:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7o
Message-ID: <5229@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:58:25 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2418
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 15
Archive-name: NetHack3/Patch7o
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 30)."
# Contents:  others/atari.cnf patch7.01
# Wrapped by billr@saab on Wed Feb 21 10:04:36 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'others/atari.cnf' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'others/atari.cnf'\" to \"'others/atari.cnf.orig'\"
  mv -f 'others/atari.cnf' 'others/atari.cnf.orig'
fi
echo shar: Extracting \"'others/atari.cnf'\" \(2801 characters\)
sed "s/^X//" >'others/atari.cnf' <<'END_OF_FILE'
X# A '#' at the beginning of a line means the rest of the line is a comment.
X#
X# This configuration file is set up for two cases, for a hard disk
X# (as drive C:), and for one (double sided) floppy disk.
X#
X# To change the configuration, comment out the unwanted lines, and
X# uncomment the configuration you want.
X
X
X# *** OPTIONS ***
X#
X# If you want people to play NetHack over the modem, you should probably
X# uncomment the following line:
X#
X#OPTIONS=!IBM_BIOS,number_pad,nocolor
X#
X# Some options to set personal preferences.  Uncomment and change these to
X# suit your personal preference.  If several people are to use the same
X# configuration, options like these should not be set.
X#
X#OPTIONS=name:Janet-V,female,dogname:Fido,catname:Morris,fruit:apricot
X#OPTIONS=packorder:")[%?+/=!(*0_`,endgame:10 top/2 around/own
X#
X#
X# Other general options.  You might also set "silent" so as not to attract
X# the boss's attention.
X#
XOPTIONS=time,rest_on_space,nopickup
X
X# Color: if you have a color monitor and *don't* want colors, 
X# comment out the following line. (Mono users don't get color no matter what.)
X#
X#OPTIONS=nocolor
X
X# *** HARD DISK CONFIGURATION ***
X#
X#HACKDIR=c:\games\nethack
X#
X#   LEVELS and SAVE default to HACKDIR
X#
X#LEVELS=c:\games\nethack
X#   appending a ";n" to SAVE means don't prompt to insert a disk.
X#SAVE=c:\games\nethack;n
X#
X# Using a ramdisk speeds things up; a 150K ramdisk is OK even on a 1 megabyte
X# system.
X#RAMDISK=m:
X
X
X# *** 1-FLOPPY CONFIGURATION ***
X#
XHACKDIR=a:
XLEVELS=a:
XSAVE=a:
X#RAMDISK=m:
X
X
X# *** CHARACTER GRAPHICS ***
X#
X# The 35 GRAPHICS characters (0-34) are:
X# stone, vertical wall, horizontal wall, top left corner, top right corner, 
X# bottom left corner, bottom right corner, crosswall, up T wall, down T wall, 
X# left T wall, right T wall, vertical beam, horizontal beam, left slant, right
X# slant, no door, vertical open door, horizontal open door, floor, corridor,
X# up stairs, down stairs, trap, web, pool, fountain, sink, throne, altar,
X# up ladder, down ladder, vertical drawbridge wall, horizontal drawbridge wall 
X#
X# If you specify less than 35 ASCII values, the remaining characters will be
X# set to their respective defaults.
X#
X#
X# To use the Atari's (not very good) graphics character set, uncomment the
X# next GRAPHICS= line:
X#	   ' '  |   -   .   .   `   '   -   -   -   -   -   |   -   \   /   .   -   |   +   .   #   <   >   ^   "   }   {   #   \   _   <   >   #   #
X#GRAPHICS=042 124 045 169 170 045 045 043 045 045 045 045 124 045 092 047 249 251 251 252 250 240 174 175 222 223 247 221 189 196 227 243 242 178 179
X#
X# To use the font constructed by hackfnt.prg, uncomment the following line:
X#GRAPHICS=032 217 218 194 195 192 193 216 197 196 199 198 217 218 092 047 202 201 201 200 202 203 210 211 207 206 214 204 205 208 209 212 213 215 215
END_OF_FILE
if test 2801 -ne `wc -c <'others/atari.cnf'`; then
    echo shar: \"'others/atari.cnf'\" unpacked with wrong size!
fi
# end of 'others/atari.cnf'
if test -f 'patch7.01' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.01'\" to \"'patch7.01.orig'\"
  mv -f 'patch7.01' 'patch7.01.orig'
fi
echo shar: Extracting \"'patch7.01'\" \(53710 characters\)
sed "s/^X//" >'patch7.01' <<'END_OF_FILE'
X*** src/Old/Makefile.src	Mon Feb 19 17:52:09 1990
X--- src/Makefile.src	Sun Feb  4 15:19:25 1990
X***************
X*** 102,109 ****
X  	   gold.h hack.h lev.h macconf.h mfndpos.h mkroom.h monattk.h mondata.h\
X  	   monflag.h monst.h monsym.h msdos.h obj.h objclass.h patchlevel.h\
X  	   pcconf.h permonst.h prop.h rm.h sp_lev.h spell.h system.h termcap.h\
X! 	   tosconf.h tradstdc.h trapname.h unixconf.h vault.h vmsconf.h wseg.h\
X! 	   you.h youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X--- 102,109 ----
X  	   gold.h hack.h lev.h macconf.h mfndpos.h mkroom.h monattk.h mondata.h\
X  	   monflag.h monst.h monsym.h msdos.h obj.h objclass.h patchlevel.h\
X  	   pcconf.h permonst.h prop.h rm.h sp_lev.h spell.h system.h termcap.h\
X! 	   tosconf.h tradstdc.h unixconf.h vault.h vmsconf.h wseg.h you.h\
X! 	   youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X***************
X*** 409,415 ****
X  topl.o:  ../include/hack.h
X  topten.o:  ../include/hack.h
X  track.o:  ../include/hack.h
X! trap.o:  ../include/hack.h ../include/edog.h ../include/trapname.h
X  u_init.o:  ../include/hack.h
X  uhitm.o:  ../include/hack.h ../include/artifact.h
X  vault.o:  ../include/hack.h ../include/vault.h
X--- 409,415 ----
X  topl.o:  ../include/hack.h
X  topten.o:  ../include/hack.h
X  track.o:  ../include/hack.h
X! trap.o:  ../include/hack.h ../include/edog.h
X  u_init.o:  ../include/hack.h
X  uhitm.o:  ../include/hack.h ../include/artifact.h
X  vault.o:  ../include/hack.h ../include/vault.h
X*** src/Old/allmain.c	Mon Feb 19 17:52:35 1990
X--- src/allmain.c	Thu Feb  8 17:49:16 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)allmain.c	3.0	89/09/26
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)allmain.c	3.0	89/12/22
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 10,17 ****
X  #include <signal.h>
X  #endif
X  
X! int (*afternmv)();
X! int (*occupation)();
X  
X  void
X  moveloop()
X--- 10,21 ----
X  #include <signal.h>
X  #endif
X  
X! #ifdef OVLB
X! int NDECL((*afternmv));
X! int NDECL((*occupation));
X! #endif
X! 
X! #ifdef OVL0
X  
X  void
X  moveloop()
X***************
X*** 18,45 ****
X  {
X  #ifdef MSDOS
X  	char ch;
X! 	int abort;
X  #endif
X  
X  	for(;;) {
X  #ifdef MACOS
X! 	if (!(moves % 20)) {
X! 		UnloadSeg(doapply);
X! 		UnloadSeg(initedog);
X  		UnloadSeg(doeat);
X! 		UnloadSeg(doengrave);
X! 		UnloadSeg(doopen);
X! 		UnloadSeg(mattacku);
X! 		UnloadSeg(mklev);
X! 		UnloadSeg(attacktype);
X! 		UnloadSeg(dohelp);
X! 		UnloadSeg(dopray);
X! 		UnloadSeg(dorecover);
X! 		UnloadSeg(timeout);
X! 		UnloadSeg(setworn);
X  		UnloadSeg(initterm);
X! 		UnloadSeg(done);
X  		UnloadSeg(savebones);
X  	}
X  #endif
X  #ifdef CLIPPING
X--- 22,78 ----
X  {
X  #ifdef MSDOS
X  	char ch;
X! 	int abort_lev;
X  #endif
X  
X  	for(;;) {
X  #ifdef MACOS
X! 	static	int old_dlevel = 0;
X! 	extern	xchar dlevel; 
X! 	extern	Boolean	lowMem;
X! 	extern	long	lowMemLimit;
X! 	if (!(moves % 20) || lowMem || FreeMem() < lowMemLimit || old_dlevel != dlevel) {
X! 		old_dlevel = dlevel;
X! 		UnloadSeg(ddocall);
X! 		UnloadSeg(castmu);
X! 		UnloadSeg(doforce);
X  		UnloadSeg(doeat);
X! 		UnloadSeg(dozap);
X  		UnloadSeg(initterm);
X! 		UnloadSeg(doapply);
X! 		UnloadSeg(dokick);
X! 		UnloadSeg(outrumor);
X! 		UnloadSeg(steal);
X! 		UnloadSeg(done1);
X! 		UnloadSeg(dodrink);
X! 		UnloadSeg(doturn);
X! #ifdef REINCARNATION
X! 		UnloadSeg(makeroguerooms);
X! #endif
X! #ifdef STRONGHOLD
X! 		UnloadSeg(load_special);
X! #endif
X! 		UnloadSeg(mklev);
X! #ifdef MUSIC
X! 		UnloadSeg(do_play_instrument);
X! #endif
X! #ifdef SPELLS
X! 		UnloadSeg(docast);
X! #endif
X  		UnloadSeg(savebones);
X+ 		UnloadSeg(expels);
X+ 		UnloadSeg(attack);
X+ 		UnloadSeg(doname);
X+ 		if (FreeMem() < 36864)
X+ 		{
X+ 			long	space;
X+ 			
X+ 			UnloadSeg(newhp);
X+ 			UnloadSeg(attack);
X+ 
X+ 			space = 0x7FFFFFFFL;
X+ 			MaxMem(&space);
X+ 		}
X  	}
X  #endif
X  #ifdef CLIPPING
X***************
X*** 163,185 ****
X  
X  		if(multi >= 0 && occupation) {
X  #ifdef MSDOS
X! 			abort = 0;
X  			if (kbhit()) {
X  				if ((ch = Getchar()) == ABORT)
X! 					abort++;
X  # ifdef REDO
X  				else
X  					pushch(ch);
X  # endif /* REDO */
X  			}
X! 			if(abort || monster_nearby()) {
X  #else
X  			if(monster_nearby()) {
X  #endif
X  				stop_occupation();
X  				reset_eat();
X! 			} else if ((*occupation)() == 0)
X! 				occupation = 0;
X  #ifdef MSDOS
X  			if (!(++occtime % 7))
X  				(void) fflush(stdout);
X--- 196,223 ----
X  
X  		if(multi >= 0 && occupation) {
X  #ifdef MSDOS
X! 			abort_lev = 0;
X  			if (kbhit()) {
X  				if ((ch = Getchar()) == ABORT)
X! 					abort_lev++;
X  # ifdef REDO
X  				else
X  					pushch(ch);
X  # endif /* REDO */
X  			}
X! 			if (!abort_lev && (*occupation)() == 0)
X! #else
X! 			if ((*occupation)() == 0)
X! #endif
X! 				occupation = 0;
X! #ifdef MSDOS
X! 			if(abort_lev || monster_nearby()) {
X  #else
X  			if(monster_nearby()) {
X  #endif
X  				stop_occupation();
X  				reset_eat();
X! 			}
X  #ifdef MSDOS
X  			if (!(++occtime % 7))
X  				(void) fflush(stdout);
X***************
X*** 219,224 ****
X--- 257,265 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  void
X  stop_occupation()
X  {
X***************
X*** 225,230 ****
X--- 266,272 ----
X  	if(occupation) {
X  		You("stop %s.", occtxt);
X  		occupation = 0;
X+ 		sync_hunger();
X  #ifdef REDO
X  		multi = 0;
X  		pushch(0);
X***************
X*** 232,237 ****
X--- 274,282 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  newgame() {
X  #ifdef DGK
X***************
X*** 278,280 ****
X--- 323,327 ----
X  
X  	return;
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/alloc.c	Mon Feb 19 17:52:52 1990
X--- src/alloc.c	Tue Jan 16 18:11:28 1990
X***************
X*** 7,12 ****
X--- 7,13 ----
X   */
X  #define EXTERN_H
X  #include "config.h"
X+ long *FDECL(alloc,(unsigned int));
X  
X  #ifdef LINT
X  /*
X***************
X*** 23,29 ****
X  
X  #else
X  #ifndef __TURBOC__
X! extern void VDECL(panic, (char *,...));
X  
X  long *
X  alloc(lth)
X--- 24,30 ----
X  
X  #else
X  #ifndef __TURBOC__
X! extern void VDECL(panic, (const char *,...));
X  
X  long *
X  alloc(lth)
X*** src/Old/apply.c	Mon Feb 19 17:53:07 1990
X--- src/apply.c	Mon Feb  5 18:08:55 1990
X***************
X*** 2,9 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include	"hack.h"
X  #include	"edog.h"
X  
X--- 2,9 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include	"hack.h"
X  #include	"edog.h"
X  
X***************
X*** 11,20 ****
X--- 11,40 ----
X  #define IS_INSTRUMENT(typ)	((typ) >= FLUTE && (typ) <= DRUM_OF_EARTHQUAKE)
X  #endif /* MUSIC /**/
X  
X+ #ifdef OVLB
X+ 
X  static const char tools[] = { TOOL_SYM, 0 };
X  
X  static boolean did_dig_msg;
X  
X+ static struct monst *FDECL(bchit, (int, int, int, CHAR_P));
X+ static void FDECL(use_camera, (struct obj *));
X+ static void FDECL(use_stethoscope, (struct obj *));
X+ static void FDECL(use_whistle, (struct obj *));
X+ static void FDECL(use_magic_whistle, (struct obj *));
X+ #ifdef WALKIES
X+ static void FDECL(use_leash, (struct obj *));
X+ #endif
X+ OSTATIC int NDECL(dig);
X+ static boolean FDECL(wield_tool, (struct obj *));
X+ static int FDECL(use_pick_axe, (struct obj *));
X+ #ifdef MEDUSA
X+ static void FDECL(use_mirror, (struct obj *));
X+ #endif
X+ static void FDECL(use_lamp, (struct obj *));
X+ static void FDECL(use_crystal_ball, (struct obj *));
X+ static void FDECL(use_tinning_kit, (struct obj *));
X+ 
X  /* version of bhit for cameras and mirrors */
X  static
X  struct monst *
X***************
X*** 35,44 ****
X  			mtmp = m_at(bchx,bchy);
X  			break;
X  		}
X! 		if(!ZAP_POS(levl[bchx][bchy].typ) ||
X! 		    (IS_DOOR(levl[bchx][bchy].typ) &&
X! 			    (levl[bchx][bchy].doormask & (D_CLOSED | D_LOCKED)))
X! 		  ) {
X  			bchx -= ddx;
X  			bchy -= ddy;
X  			break;
X--- 55,61 ----
X  			mtmp = m_at(bchx,bchy);
X  			break;
X  		}
X! 		if(!ZAP_POS(levl[bchx][bchy].typ) || closed_door(bchx, bchy)) {
X  			bchx -= ddx;
X  			bchy -= ddy;
X  			break;
X***************
X*** 57,63 ****
X  		return;
X  	}
X  	if(u.uswallow) {
X! 		You("take a picture of %s's stomach.", mon_nam(u.ustuck));
X  		return;
X  	}
X  	if(obj->cursed && !rn2(2)) goto blindu;
X--- 74,81 ----
X  		return;
X  	}
X  	if(u.uswallow) {
X! 		You("take a picture of %s's %s.", mon_nam(u.ustuck),
X! 		    is_animal(u.ustuck->data)? "stomach" : "interior");
X  		return;
X  	}
X  	if(obj->cursed && !rn2(2)) goto blindu;
X***************
X*** 216,224 ****
X--- 234,246 ----
X  	return(abs(u.ux - x) > n  || abs(u.uy - y) > n);
X  }
X  
X+ #endif /* OVLB */
X+ 
X  #ifdef WALKIES
X  #define MAXLEASHED	2
X  
X+ #ifdef OVLB
X+ 
X  int
X  number_leashed()
X  {
X***************
X*** 369,375 ****
X  	}
X  	return((struct obj *)0);
X  }
X! 
X  void
X  check_leash(x, y)
X  register xchar x, y;
X--- 391,400 ----
X  	}
X  	return((struct obj *)0);
X  }
X! #endif /* WALKIES */
X! #endif /* OVLB */
X! #ifdef OVL0
X! #ifdef WALKIES
X  void
X  check_leash(x, y)
X  register xchar x, y;
X***************
X*** 415,425 ****
X  		}
X  	    }
X  }
X  #endif /* WALKIES */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  dig() {
X  	register struct rm *lev;
X--- 440,452 ----
X  		}
X  	    }
X  }
X+ 
X  #endif /* WALKIES */
X  
X! #endif /* OVL0 */
X! #ifdef OVLB
X! 
X! XSTATIC
X  int
X  dig() {
X  	register struct rm *lev;
X***************
X*** 484,490 ****
X  		}
X  	} else
X  	if(dig_effort > 100) {
X! 		register char *digtxt;
X  		register struct obj *obj;
X  
X  		if(obj = sobj_at(STATUE, dpx, dpy)) {
X--- 511,517 ----
X  		}
X  	} else
X  	if(dig_effort > 100) {
X! 		register const char *digtxt;
X  		register struct obj *obj;
X  
X  		if(obj = sobj_at(STATUE, dpx, dpy)) {
X***************
X*** 516,523 ****
X  			digtxt = "You just broke through a secret door.";
X  			if(!(lev->doormask & D_TRAPPED))
X  				lev->doormask = D_BROKEN;
X! 		} else if (IS_DOOR(lev->typ) &&
X! 			   (lev->doormask & (D_CLOSED | D_LOCKED))) {
X  			digtxt = "You just broke a hole through the door.";
X  			if(!(lev->doormask & D_TRAPPED))
X  				lev->doormask = D_BROKEN;
X--- 543,549 ----
X  			digtxt = "You just broke through a secret door.";
X  			if(!(lev->doormask & D_TRAPPED))
X  				lev->doormask = D_BROKEN;
X! 		} else if(closed_door(dpx, dpy)) {
X  			digtxt = "You just broke a hole through the door.";
X  			if(!(lev->doormask & D_TRAPPED))
X  				lev->doormask = D_BROKEN;
X***************
X*** 534,541 ****
X  		dig_level = -1;
X  		return(0);
X  	} else {
X! 		if(IS_WALL(lev->typ) ||
X! 		 (IS_DOOR(lev->typ) && lev->doormask & (D_CLOSED | D_LOCKED))) {
X  		    register int rno = inroom(dpx,dpy);
X  
X  		    if(rno >= 0 && rooms[rno].rtype >= SHOPBASE) {
X--- 560,566 ----
X  		dig_level = -1;
X  		return(0);
X  	} else {
X! 		if(IS_WALL(lev->typ) || closed_door(dpx, dpy)) {
X  		    register int rno = inroom(dpx,dpy);
X  
X  		    if(rno >= 0 && rooms[rno].rtype >= SHOPBASE) {
X***************
X*** 676,687 ****
X  	if(u.uswallow && attack(u.ustuck)) /* return(1) */;
X  	else if(u.dz < 0) You("cannot reach the ceiling.");
X  	else if(!u.dx && !u.dy && !u.dz) {
X  		int dam;
X  
X! 		dam = rnd(2) + dbon();
X  		if (dam <= 0) dam = 1;
X  		You("hit yourself with your own pick-axe.");
X! 		losehp(dam, "self-inflicted wound");
X  		flags.botl=1;
X  		return(1);
X  	} else if(u.dz == 0) {
X--- 701,716 ----
X  	if(u.uswallow && attack(u.ustuck)) /* return(1) */;
X  	else if(u.dz < 0) You("cannot reach the ceiling.");
X  	else if(!u.dx && !u.dy && !u.dz) {
X+ 		char buf[BUFSZ];
X  		int dam;
X  
X! 		dam = rnd(2) + dbon() + obj->spe;
X  		if (dam <= 0) dam = 1;
X  		You("hit yourself with your own pick-axe.");
X! 		/* self_pronoun() won't work twice in a sentence */
X! 		Strcpy(buf, self_pronoun("killed %sself with %%s own pick-axe",
X! 			"him"));
X! 		losehp(dam, self_pronoun(buf, "his"), NO_KILLER_PREFIX);
X  		flags.botl=1;
X  		return(1);
X  	} else if(u.dz == 0) {
X***************
X*** 695,705 ****
X  			pline("Clash!");
X  			return(1);
X  		}
X! 		isclosedoor = (IS_DOOR(lev->typ) &&
X! 			       (lev->doormask & (D_CLOSED | D_LOCKED)));
X  		if(!IS_ROCK(lev->typ)
X! 		     && (!IS_DOOR(lev->typ) || (lev->doormask==D_NODOOR
X! 			|| lev->doormask & (D_ISOPEN | D_BROKEN)))
X  		     && !sobj_at(STATUE, rx, ry)
X  		     && !sobj_at(BOULDER, rx, ry)) {
X  			/* ACCESSIBLE or POOL */
X--- 724,732 ----
X  			pline("Clash!");
X  			return(1);
X  		}
X! 		isclosedoor = closed_door(rx, ry);
X  		if(!IS_ROCK(lev->typ)
X! 		     && !isclosedoor
X  		     && !sobj_at(STATUE, rx, ry)
X  		     && !sobj_at(BOULDER, rx, ry)) {
X  			/* ACCESSIBLE or POOL */
X***************
X*** 806,812 ****
X  				(poly_gender()==1 ? "beautiful" : "handsome") :
X  				"ugly");
X  		} else {
X! 		if (rn2(4-u.uluck/3) || !HTelepat ||
X  		    (u.ukilled_medusa
X  #ifdef HARD
X  			&& u.udemigod
X--- 833,839 ----
X  				(poly_gender()==1 ? "beautiful" : "handsome") :
X  				"ugly");
X  		} else {
X! 		if (Luck <= 10 && rn2(4-Luck/3) || !HTelepat ||
X  		    (u.ukilled_medusa
X  #ifdef HARD
X  			&& u.udemigod
X***************
X*** 819,825 ****
X  				body_part(FACE));
X  		} else {
X  			static char buf[35];
X! 			char *tm, *tl; int ll;
X  			if (!u.ukilled_medusa && rn2(4)) {
X  			    tm = "n ugly snake-headed monster";
X  			    ll = dlevel - medusa_level;
X--- 846,852 ----
X  				body_part(FACE));
X  		} else {
X  			static char buf[35];
X! 			const char *tm, *tl; int ll;
X  			if (!u.ukilled_medusa && rn2(4)) {
X  			    tm = "n ugly snake-headed monster";
X  			    ll = dlevel - medusa_level;
X***************
X*** 847,853 ****
X  		return;
X  	}
X  	if(u.uswallow) {
X! 		You("reflect %s's stomach.", mon_nam(u.ustuck));
X  		return;
X  	}
X  	if(u.dz) {
X--- 874,881 ----
X  		return;
X  	}
X  	if(u.uswallow) {
X! 		You("reflect %s's %s.", mon_nam(u.ustuck), 
X! 		    is_animal(u.ustuck->data)? "stomach" : "interior");
X  		return;
X  	}
X  	if(u.dz) {
X***************
X*** 879,890 ****
X  		killed(mtmp);
X  	} else if(!mtmp->mcan && !mtmp->minvis &&
X  					mtmp->data == &mons[PM_FLOATING_EYE]) {
X  	/* Note: floating eyes cannot use their abilities while invisible,
X  	 * but medusas and umber hulks can.
X  	 */
X  		if (!Blind)
X  			pline("%s is frozen by its reflection.",Monnam(mtmp));
X! 		mtmp->mfroz = 1;
X  	} else if(!mtmp->mcan && mtmp->data == &mons[PM_UMBER_HULK]) {
X  		if (!Blind)
X  			pline ("%s has confused itself!", Monnam(mtmp));
X--- 907,923 ----
X  		killed(mtmp);
X  	} else if(!mtmp->mcan && !mtmp->minvis &&
X  					mtmp->data == &mons[PM_FLOATING_EYE]) {
X+ 		int tmp = d((int)mtmp->m_lev, (int)mtmp->data->mattk[0].damd);
X+ 		if (!rn2(4)) tmp = 120;
X  	/* Note: floating eyes cannot use their abilities while invisible,
X  	 * but medusas and umber hulks can.
X  	 */
X  		if (!Blind)
X  			pline("%s is frozen by its reflection.",Monnam(mtmp));
X! 		mtmp->mcanmove = 0;
X! 		if (mtmp->mfrozen + tmp > 127)
X! 			mtmp->mfrozen = 127;
X! 		else mtmp->mfrozen += tmp;
X  	} else if(!mtmp->mcan && mtmp->data == &mons[PM_UMBER_HULK]) {
X  		if (!Blind)
X  			pline ("%s has confused itself!", Monnam(mtmp));
X***************
X*** 898,903 ****
X--- 931,937 ----
X  	    	    pline ("%s looks beautiful in your mirror.",Monnam(mtmp));
X  	    	    pline ("She decides to take it!");
X  		} else pline ("It steals your mirror!");
X+ 		setnotworn(obj); /* in case mirror was wielded */
X  	    	freeinv(obj);
X  	    	mpickobj(mtmp,obj);
X  	    	rloc(mtmp);
X***************
X*** 967,973 ****
X  			break;
X  		case 5 : pline("The crystal ball explodes!");
X  			useup(obj);
X! 			losehp(rnd(30), "exploding crystal ball");
X  			break;
X  		}
X  		obj->spe -= 1;
X--- 1001,1008 ----
X  			break;
X  		case 5 : pline("The crystal ball explodes!");
X  			useup(obj);
X! 			losehp(rnd(30), "exploding crystal ball",
X! 				KILLED_BY_AN);
X  			break;
X  		}
X  		obj->spe -= 1;
X***************
X*** 1119,1125 ****
X  	 */
X  	if (!(corpse = floorfood("can", 1))) return;
X  	if (corpse->oeaten) {
X! 		pline("You cannot tin something which is partly eaten.");
X  		return;
X  	}
X  	if ((corpse->corpsenm == PM_COCKATRICE)
X--- 1154,1160 ----
X  	 */
X  	if (!(corpse = floorfood("can", 1))) return;
X  	if (corpse->oeaten) {
X! 		You("cannot tin something which is partly eaten.");
X  		return;
X  	}
X  	if ((corpse->corpsenm == PM_COCKATRICE)
X***************
X*** 1129,1137 ****
X  		&& !uarmg) {
X  pline("Tinning a cockatrice corpse without gloves was not a very wise move...");
X  		You("turn to stone...");
X! 		killer = "unwise tinning decision";
X  		done(STONING);
X  	}
X  	can = mksobj(TIN,FALSE);
X  	can->corpsenm = corpse->corpsenm;
X  	can->quan = 1; /* Defeat the occasional creation of pairs of tins */
X--- 1164,1177 ----
X  		&& !uarmg) {
X  pline("Tinning a cockatrice corpse without gloves was not a very wise move...");
X  		You("turn to stone...");
X! 		killer_format = KILLED_BY;
X! 		killer = "trying to tin a cockatrice without gloves";
X  		done(STONING);
X  	}
X+ 	if (mons[corpse->corpsenm].cnutrit == 0) {
X+ 		You("can't tin something that insubstantial!");
X+ 		return;
X+ 	}
X  	can = mksobj(TIN,FALSE);
X  	can->corpsenm = corpse->corpsenm;
X  	can->quan = 1; /* Defeat the occasional creation of pairs of tins */
X***************
X*** 1150,1165 ****
X  use_unicorn_horn(obj)
X  struct obj *obj;
X  {
X- 	boolean cursed = (obj && obj->cursed);
X  	boolean blessed = (obj && obj->blessed);
X  	boolean did_something = FALSE;
X  
X! 	if (cursed) {
X  		switch (rn2(6)) {
X  		    static char buf[BUFSZ];
X  		    case 0: make_sick(Sick ? 1L : (long)(20 + rn2(20)), TRUE);
X  			    Strcpy(buf, xname(obj));
X! 			    u.usick_cause = buf;
X  			    break;
X  		    case 1: make_blinded(Blinded + (long) rnd(100), TRUE);
X  			    break;
X--- 1190,1204 ----
X  use_unicorn_horn(obj)
X  struct obj *obj;
X  {
X  	boolean blessed = (obj && obj->blessed);
X  	boolean did_something = FALSE;
X  
X! 	if (obj && obj->cursed) {
X  		switch (rn2(6)) {
X  		    static char buf[BUFSZ];
X  		    case 0: make_sick(Sick ? 1L : (long)(20 + rn2(20)), TRUE);
X  			    Strcpy(buf, xname(obj));
X! 			    u.usick_cause = (const char *)buf;
X  			    break;
X  		    case 1: make_blinded(Blinded + (long) rnd(100), TRUE);
X  			    break;
X***************
X*** 1191,1196 ****
X--- 1230,1239 ----
X  		make_hallucinated(0L, TRUE);
X  		did_something++;
X  	}
X+ 	if (Vomiting && (!did_something || blessed)) {
X+ 		make_vomiting(0L, TRUE);
X+ 		did_something++;
X+ 	}
X  	if (HConfusion && (!did_something || blessed)) {
X  		make_confused(0L, TRUE);
X  		did_something++;
X***************
X*** 1303,1309 ****
X  			You("have no tin to open.");
X  			goto xit;
X  		}
X! 		You("cannot open a tin without eating its contents.");
X  		if(flags.verbose)
X  			pline("In order to eat, use the 'e' command.");
X  		if(obj != uwep)
X--- 1346,1352 ----
X  			You("have no tin to open.");
X  			goto xit;
X  		}
X! 		You("cannot open a tin without eating or discarding its contents.");
X  		if(flags.verbose)
X  			pline("In order to eat, use the 'e' command.");
X  		if(obj != uwep)
X***************
X*** 1339,1341 ****
X--- 1382,1386 ----
X  	nomul(0);
X  	return res;
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/artifact.c	Mon Feb 19 17:53:57 1990
X--- src/artifact.c	Mon Feb  5 18:08:58 1990
X***************
X*** 8,15 ****
X  
X  #include "artifact.h"
X  
X  /* the artifacts (currently weapons only) */
X! static const struct artifact artilist[] = {
X  
X  #define	    NO_ATTK	{ 0, 0, 0, 0 }
X  
X--- 8,21 ----
X  
X  #include "artifact.h"
X  
X+ #ifndef OVLB
X+ 
X+ OSTATIC const struct artifact artilist[];
X+ 
X+ #else /* OVLB */
X+ 
X  /* the artifacts (currently weapons only) */
X! XSTATIC const struct artifact artilist[] = {
X  
X  #define	    NO_ATTK	{ 0, 0, 0, 0 }
X  
X***************
X*** 64,70 ****
X  								SPFX_DRLI), 0,
X    { 0, AD_DRLI, 5, 2 }, { 0, AD_DRLI, 0, 0 }, A_CHAOS, 0 },
X  
X! { LONG_SWORD,	 "Sunsword",	(SPFX_RESTR | SPFX_DFLAG1), M1_UNDEAD,
X    { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  { BROADSWORD,	 "Dragonbane",	(SPFX_RESTR | SPFX_DCLAS), S_DRAGON,
X--- 70,76 ----
X  								SPFX_DRLI), 0,
X    { 0, AD_DRLI, 5, 2 }, { 0, AD_DRLI, 0, 0 }, A_CHAOS, 0 },
X  
X! { LONG_SWORD,	 "Sunsword",	(SPFX_RESTR | SPFX_DFLAG2), M2_UNDEAD,
X    { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  { BROADSWORD,	 "Dragonbane",	(SPFX_RESTR | SPFX_DCLAS), S_DRAGON,
X***************
X*** 74,80 ****
X    { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  /* A silver weapon would be appropriate, if we had one. */
X! { LONG_SWORD,	 "Werebane",	(SPFX_RESTR | SPFX_DFLAG1), M1_WERE,
X    { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  { LONG_SWORD,	 "Giantslayer", (SPFX_RESTR | SPFX_DFLAG2), M2_GIANT,
X--- 80,86 ----
X    { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  /* A silver weapon would be appropriate, if we had one. */
X! { LONG_SWORD,	 "Werebane",	(SPFX_RESTR | SPFX_DFLAG2), M2_WERE,
X    { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  { LONG_SWORD,	 "Giantslayer", (SPFX_RESTR | SPFX_DFLAG2), M2_GIANT,
X***************
X*** 97,102 ****
X--- 103,130 ----
X  { 0,  "", 0, 0, NO_ATTK, NO_ATTK, 0, 0 }
X  };
X  
X+ const int artifact_num = SIZE(artilist);
X+ 
X+ /* this array gets saved / restored - thus not static */
X+ boolean artiexist[SIZE(artilist)];
X+ 
X+ #endif /* OVLB */
X+ 
X+ OSTATIC const struct artifact *FDECL(get_artifact, (struct obj *));
X+ OSTATIC int FDECL(spec_applies, (const struct artifact *, struct permonst *));
X+ 
X+ #ifdef OVLB
X+ 
X+ /* zero out the artifact exist list */
X+ void
X+ init_exists()
X+ {
X+ 	int i;
X+ 
X+ 	for(i = 0; i < SIZE(artilist); i++)
X+ 		artiexist[i] = 0;
X+ }
X+ 
X  void
X  mkartifact(otmp1)
X  struct obj **otmp1;
X***************
X*** 103,125 ****
X  {
X  	register const struct artifact *artif;
X  	register struct obj *otmp = *otmp1;
X! 	register int n = 0;
X  
X! 	for(artif = artilist; artif->otyp; artif++)
X! 	    if(otmp->otyp == artif->otyp && !(artif->spfx & SPFX_NOGEN)) n++;
X  
X  	if (n) {
X  		n = rnd(n);
X! 		for(artif = artilist; artif->otyp && n > 0; ) {
X! 		    if(otmp->otyp == artif->otyp && !(artif->spfx & SPFX_NOGEN)) n--;
X! 		    if (n>0) artif++;
X  		}
X  
X! 		if(artif->otyp) *otmp1 = oname(otmp, artif->name, 0);
X  	}
X  }
X  
X! static struct artifact *
X  get_artifact(otmp)
X  struct obj *otmp;
X  {
X--- 131,164 ----
X  {
X  	register const struct artifact *artif;
X  	register struct obj *otmp = *otmp1;
X! 	register int n = 0, m;
X  
X! 	for(artif = artilist,m = 0; artif->otyp; artif++,m++)
X! 	    if(otmp->otyp == artif->otyp && !(artif->spfx & SPFX_NOGEN) &&
X! 	       !artiexist[m]) n++;
X  
X  	if (n) {
X  		n = rnd(n);
X! 		for(artif = artilist,m = 0; artif->otyp && n > 0; ) {
X! 		    if(otmp->otyp == artif->otyp && !(artif->spfx & SPFX_NOGEN) &&
X! 		       !artiexist[m]) n--;
X! 		    if (n > 0) {
X! 			artif++;
X! 			m++;
X! 		    }
X  		}
X  
X! 		if(artif->otyp) {
X! 		    *otmp1 = oname(otmp, artif->name, 0);
X! 		    artiexist[m] = TRUE;
X! 		}
X  	}
X  }
X  
X! #endif /* OVLB */
X! #ifdef OVL0
X! 
X! XSTATIC const struct artifact *
X  get_artifact(otmp)
X  struct obj *otmp;
X  {
X***************
X*** 130,139 ****
X  		for(artif = artilist; artif->otyp; artif++)
X  		    if(artif->otyp == otmp->otyp &&
X  		       !strcmp(ONAME(otmp), artif->name))
X! 			    return((struct artifact *)artif);
X  	return((struct artifact *)0);
X  }
X  
X  boolean
X  is_artifact(otmp)
X  struct obj *otmp;
X--- 169,181 ----
X  		for(artif = artilist; artif->otyp; artif++)
X  		    if(artif->otyp == otmp->otyp &&
X  		       !strcmp(ONAME(otmp), artif->name))
X! 			    return artif;
X  	return((struct artifact *)0);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  boolean
X  is_artifact(otmp)
X  struct obj *otmp;
X***************
X*** 142,156 ****
X  }
X  
X  boolean
X  spec_ability(otmp, abil)
X  struct obj *otmp;
X  unsigned abil;
X  {
X! 	struct artifact *arti = get_artifact(otmp);
X  	
X  	return(arti && (arti->spfx & abil));
X  }
X  
X  int
X  restr_name(otmp, name)	/* returns 1 if name is restricted for otmp->otyp */
X  register struct obj *otmp;
X--- 184,238 ----
X  }
X  
X  boolean
X+ exist_artifact(otmp, name)
X+ register struct obj *otmp;
X+ register const char *name;
X+ {
X+ 	register const struct artifact *artif;
X+ 	register boolean *arex;
X+ 
X+ 	if(otmp && strlen(name))
X+ 	    for(artif = artilist,arex = artiexist; artif->otyp; artif++,arex++)
X+ 		if(artif->otyp == otmp->otyp &&
X+ 		   !strcmp(name, artif->name) &&
X+ 		   *arex)
X+ 		    return TRUE;
X+ 	return FALSE;
X+ }
X+ 
X+ void
X+ artifact_exists(otmp, name, mod)
X+ register struct obj *otmp;
X+ register const char *name;
X+ register boolean mod;
X+ {
X+ 	register const struct artifact *artif;
X+ 	register boolean *arex;
X+ 
X+ 	if(otmp && strlen(name))
X+ 	    for(artif = artilist,arex = artiexist; artif->otyp; artif++,arex++)
X+ 		if(artif->otyp == otmp->otyp &&
X+ 		   !strcmp(name, artif->name))
X+ 		    *arex = mod;
X+ 	return;
X+ }
X+ 
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X+ boolean
X  spec_ability(otmp, abil)
X  struct obj *otmp;
X  unsigned abil;
X  {
X! 	const struct artifact *arti = get_artifact(otmp);
X  	
X  	return(arti && (arti->spfx & abil));
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  int
X  restr_name(otmp, name)	/* returns 1 if name is restricted for otmp->otyp */
X  register struct obj *otmp;
X***************
X*** 175,198 ****
X  {
X  	register const struct artifact *artif;
X  	register struct obj *otmp;
X! 	register int n = 0;
X  
X! 	for(artif = artilist; artif->otyp; artif++)
X! 	    if(align == artif->align && !(artif->spfx & SPFX_NOGEN))
X  		if (pl_character[0] == artif->class) {
X! 		    n=0; break;
X  		} else n++;
X  	if (n) {
X  		n = rnd(n);
X! 		for(artif = artilist; artif->otyp && n > 0; ) {
X! 		    if(align == artif->align && !(artif->spfx & SPFX_NOGEN))
X  			n--;
X! 		    if (n > 0) artif++;
X  		}
X  	}
X  	if(artif->otyp) {
X  		otmp = mksobj((int)artif->otyp, FALSE);
X  		otmp = oname(otmp, artif->name, 0);
X  		return (otmp);
X  	}
X  	return ((struct obj *) 0);
X--- 257,285 ----
X  {
X  	register const struct artifact *artif;
X  	register struct obj *otmp;
X! 	register int n = 0, m;
X  
X! 	for(artif = artilist,m = 0; artif->otyp; artif++,m++)
X! 	    if(align == artif->align && !(artif->spfx & SPFX_NOGEN) && !artiexist[m])
X  		if (pl_character[0] == artif->class) {
X! 		    n = 0;
X! 		    break;
X  		} else n++;
X  	if (n) {
X  		n = rnd(n);
X! 		for(artif = artilist,m = 0; artif->otyp && n > 0; ) {
X! 		    if(align == artif->align && !(artif->spfx & SPFX_NOGEN) && !artiexist[m])
X  			n--;
X! 		    if (n > 0) {
X! 			artif++;
X! 			m++;
X! 		    }
X  		}
X  	}
X  	if(artif->otyp) {
X  		otmp = mksobj((int)artif->otyp, FALSE);
X  		otmp = oname(otmp, artif->name, 0);
X+ 		artiexist[m] = TRUE;
X  		return (otmp);
X  	}
X  	return ((struct obj *) 0);
X***************
X*** 204,210 ****
X  register int adtyp;
X  register struct obj *otmp;
X  {
X! 	register struct artifact *weap;
X  
X  	if(weap = get_artifact(otmp))
X  		return(weap->defn.adtyp == adtyp);
X--- 291,297 ----
X  register int adtyp;
X  register struct obj *otmp;
X  {
X! 	register const struct artifact *weap;
X  
X  	if(weap = get_artifact(otmp))
X  		return(weap->defn.adtyp == adtyp);
X***************
X*** 211,223 ****
X  	return(0);
X  }
X  
X! static int
X  spec_applies(weap, ptr)
X! register struct artifact *weap;
X  struct permonst *ptr;
X  {
X  	if(!(weap->spfx & (SPFX_DBONUS | SPFX_ATTK)))
X! 	    return(1);
X  
X  	if(weap->spfx & SPFX_DMONS)
X  	    return((ptr == &mons[(int)weap->mtype]));
X--- 298,310 ----
X  	return(0);
X  }
X  
X! XSTATIC int
X  spec_applies(weap, ptr)
X! register const struct artifact *weap;
X  struct permonst *ptr;
X  {
X  	if(!(weap->spfx & (SPFX_DBONUS | SPFX_ATTK)))
X! 	    return(0);
X  
X  	if(weap->spfx & SPFX_DMONS)
X  	    return((ptr == &mons[(int)weap->mtype]));
X***************
X*** 241,252 ****
X  	return(0);
X  }
X  
X  int
X  spec_abon(otmp, ptr)
X  struct obj *otmp;
X  struct permonst *ptr;
X  {
X! 	register struct artifact *weap;
X  
X  	if((weap = get_artifact(otmp)))
X  		if(spec_applies(weap, ptr))
X--- 328,342 ----
X  	return(0);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  int
X  spec_abon(otmp, ptr)
X  struct obj *otmp;
X  struct permonst *ptr;
X  {
X! 	register const struct artifact *weap;
X  
X  	if((weap = get_artifact(otmp)))
X  		if(spec_applies(weap, ptr))
X***************
X*** 260,266 ****
X  register struct permonst *ptr;
X  register int	tmp;
X  {
X! 	register struct artifact *weap;
X  
X  	if((weap = get_artifact(otmp)))
X  		if(spec_applies(weap, ptr))
X--- 350,356 ----
X  register struct permonst *ptr;
X  register int	tmp;
X  {
X! 	register const struct artifact *weap;
X  
X  	if((weap = get_artifact(otmp)))
X  		if(spec_applies(weap, ptr))
X***************
X*** 267,270 ****
X--- 357,363 ----
X  		    return((weap->attk.damd) ? rnd((int)weap->attk.damd) : tmp);
X  	return(0);
X  }
X+ 
X+ #endif /* OVL1 */
X+ 
X  #endif /* NAMED_ITEMS */
X*** src/Old/attrib.c	Mon Feb 19 17:54:19 1990
X--- src/attrib.c	Sat Feb 17 20:29:27 1990
X***************
X*** 1,11 ****
X! /*
X!  *	attrib.c	- attribute modification routines.
X!  *
X!  *	Copyright 1988, M. Stephenson
X!  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  
X  const char	*plusattr[] = {	/* part of the output on gain of attribute */
X  
X--- 1,12 ----
X! /*	SCCS Id: @(#)attrib.c	3.0	90/2/15
X! /*	Copyright 1988, 1989, 1990, M. Stephenson		  */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! /*  attribute modification routines. */
X! 
X! #include "hack.h"
X! 
X! #ifdef OVLB
X  
X  const char	*plusattr[] = {	/* part of the output on gain of attribute */
X  
X***************
X*** 30,42 ****
X  
X  	schar	ulevel;
X  	long	*ability;
X! 	char	*gainstr, *losestr;
X! }	a_abil[] = { {	 0, &(Stealth), "", "" },
X! 		     {   0, &(Fast), "", "" },
X  		     {  10, &(Searching), "perceptive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	b_abil[] = { {	 0, &(HPoison_resistance), "", "" },
X  		     {   7, &(Fast), "quick", "slow" },
X  		     {  15, &(Stealth), "stealthy", "" },
X  		     {	 0, 0, 0, 0 } },
X--- 31,43 ----
X  
X  	schar	ulevel;
X  	long	*ability;
X! 	const char *gainstr, *losestr;
X! }	a_abil[] = { {	 1, &(Stealth), "", "" },
X! 		     {   1, &(Fast), "", "" },
X  		     {  10, &(Searching), "perceptive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	b_abil[] = { {	 1, &(HPoison_resistance), "", "" },
X  		     {   7, &(Fast), "quick", "slow" },
X  		     {  15, &(Stealth), "stealthy", "" },
X  		     {	 0, 0, 0, 0 } },
X***************
X*** 45,57 ****
X  		     {	15, &(Warning), "sensitive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	e_abil[] = { {   0, &(Fast), "", "" },
X! 		     {	 0, &(HSee_invisible), "", "" },
X! 		     {	 0, &(Searching), "", "" },
X! 		     {	 0, &(HSleep_resistance), "", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	h_abil[] = { {	 0, &(HPoison_resistance), "", "" },
X  		     {	15, &(Warning), "sensitive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X--- 46,58 ----
X  		     {	15, &(Warning), "sensitive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	e_abil[] = { {   1, &(Fast), "", "" },
X! 		     {	 1, &(HSee_invisible), "", "" },
X! 		     {	 1, &(Searching), "", "" },
X! 		     {	 1, &(HSleep_resistance), "", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	h_abil[] = { {	 1, &(HPoison_resistance), "", "" },
X  		     {	15, &(Warning), "sensitive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X***************
X*** 62,72 ****
X  		     {  20, &(HFire_resistance), "cool", "warmer" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	r_abil[] = { {	 0, &(Stealth), "", ""  },
X  		     {  10, &(Searching), "perceptive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	s_abil[] = { {	 0, &(Fast), "", "" },
X  		     {  15, &(Stealth), "stealthy", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X--- 63,73 ----
X  		     {  20, &(HFire_resistance), "cool", "warmer" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	r_abil[] = { {	 1, &(Stealth), "", ""  },
X  		     {  10, &(Searching), "perceptive", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	s_abil[] = { {	 1, &(Fast), "", "" },
X  		     {  15, &(Stealth), "stealthy", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X***************
X*** 74,81 ****
X  		     {	20, &(HPoison_resistance), "hardy", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	v_abil[] = { {	 0, &(HCold_resistance), "", "" },
X! 		     {	 0, &(Stealth), "", "" },
X  		     {   7, &(Fast), "quick", "slow" },
X  		     {	 0, 0, 0, 0 } },
X  
X--- 75,82 ----
X  		     {	20, &(HPoison_resistance), "hardy", "" },
X  		     {	 0, 0, 0, 0 } },
X  
X! 	v_abil[] = { {	 1, &(HCold_resistance), "", "" },
X! 		     {	 1, &(Stealth), "", "" },
X  		     {   7, &(Fast), "quick", "slow" },
X  		     {	 0, 0, 0, 0 } },
X  
X***************
X*** 151,156 ****
X--- 152,160 ----
X  		   {	20, 15, 15, 15, 20, 15 },
X  		     0,  0, 12, 10, 14,  1,  0 };
X  
X+ static const struct clattr *NDECL(clx);
X+ static void NDECL(init_align);
X+ 
X  void
X  adjattrib(ndx, incr, silent)
X  
X***************
X*** 259,264 ****
X--- 263,271 ----
X  	return sgn(bonchance);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  restore_attrib() {
X  
X***************
X*** 277,282 ****
X--- 284,292 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  static const struct	clattr *
X  clx()  {
X  
X***************
X*** 394,418 ****
X  }
X  
X  void
X! adjabil(flag)
X! 
X! 	int	flag;		/* +ve/-ve  = gain/lose */
X  {
X  	register const struct clattr	*attr = clx();
X  	register const struct innate	*abil = attr->abil;
X  
X  	if(abil) {
X- 
X  	    for(; abil->ability; abil++) {
X! 		if ((flag>0 && u.ulevel >= abil->ulevel) ||
X! 					(flag<0 && u.ulevel < abil->ulevel)) {
X! 		    if(flag > 0) {
X  			if(!(*(abil->ability) & INTRINSIC)) {
X  			    *(abil->ability) |= INTRINSIC;
X  			    if(strlen(abil->gainstr))
X  				You("feel %s!", abil->gainstr);
X  			}
X! 		    } else {
X  			if((*(abil->ability) & INTRINSIC)) {
X  			    *(abil->ability) &= ~INTRINSIC;
X  			    if(strlen(abil->losestr))
X--- 404,430 ----
X  }
X  
X  void
X! adjabil(oldlevel,newlevel)
X! int oldlevel, newlevel;
X  {
X  	register const struct clattr	*attr = clx();
X+ #ifdef __GNULINT__
X+ 	/* this is the "right" definition */
X  	register const struct innate	*abil = attr->abil;
X+ #else
X+ 	/* this one satisfies more compilers */
X+ 	register struct innate	*abil = (struct innate *)attr->abil;
X+ #endif
X  
X  	if(abil) {
X  	    for(; abil->ability; abil++) {
X! 		if(oldlevel < abil->ulevel && newlevel >= abil->ulevel) {
X  			if(!(*(abil->ability) & INTRINSIC)) {
X  			    *(abil->ability) |= INTRINSIC;
X  			    if(strlen(abil->gainstr))
X  				You("feel %s!", abil->gainstr);
X  			}
X! 		} else if (oldlevel >= abil->ulevel && newlevel < abil->ulevel) {
X  			if((*(abil->ability) & INTRINSIC)) {
X  			    *(abil->ability) &= ~INTRINSIC;
X  			    if(strlen(abil->losestr))
X***************
X*** 420,427 ****
X  			    else if(strlen(abil->gainstr))
X  				You("feel less %s!", abil->gainstr);
X  			}
X! 		    }
X! 		} 
X  	    }
X  	}
X  }
X--- 432,438 ----
X  			    else if(strlen(abil->gainstr))
X  				You("feel less %s!", abil->gainstr);
X  			}
X! 		}
X  	    }
X  	}
X  }
X***************
X*** 459,466 ****
X  	return((hp <= 0) ? 1 : hp);
X  }
X  
X  schar
X! acurr(x) { 
X  	register int tmp = (u.abon.a[x] + u.atemp.a[x] + u.acurr.a[x]);
X  
X  	if (x == A_STR) {
X--- 470,482 ----
X  	return((hp <= 0) ? 1 : hp);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  schar
X! acurr(x)
X! int x;
X! { 
X  	register int tmp = (u.abon.a[x] + u.atemp.a[x] + u.acurr.a[x]);
X  
X  	if (x == A_STR) {
X***************
X*** 470,475 ****
X--- 486,494 ----
X  	else return((tmp >= 25) ? 25 : (tmp <= 3) ? 3 : tmp);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X  /* avoid possible problems with alignment overflow, and provide a centralized
X   * location for any future alignment limits
X   */
X***************
X*** 486,488 ****
X--- 505,509 ----
X  		if(newalign > u.ualign)
X  			u.ualign = newalign;
X  }
X+ 
X+ #endif /* OVL2 */
X*** src/Old/bones.c	Mon Feb 19 17:54:43 1990
X--- src/bones.c	Sun Feb 18 14:15:22 1990
X***************
X*** 4,20 ****
X  
X  #include "hack.h"
X  
X- #ifdef OLD_TOS
X- #define OMASK	0x8000
X- #else
X  #define OMASK	0
X- #endif
X  
X  #ifdef DGK
X  char bones[FILENAME];
X- #ifndef OLD_TOS
X  extern long bytes_counted;
X- #endif
X  #else
X  char bones[] = "bones.xxxx";
X  #endif
X--- 4,14 ----
X***************
X*** 22,27 ****
X--- 16,30 ----
X  #ifdef COMPRESS
X  static char cmd[60], proxy[20];
X  
X+ static void NDECL(compress_bones);
X+ #endif
X+ static boolean FDECL(no_bones_level, (int));
X+ void FDECL(resetobjs,(struct obj *));
X+ #ifdef TUTTI_FRUTTI
X+ static void FDECL(goodfruit, (int));
X+ #endif
X+ 
X+ #ifdef COMPRESS
X  static void
X  compress_bones()
X  {
X***************
X*** 40,45 ****
X--- 43,52 ----
X  no_bones_level(lev)
X  int lev;
X  {
X+ 	extern int save_dlevel;		/* in do.c */
X+ 
X+ 	if (save_dlevel) lev = save_dlevel;
X+ 
X  	return (lev == medusa_level ||
X  		lev == wiz_level
X  #ifdef REINCARNATION
X***************
X*** 80,91 ****
X  	for (otmp = ochain; otmp; otmp = otmp->nobj) {
X  		otmp->o_id = 0;
X  		if (((otmp->otyp != CORPSE && otmp->otyp != STATUE)
X!        			|| otmp->corpsenm < PM_ARCHEOLOGIST)
X  #ifdef NAMED_ITEMS
X! 			&& !is_artifact(otmp)
X  #endif
X  		)
X! 		otmp->onamelth = 0;
X  		if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X  #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X--- 87,102 ----
X  	for (otmp = ochain; otmp; otmp = otmp->nobj) {
X  		otmp->o_id = 0;
X  		if (((otmp->otyp != CORPSE && otmp->otyp != STATUE)
X! 			|| otmp->corpsenm < PM_ARCHEOLOGIST)
X  #ifdef NAMED_ITEMS
X! 			&& !(is_artifact(otmp) && !exist_artifact(otmp,ONAME(otmp)))
X  #endif
X  		)
X! 			otmp->onamelth = 0;
X! #ifdef NAMED_ITEMS
X! 		else if (is_artifact(otmp))
X! 			artifact_exists(otmp,ONAME(otmp),TRUE);
X! #endif
X  		if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X  #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X***************
X*** 194,206 ****
X  		if (!mtmp) return;
X  		Strcpy((char *) mtmp->mextra, plname);
X  	} else {
X- 		mons[u.ugrave_arise].pxlth += strlen(plname);
X  		mtmp = makemon(&mons[u.ugrave_arise], u.ux, u.uy);
X- 		mons[u.ugrave_arise].pxlth -= strlen(plname);
X  		in_mklev = FALSE;
X  		if (!mtmp) return;
X! 		Strcpy(NAME(mtmp), plname);
X! 		mtmp->mnamelth = strlen(plname);
X  		atl(u.ux, u.uy, mtmp->data->mlet);
X  		Your("body rises from the dead as %s...",
X  			an(mons[u.ugrave_arise].mname));
X--- 205,214 ----
X  		if (!mtmp) return;
X  		Strcpy((char *) mtmp->mextra, plname);
X  	} else {
X  		mtmp = makemon(&mons[u.ugrave_arise], u.ux, u.uy);
X  		in_mklev = FALSE;
X  		if (!mtmp) return;
X! 		mtmp = christen_monst(mtmp, plname);
X  		atl(u.ux, u.uy, mtmp->data->mlet);
X  		Your("body rises from the dead as %s...",
X  			an(mons[u.ugrave_arise].mname));
X***************
X*** 260,279 ****
X  		return;
X  	}
X  
X! #if defined(DGK) && !defined(OLD_TOS)	/* check whether there is room */
X  	count_only = TRUE;
X! #ifdef TUTTI_FRUTTI
X  	savefruitchn(fd);
X! #endif
X  	savelev(fd, dlevel, COUNT);
X! #ifdef ZEROCOMP
X  	bflush(fd);
X! #endif
X  	if (bytes_counted > freediskspace(bones)) {	/* not enough room */
X! #ifdef WIZARD
X  		if (wizard)
X  			pline("Insufficient space to create bones file.");
X! #endif
X  		unlink(bones);
X  		return;
X  	}
X--- 268,287 ----
X  		return;
X  	}
X  
X! #if defined(DGK)	/* check whether there is room */
X  	count_only = TRUE;
X! # ifdef TUTTI_FRUTTI
X  	savefruitchn(fd);
X! # endif
X  	savelev(fd, dlevel, COUNT);
X! # ifdef ZEROCOMP
X  	bflush(fd);
X! # endif
X  	if (bytes_counted > freediskspace(bones)) {	/* not enough room */
X! # ifdef WIZARD
X  		if (wizard)
X  			pline("Insufficient space to create bones file.");
X! # endif
X  		unlink(bones);
X  		return;
X  	}
X***************
X*** 283,289 ****
X  #ifdef TUTTI_FRUTTI
X  	savefruitchn(fd);
X  #endif
X! #if defined(DGK) && !defined(OLD_TOS)
X  	savelev(fd, dlevel, WRITE);
X  #else
X  	savelev(fd,dlevel);
X--- 291,297 ----
X  #ifdef TUTTI_FRUTTI
X  	savefruitchn(fd);
X  #endif
X! #if defined(DGK)
X  	savelev(fd, dlevel, WRITE);
X  #else
X  	savelev(fd,dlevel);
X***************
X*** 354,359 ****
X--- 362,378 ----
X  		getlev(fd, 0, dlevel, TRUE);
X  	}
X  	(void) close(fd);
X+ #ifdef NAMED_ITEMS
X+ 	/* to correctly reset named artifacts on the level */
X+ 	{
X+ 		register struct monst *mtmp;
X+ 
X+ 		for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X+ 			resetobjs(mtmp->minvent);
X+ 		resetobjs(fobj);
X+ 		resetobjs(fcobj);
X+ 	}
X+ #endif
X  #ifdef WIZARD
X  	if(wizard) {
X  		pline("Unlink bones? ");
X*** src/Old/lev_comp.l	Mon Feb 19 18:08:37 1990
X--- src/lev_comp.l	Fri Feb  2 18:24:03 1990
X***************
X*** 1,5 ****
X  %{
X! /*	SCCS Id: @(#)lev_lex.c	3.0	89/11/08
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,5 ----
X  %{
X! /*	SCCS Id: @(#)lev_lex.c	3.0	90/01/04
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 6,29 ****
X  #define LEV_LEX_C
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X! #define MONDATA_H
X! #define MONFLAG_H
X  
X  #include "hack.h"
X  #include "lev_comp.h"
X  #include "sp_lev.h"
X  
X  #ifdef MSDOS
X  #undef exit
X  #endif
X  
X! #ifdef TOS
X! extern YYSTYPE yylval;	/* this doesn't always get put in lev_comp.h */
X! #endif
X  
X  #ifdef MACOS
X  #undef putchar
X  #undef putc
X  #endif
X  int line_number = 1;
X  
X--- 6,51 ----
X  #define LEV_LEX_C
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X! #define MONDATA_H	/* comment this line for pre-compiled headers */
X! #define MONFLAG_H	/* comment this line for pre-compiled headers */
X  
X  #include "hack.h"
X  #include "lev_comp.h"
X  #include "sp_lev.h"
X  
X+ /* Most of these don't exist in flex, yywrap is macro and
X+  * yyunput is properly declared in flex.skel.
X+  */
X+ #ifndef FLEX_SCANNER
X+ int FDECL (yyback, (int *, int));
X+ int NDECL (yylook);
X+ int NDECL (yyinput);
X+ int NDECL (yywrap);
X+ int NDECL (yylex);
X+ int FDECL (yyunput, (int));
X+ int FDECL (yyoutput, (int));
X+ #endif
X+ 
X  #ifdef MSDOS
X  #undef exit
X  #endif
X  
X! /* this doesn't always get put in lev_comp.h
X!  * (esp. when using older versions of bison)
X!  */
X! 
X! extern YYSTYPE yylval;
X  
X  #ifdef MACOS
X  #undef putchar
X  #undef putc
X+ #undef printf
X+ #undef Printf
X+ #define Printf printf
X+ # ifdef LSC
X+ #define	putc(c,stream)	(fputc(c,stream))
X+ #define	putchar(c)	(fputc(c,stdout))
X+ # endif
X  #endif
X  int line_number = 1;
X  
X***************
X*** 102,104 ****
X--- 124,133 ----
X  '.'		{ yylval.i = yytext[1]; return CHAR; }
X  .		{ return yytext[0]; }
X  %%
X+ #ifdef	AMIGA
X+ long *alloc(n)
X+ 	unsigned n;
X+ {
X+ 	return ((long *)malloc (n));
X+ }
X+ #endif
X*** src/Old/lev_comp.y	Mon Feb 19 18:08:53 1990
X--- src/lev_comp.y	Wed Feb 14 20:49:06 1990
X***************
X*** 1,5 ****
X  %{ 
X! /*	SCCS Id: @(#)lev_comp.c	3.0	89/07/02
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,5 ----
X  %{ 
X! /*	SCCS Id: @(#)lev_comp.c	3.0	90/01/03
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 9,16 ****
X   */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X! #define MONDATA_H
X! #define MONFLAG_H
X  
X  #include "hack.h"
X  #include "sp_lev.h"
X--- 9,16 ----
X   */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X! #define MONDATA_H	/* comment line for pre-compiled headers */
X! #define MONFLAG_H	/* comment line for pre-compiled headers */
X  
X  #include "hack.h"
X  #include "sp_lev.h"
X***************
X*** 21,35 ****
X  # include <sys/file.h>
X  #endif
X  
X  #ifdef AMIGA
X  char *fgets();
X- # define    alloc   malloc
X  # undef     fopen
X  # undef     printf
X  # undef     Printf
X  # define    Printf  printf
X  # define    memset(addr,val,len)    setmem(addr,len,val)
X  #endif
X  
X  #ifdef MSDOS
X  # undef exit
X--- 21,51 ----
X  # include <sys/file.h>
X  #endif
X  
X+ void FDECL(yyerror, (char *));
X+ void FDECL(yywarning, (char *));
X+ int NDECL(yylex);
X+ int NDECL(yyparse);
X+ 
X+ int FDECL(get_room_type, (char *));
X+ int FDECL(get_trap_type, (char *));
X+ int FDECL(get_monster_id, (char *, CHAR_P));
X+ int FDECL(get_object_id, (char *, CHAR_P));
X+ boolean FDECL(check_monster_char, (CHAR_P));
X+ boolean FDECL(check_object_char, (CHAR_P));
X+ void FDECL(scan_map, (char *));
X+ void NDECL(store_part);
X+ void FDECL(write_maze, (int, specialmaze *));
X+ 
X  #ifdef AMIGA
X  char *fgets();
X  # undef     fopen
X  # undef     printf
X  # undef     Printf
X  # define    Printf  printf
X+ #ifndef	LATTICE
X  # define    memset(addr,val,len)    setmem(addr,len,val)
X  #endif
X+ #endif
X  
X  #ifdef MSDOS
X  # undef exit
X***************
X*** 41,46 ****
X--- 57,64 ----
X  # define Printf printf
X  #endif
X  
X+ #undef NULL
X+ 
X  #define MAX_REGISTERS	10
X  #define ERR		(-1)
X  
X***************
X*** 145,153 ****
X  extern int fatal_error;
X  extern char* fname;
X  
X- boolean check_monster_char(), check_object_char();
X- void scan_map(), store_part(), write_maze();
X- 
X  %}
X  
X  %union
X--- 163,168 ----
X***************
X*** 167,172 ****
X--- 182,189 ----
X  %token	<i> ALIGNMENT LEFT_OR_RIGHT CENTER TOP_OR_BOT ALTAR_TYPE UP_OR_DOWN
X  %token	<i> ',' ':' '(' ')' '[' ']'
X  %token	<map> STRING MAP_ID
X+ %type	<i> h_justif v_justif trap_name room_type door_state light_state
X+ %type	<i> alignment altar_type a_register
X  %type	<map> string maze_def m_name o_name
X  %start	file
X  
X***************
X*** 175,181 ****
X  		| levels ;
X  
X  levels		: level
X! 		| levels level ;
X  
X  level		: maze_level ;
X  
X--- 192,198 ----
X  		| levels ;
X  
X  levels		: level
X! 		| level levels ;
X  
X  level		: maze_level ;
X  
X***************
X*** 186,191 ****
X--- 203,214 ----
X  			  if (fatal_error > 0)
X  				  fprintf(stderr,"%s : %d errors detected. No output created!\n", fname, fatal_error);
X  			  else {
X+ #ifdef MACOS
X+ 				  OSErr	result;
X+ 				  
X+ 				  result = Create(CtoPstr($1), 0, CREATOR, AUXIL_TYPE);
X+ 				  (void)PtoCstr($1);
X+ #endif		
X  				  fout = open($1, O_WRONLY | O_CREAT
X  #if defined(MSDOS) || defined(MACOS)
X  					      | O_BINARY
X***************
X*** 211,217 ****
X  		  }
X  
X  regions 	: aregion
X! 		| regions aregion;
X  
X  aregion 	: map_definition reg_init map_details
X  		  {
X--- 234,240 ----
X  		  }
X  
X  regions 	: aregion
X! 		| aregion regions ;
X  
X  aregion 	: map_definition reg_init map_details
X  		  {
X***************
X*** 286,295 ****
X  			  else
X  			      yyerror("Object list too long!");
X  		  }
X! 		| object_list ',' object
X  		  {
X  			  if (n_olist < MAX_REGISTERS)
X! 			      olist[n_olist++] = $<i>3;
X  			  else
X  			      yyerror("Object list too long!");
X  		  }
X--- 309,318 ----
X  			  else
X  			      yyerror("Object list too long!");
X  		  }
X! 		| object ',' object_list
X  		  {
X  			  if (n_olist < MAX_REGISTERS)
X! 			      olist[n_olist++] = $<i>1;
X  			  else
X  			      yyerror("Object list too long!");
X  		  }
X***************
X*** 301,310 ****
X  			  else
X  			      yyerror("Monster list too long!");
X  		  }
X! 		| monster_list ',' monster
X  		  {
X  			  if (n_mlist < MAX_REGISTERS)
X! 			      mlist[n_mlist++] = $<i>3;
X  			  else
X  			      yyerror("Monster list too long!");
X  		  }
X--- 324,333 ----
X  			  else
X  			      yyerror("Monster list too long!");
X  		  }
X! 		| monster ',' monster_list
X  		  {
X  			  if (n_mlist < MAX_REGISTERS)
X! 			      mlist[n_mlist++] = $<i>1;
X  			  else
X  			      yyerror("Monster list too long!");
X  		  }
X***************
X*** 316,328 ****
X  			  else
X  			      yyerror("Location list too long!");
X  		  }
X! 		| place_list ',' place
X  		  {
X  			  if (n_plist < MAX_REGISTERS)
X  			      plist[n_plist++] = current_coord;
X  			  else
X  			      yyerror("Location list too long!");
X! 		  }
X  
X  map_details	: /* nothing */
X  		| map_details map_detail ;
X--- 339,351 ----
X  			  else
X  			      yyerror("Location list too long!");
X  		  }
X! 		| place
X  		  {
X  			  if (n_plist < MAX_REGISTERS)
X  			      plist[n_plist++] = current_coord;
X  			  else
X  			      yyerror("Location list too long!");
X! 		  } ',' place_list
X  
X  map_details	: /* nothing */
X  		| map_details map_detail ;
X***************
X*** 576,582 ****
X  
X  monster 	: CHAR
X  		  {
X! 			if (check_monster_char($1))
X  				$<i>$ = $1 ;
X  			else {
X  				yyerror("unknown monster class!");
X--- 599,605 ----
X  
X  monster 	: CHAR
X  		  {
X! 			if (check_monster_char((char) $1))
X  				$<i>$ = $1 ;
X  			else {
X  				yyerror("unknown monster class!");
X***************
X*** 641,647 ****
X  	
X  	for(i=0; i < SHOPBASE -1; i++)
X  	    if (!strcmp(s, room_types[i].name))
X! 		return room_types[i].type;
X  	return ERR;
X  }
X  
X--- 664,670 ----
X  	
X  	for(i=0; i < SHOPBASE -1; i++)
X  	    if (!strcmp(s, room_types[i].name))
X! 		return ((int) room_types[i].type);
X  	return ERR;
X  }
X  
X***************
X*** 657,663 ****
X  	
X  	for(i=0; i < TRAPNUM - 1; i++)
X  	    if(!strcmp(s,trap_types[i].name))
X! 		return(trap_types[i].type);
X  	return ERR;
X  }
X  
X--- 680,686 ----
X  	
X  	for(i=0; i < TRAPNUM - 1; i++)
X  	    if(!strcmp(s,trap_types[i].name))
X! 		return((int)trap_types[i].type);
X  	return ERR;
X  }
X  
X*** src/Old/lev_main.c	Mon Feb 19 18:10:04 1990
X--- src/lev_main.c	Thu Feb 15 19:06:08 1990
X***************
X*** 8,13 ****
X--- 8,18 ----
X   */
X  
X  /* #include "hack.h"	/* uncomment for the Mac */
X+ 
X+ #ifdef AMIGA
X+ #include "hack.h"
X+ #undef exit
X+ #endif
X  #include <stdio.h>
X  
X  #define MAX_ERRORS	25
X***************
X*** 16,22 ****
X--- 21,47 ----
X  char *fname = "(stdin)";
X  int fatal_error = 0;
X  
X+ #ifdef LATTICE
X+ long *alloc(unsigned int);
X+ #ifdef exit
X+ #undef exit
X+ #endif
X+ #include <stdlib.h>
X+ #endif
X+ 
X+ #ifdef	FDECL
X+ int  FDECL (main, (int, char **));
X+ int  NDECL (yyparse);
X+ void FDECL (yyerror, (char *));
X+ void FDECL (yywarning, (char *));
X+ int  NDECL (yywrap);
X+ #endif
X+ 
X+ #ifdef LSC
X+ _main(argc, argv)
X+ #else
X  main(argc, argv) 
X+ #endif
X  int argc;
X  char **argv;
X  {
X***************
X*** 76,82 ****
X  	    yyparse();
X  	else 			/* Otherwise every argument is a filename */
X  	    for(i=1; i<argc; i++) {
X! #ifdef VMS
X  		    extern FILE *yyin;
X  		    yyin = fin = fopen(argv[i], "r");
X  #else
X--- 101,107 ----
X  	    yyparse();
X  	else 			/* Otherwise every argument is a filename */
X  	    for(i=1; i<argc; i++) {
X! #if defined(VMS) || defined(AZTEC_C)
X  		    extern FILE *yyin;
X  		    yyin = fin = fopen(argv[i], "r");
X  #else
X***************
X*** 99,105 ****
X   * MAX_ERRORS wouldn't be reasonable.
X   */
X  
X! yyerror(s)
X  char *s;
X  {
X  	fprintf(stderr,"%s : line %d : %s\n",fname,line_number, s);
X--- 124,130 ----
X   * MAX_ERRORS wouldn't be reasonable.
X   */
X  
X! void yyerror(s)
X  char *s;
X  {
X  	fprintf(stderr,"%s : line %d : %s\n",fname,line_number, s);
X***************
X*** 113,119 ****
X   * Just display a warning (that is : a non fatal error)
X   */
X  
X! yywarning(s)
X  char *s;
X  {
X  	fprintf(stderr,"%s : line %d : WARNING : %s\n",fname,line_number,s);
X--- 138,144 ----
X   * Just display a warning (that is : a non fatal error)
X   */
X  
X! void yywarning(s)
X  char *s;
X  {
X  	fprintf(stderr,"%s : line %d : WARNING : %s\n",fname,line_number,s);
X*** src/Old/lock.c	Mon Feb 19 18:10:19 1990
X--- src/lock.c	Wed Feb 14 18:38:07 1990
X***************
X*** 4,10 ****
X  
X  #include	"hack.h"
X  
X! static struct {
X  	int	door_or_box, picktyp;
X  	struct rm  *door;
X  	struct obj *box;
X--- 4,19 ----
X  
X  #include	"hack.h"
X  
X! #ifndef OVERLAY
X! static int NDECL(picklock);
X! static int NDECL(forcelock);
X! #else
X! int NDECL(picklock);
X! int NDECL(forcelock);
X! #endif
X! static boolean FDECL(obstructed,(int,int));
X! 
X! VSTATIC struct xlock_s {
X  	int	door_or_box, picktyp;
X  	struct rm  *door;
X  	struct obj *box;
X***************
X*** 11,16 ****
X--- 20,27 ----
X  	int chance, usedtime;
X  } xlock;
X  
X+ #ifdef OVLB
X+ 
X  #ifndef OVERLAY
X  static
X  #endif
X***************
X*** 146,154 ****
X--- 157,171 ----
X  	return((xlock.usedtime = 0));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  reset_pick() { xlock.usedtime = 0; }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  int
X  pick_lock(pick) /* pick a lock with a given object */
X  	register struct	obj	*pick;
X***************
X*** 157,162 ****
X--- 174,182 ----
X  	register struct rm	*door;
X  	register struct obj	*otmp;
X  
X+ #ifdef __GNULINT__
X+ 	ch = 0;		/* GCC myopia */
X+ #endif
X  	picktyp = pick->otyp;
X  	if(xlock.usedtime && picktyp == xlock.picktyp) {
X  
X***************
X*** 375,382 ****
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X! 				mtmp->mappearance == CLOSED_DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X--- 395,403 ----
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic &&
X! 				mtmp->m_ap_type == M_AP_FURNITURE &&
X! 				mtmp->mappearance == S_cdoor &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X***************
X*** 463,470 ****
X  		return(1);
X  	}
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X! 				mtmp->mappearance == CLOSED_DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X--- 484,492 ----
X  		return(1);
X  	}
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic &&
X! 				mtmp->m_ap_type == M_AP_FURNITURE && 
X! 				mtmp->mappearance == S_cdoor &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X***************
X*** 524,530 ****
X  			/* returns 1 if something happened */
X  	register struct obj *obj, *otmp;	/* obj *is* a box */
X  {
X! 	register boolean res;
X  
X  	switch(otmp->otyp) {
X  	    case WAN_LOCKING:
X--- 546,552 ----
X  			/* returns 1 if something happened */
X  	register struct obj *obj, *otmp;	/* obj *is* a box */
X  {
X! 	register boolean res = 0;
X  
X  	switch(otmp->otyp) {
X  	    case WAN_LOCKING:
X***************
X*** 683,685 ****
X--- 705,709 ----
X  	return(otmp->olet == WEAPON_SYM && objects[otmp->otyp].oc_bimanual);
X  }
X  #endif /* STUPID_CPP */
X+ 
X+ #endif /* OVLB */
X
END_OF_FILE
if test 53710 -ne `wc -c <'patch7.01'`; then
    echo shar: \"'patch7.01'\" unpacked with wrong size!
fi
# end of 'patch7.01'
echo shar: End of archive 15 \(of 30\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
