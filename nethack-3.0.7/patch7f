Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!tut.cis.ohio-state.edu!zaphod.mps.ohio-state.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i006:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7f
Message-ID: <5220@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:32:13 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2270
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 6
Archive-name: NetHack3/Patch7f
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 30)."
# Contents:  do_patch7.sh patch7.05
# Wrapped by billr@saab on Wed Feb 21 10:04:27 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'do_patch7.sh' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'do_patch7.sh'\" to \"'do_patch7.sh.orig'\"
  mv -f 'do_patch7.sh' 'do_patch7.sh.orig'
fi
echo shar: Extracting \"'do_patch7.sh'\" \(763 characters\)
sed "s/^X//" >'do_patch7.sh' <<'END_OF_FILE'
X#! /bin/sh
X# script to call patch to apply diff files
X# make sure all of the patch files (and this file) are in your top level
X# NetHack directory
X#
Xecho "removing unused files"
Xrm -f amiga/Install.ami
Xrm -f amiga/fcntl.h
Xrm -f amiga/signal.h
Xrm -f amiga/stdio.h
Xrm -f include/trapname.h
Xrm -f mac/Install.mac
Xrm -f mac/Makedefs.rma
Xrm -f mac/Nethack.rma
Xrm -f mac/hackfont.hqx
Xrm -f mac/makedefs.r
Xrm -f mac/nethack.r
Xrm -f others/Make.ini
Xrm -f others/Maketcc.ini
Xrm -f others/oldtos.c
Xrm -f vms/Install.vms
Xecho "creating monst.c from monst.c1 and monst.c2"
Xmv -f src/monst.c src/monst.c.orig
Xcat src/monst.c1 src/monst.c2 > src/monst.c
Xrm src/monst.c1 src/monst.c2
Xecho "applying patch7"
Xcat patch7.?? | patch -p
Xecho "all patches applied, check for rejects"
END_OF_FILE
if test 763 -ne `wc -c <'do_patch7.sh'`; then
    echo shar: \"'do_patch7.sh'\" unpacked with wrong size!
fi
chmod +x 'do_patch7.sh'
# end of 'do_patch7.sh'
if test -f 'patch7.05' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.05'\" to \"'patch7.05.orig'\"
  mv -f 'patch7.05' 'patch7.05.orig'
fi
echo shar: Extracting \"'patch7.05'\" \(56505 characters\)
sed "s/^X//" >'patch7.05' <<'END_OF_FILE'
X*** src/Old/pager.c	Mon Feb 19 18:49:43 1990
X--- src/pager.c	Fri Feb 16 19:15:27 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pager.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pager.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 6,15 ****
X  /* Also readmail() and doshell(), and generally the things that
X     contact the outside world. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X- #define MONATTK_H
X  #include	"hack.h"
X  
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif
X--- 6,16 ----
X  /* Also readmail() and doshell(), and generally the things that
X     contact the outside world. */
X  
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X  /* block some unused #defines to avoid overloading some cpp's */
X  #include	"hack.h"
X  
X+ #include <ctype.h>
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif
X***************
X*** 21,32 ****
X  extern short macflags;
X  #endif
X  
X! static char hc = 0;
X  
X  static void FDECL(page_more, (FILE *,int));
X! static boolean FDECL(clear_help, (CHAR_P));
X! static boolean FDECL(valid_help, (CHAR_P));
X  
X  /*
X   * print out another possibility for dowhatis. "new" is the possible new
X   * string; "out_flag" indicates whether we really want output, and if
X--- 22,78 ----
X  extern short macflags;
X  #endif
X  
X! #ifndef SEEK_SET
X! #define SEEK_SET 0
X! #endif
X! 
X! #ifndef OVLB
X! OSTATIC char hc;
X! #else /* OVLB */
X! XSTATIC char hc = 0;
X! #endif /* OVLB */
X  
X  static void FDECL(page_more, (FILE *,int));
X! OSTATIC boolean FDECL(clear_help, (CHAR_P));
X! OSTATIC boolean FDECL(valid_help, (CHAR_P));
X! static boolean FDECL(pmatch,(const char *,const char *));
X! static boolean FDECL(outspec,(const char *,int));
X! static const char *FDECL(lookat,(int,int,UCHAR_P));
X! #ifdef WIZARD
X! static void NDECL(wiz_help);
X! #endif
X! static void NDECL(help_menu);
X! 
X! #ifdef OVLB
X! 
X! /*
X!  * simple pattern matcher: '*' matches 0 or more characters
X!  * returns TRUE if strng matches patrn
X!  */
X! 
X! static boolean
X! pmatch(patrn, strng)
X! 	const char *patrn, *strng;
X! {
X! 	char s, p;
X  
X+ 	s = *strng;
X+ 	p = *patrn;
X+ 
X+ 	if (!p) {
X+ 		return (s == 0);
X+ 	}
X+ 
X+ 	if (p == '*') {
X+ 		if (!patrn[1] || pmatch(patrn+1, strng)) {
X+ 			return TRUE;
X+ 		}
X+ 		return (s ? pmatch(patrn, strng+1) : FALSE);
X+ 	}
X+ 
X+ 	return (p == s) ? pmatch(patrn+1, strng+1) : FALSE;
X+ }
X+ 
X  /*
X   * print out another possibility for dowhatis. "new" is the possible new
X   * string; "out_flag" indicates whether we really want output, and if
X***************
X*** 36,42 ****
X  
X  static boolean
X  outspec(new, out_flag)
X! char *new;
X  int out_flag;
X  {
X  	static char old[50];
X--- 82,88 ----
X  
X  static boolean
X  outspec(new, out_flag)
X! const char *new;
X  int out_flag;
X  {
X  	static char old[50];
X***************
X*** 45,69 ****
X  		return FALSE;		/* don't print the same thing twice */
X  
X  	if (out_flag)
X! 		pline("(or %s)", new);
X  
X  	Strcpy(old, new);
X  	return 1;
X  }
X  
X  int
X  dowhatis()
X  {
X  	FILE *fp;
X! 	char bufr[BUFSZ+6];
X! 	register char *buf = &bufr[6], *ep;
X! 	uchar q, typ;
X  	register int i;
X  	coord	cc;
X  	boolean oldverb = flags.verbose;
X! 	boolean found_in_file = FALSE;
X  	int	found = 0;
X- 	register struct monst *mtmp;
X  
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X--- 91,268 ----
X  		return FALSE;		/* don't print the same thing twice */
X  
X  	if (out_flag)
X! 		pline("(or %s)", an(new));
X  
X  	Strcpy(old, new);
X  	return 1;
X  }
X  
X+ /*
X+  * return the name of the character ch found at (x,y)
X+  */
X+ 
X+ static
X+ const char *
X+ lookat(x, y, ch)
X+ int x,y;
X+ uchar ch;
X+ {
X+ 	register struct monst *mtmp;
X+ 	register struct obj *otmp;
X+ 	struct trap *trap;
X+ 	static char answer[50];
X+ 	register char *s, *t;
X+ 	uchar typ;
X+ 
X+ 	answer[0] = 0;
X+ 
X+ 	if(MON_AT(x,y)) {
X+ 		mtmp = m_at(x,y);
X+ 		if (!showmon(mtmp) || Hallucination)
X+ 			mtmp = (struct monst *)0;
X+ 	} else
X+ 		mtmp = (struct monst *) 0;
X+ 	typ = levl[x][y].typ;
X+ 	if (!Invisible 
X+ #ifdef POLYSELF
X+ 			&& !u.uundetected
X+ #endif
X+ 			&& u.ux==x && u.uy==y) {
X+ 		Sprintf(answer, "%s named %s",
X+ #ifdef POLYSELF
X+ 			u.mtimedone ? mons[u.umonnum].mname :
X+ #endif
X+ 			pl_character, plname);
X+ 	} else if (mtmp && !mtmp->mimic)
X+ 		Sprintf(answer, "%s%s",
X+ 		   mtmp->mtame ? "tame " :
X+ 		   mtmp->mpeaceful ? "peaceful " : "",
X+ 		   strncmp(lmonnam(mtmp), "the ", 4)
X+ 			  ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X+ 	else if (!levl[x][y].seen)
X+ 		Strcpy(answer,"dark part of a room");
X+ 	else if (mtmp && mtmp->mimic) {
X+ 		if (mtmp->m_ap_type == M_AP_FURNITURE) {
X+ 			if (mtmp->mappearance == S_altar)
X+ 				Strcpy(answer, "neutral altar");
X+ 			else
X+ 				Strcpy(answer, explainsyms[mtmp->mappearance]);
X+ 		}
X+ 		else if (mtmp->m_ap_type == M_AP_OBJECT) {
X+ 			if (mtmp->mappearance == STRANGE_OBJECT)
X+ 				Strcpy(answer, "strange object");
X+ 			else {
X+ 				otmp = mksobj((int) mtmp->mappearance,FALSE );
X+ 				Strcpy(answer, distant_name(otmp, xname));
X+ 				free((genericptr_t) otmp);
X+ 			}
X+ 		}
X+ 		else if (mtmp->m_ap_type == M_AP_GOLD)
X+ 			Strcpy(answer, "pile of gold");
X+ 	}
X+ 	else if (OBJ_AT(x, y)) {
X+ 		otmp = level.objects[x][y];
X+ 		Strcpy(answer, distant_name(otmp, xname));
X+ 	}
X+ 	else if (ch == GOLD_SYM) {
X+ 		Strcpy(answer, "pile of gold");
X+ 	}
X+ #ifdef ALTARS
X+ 	else if (ch == ALTAR_SYM && IS_ALTAR(typ)) {
X+ 		int kind = levl[x][y].altarmask & ~A_SHRINE;
X+ 		Sprintf( answer, "%s altar",
X+ 			(kind == A_CHAOS) ? "chaotic" :
X+ 			(kind == A_NEUTRAL) ? "neutral" :
X+ 			 "lawful" );
X+ 	}
X+ #endif
X+ #ifdef STRONGHOLD
X+ 	else if ((ch == DB_VWALL_SYM || ch == DB_HWALL_SYM) && is_db_wall(x,y))
X+ 		Strcpy(answer,"raised drawbridge");
X+ #endif
X+ #ifdef THRONES
X+ 	else if ((ch == THRONE_SYM) && IS_THRONE(typ))
X+ 		Strcpy(answer, "throne");
X+ #endif
X+ 	else if ( (ch==H_OPEN_DOOR_SYM ||
X+ 		   ch==V_OPEN_DOOR_SYM ||
X+ 		   ch==CLOSED_DOOR_SYM ||
X+ 		   ch==NO_DOOR_SYM) &&
X+ 		  IS_DOOR(typ) ) {
X+ 		switch(levl[x][y].doormask & ~D_TRAPPED) {
X+ 			case D_NODOOR: Strcpy(answer,"doorway"); break;
X+ 			case D_BROKEN: Strcpy(answer,"broken door"); break;
X+ 			case D_ISOPEN: Strcpy(answer,"open door"); break;
X+ 			default:       Strcpy(answer,"closed door"); break;
X+ 					   /* locked or not */
X+ 		}
X+ 	}
X+ #ifdef SINKS
X+ 	else if (ch == SINK_SYM && IS_SINK(levl[x][y].typ))
X+ 		Strcpy(answer,"sink");
X+ #endif
X+ 	else if ((ch == TRAP_SYM || ch == WEB_SYM) && (trap = t_at(x, y))) {
X+ 		if (trap->ttyp == WEB && ch == WEB_SYM)
X+ 			Strcpy(answer, "web");
X+ 		else if (trap->ttyp != MONST_TRAP && ch == TRAP_SYM) {
X+ 			Strcpy(answer, traps[ Hallucination ?
X+ 				rn2(TRAPNUM-3)+3 : trap->ttyp]);
X+ 		/* strip leading garbage */
X+ 			for (s = answer; *s && *s != ' '; s++) ;
X+ 			if (*s) ++s;
X+ 			for (t = answer; *t++ = *s++; ) ;
X+ 		}
X+ 	}
X+ 	else if (ch == UP_SYM && x == xupstair && y == yupstair)
X+ 		Strcpy(answer, "staircase up");
X+ 	else if (ch == DN_SYM && x == xdnstair && y == ydnstair)
X+ 		Strcpy(answer, "staircase down");
X+ #ifdef STRONGHOLD
X+ 	else if (ch == UPLADDER_SYM && x && x == xupladder && y == ydnladder)
X+ 		Strcpy(answer, "ladder up");
X+ 	else if (ch == DNLADDER_SYM && x && x == xdnladder && y == ydnladder)
X+ 		Strcpy(answer, "ladder down");
X+ #endif
X+ 	else if (IS_ROOM(typ)) {
X+ 		if (ch == ROOM_SYM) {
X+ 			if (levl[x][y].icedpool)
X+ 			    Strcpy(answer,"iced pool");
X+ 			else
X+ 			    Strcpy(answer,"floor of a room");
X+ 		}
X+ 		else if (ch == STONE_SYM || ch == ' ')
X+ 			Strcpy(answer,"dark part of a room");
X+ 	}
X+ 	else if (ch == CORR_SYM && SPACE_POS(typ))
X+ 		Strcpy(answer,"corridor");
X+ 	else if (!ACCESSIBLE(typ)) {
X+ 		if (ch == STONE_SYM || ch == ' ')
X+ 			Strcpy(answer,"dark part of a room");
X+ 		else
X+ 			Strcpy(answer,"wall");
X+ 	}
X+ 	return answer;
X+ }
X+ 
X+ 	
X  int
X  dowhatis()
X  {
X  	FILE *fp;
X! 	char buf[BUFSZ], inpbuf[BUFSZ];
X! 	register char *ep, *inp = inpbuf;
X! 	char *alt = 0;		/* alternate description */
X! #ifdef __GNULINT__
X! 	const char *firstmatch = 0;
X! #else
X! 	const char *firstmatch;
X! #endif
X! 	uchar q;
X  	register int i;
X  	coord	cc;
X  	boolean oldverb = flags.verbose;
X! 	boolean found_in_file = FALSE, need_to_print = FALSE;
X  	int	found = 0;
X  
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X***************
X*** 92,105 ****
X  		return 0;
X  	} else if (q == 'n') {
X  		cc.x = cc.y = -1;
X! 		pline("Specify what? ");
X! 		q = readchar();
X  	} else {
X  		cc.x = u.ux;
X  		cc.y = u.uy;
X  selobj:
X! 		found_in_file = FALSE;
X  		found = 0;
X  		(void) outspec("", 0);		/* reset output */
X  		if(flags.verbose)
X  			pline("Please move the cursor to an unknown object.");
X--- 291,314 ----
X  		return 0;
X  	} else if (q == 'n') {
X  		cc.x = cc.y = -1;
X! 		pline("Specify what? (type the word) ");
X! 		getlin(inp);
X! 		if (inp[0] == '\033' || !inp[0]) {
X! 			(void)fclose(fp);
X! 			return 0;
X! 		}
X! 		if (!inp[1])
X! 			q = inp[0];
X! 		else
X! 			q = 0;
X  	} else {
X  		cc.x = u.ux;
X  		cc.y = u.uy;
X  selobj:
X! 		need_to_print = found_in_file = FALSE;
X  		found = 0;
X+ 		inp = inpbuf;
X+ 		alt = 0;
X  		(void) outspec("", 0);		/* reset output */
X  		if(flags.verbose)
X  			pline("Please move the cursor to an unknown object.");
X***************
X*** 117,258 ****
X  			q = ' ';
X  	}
X  
X! 	if (index(quitchars, (char)q)) {
X  		(void) fclose(fp); /* sweet@scubed */
X  		flags.verbose = oldverb;
X  		return 0;
X  	}
X  
X! /* now check for symbols defined in the data file */
X! 	if(q != '\t')
X! 	while(fgets(buf,BUFSZ,fp)) {
X! 		if(*buf == q) {
X! 			ep = index(buf, '\n');
X! 			if(ep) *ep = 0;
X! 			/* else: bad data file */
X! 			/* Expand tab 'by hand' */
X! 			if (buf[1] == '\t') {
X! 				buf = bufr;
X! 				buf[0] = q;
X! 				(void) strncpy(buf+1, "       ", 7);
X! 			}
X! 			pline("%s", buf);	/* watch out for % in output */
X! 			(void) outspec("", 0);
X  			found++;
X- 			found_in_file = TRUE;
X  			break;
X  		}
X  	}
X  
X  /* Now check for graphics symbols */
X  	for (i = 0; i < MAXPCHARS; i++) {
X  		if ( q == showsyms[i] && (*explainsyms[i])) {
X  			if (!found) {
X! 				pline("%c       %s",q,explainsyms[i]);
X! 				(void) outspec(explainsyms[i], 0);
X  				found++;
X  			}
X  			else if (outspec(explainsyms[i], 1))
X  				found++;
X  		}
X  	}
X  
X  	if (!found)
X  		pline("I've never heard of such things.");
X! 
X! /* now check for specific things at a given location */
X! 	if(cc.x != -1 && found) {
X! 		if(MON_AT(cc.x,cc.y)) {
X! 			mtmp = m_at(cc.x,cc.y);
X! 			if (!showmon(mtmp) || Hallucination)
X! 				mtmp = (struct monst *)0;
X! 		} else
X! 			mtmp = (struct monst *) 0;
X! 		typ = levl[cc.x][cc.y].typ;
X! 		if (!Invisible 
X! #ifdef POLYSELF
X! 				&& !u.uundetected
X! #endif
X! 				&& u.ux==cc.x && u.uy==cc.y) {
X! 			pline("(%s named %s)",
X! #ifdef POLYSELF
X! 				u.mtimedone ? mons[u.umonnum].mname :
X! #endif
X! 				pl_character, plname);
X! 		} else if (mtmp && !mtmp->mimic)
X! 			pline("(%s%s)",
X! 			   mtmp->mtame ? "tame " :
X! 			   mtmp->mpeaceful ? "peaceful " : "",
X! 			   strncmp(lmonnam(mtmp), "the ", 4)
X! 				  ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X! /* Only worry about the rest of the cases if the symbol could represent
X!    more than one thing */
X! 		else if (found <= 1)
X! 			/* do nothing */ ;
X! 		else if (!levl[cc.x][cc.y].seen)
X! 			pline("(a dark part of a room)");
X! #ifdef ALTARS
X! 		else if (q == showsyms[S_altar] && 
X! 			 (IS_ALTAR(typ) || (mtmp && mtmp->mimic))) {
X! 			int kind = levl[cc.x][cc.y].altarmask & ~A_SHRINE;
X! 			pline( "(%s altar)",
X! 				(kind == A_CHAOS) ? "chaotic" :
X! 				(kind == A_NEUTRAL) ? "neutral" :
X! 				 "lawful" );
X! 		}
X! #endif
X! 		else if ((q==showsyms[S_ndoor] ||
X! 			  q==showsyms[S_vodoor] ||
X! 			  q==showsyms[S_hodoor] ||
X! 			  q==showsyms[S_cdoor]) &&
X! 			(IS_DOOR(typ) ||
X! 				(IS_WALL(typ) && mtmp && mtmp->mimic))) {
X! 			/* Note: this will say mimics in walls are
X! 			 *	 closed doors, which we want.
X! 			 */
X! 			switch(levl[cc.x][cc.y].doormask & ~D_TRAPPED) {
X! 				case D_NODOOR: pline("(doorway)"); break;
X! 				case D_BROKEN: pline("(broken door)"); break;
X! 				case D_ISOPEN: pline("(open door)"); break;
X! 				default:       pline("(closed door)"); break;
X! 						   /* locked or not */
X! 			}
X  		}
X! #ifdef STRONGHOLD
X! 		else if ((q == showsyms[S_dbvwall] ||
X! 			  q == showsyms[S_dbhwall]) &&
X! 			  is_db_wall(cc.x,cc.y))
X! 				pline("(raised drawbridge)");
X! #endif
X! #ifdef SINKS
X! 		else if (q == showsyms[S_sink] && IS_SINK(levl[cc.x][cc.y].typ))
X! 			pline("(sink)");
X! #endif
X! 		else if (IS_ROOM(typ) && q == showsyms[S_room])
X! 			pline("(floor of a room)");
X! 		else if (q == showsyms[S_corr] && SPACE_POS(typ))
X! 			pline("(corridor)");
X! 		else if (!ACCESSIBLE(typ)) {
X! 			if (q == showsyms[S_stone] || q == ' ')
X! 				pline("(dark part of a room)");
X  			else
X! 				pline("(wall)");
X  		}
X  	}
X  
X! /* now check for "more info" */
X! 	if(found_in_file && ep[-1] == ';') {
X! 		pline("More info? ");
X! 		if(yn() == 'y') {
X! 			page_more(fp,1); /* does fclose() */
X  			flags.verbose = oldverb;
X  			return 0;
X  		}
X  	}
X  
X  /* if specified by cursor, keep going */
X  	if(cc.x != -1) {
X- 		buf = &bufr[6];
X  		more();
X  		rewind(fp);
X  		goto selobj;
X--- 326,486 ----
X  			q = ' ';
X  	}
X  
X! 	if (!q)
X! 		goto checkfile; /* user typed in a complete string */
X! 
X! 	if (q != ' ' && index(quitchars, (char)q)) {
X  		(void) fclose(fp); /* sweet@scubed */
X  		flags.verbose = oldverb;
X  		return 0;
X  	}
X+ /*
X+  * if the user just typed one letter, or we're identifying from the
X+  * screen, then we have to check all the possibilities and print them
X+  * out for him/her
X+  */
X  
X! /* Check for monsters */
X! 	for (i = 0; monsyms[i]; i++) {
X! 		if (q == monsyms[i]) {
X! 			need_to_print = TRUE;
X! 			pline("%c       %s",q,an(monexplain[i]));
X! 			(void) outspec(firstmatch = monexplain[i], 0);
X  			found++;
X  			break;
X  		}
X  	}
X  
X+ /* Now check for objects */
X+ 	for (i = 0; objsyms[i]; i++) {
X+ 		if (q == objsyms[i]) {
X+ 			need_to_print = TRUE;
X+ 			if (!found) {
X+ 				pline("%c       %s",q,an(objexplain[i]));
X+ 				(void)outspec(firstmatch = objexplain[i], 0);
X+ 				found++;
X+ 			}
X+ 			else if (outspec(objexplain[i], 1))
X+ 				found++;
X+ 		}
X+ 	}
X+ 
X  /* Now check for graphics symbols */
X  	for (i = 0; i < MAXPCHARS; i++) {
X  		if ( q == showsyms[i] && (*explainsyms[i])) {
X  			if (!found) {
X! 				pline("%c       %s",q,an(explainsyms[i]));
X! 				(void)outspec(firstmatch = explainsyms[i], 0);
X  				found++;
X  			}
X  			else if (outspec(explainsyms[i], 1))
X  				found++;
X+ 			if (i == S_altar || i == S_trap || i == S_web)
X+ 				need_to_print = TRUE;
X  		}
X  	}
X  
X  	if (!found)
X  		pline("I've never heard of such things.");
X! 	else if (cc.x != -1) {	/* a specific object on screen */
X! 		if (found > 1 || need_to_print) {
X! 			Strcpy(inp, lookat(cc.x, cc.y, q));
X! 			if (*inp)
X! 				pline("(%s)", inp);
X  		}
X! 		else {
X! 			Strcpy(inp, firstmatch);
X! 		}
X! 	}
X! 	else if (found == 1) {
X! 		Strcpy(inp, firstmatch);
X! 	}
X! 	else
X! 		found = FALSE;	/* abort the 'More info?' stuff */
X! 
X! /* check the data file for information about this thing */
X! 
X! checkfile:
X! 
X! 	if (!strncmp(inp, "a ", 2))
X! 		inp += 2;
X! 	else if (!strncmp(inp, "an ", 3))
X! 		inp += 3;
X! 	else if (!strncmp(inp, "the ", 4))
X! 		inp += 4;
X! 	if (!strncmp(inp, "tame ", 5))
X! 		inp += 5;
X! 	else if (!strncmp(inp, "peaceful ", 9))
X! 		inp += 9;
X! 	if (!strncmp(inp, "invisible ", 10))
X! 		inp += 10;
X! 
X! 	if ((!q || found) && *inp) {
X! /* adjust the input to remove "named " and convert to lower case */
X!  		for (ep = inp; *ep; ) {
X! 			if ((!strncmp(ep, " named ", 7) && (alt = ep + 7)) ||
X! 			    !strncmp(ep, " called ", 8))
X! 				*ep = 0;
X  			else
X! 				(*ep = tolower(*ep)), ep++;
X! 		}
X! 
X! /*
X!  * If the object is named, then the name is the alternate search string;
X!  * otherwise, the result of makesingular() applied to the name is. This
X!  * isn't strictly optimal, but named objects of interest to the user should
X!  * will usually be found under their name, rather than under their
X!  * object type, so looking for a singular form is pointless.
X!  */
X! 
X! 		if (!alt)
X! 			alt = makesingular(inp);
X! 		else
X! 			for (ep = alt; *ep; ep++) *ep = tolower(*ep);
X! 
X! 		while(fgets(buf,BUFSZ,fp)) {
X! 			if(*buf != '\t') {
X! 			    ep = index(buf, '\n');
X! 			    if(ep) *ep = 0;
X! 			    else impossible("bad data file");
X! 			    if (pmatch(buf, inp)||(alt && pmatch(buf, alt))) {
X! 				found_in_file = TRUE;
X! 				break;
X! 			    }
X! 			}
X  		}
X  	}
X  
X! 	if(found_in_file) {
X! /* skip over other possible matches for the info */
X! 		for(;;) {
X! 			if ( (i = getc(fp)) == '\t' ) {
X! 				(void) ungetc(i, fp);
X! 				break;
X! 			}
X! 			if (!fgets(buf, BUFSZ, fp)) {
X! 				break;
X! 			}
X! 		}
X! 		if (q) {
X! 			pline("More info? ");
X! 			if(yn() == 'y') {
X! 				page_more(fp,1); /* does fclose() */
X! 				flags.verbose = oldverb;
X! 				return 0;
X! 			}
X! 		}
X! 		else {
X! 			page_more(fp, 1);
X  			flags.verbose = oldverb;
X  			return 0;
X  		}
X  	}
X+ 	else if (!q)
X+ 		pline("I don't have any information on those things.");
X  
X  /* if specified by cursor, keep going */
X  	if(cc.x != -1) {
X  		more();
X  		rewind(fp);
X  		goto selobj;
X***************
X*** 351,356 ****
X--- 579,595 ----
X  #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X  	int (*prevsig)() = (int (*)())signal(SIGINT, (SIG_RET_TYPE) intruph);
X  #endif
X+ #ifdef MACOS
X+ 	short tmpflags;
X+ 	
X+ 	tmpflags = macflags;
X+ 	macflags &= ~fDoUpdate;
X+ 	if(!mac_more(fp, strip)) {
X+ 		macflags |= (tmpflags & fDoUpdate);
X+ 		return;
X+ 	}
X+ 	macflags |= (tmpflags & fDoUpdate);
X+ #else
X  #if defined(MSDOS) || defined(MINIMAL_TERM)
X  	/* There seems to be a bug in ANSI.SYS  The first tab character
X  	 * after a clear screen sequence is not expanded correctly.  Thus
X***************
X*** 396,406 ****
X  	(void) signal(SIGINT, (SIG_RET_TYPE) prevsig);
X  	got_intrup = 0;
X  #endif
X  }
X  
X! static boolean whole_screen = TRUE;
X  #define	PAGMIN	12	/* minimum # of lines for page below level map */
X  
X  void
X  set_whole_screen() {	/* called in termcap as soon as LI is known */
X  	whole_screen = (LI-ROWNO-2 <= PAGMIN || !CD);
X--- 635,655 ----
X  	(void) signal(SIGINT, (SIG_RET_TYPE) prevsig);
X  	got_intrup = 0;
X  #endif
X+ #endif
X  }
X  
X! #endif /* OVLB */
X! 
X  #define	PAGMIN	12	/* minimum # of lines for page below level map */
X  
X+ #ifndef OVLB
X+ 
X+ OSTATIC boolean whole_screen;
X+ 
X+ #else /* OVLB */
X+ 
X+ XSTATIC boolean whole_screen = TRUE;
X+ 
X  void
X  set_whole_screen() {	/* called in termcap as soon as LI is known */
X  	whole_screen = (LI-ROWNO-2 <= PAGMIN || !CD);
X***************
X*** 439,445 ****
X--- 688,700 ----
X  		so = flags.standout;
X  		flags.standout = 1;
X  	} else {
X+ #ifdef MACOS
X+ 		macflags |= fFullScrKluge;
X+ #endif
X  		if(mode == 1) {
X+ #ifdef MACOS
X+ 			macflags |= fCornScrKluge;
X+ #endif
X  			curs(1, LI);
X  			more();
X  		}
X***************
X*** 450,461 ****
X  			curs(1, ROWNO+4);
X  			cl_eos();
X  		}
X  	}
X  }
X  
X  int
X  page_line(s)		/* returns 1 if we should quit */
X! register char *s;
X  {
X  	if(cury == LI-1) {
X  		if(!*s)
X--- 705,722 ----
X  			curs(1, ROWNO+4);
X  			cl_eos();
X  		}
X+ #ifdef MACOS
X+ 		macflags &= ~fScreenKluges;
X+ #endif
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  page_line(s)		/* returns 1 if we should quit */
X! register const char *s;
X  {
X  	if(cury == LI-1) {
X  		if(!*s)
X***************
X*** 501,507 ****
X  void
X  cornline(mode, text)
X  int mode;
X! char *text;
X  {
X  	static struct line {
X  		struct line *next_line;
X--- 762,768 ----
X  void
X  cornline(mode, text)
X  int mode;
X! const char *text;
X  {
X  	static struct line {
X  		struct line *next_line;
X***************
X*** 556,561 ****
X--- 817,833 ----
X  	else
X  	if(mode == 2) {
X  	    register int curline, lth;
X+ #ifdef MACOS
X+ 		short tmpflags;
X+ 		extern struct line *mactexthead;
X+ 		extern int macmaxlen, maclinect;
X+ 		
X+ 		tmpflags = macflags;
X+ 		macflags |= fDoUpdate | fDisplayKluge;
X+ 		mactexthead = texthead;
X+ 		macmaxlen = maxlen;
X+ 		maclinect = linect;
X+ #endif
X  
X  	    if(flags.toplin == 1) more();	/* ab@unido */
X  	    remember_topl();
X***************
X*** 589,600 ****
X  		curs (lth, curline);
X  #endif
X  		cl_end ();
X! 		if (!hmenu) cmore (text);
X  		if (!hmenu || clear_help(hc)) {
X  		    home ();
X  		    cl_end ();
X  		    docorner (lth, curline-1);
X  		}
X  	    } else {					/* feed to pager */
X  		set_pager(0);
X  		for (tl = texthead; tl; tl = tl->next_line) {
X--- 861,881 ----
X  		curs (lth, curline);
X  #endif
X  		cl_end ();
X! 		if (!hmenu) {
X! #ifdef MACOS
X! 			macflags |= fCornScrKluge;
X! #endif
X! 			cmore (text);
X! 		}
X  		if (!hmenu || clear_help(hc)) {
X  		    home ();
X  		    cl_end ();
X  		    docorner (lth, curline-1);
X  		}
X+ #ifdef MACOS
X+ 			mactexthead = NULL;
X+ 			macflags |= (tmpflags & (fDoUpdate | fDisplayKluge));
X+ #endif
X  	    } else {					/* feed to pager */
X  		set_pager(0);
X  		for (tl = texthead; tl; tl = tl->next_line) {
X***************
X*** 621,626 ****
X--- 902,910 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  #ifdef WIZARD
X  static
X  void
X***************
X*** 653,673 ****
X  	cornline(1, "g.  Longer explanation of game options.");
X  	cornline(1, "h.  List of extended commands.");
X  	cornline(1, "i.  The NetHack license.");
X  #ifdef WIZARD
X  	if (wizard)
X  		cornline(1, "j.  List of wizard-mode commands.");
X  #endif
X  	cornline(1, "");
X  #ifdef WIZARD
X  	if (wizard)
X  		cornline(1, "Select one of a,b,c,d,e,f,g,h,i,j or ESC: ");
X  	else
X  #endif
X  		cornline(1, "Select one of a,b,c,d,e,f,g,h,i or ESC: ");
X  	cornline(-1,"");
X  }
X  
X! static boolean
X  clear_help(c)
X  char c;
X  {
X--- 937,972 ----
X  	cornline(1, "g.  Longer explanation of game options.");
X  	cornline(1, "h.  List of extended commands.");
X  	cornline(1, "i.  The NetHack license.");
X+ #ifdef MACOS
X+ 	cornline(1, "j.  Macintosh primer.");
X+ #endif
X  #ifdef WIZARD
X  	if (wizard)
X+ # ifdef MACOS
X+ 		cornline(1, "k.  List of wizard-mode commands.");
X+ # else
X  		cornline(1, "j.  List of wizard-mode commands.");
X+ # endif
X  #endif
X  	cornline(1, "");
X  #ifdef WIZARD
X  	if (wizard)
X+ # ifdef MACOS
X+ 		cornline(1, "Select one of a,b,c,d,e,f,g,h,i,j,k or ESC: ");
X+ # else
X  		cornline(1, "Select one of a,b,c,d,e,f,g,h,i,j or ESC: ");
X+ # endif
X  	else
X  #endif
X+ #ifdef MACOS
X+ 		cornline(1, "Select one of a,b,c,d,e,f,g,h,i,j or ESC: ");
X+ #else
X  		cornline(1, "Select one of a,b,c,d,e,f,g,h,i or ESC: ");
X+ #endif
X  	cornline(-1,"");
X  }
X  
X! XSTATIC boolean
X  clear_help(c)
X  char c;
X  {
X***************
X*** 696,714 ****
X  	        || !whole_screen
X  #endif
X  #ifdef WIZARD
X  		|| c == 'j'
X  #endif
X  		);
X  }
X  
X! static boolean
X  valid_help(c)
X  char c;
X  {
X  #ifdef WIZARD
X  	return ((c >= 'a' && c <= (wizard ? 'j' : 'i')) || index(quitchars,c));
X  #else
X  	return ((c >= 'a' && c <= 'i') || index(quitchars,c));
X  #endif
X  }
X  
X--- 995,1025 ----
X  	        || !whole_screen
X  #endif
X  #ifdef WIZARD
X+ # ifdef MACOS
X+ 		|| c == 'k'
X+ # else
X  		|| c == 'j'
X+ # endif
X  #endif
X  		);
X  }
X  
X! XSTATIC boolean
X  valid_help(c)
X  char c;
X  {
X  #ifdef WIZARD
X+ # ifdef MACOS
X+ 	return ((c >= 'a' && c <= (wizard ? 'k' : 'j')) || index(quitchars,c));
X+ # else
X  	return ((c >= 'a' && c <= (wizard ? 'j' : 'i')) || index(quitchars,c));
X+ # endif
X  #else
X+ # ifdef MACOS
X+ 	return ((c >= 'a' && c <= 'j') || index(quitchars,c));
X+ # else
X  	return ((c >= 'a' && c <= 'i') || index(quitchars,c));
X+ # endif
X  #endif
X  }
X  
X***************
X*** 717,724 ****
X  {
X  #ifdef MACOS
X  	term_info	*t;
X! 	
X! 	macflags &= ~(fDoUpdate | fDoNonKeyEvt);
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	SetVol((StringPtr)NULL,
X  		(t->auxFileVRefNum) ? t->auxFileVRefNum : t->recordVRefNum);
X--- 1028,1035 ----
X  {
X  #ifdef MACOS
X  	term_info	*t;
X! 
X! 	macflags &= ~fDoNonKeyEvt;
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	SetVol((StringPtr)NULL,
X  		(t->auxFileVRefNum) ? t->auxFileVRefNum : t->recordVRefNum);
X***************
X*** 736,748 ****
X  			case 'h':  (void) doextlist();  break;
X  			case 'i':  (void) page_file(LICENSE, FALSE);  break;
X  #ifdef WIZARD
X  			case 'j':  wiz_help();  break;
X  #endif
X  		}
X  	}
X  #ifdef MACOS
X- 	macflags |= (fDoUpdate | fDoNonKeyEvt);
X  	SetVol((StringPtr)NULL, t->recordVRefNum);
X  #endif
X  	return 0;
X  }
X--- 1047,1064 ----
X  			case 'h':  (void) doextlist();  break;
X  			case 'i':  (void) page_file(LICENSE, FALSE);  break;
X  #ifdef WIZARD
X+ # ifdef MACOS
X+ 			case 'j':  (void) page_file(MACHELP, FALSE);  break;
X+ 			case 'k':  wiz_help();  break;
X+ # else
X  			case 'j':  wiz_help();  break;
X+ # endif
X  #endif
X  		}
X  	}
X  #ifdef MACOS
X  	SetVol((StringPtr)NULL, t->recordVRefNum);
X+ 	macflags |= fDoNonKeyEvt;
X  #endif
X  	return 0;
X  }
X***************
X*** 756,762 ****
X  
X  int
X  page_file(fnam, silent)	/* return: 0 - cannot open fnam; 1 - otherwise */
X! register char *fnam;
X  boolean silent;
X  {
X  #ifdef DEF_PAGER			/* this implies that UNIX is defined */
X--- 1072,1078 ----
X  
X  int
X  page_file(fnam, silent)	/* return: 0 - cannot open fnam; 1 - otherwise */
X! register const char *fnam;
X  boolean silent;
X  {
X  #ifdef DEF_PAGER			/* this implies that UNIX is defined */
X***************
X*** 798,809 ****
X  # ifdef MACOS
X  	if ((f = fopen (fnam, "r")) == (FILE *) 0)
X  		f = openFile(fnam, "r");
X- 	/* refresh screen kluge */
X  	if (!f) {
X- 		cls();
X- 		docrt();
X- 		clrlin();
X- 		ValidRect(&(**(*HackWindow).visRgn).rgnBBox);
X  # else
X  	if ((f = fopen (fnam, "r")) == (FILE *) 0) {
X  # endif
X--- 1114,1120 ----
X***************
X*** 887,889 ****
X--- 1198,1202 ----
X  }
X  #endif
X  #endif /* UNIX /**/
X+ 
X+ #endif /* OVLB */
X*** src/Old/panic.c	Mon Feb 19 18:50:31 1990
X--- src/panic.c	Wed Jan 17 23:02:40 1990
X***************
X*** 6,12 ****
X   */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X- /* #define MAKEDEFS_C	1   /* define for Macs */
X  #define NEED_VARARGS
X  #include	"config.h"
X  
X--- 6,11 ----
X*** src/Old/pickup.c	Mon Feb 19 18:50:45 1990
X--- src/pickup.c	Mon Feb 19 10:17:32 1990
X***************
X*** 7,14 ****
X   */
X  
X  #include	"hack.h"
X  
X! void explode_bag();
X  
X  void
X  pickup(all)
X--- 7,28 ----
X   */
X  
X  #include	"hack.h"
X+ #ifndef OVERLAY
X+ static int FDECL(in_container,(struct obj *));
X+ static int FDECL(ck_container,(struct obj *));
X+ static int FDECL(ck_bag,(struct obj *));
X+ static int FDECL(out_container,(struct obj *));
X+ #else
X+ int FDECL(in_container,(struct obj *));
X+ int FDECL(ck_container,(struct obj *));
X+ int FDECL(ck_bag,(struct obj *));
X+ int FDECL(out_container,(struct obj *));
X+ #endif
X+ void FDECL(explode_bag,(struct obj *));
X+ 
X+ #ifdef OVLB
X  
X! static const char nearloadmsg[] = "have a little trouble lifting";
X  
X  void
X  pickup(all)
X***************
X*** 33,42 ****
X  	dummygold.cobj = 0;
X  
X  	if(Levitation) {
X! 		if (multi || (all && !flags.pickup)) read_engr_at(u.ux,u.uy);
X  		return;
X  	}
X! 	if (multi || (all && !flags.pickup)) {
X  		int ct = 0;
X  
X  		for (obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X--- 47,61 ----
X  	dummygold.cobj = 0;
X  
X  	if(Levitation) {
X! 		if ((multi && !flags.run) || (all && !flags.pickup))
X! 			read_engr_at(u.ux,u.uy);
X  		return;
X  	}
X! 	/* multi && !flags.run means they are in the middle of some other
X! 	 * action, or possibly paralyzed, sleeping, etc.... and they just
X! 	 * teleported onto the object.  They shouldn't pick it up.
X! 	 */
X! 	if ((multi && !flags.run) || (all && !flags.pickup)) {
X  		int ct = 0;
X  
X  		for (obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X***************
X*** 172,185 ****
X  			continue;
X  		    }
X  		    if (gold_capacity >= gold->amount) {
X  			pline("%ld gold piece%s.",
X  				gold->amount, plur(gold->amount));
X- 			u.ugold += gold->amount;
X  			freegold(gold);
X  			if(Invisible) newsym(u.ux,u.uy);
X  		    } else {
X! 	pline("You can only carry %s of the %ld gold pieces lying here.",
X  			    gold_capacity == 1L ? "one" : "some", gold->amount);
X  			pline("%ld gold piece%s.",
X  				 gold_capacity, plur(gold_capacity));
X  			u.ugold += gold_capacity;
X--- 191,207 ----
X  			continue;
X  		    }
X  		    if (gold_capacity >= gold->amount) {
X+ 			u.ugold += gold->amount;
X+ 			if (inv_weight() > -5)
X+ 				You(nearloadmsg);
X  			pline("%ld gold piece%s.",
X  				gold->amount, plur(gold->amount));
X  			freegold(gold);
X  			if(Invisible) newsym(u.ux,u.uy);
X  		    } else {
X! 		You("can only carry %s of the %ld gold pieces lying here.",
X  			    gold_capacity == 1L ? "one" : "some", gold->amount);
X+ 			You(nearloadmsg);
X  			pline("%ld gold piece%s.",
X  				 gold_capacity, plur(gold_capacity));
X  			u.ugold += gold_capacity;
X***************
X*** 199,204 ****
X--- 221,227 ----
X  		    pline("Touching the dead cockatrice is a fatal mistake.");
X  		    You("turn to stone.");
X  		    You("die...");
X+ 		    killer_format = KILLED_BY_AN;
X  		    killer = "cockatrice corpse";
X  		    done(STONING);
X  		}
X***************
X*** 213,219 ****
X  			if(!(objects[SCR_SCARE_MONSTER].oc_name_known) &&
X  			   !(objects[SCR_SCARE_MONSTER].oc_uname))
X  				docall(obj);
X! 		    delobj(obj);
X  		    continue;
X  		  }
X  		}
X--- 236,242 ----
X  			if(!(objects[SCR_SCARE_MONSTER].oc_name_known) &&
X  			   !(objects[SCR_SCARE_MONSTER].oc_uname))
X  				docall(obj);
X! 		    useupf(obj);
X  		    continue;
X  		  }
X  		}
X***************
X*** 222,228 ****
X  		if(obj == uchain)
X  			continue;
X  
X! 		wt = inv_weight() + obj->owt;
X  		if (obj->otyp == LOADSTONE)
X  			goto lift_some; /* pick it up even if too heavy */
X  #ifdef POLYSELF
X--- 245,251 ----
X  		if(obj == uchain)
X  			continue;
X  
X! 		wt = inv_weight() + (int)obj->owt;
X  		if (obj->otyp == LOADSTONE)
X  			goto lift_some; /* pick it up even if too heavy */
X  #ifdef POLYSELF
X***************
X*** 277,283 ****
X  		  int mergquan;
X  
X  		  obj = pick_obj(obj);
X! 		  if(wt > -5) You("have a little trouble lifting");
X  		  if(!Blind) obj->dknown = 1;
X  		  mergquan = obj->quan;
X  		  obj->quan = pickquan; /* to fool prinv() */
X--- 300,306 ----
X  		  int mergquan;
X  
X  		  obj = pick_obj(obj);
X! 		  if(wt > -5) You(nearloadmsg);
X  		  if(!Blind) obj->dknown = 1;
X  		  mergquan = obj->quan;
X  		  obj->quan = pickquan; /* to fool prinv() */
X***************
X*** 294,300 ****
X  pick_obj(otmp)
X  register struct obj *otmp;
X  {
X! 	addtobill(otmp, TRUE);       /* sets obj->unpaid if necessary */
X  	freeobj(otmp);
X  	if(Invisible) newsym(u.ux,u.uy);
X  	return(addinv(otmp));    /* might merge it with other objects */
X--- 317,324 ----
X  pick_obj(otmp)
X  register struct obj *otmp;
X  {
X! 	if (otmp != uball)	     /* don't charge for this - kd, 1/17/90 */
X! 		addtobill(otmp, TRUE);       /* sets obj->unpaid if necessary */
X  	freeobj(otmp);
X  	if(Invisible) newsym(u.ux,u.uy);
X  	return(addinv(otmp));    /* might merge it with other objects */
X***************
X*** 307,313 ****
X  	register int c;
X  
X  	if (Levitation) {
X! 		pline("You cannot reach the floor.");
X  		return(0);
X  	}
X  	for(cobj = level.objects[u.ux][u.uy]; cobj; cobj = cobj->nexthere) {
X--- 331,337 ----
X  	register int c;
X  
X  	if (Levitation) {
X! 		You("cannot reach the floor.");
X  		return(0);
X  	}
X  	for(cobj = level.objects[u.ux][u.uy]; cobj; cobj = cobj->nexthere) {
X***************
X*** 327,333 ****
X  
X  			You("carefully open the bag...");
X  			pline("It develops a huge set of teeth and bites you!");
X! 			losehp(rnd(10), "carnivorous bag");
X  			makeknown(BAG_OF_TRICKS);
X  			continue;
X  		    }
X--- 351,357 ----
X  
X  			You("carefully open the bag...");
X  			pline("It develops a huge set of teeth and bites you!");
X! 			losehp(rnd(10), "carnivorous bag", KILLED_BY_AN);
X  			makeknown(BAG_OF_TRICKS);
X  			continue;
X  		    }
X***************
X*** 334,339 ****
X--- 358,364 ----
X  
X  		    You("carefully open the %s...", xname(cobj));
X  		    if(cobj->otrapped) chest_trap(cobj, FINGER);
X+ 		    if(multi < 0) return 0; /* a paralysis trap */
X  
X  		    use_container(cobj, 0);
X  		}
X***************
X*** 347,361 ****
X  #define Icebox (current_container->otyp == ICE_BOX)
X  int baggone;	/* used in askchain so bag isn't used after explosion */
X  
X  void
X  inc_cwt(cobj, obj)
X  register struct obj *cobj, *obj;
X  {
X  	if (cobj->otyp == BAG_OF_HOLDING)
X! 		cobj->owt += (obj->cursed?(obj->owt*2):(obj->owt/(obj->blessed?4:2)) + 1);
X  	else	cobj->owt += obj->owt;
X  }
X  
X  #ifndef OVERLAY
X  static 
X  #endif
X--- 372,392 ----
X  #define Icebox (current_container->otyp == ICE_BOX)
X  int baggone;	/* used in askchain so bag isn't used after explosion */
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  inc_cwt(cobj, obj)
X  register struct obj *cobj, *obj;
X  {
X  	if (cobj->otyp == BAG_OF_HOLDING)
X! 		cobj->owt += (cobj->cursed?(obj->owt*2):(obj->owt/(cobj->blessed?4:2)) + 1);
X  	else	cobj->owt += obj->owt;
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  #ifndef OVERLAY
X  static 
X  #endif
X***************
X*** 363,368 ****
X--- 394,401 ----
X  in_container(obj)
X  register struct obj *obj;
X  {
X+ 	char buf[BUFSZ];
X+ 
X  	if(obj == uball || obj == uchain) {
X  		You("must be kidding.");
X  		return(0);
X***************
X*** 394,400 ****
X  	/* magic bag -> magic bag will self destruct later on. */
X  	if(Is_container(obj) && Is_container(current_container) &&
X  	    (!Is_mbag(obj) || !Is_mbag(current_container))) {
X! 		pline("It won't go in.");
X  		return(1);	/* be careful! */
X  	}
X  	if(obj == uwep) {
X--- 427,433 ----
X  	/* magic bag -> magic bag will self destruct later on. */
X  	if(Is_container(obj) && Is_container(current_container) &&
X  	    (!Is_mbag(obj) || !Is_mbag(current_container))) {
X! 		pline("The %s won't go in.", xname(obj));
X  		return(1);	/* be careful! */
X  	}
X  	if(obj == uwep) {
X***************
X*** 407,413 ****
X  	}
X  #ifdef WALKIES
X  	if(obj->otyp == LEASH && obj->leashmon != 0) {
X! 		pline("It is attached to your pet.");
X  		return(0);
X  	}
X  #endif
X--- 440,446 ----
X  	}
X  #ifdef WALKIES
X  	if(obj->otyp == LEASH && obj->leashmon != 0) {
X! 		pline("The %s is attached to your pet.", xname(obj));
X  		return(0);
X  	}
X  #endif
X***************
X*** 417,422 ****
X--- 450,457 ----
X  	obj->cobj = current_container;
X  	obj->nobj = fcobj;
X  	fcobj = obj;
X+ 	Strcpy(buf, xname(obj->cobj));
X+ 	You("put %s into the %s.", doname(obj), buf);
X  
X  	if(Icebox) obj->age = monstermoves - obj->age; /* actual age */
X  
X***************
X*** 425,431 ****
X  		 (obj->otyp == WAN_CANCELLATION && (obj->spe > 0)) )) {
X  		explode_bag(obj);
X  		You("are blasted by a magical explosion!");
X! 		losehp(d(6,6),"magical explosion");
X  		baggone = 1;
X  	}
X  	return(1);
X--- 460,466 ----
X  		 (obj->otyp == WAN_CANCELLATION && (obj->spe > 0)) )) {
X  		explode_bag(obj);
X  		You("are blasted by a magical explosion!");
X! 		losehp(d(6,6),"magical explosion", KILLED_BY_AN);
X  		baggone = 1;
X  	}
X  	return(1);
X***************
X*** 441,451 ****
X  	return(obj->cobj == current_container);
X  }
X  
X  #ifndef OVERLAY
X  static 
X  #endif
X  int
X! ck_bag()
X  {
X  	return(!baggone);
X  }
X--- 476,490 ----
X  	return(obj->cobj == current_container);
X  }
X  
X+ /* ck_bag() needs a formal argument to make the overlay/prototype mechanism
X+  * work right */
X+ /*ARGSUSED*/
X  #ifndef OVERLAY
X  static 
X  #endif
X  int
X! ck_bag(obj)
X! struct obj *obj;
X  {
X  	return(!baggone);
X  }
X***************
X*** 458,468 ****
X--- 497,521 ----
X  register struct obj *obj;
X  {
X  	register struct obj *otmp;
X+ 	register boolean near_capacity = (inv_weight() > -5);
X  
X  	if(inv_cnt() >= 52) {
X  		pline("You have no room to hold anything else.");
X  		return(0);
X  	}
X+ 	if(obj->otyp != LOADSTONE && inv_weight() + (int)obj->owt > 0) {
X+ 		char buf[BUFSZ];
X+ 
X+ 		Strcpy(buf, doname(obj));
X+ 		pline("There %s %s in the %s, but %s.",
X+ 			obj->quan==1 ? "is" : "are",
X+ 			buf, xname(current_container),
X+ 			invent ? "you cannot carry any more"
X+ 			: "it is too heavy for you to carry");
X+ 		/* "too heavy for you to lift" is not right if you're carrying
X+ 		   the container... */
X+ 		return(0);
X+ 	}
X  	if(obj == fcobj) fcobj = fcobj->nobj;
X  	else {
X  		for(otmp = fcobj; otmp->nobj != obj; otmp = otmp->nobj)
X***************
X*** 476,481 ****
X--- 529,536 ----
X  	/* simulated point of time */
X  
X  	(void) addinv(obj);
X+ 	if (near_capacity) You("have a little trouble removing");
X+ 	prinv(obj);
X  	return 0;
X  }
X  
X***************
X*** 608,616 ****
X  register struct obj *cobj, *obj;
X  {
X  	if (Is_mbag(cobj))
X! 		cobj->owt -= (obj->owt/2 + 1);
X  	else	cobj->owt -= obj->owt;
X  
X  	if(cobj->owt < objects[cobj->otyp].oc_weight)
X  		cobj->owt = objects[cobj->otyp].oc_weight;
X  }
X--- 663,673 ----
X  register struct obj *cobj, *obj;
X  {
X  	if (Is_mbag(cobj))
X! 		cobj->owt -= (cobj->cursed?(obj->owt*2):(obj->owt/(cobj->blessed?4:2)) + 1);
X  	else	cobj->owt -= obj->owt;
X  
X  	if(cobj->owt < objects[cobj->otyp].oc_weight)
X  		cobj->owt = objects[cobj->otyp].oc_weight;
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/polyself.c	Mon Feb 19 18:51:14 1990
X--- src/polyself.c	Wed Feb 14 17:54:16 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)polyself.c 3.0	89/11/19
X  /* Polymorph self routine.  Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)polyself.c 3.0	89/11/21
X  /* Polymorph self routine.  Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,16 ****
X  #include "hack.h"
X  
X  #ifdef POLYSELF
X! static void break_armor(), drop_weapon();
X! static void skinback();
X! static void uunstick();
X  static boolean sticky;
X  #endif
X  
X  void
X  newman()
X  {
X--- 5,21 ----
X  #include "hack.h"
X  
X  #ifdef POLYSELF
X! static void NDECL(break_armor);
X! static void FDECL(drop_weapon,(int));
X! static void NDECL(skinback);
X! static void NDECL(uunstick);
X! #ifdef OVLB
X  static boolean sticky;
X+ #endif /* OVLB */
X  #endif
X  
X+ #ifdef OVLB
X+ 
X  void
X  newman()
X  {
X***************
X*** 20,28 ****
X  	if (!rn2(10)) {
X  		flags.female = !flags.female;
X  		max_rank_sz();
X! 		if (pl_character[0]=='P')
X! 			Strcpy(pl_character+6, flags.female?"ess":"");
X! 		if (pl_character[0]=='C')
X  			Strcpy(pl_character+5, flags.female ? "woman" : "man");
X  	}
X  #ifdef POLYSELF
X--- 25,33 ----
X  	if (!rn2(10)) {
X  		flags.female = !flags.female;
X  		max_rank_sz();
X! 		if (pl_character[0] == 'P')
X! 			Strcpy(pl_character+6, flags.female ? "ess" : "");
X! 		if (pl_character[0] == 'C')
X  			Strcpy(pl_character+5, flags.female ? "woman" : "man");
X  	}
X  #ifdef POLYSELF
X***************
X*** 42,49 ****
X  	if (u.ulevel > 127 || u.ulevel == 0) u.ulevel = 1;
X  	if (u.ulevel > MAXULEV) u.ulevel = MAXULEV;
X  
X! 	for(tmp = u.ulevel; tmp != tmp2; tmp += (tmp2 < u.ulevel) ? -1 : 1)
X! 		adjabil((tmp2 > u.ulevel) ? -1 : 1);
X  	tmp = u.uhpmax;
X  
X  	/* random experience points for the new experience level */
X--- 47,53 ----
X  	if (u.ulevel > 127 || u.ulevel == 0) u.ulevel = 1;
X  	if (u.ulevel > MAXULEV) u.ulevel = MAXULEV;
X  
X! 	adjabil(tmp2, (int)u.ulevel);
X  	tmp = u.uhpmax;
X  
X  	/* random experience points for the new experience level */
X***************
X*** 54,60 ****
X  /* If it was u.uhpmax*u.ulevel/tmp+9-rn2(19), then a 1st level character
X     with 16 hp who polymorphed into a 3rd level one would have an average
X     of 48 hp.  */
X! #ifndef LINT
X  	u.uhp = u.uhp * (long)u.uhpmax/tmp;
X  #endif
X  #ifdef SPELLS
X--- 58,66 ----
X  /* If it was u.uhpmax*u.ulevel/tmp+9-rn2(19), then a 1st level character
X     with 16 hp who polymorphed into a 3rd level one would have an average
X     of 48 hp.  */
X! #ifdef LINT
X! 	u.uhp = u.uhp + tmp;
X! #else
X  	u.uhp = u.uhp * (long)u.uhpmax/tmp;
X  #endif
X  #ifdef SPELLS
X***************
X*** 79,84 ****
X--- 85,91 ----
X  		} else {
X  #endif
X  		    Your("new form doesn't seem healthy enough to survive.");
X+ 		    killer_format = KILLED_BY_AN;
X  		    killer="unsuccessful polymorph";
X  		    done(DIED);
X  #ifdef POLYSELF
X***************
X*** 107,114 ****
X--- 114,131 ----
X  		regularize(SAVEF+7);
X  		Strcat(SAVEF, ";1");
X  #else
X+ # ifdef MSDOS
X+ 		(void)strcpy(SAVEF, SAVEP);
X+ 		{
X+ 			int i = strlen(SAVEF);
X+ 			(void)strncat(SAVEF, plname, 8);
X+ 			regularize(SAVEF+i);
X+ 		}
X+ 		(void)strcat(SAVEF, ".sav");
X+ # else
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X+ # endif
X  #endif
X  #ifdef WIZARD
X  	}
X***************
X*** 141,147 ****
X  	if(!Polymorph_control && !draconian && !iswere && !isvamp) {
X  	    if (rn2(20) > ACURR(A_CON)) {
X  		You("shudder for a moment.");
X! 		losehp(rn2(30),"system shock");
X  		return;
X  	    }
X  	}
X--- 158,164 ----
X  	if(!Polymorph_control && !draconian && !iswere && !isvamp) {
X  	    if (rn2(20) > ACURR(A_CON)) {
X  		You("shudder for a moment.");
X! 		losehp(rn2(30),"system shock", KILLED_BY_AN);
X  		return;
X  	    }
X  	}
X***************
X*** 200,207 ****
X  	if (!uarmg) selftouch("No longer petrify-resistant, you");
X  	if (Inhell && !Fire_resistance) {
X  	    You("burn to a crisp.");
X! 	    killer = "unwise polymorph";
X! 	    done(BURNING);
X  	}
X  }
X  
X--- 217,228 ----
X  	if (!uarmg) selftouch("No longer petrify-resistant, you");
X  	if (Inhell && !Fire_resistance) {
X  	    You("burn to a crisp.");
X! 	    killer_format = KILLED_BY;
X! 	    killer = "losing fire resistance after polymorphing";
X! 	    while(1) {
X! 		done(BURNING);
X! 		You("continue burning.");
X! 	    }
X  	}
X  }
X  
X***************
X*** 284,307 ****
X  	/* Low level characters can't become high level monsters for long */
X  		u.mtimedone = u.mtimedone * u.ulevel / mons[mntmp].mlevel;
X  	flags.botl = 1;
X! 	if (can_breathe(uasmon))
X! 		pline("Use the command #monster for breath weapon.");
X! 	if (attacktype(uasmon, AT_SPIT))
X  		pline("Use the command #monster to spit venom.");
X! 	if (u.usym == S_NYMPH)
X! 		pline("Use the command #monster if you have to remove an iron ball.");
X! 	if (u.usym == S_UMBER)
X  		pline("Use the command #monster to confuse monsters.");
X! 	if (is_hider(uasmon))
X  		pline("Use the command #monster to hide.");
X! 	if (is_were(uasmon))
X  		pline("Use the command #monster to summon help.");
X! 	if (webmaker(uasmon))
X  		pline("Use the command #monster to spin a web.");
X! 	if (u.usym == S_UNICORN)
X  		pline("Use the command #monster to use your horn.");
X! 	if (lays_eggs(uasmon) || u.umonnum == PM_QUEEN_BEE)
X  		pline("Use the command #sit to lay an egg.");
X  	find_ac();
X  	return(1);
X  }
X--- 305,330 ----
X  	/* Low level characters can't become high level monsters for long */
X  		u.mtimedone = u.mtimedone * u.ulevel / mons[mntmp].mlevel;
X  	flags.botl = 1;
X! 	if (flags.verbose) {
X! 	    if (can_breathe(uasmon))
X! 		pline("Use the command #monster to use your breath weapon.");
X! 	    if (attacktype(uasmon, AT_SPIT))
X  		pline("Use the command #monster to spit venom.");
X! 	    if (u.usym == S_NYMPH)
X! 		pline("Use the command #monster to remove an iron ball.");
X! 	    if (u.usym == S_UMBER)
X  		pline("Use the command #monster to confuse monsters.");
X! 	    if (is_hider(uasmon))
X  		pline("Use the command #monster to hide.");
X! 	    if (is_were(uasmon))
X  		pline("Use the command #monster to summon help.");
X! 	    if (webmaker(uasmon))
X  		pline("Use the command #monster to spin a web.");
X! 	    if (u.usym == S_UNICORN)
X  		pline("Use the command #monster to use your horn.");
X! 	    if (lays_eggs(uasmon) || u.umonnum == PM_QUEEN_BEE)
X  		pline("Use the command #sit to lay an egg.");
X+ 	}
X  	find_ac();
X  	return(1);
X  }
X***************
X*** 312,317 ****
X--- 335,341 ----
X  
X       if (breakarm(uasmon)) {
X  	if (otmp = uarm) {
X+ 		if (donning(otmp)) cancel_don();
X  		You("break out of your armor!");
X  		(void) Armor_gone();
X  		useup(otmp);
X***************
X*** 329,334 ****
X--- 353,359 ----
X  #endif
X       } else if (sliparm(uasmon)) {
X  	if (otmp = uarm) {
X+ 		if (donning(otmp)) cancel_don();
X  		Your("armor falls around you!");
X  		(void) Armor_gone();
X  		dropx(otmp);
X***************
X*** 348,358 ****
X       }
X       if (nohands(uasmon) || verysmall(uasmon)) {
X  	  if (otmp = uarmg) {
X  	       /* Drop weapon along with gloves */
X  	       You("drop your gloves%s!", uwep ? " and weapon" : "");
X  	       (void) Gloves_off();
X  	       dropx(otmp);
X- 	       drop_weapon(0);
X  	  }
X  	  if (otmp = uarms) {
X  	       You("can no longer hold your shield!");
X--- 373,384 ----
X       }
X       if (nohands(uasmon) || verysmall(uasmon)) {
X  	  if (otmp = uarmg) {
X+ 	       if (donning(otmp)) cancel_don();
X  	       /* Drop weapon along with gloves */
X  	       You("drop your gloves%s!", uwep ? " and weapon" : "");
X+ 	       drop_weapon(0);
X  	       (void) Gloves_off();
X  	       dropx(otmp);
X  	  }
X  	  if (otmp = uarms) {
X  	       You("can no longer hold your shield!");
X***************
X*** 360,370 ****
X--- 386,398 ----
X  	       dropx(otmp);
X  	  }
X  	  if (otmp = uarmh) {
X+ 	       if (donning(otmp)) cancel_don();
X  	       Your("helmet falls to the floor!");
X  	       (void) Helmet_off();
X  	       dropx(otmp);
X  	  }
X  	  if (otmp = uarmf) {
X+ 	       if (donning(otmp)) cancel_don();
X  	       Your("boots %s off your feet!",
X  			verysmall(uasmon) ? "slide" : "are pushed");
X  	       (void) Boots_off();
X***************
X*** 403,415 ****
X  	u.umonnum = -1;
X  	skinback();
X  	set_uasmon();
X! 	You("return to %sn form!",(pl_character[0]=='E')?"elve":"huma");
X  
X  	if (u.uhp < 1)	done(DIED);
X  	if (!Fire_resistance && Inhell) {
X  	    You("burn to a crisp.");
X! 	    killer = "dissipating polymorph spell";
X! 	    done(BURNING);
X  	}
X  	if (!uarmg) selftouch("No longer petrify-resistant, you");
X  	if (sticky) uunstick();
X--- 431,447 ----
X  	u.umonnum = -1;
X  	skinback();
X  	set_uasmon();
X! 	You("return to %sn form!", (pl_character[0] == 'E')? "elve" : "huma");
X  
X  	if (u.uhp < 1)	done(DIED);
X  	if (!Fire_resistance && Inhell) {
X  	    You("burn to a crisp.");
X! 	    killer_format = KILLED_BY;
X! 	    killer = "losing fire resistance after rehumanization";
X! 	    while(1) {
X! 		done(BURNING);
X! 		You("continue burning.");
X! 	    }
X  	}
X  	if (!uarmg) selftouch("No longer petrify-resistant, you");
X  	if (sticky) uunstick();
X***************
X*** 470,478 ****
X  	}
X  	if (u.uswallow) {
X  		You("release web fluid inside %s.", mon_nam(u.ustuck));
X! 		pline("%s regurgitates you!", Monnam(u.ustuck));
X! 		regurgitates(u.ustuck);
X! 		return(1);
X  	}
X  	if (u.utrap) {
X  		You("cannot spin webs while stuck in a trap.");
X--- 502,541 ----
X  	}
X  	if (u.uswallow) {
X  		You("release web fluid inside %s.", mon_nam(u.ustuck));
X! 		if (is_animal(u.ustuck->data)) {
X! 			expels(u.ustuck, u.ustuck->data, TRUE);
X! 			return(0);
X! 		}
X! 		if (is_whirly(u.ustuck->data)) {
X! 			int i;
X! 
X! 			for (i = 0; i < NATTK; i++)
X! 				if (u.ustuck->data->mattk[i].aatyp == AT_ENGL)
X! 					break;
X! 			if (i == NATTK)
X! 			       impossible("Swallower has no engulfing attack?");
X! 			else {
X! 				char sweep[30];
X! 
X! 				sweep[0] = '\0';
X! 				switch(u.ustuck->data->mattk[i].adtyp) {
X! 					case AD_FIRE:
X! 						Strcpy(sweep, "ignites and ");
X! 						break;
X! 					case AD_ELEC:
X! 						Strcpy(sweep, "fries and ");
X! 						break;
X! 					case AD_COLD:
X! 						Strcpy(sweep,
X! 						      "freezes, shatters and ");
X! 						break;
X! 				}
X! 				pline("The web %sis swept away!", sweep);
X! 			}
X! 			return(0);
X! 		}		     /* default: a nasty jelly-like creature */ 
X! 		pline("The web dissolves into %s.", mon_nam(u.ustuck));
X! 		return(0);
X  	}
X  	if (u.utrap) {
X  		You("cannot spin webs while stuck in a trap.");
X***************
X*** 495,501 ****
X  			Your("webbing vanishes!");
X  			return(0);
X  		case TRAPDOOR: if (!is_maze_lev) {
X! 				You("web over the trapdoor.");
X  				deltrap(ttmp);
X  				if (Invisible) newsym(u.ux, u.uy);
X  				return 1;
X--- 558,564 ----
X  			Your("webbing vanishes!");
X  			return(0);
X  		case TRAPDOOR: if (!is_maze_lev) {
X! 				You("web over the trap door.");
X  				deltrap(ttmp);
X  				if (Invisible) newsym(u.ux, u.uy);
X  				return 1;
X***************
X*** 516,522 ****
X  			dotrap(ttmp);
X  			return(1);
X  		default:
X! 			impossible("Webbing over trap type %d?",ttmp->ttyp);
X  			return(0);
X  	}
X  	ttmp = maketrap(u.ux, u.uy, WEB);
X--- 579,585 ----
X  			dotrap(ttmp);
X  			return(1);
X  		default:
X! 			impossible("Webbing over trap type %d?", ttmp->ttyp);
X  			return(0);
X  	}
X  	ttmp = maketrap(u.ux, u.uy, WEB);
X***************
X*** 554,560 ****
X  		else if (mtmp->mimic)
X  		    continue;
X  		else if (flags.safe_dog && !Confusion && !Hallucination
X- 		  && (mtmp->data->mlet == S_DOG || mtmp->data->mlet == S_FELINE)
X  		  && mtmp->mtame) {
X  		    if (mtmp->mnamelth)
X  			You("avoid gazing at %s.", NAME(mtmp));
X--- 617,622 ----
X***************
X*** 564,576 ****
X  		} else {
X  		    if (flags.confirm && mtmp->mpeaceful && !Confusion
X  							&& !Hallucination) {
X  			pline("Really confuse %s? ", mon_nam(mtmp));
X  			(void) fflush(stdout);
X  			if (yn() != 'y') continue;
X  			setmangry(mtmp);
X  		    }
X! 		    if (mtmp->mfroz || mtmp->mstun || mtmp->msleep ||
X! 							mtmp->mblinded)
X  			continue;
X  		    if (!mtmp->mconf)
X  			Your("gaze confuses %s!", mon_nam(mtmp));
X--- 626,645 ----
X  		} else {
X  		    if (flags.confirm && mtmp->mpeaceful && !Confusion
X  							&& !Hallucination) {
X+ #ifdef MACOS
X+ 			char mac_tbuf[80];
X+ 			if(!flags.silent) SysBeep(1);
X+ 			sprintf(mac_tbuf, "Really confuse %s?", mon_nam(mtmp));
X+ 			if(UseMacAlertText(128, mac_tbuf) != 1) continue;
X+ #else
X  			pline("Really confuse %s? ", mon_nam(mtmp));
X  			(void) fflush(stdout);
X  			if (yn() != 'y') continue;
X+ #endif
X  			setmangry(mtmp);
X  		    }
X! 		    if (!mtmp->mcanmove || mtmp->mstun || mtmp->msleep ||
X! 							!mtmp->mcansee)
X  			continue;
X  		    if (!mtmp->mconf)
X  			Your("gaze confuses %s!", mon_nam(mtmp));
X***************
X*** 588,594 ****
X  		    }
X  #ifdef MEDUSA
X  		    if ((mtmp->data==&mons[PM_MEDUSA]) && !mtmp->mcan) {
X! 			pline("Gazing at an awake medusa is not a very good idea...");
X  			/* as if gazing at a sleeping anything is fruitful... */
X  			You("turn to stone...");
X  			done(STONING);
X--- 657,663 ----
X  		    }
X  #ifdef MEDUSA
X  		    if ((mtmp->data==&mons[PM_MEDUSA]) && !mtmp->mcan) {
X! 			pline("Gazing at the awake Medusa is not a very good idea.");
X  			/* as if gazing at a sleeping anything is fruitful... */
X  			You("turn to stone...");
X  			done(STONING);
X***************
X*** 605,611 ****
X  dohide()
X  {
X  	if (u.uundetected || u.usym == S_MIMIC_DEF) {
X! 		pline("You are already hiding.");
X  		return(0);
X  	}
X  	if (u.usym == S_MIMIC) {
X--- 674,680 ----
X  dohide()
X  {
X  	if (u.uundetected || u.usym == S_MIMIC_DEF) {
X! 		You("are already hiding.");
X  		return(0);
X  	}
X  	if (u.usym == S_MIMIC) {
X***************
X*** 621,627 ****
X  static void
X  uunstick()
X  {
X! 	kludge("%s is no longer in your clutches...", Monnam(u.ustuck));
X  	u.ustuck = 0;
X  }
X  
X--- 690,696 ----
X  static void
X  uunstick()
X  {
X! 	kludge("%s is no longer in your clutches.", Monnam(u.ustuck));
X  	u.ustuck = 0;
X  }
X  
X***************
X*** 636,642 ****
X  }
X  #endif
X  
X! char *
X  body_part(part)
X  int part;
X  {
X--- 705,711 ----
X  }
X  #endif
X  
X! const char *
X  body_part(part)
X  int part;
X  {
X***************
X*** 646,678 ****
X  	 */
X  	static const char *humanoid_parts[] = { "arm", "eye", "face", "finger",
X  		"fingertip", "foot", "hand", "handed", "head", "leg",
X! 		"light headed", "neck", "toe" };
X  #ifdef POLYSELF
X  	static const char *jelly_parts[] = { "pseudopod", "dark spot", "front",
X  		"pseudopod extension", "pseudopod extremity",
X  		"pseudopod root", "grasp", "grasped", "cerebral area",
X! 		"lower pseudopod", "viscous", "middle",
X  		"pseudopod extremity" },
X  	*animal_parts[] = { "forelimb", "eye", "face", "foreclaw", "claw tip",
X  		"rear claw", "foreclaw", "clawed", "head", "rear limb",
X! 		"light headed", "neck", "rear claw tip" },
X  	*horse_parts[] = { "forelimb", "eye", "face", "forehoof", "hoof tip",
X  		"rear hoof", "foreclaw", "hooved", "head", "rear limb",
X! 		"light headed", "neck", "rear hoof tip" },
X  	*sphere_parts[] = { "appendage", "optic nerve", "body", "tentacle",
X  		"tentacle tip", "lower appendage", "tentacle", "tentacled",
X! 		"body", "lower tentacle", "rotational", "equator",
X  		"lower tentacle tip" },
X  	*fungus_parts[] = { "mycelium", "visual area", "front", "hypha",
X  		"hypha", "root", "strand", "stranded", "cap area",
X! 		"rhizome", "sporulated", "stalk", "rhizome tip" },
X  	*vortex_parts[] = { "region", "eye", "front", "minor current",
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X! 		"edge" },
X  	*snake_parts[] = { "vestigial limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X! 		"head", "rear region", "light headed", "neck", "rear scale" };
X  	
X  	if (humanoid(uasmon) || (u.usym==S_CENTAUR && 
X  		(part==ARM || part==FINGER || part==FINGERTIP
X--- 715,748 ----
X  	 */
X  	static const char *humanoid_parts[] = { "arm", "eye", "face", "finger",
X  		"fingertip", "foot", "hand", "handed", "head", "leg",
X!                 "light headed", "neck", "spine", "toe" };
X  #ifdef POLYSELF
X  	static const char *jelly_parts[] = { "pseudopod", "dark spot", "front",
X  		"pseudopod extension", "pseudopod extremity",
X  		"pseudopod root", "grasp", "grasped", "cerebral area",
X! 		"lower pseudopod", "viscous", "middle", "surface",
X  		"pseudopod extremity" },
X  	*animal_parts[] = { "forelimb", "eye", "face", "foreclaw", "claw tip",
X  		"rear claw", "foreclaw", "clawed", "head", "rear limb",
X! 		"light headed", "neck", "spine", "rear claw tip" },
X  	*horse_parts[] = { "forelimb", "eye", "face", "forehoof", "hoof tip",
X  		"rear hoof", "foreclaw", "hooved", "head", "rear limb",
X! 		"light headed", "neck", "backbone", "rear hoof tip" },
X  	*sphere_parts[] = { "appendage", "optic nerve", "body", "tentacle",
X  		"tentacle tip", "lower appendage", "tentacle", "tentacled",
X! 		"body", "lower tentacle", "rotational", "equator", "body",
X  		"lower tentacle tip" },
X  	*fungus_parts[] = { "mycelium", "visual area", "front", "hypha",
X  		"hypha", "root", "strand", "stranded", "cap area",
X! 		"rhizome", "sporulated", "stalk", "root", "rhizome tip" },
X  	*vortex_parts[] = { "region", "eye", "front", "minor current",
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X! 		"currents", "edge" },
X  	*snake_parts[] = { "vestigial limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X! 		"head", "rear region", "light headed", "neck", "length",
X! 		"rear scale" };
X  	
X  	if (humanoid(uasmon) || (u.usym==S_CENTAUR && 
X  		(part==ARM || part==FINGER || part==FINGERTIP
X***************
X*** 681,687 ****
X  	if (u.usym==S_SNAKE || u.usym==S_NAGA || u.usym==S_WORM)
X  		return snake_parts[part];
X  	if (u.usym==S_EYE) return sphere_parts[part];
X! 	if (u.usym==S_JELLY || u.usym==S_PUDDING) return jelly_parts[part];
X  	if (u.usym==S_VORTEX || u.usym==S_ELEMENTAL) return vortex_parts[part];
X  	if (u.usym==S_FUNGUS) return fungus_parts[part];
X  	return animal_parts[part];
X--- 751,758 ----
X  	if (u.usym==S_SNAKE || u.usym==S_NAGA || u.usym==S_WORM)
X  		return snake_parts[part];
X  	if (u.usym==S_EYE) return sphere_parts[part];
X! 	if (u.usym==S_JELLY || u.usym==S_PUDDING || u.usym==S_BLOB)
X! 		return jelly_parts[part];
X  	if (u.usym==S_VORTEX || u.usym==S_ELEMENTAL) return vortex_parts[part];
X  	if (u.usym==S_FUNGUS) return fungus_parts[part];
X  	return animal_parts[part];
X***************
X*** 690,695 ****
X--- 761,769 ----
X  #endif
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  poly_gender()
X  {
X***************
X*** 709,725 ****
X   *	  or "lady" when polymorphed)
X   */
X  #ifdef POLYSELF
X! 	if (uasmon->mflags1 & M1_FEM) return 1;
X! #ifdef INFERNO
X! 	if (u.umonnum==PM_INCUBUS) return 0;
X! #endif
X  	if (!humanoid(uasmon)) return 2;
X  #endif
X  	return flags.female;
X  }
X  
X! #ifdef POLYSELF
X! #ifdef GOLEMS
X  void
X  ugolemeffects(damtype, dam)
X  int damtype, dam;
X--- 783,801 ----
X   *	  or "lady" when polymorphed)
X   */
X  #ifdef POLYSELF
X! 	if (uasmon->mflags2 & M2_FEM) return 1;
X! # ifdef INFERNO
X! 	if (u.umonnum == PM_INCUBUS) return 0;
X! # endif
X  	if (!humanoid(uasmon)) return 2;
X  #endif
X  	return flags.female;
X  }
X  
X! #endif /* OVL0 */
X! #ifdef OVLB
X! 
X! #if defined(POLYSELF) && defined(GOLEMS)
X  void
X  ugolemeffects(damtype, dam)
X  int damtype, dam;
X***************
X*** 746,750 ****
X  		pline("Strangely, you feel better than before.");
X  	}
X  }
X! #endif /* GOLEMS */
X! #endif
X--- 822,827 ----
X  		pline("Strangely, you feel better than before.");
X  	}
X  }
X! #endif /* POLYSELF && GOLEMS */
X! 
X! #endif /* OVLB */
X
END_OF_FILE
if test 56505 -ne `wc -c <'patch7.05'`; then
    echo shar: \"'patch7.05'\" unpacked with wrong size!
fi
# end of 'patch7.05'
echo shar: End of archive 6 \(of 30\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
