Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!swrinde!zaphod.mps.ohio-state.edu!think!mintaka!mit-eddie!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i030:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7dd
Message-ID: <5244@tekred.CNA.TEK.COM>
Date: 24 Feb 90 01:12:59 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2364
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 30
Archive-name: NetHack3/Patch7dd
Patch-To: NetHack3: Volume 7, Issue 56-93

	[This is the last part of patch #7. You should have 30 files,
	 Patch7a-Patch7z, Patch7aa-Patch7dd.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 30 (of 30)."
# Contents:  patch7.02
# Wrapped by billr@saab on Wed Feb 21 10:04:22 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.02' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.02'\" to \"'patch7.02.orig'\"
  mv -f 'patch7.02' 'patch7.02.orig'
fi
echo shar: Extracting \"'patch7.02'\" \(55250 characters\)
sed "s/^X//" >'patch7.02' <<'END_OF_FILE'
X*** src/Old/cmd.c	Mon Feb 19 17:55:04 1990
X--- src/cmd.c	Fri Feb  2 18:21:18 1990
X***************
X*** 6,92 ****
X  #include	"func_tab.h"
X  
X  #ifdef DUMB	/* stuff commented out in extern.h, but needed here */
X! extern int doapply(); /**/
X! extern int dorub(); /**/
X! extern int dojump(); /**/
X! extern int doextlist(); /**/
X! extern int dodrop(); /**/
X! extern int doddrop(); /**/
X! extern int dodown(); /**/
X! extern int doup(); /**/
X! extern int donull(); /**/
X! extern int dowipe(); /**/
X! extern int do_mname(); /**/
X! extern int ddocall(); /**/
X! extern int dotakeoff(); /**/
X! extern int doremring(); /**/
X! extern int dowear(); /**/
X! extern int doputon(); /**/
X! extern int doddoremarm(); /**/
X! extern int dokick(); /**/
X! extern int dothrow(); /**/
X! extern int doeat(); /**/
X! extern int done2(); /**/
X! extern int doengrave(); /**/
X! extern int dopickup(); /**/
X! extern int ddoinv(); /**/
X! extern int dotypeinv(); /**/
X! extern int dolook(); /**/
X! extern int doprgold(); /**/
X! extern int doprwep(); /**/
X! extern int doprarm(); /**/
X! extern int doprring(); /**/
X! extern int dopramulet(); /**/
X! extern int doprtool(); /**/
X! extern int dosuspend(); /**/
X! extern int doforce(); /**/
X! extern int doopen(); /**/
X! extern int doclose(); /**/
X! extern int dosh(); /**/
X! extern int dodiscovered(); /**/
X! extern int doset(); /**/
X! extern int dotogglepickup(); /**/
X! extern int dowhatis(); /**/
X! extern int dowhatdoes(); /**/
X! extern int dohelp(); /**/
X! extern int dohistory(); /**/
X! extern int doloot(); /**/
X! extern int dodrink(); /**/
X! extern int dodip(); /**/
X! extern int dosacrifice(); /**/
X! extern int dopray(); /**/
X! extern int doturn(); /**/
X! extern int doredraw(); /**/
X! extern int doread(); /**/
X! extern int dosave(); /**/
X! extern int dosave0(); /**/
X! extern int dosearch(); /**/
X  extern int FDECL(dosearch0, (int)); /**/
X! extern int doidtrap(); /**/
X! extern int dopay(); /**/
X! extern int dosit(); /**/
X! extern int dotalk(); /**/
X! extern int docast(); /**/
X! extern int dovspell(); /**/
X! extern int doredotopl(); /**/
X! extern int dotele(); /**/
X! extern int dountrap(); /**/
X! extern int doversion(); /**/
X! extern int dowield(); /**/
X! extern int dozap(); /**/
X  #endif /* DUMB */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int (*timed_occ_fn)();
X! #ifdef POLYSELF
X! #ifndef OVERLAY
X! static 
X  #endif
X! int domonability();
X  #endif
X  
X  /* Count down by decrementing multi */
X  #ifndef OVERLAY
X  static 
X--- 6,122 ----
X  #include	"func_tab.h"
X  
X  #ifdef DUMB	/* stuff commented out in extern.h, but needed here */
X! extern int NDECL(doapply); /**/
X! extern int NDECL(dorub); /**/
X! extern int NDECL(dojump); /**/
X! extern int NDECL(doextlist); /**/
X! extern int NDECL(dodrop); /**/
X! extern int NDECL(doddrop); /**/
X! extern int NDECL(dodown); /**/
X! extern int NDECL(doup); /**/
X! extern int NDECL(donull); /**/
X! extern int NDECL(dowipe); /**/
X! extern int NDECL(do_mname); /**/
X! extern int NDECL(ddocall); /**/
X! extern int NDECL(dotakeoff); /**/
X! extern int NDECL(doremring); /**/
X! extern int NDECL(dowear); /**/
X! extern int NDECL(doputon); /**/
X! extern int NDECL(doddoremarm); /**/
X! extern int NDECL(dokick); /**/
X! extern int NDECL(dothrow); /**/
X! extern int NDECL(doeat); /**/
X! extern int NDECL(done2); /**/
X! extern int NDECL(doengrave); /**/
X! extern int NDECL(dopickup); /**/
X! extern int NDECL(ddoinv); /**/
X! extern int NDECL(dotypeinv); /**/
X! extern int NDECL(dolook); /**/
X! extern int NDECL(doprgold); /**/
X! extern int NDECL(doprwep); /**/
X! extern int NDECL(doprarm); /**/
X! extern int NDECL(doprring); /**/
X! extern int NDECL(dopramulet); /**/
X! extern int NDECL(doprtool); /**/
X! extern int NDECL(dosuspend); /**/
X! extern int NDECL(doforce); /**/
X! extern int NDECL(doopen); /**/
X! extern int NDECL(doclose); /**/
X! extern int NDECL(dosh); /**/
X! extern int NDECL(dodiscovered); /**/
X! extern int NDECL(doset); /**/
X! extern int NDECL(dotogglepickup); /**/
X! extern int NDECL(dowhatis); /**/
X! extern int NDECL(dowhatdoes); /**/
X! extern int NDECL(dohelp); /**/
X! extern int NDECL(dohistory); /**/
X! extern int NDECL(doloot); /**/
X! extern int NDECL(dodrink); /**/
X! extern int NDECL(dodip); /**/
X! extern int NDECL(dosacrifice); /**/
X! extern int NDECL(dopray); /**/
X! extern int NDECL(doturn); /**/
X! extern int NDECL(doredraw); /**/
X! extern int NDECL(doread); /**/
X! extern int NDECL(dosave); /**/
X! extern int NDECL(dosave0); /**/
X! extern int NDECL(dosearch); /**/
X  extern int FDECL(dosearch0, (int)); /**/
X! extern int NDECL(doidtrap); /**/
X! extern int NDECL(dopay); /**/
X! extern int NDECL(dosit); /**/
X! extern int NDECL(dotalk); /**/
X! extern int NDECL(docast); /**/
X! extern int NDECL(dovspell); /**/
X! extern int NDECL(doredotopl); /**/
X! extern int NDECL(dotele); /**/
X! extern int NDECL(dountrap); /**/
X! extern int NDECL(doversion); /**/
X! extern int NDECL(doextversion); /**/
X! extern int NDECL(dowield); /**/
X! extern int NDECL(dozap); /**/
X  #endif /* DUMB */
X  
X! #ifdef OVL1
X! 
X! static int NDECL((*timed_occ_fn));
X! 
X! #endif /* OVL1 */
X! 
X! #ifndef OVERLAY
X! static int NDECL(timed_occupation);
X! static int NDECL(doextcmd);
X! # ifdef POLYSELF
X! static int NDECL(domonability);
X! # endif
X! # ifdef WIZARD
X! static int NDECL(wiz_wish);
X! static int NDECL(wiz_identify);
X! static int NDECL(wiz_map);
X! static int NDECL(wiz_genesis);
X! static int NDECL(wiz_where);
X! static int NDECL(wiz_detect);
X! static int NDECL(wiz_level_tele);
X! # endif
X! # ifdef EXPLORE_MODE
X! static int NDECL(enter_explore_mode);
X! # endif
X! # if defined(WIZARD) || defined(EXPLORE_MODE)
X! static int NDECL(wiz_attributes);
X! # endif
X! #endif /* OVERLAY */
X! 
X! #ifdef REDO
X! static char NDECL(popch);
X  #endif
X! 
X! #ifdef STUPID_CPP
X! static char FDECL(unctrl, (CHAR_P));
X! static char FDECL(unmeta, (CHAR_P));
X  #endif
X  
X+ #ifdef OVL1
X+ 
X  /* Count down by decrementing multi */
X  #ifndef OVERLAY
X  static 
X***************
X*** 124,131 ****
X   */
X  void
X  set_occupation(fn, txt, xtime)
X! int (*fn)();
X! char *txt;
X  int xtime;
X  {
X  	if (xtime) {
X--- 154,161 ----
X   */
X  void
X  set_occupation(fn, txt, xtime)
X! int NDECL((*fn));
X! const char *txt;
X  int xtime;
X  {
X  	if (xtime) {
X***************
X*** 199,204 ****
X--- 229,237 ----
X  }
X  #endif /* REDO */
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifndef OVERLAY
X  static 
X  #endif
X***************
X*** 278,283 ****
X--- 311,346 ----
X  }
X  #endif
X  
X+ #ifdef EXPLORE_MODE
X+ #ifndef OVERLAY
X+ static 
X+ #endif
X+ int
X+ enter_explore_mode()
X+ {
X+ 	if(!discover && !wizard) {
X+ 		pline("Beware!  From discovery mode there will be no return to normal game.");
X+ 		more();
X+ #ifndef MACOS
X+ 		pline("Do you want to enter discovery mode? ");
X+ 	 	if(yn() == 'y') {
X+ #else
X+ 		if(!flags.silent) SysBeep(1);
X+ 		if(UseMacAlertText(128, "Enter discovery mode ?") == 1) {
X+ #endif
X+ 			clrlin();
X+ 			pline("You are now in non-scoring discovery mode.");
X+ 			discover = TRUE;
X+ 		}
X+ 		else {
X+ 			clrlin();
X+ 			pline("Resuming normal game.");
X+ 		}
X+ 	}
X+ 	return 0;
X+ }
X+ #endif
X+ 
X  #ifdef WIZARD
X  #ifndef OVERLAY
X  static 
X***************
X*** 462,468 ****
X  	}
X  #ifdef WIZARD
X  	if (wizard) {
X! 		Sprintf(buf, "Your luck is %d.", u.uluck);
X  		cornline(1, buf);
X  	}
X  #endif
X--- 525,531 ----
X  	}
X  #ifdef WIZARD
X  	if (wizard) {
X! 		Sprintf(buf, "Your luck is %d.", Luck);
X  		cornline(1, buf);
X  	}
X  #endif
X***************
X*** 486,491 ****
X--- 549,557 ----
X  }
X  #endif /* WIZARD || EXPLORE_MODE */
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  #ifndef M
X  #define M(c)		(0x80 | (c))
X  #endif
X***************
X*** 573,578 ****
X--- 639,645 ----
X  	{M('u'), dountrap},
X  	{'v', doversion},
X  	{'V', dohistory},
X+ 	{M('v'), doextversion},
X  	{'w', dowield},
X  	{'W', dowear},
X  	{M('w'), dowipe},
X***************
X*** 579,584 ****
X--- 646,654 ----
X  #ifdef SPELLS
X  	{'x', dovspell},			/* Mike Stephenson */
X  #endif
X+ #ifdef EXPLORE_MODE
X+ 	{'X', enter_explore_mode},
X+ #endif
X  /*	'y', 'Y' : go nw */
X  	{'z', dozap},
X  #ifdef SPELLS
X***************
X*** 631,636 ****
X--- 701,708 ----
X  	"sit", "sit down", dosit,
X  	"turn", "turn undead", doturn,
X  	"untrap", "untrap something", dountrap,
X+ 	"version", "print compile time options for this version of NetHack",
X+ 		doextversion,
X  	"wipe", "wipe off your face", dowipe,
X  	"?", "get this list of extended commands", doextlist,
X  	NULL, NULL, donull
X***************
X*** 716,722 ****
X  		flags.run = 3;
X  		goto rush;
X  	}
X! 	if(*cmd == 'm' && movecmd(cmd[1])) {
X  		flags.run = 0;
X  		flags.nopick = 1;
X  		goto walk;
X--- 788,795 ----
X  		flags.run = 3;
X  		goto rush;
X  	}
X! 	if((*cmd == 'm' || (flags.num_pad & *cmd == '-')) &&
X! 	    movecmd(cmd[1])) {
X  		flags.run = 0;
X  		flags.nopick = 1;
X  		goto walk;
X***************
X*** 726,731 ****
X--- 799,810 ----
X  		flags.nopick = 1;
X  		goto rush;
X  	}
X+ 	if(flags.num_pad && *cmd == '0') {
X+ 	        (void)ddoinv();	/* A convenience borrowed from the PC */
X+ 		flags.move = 0;
X+ 		multi = 0;
X+ 		return;
X+ 	}
X  	while(tlist->f_char) {
X  		if((*cmd & 0xff) == (tlist->f_char & 0xff)){
X  			/* Special case of *cmd == ' ' handled here */
X***************
X*** 735,742 ****
X  			/* Now control-A can stop lengthy commands */
X  			/* in the PC version only -- use ^C-N otherwise */
X  			if (tlist->f_text && !occupation && multi)
X! 				set_occupation(tlist->f_funct, tlist->f_text,
X! 					multi);
X  			res = (*(tlist->f_funct))();
X  			if(!res) {
X  				flags.move = 0;
X--- 814,826 ----
X  			/* Now control-A can stop lengthy commands */
X  			/* in the PC version only -- use ^C-N otherwise */
X  			if (tlist->f_text && !occupation && multi)
X! #ifdef __GNULINT__
X! 				set_occupation(tlist->f_funct,
X! 						tlist->f_text, multi);
X! #else
X! 				set_occupation(((struct func_tab *)tlist)->f_funct,
X! 					tlist->f_text, multi);
X! #endif
X  			res = (*(tlist->f_funct))();
X  			if(!res) {
X  				flags.move = 0;
X***************
X*** 810,816 ****
X  movecmd(sym)	/* also sets u.dz, but returns false for <> */
X  char sym;
X  {
X! 	register char *dp;
X  	register const char *sdp = flags.num_pad ? ndir : sdir;
X  
X  	u.dz = 0;
X--- 894,900 ----
X  movecmd(sym)	/* also sets u.dz, but returns false for <> */
X  char sym;
X  {
X! 	register const char *dp;
X  	register const char *sdp = flags.num_pad ? ndir : sdir;
X  
X  	u.dz = 0;
X***************
X*** 827,832 ****
X--- 911,919 ----
X  	return !u.dz;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  getdir(s)
X  boolean s;
X***************
X*** 865,870 ****
X--- 952,960 ----
X  	return;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  isok(x,y)
X  register int x, y;
X***************
X*** 872,874 ****
X--- 962,966 ----
X  	/* x corresponds to curx, so x==1 is the first column. Ach. %% */
X  	return x >= 1 && x <= COLNO-1 && y >= 0 && y <= ROWNO-1;
X  }
X+ 
X+ #endif /* OVL0 */
X*** src/Old/dbridge.c	Mon Feb 19 17:55:39 1990
X--- src/dbridge.c	Fri Feb  2 18:22:08 1990
X***************
X*** 12,17 ****
X--- 12,37 ----
X  
X  #include "hack.h"
X  
X+ #ifdef STRONGHOLD
X+ static void FDECL(redosym, (int, int));
X+ static void FDECL(get_wall_for_db, (int *, int *));
X+ static struct entity *FDECL(e_at, (int, int));
X+ static void FDECL(m_to_e, (struct monst *, struct entity *));
X+ static void FDECL(u_to_e, (struct entity *));
X+ static void FDECL(set_entity, (int, int, struct entity *));
X+ static char *FDECL(e_nam, (struct entity *));
X+ /* static char *FDECL(Enam, (struct entity *)); */ /* unused */
X+ static char *FDECL(E_phrase, (struct entity *, const char *));
X+ static boolean FDECL(e_survives_at, (struct entity *, int, int));
X+ static void FDECL(e_died, (struct entity *, int, int));
X+ static boolean FDECL(automiss, (struct entity *));
X+ static boolean FDECL(e_missed, (struct entity *, BOOLEAN_P));
X+ static boolean FDECL(e_jumps, (struct entity *));
X+ static void FDECL(do_entity, (struct entity *));
X+ #endif
X+ 
X+ #ifdef OVL0
X+ 
X  boolean
X  is_pool(x,y)
X  int x,y;
X***************
X*** 24,30 ****
X--- 44,55 ----
X         return FALSE;
X  }
X  
X+ #endif /* OVL0 */
X+ 
X  #ifdef STRONGHOLD
X+ 
X+ #ifdef OVL1
X+ 
X  void
X  initsym(x,y)
X  int x,y;
X***************
X*** 88,93 ****
X--- 113,121 ----
X  	return (-1);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL1
X+ 
X  /*
X   * Use is_db_wall where you want to verify that a
X   * drawbridge "wall" is UP in the location x, y
X***************
X*** 101,106 ****
X--- 129,137 ----
X  		levl[x][y].diggable & W_GATEWAY);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  /*
X   * Return true with x,y pointing to the drawbridge if x,y initially indicate
X   * a drawbridge or drawbridge wall.
X***************
X*** 169,174 ****
X--- 200,208 ----
X  			wall = VWALL;
X  			x2++;
X  			break;
X+ 		default:
X+ 			impossible("bad direction in create_drawbridge");
X+ 			/* fall through */
X  		case DB_WEST:
X  			wall = VWALL;
X  			x2--;
X***************
X*** 308,314 ****
X  static char *
X  E_phrase(etmp, verb)
X  struct entity *etmp;
X! char *verb;
X  {
X  	char wholebuf[80], verbbuf[30];
X  
X--- 342,348 ----
X  static char *
X  E_phrase(etmp, verb)
X  struct entity *etmp;
X! const char *verb;
X  {
X  	char wholebuf[80], verbbuf[30];
X  
X***************
X*** 427,433 ****
X  
X  	if (is_flyer(etmp->edata) && 
X  	    (is_u(etmp)? !Sleeping : 
X! 	     (!etmp->emon->mfroz && !etmp->emon->msleep)))
X  						  /* flying requires mobility */
X  		misses = 5;	/* out of 8 */	
X  	else
X--- 461,467 ----
X  
X  	if (is_flyer(etmp->edata) && 
X  	    (is_u(etmp)? !Sleeping : 
X! 	     (etmp->emon->mcanmove && !etmp->emon->msleep)))
X  						  /* flying requires mobility */
X  		misses = 5;	/* out of 8 */	
X  	else
X***************
X*** 461,467 ****
X  	int tmp = 4; 		/* out of 10 */
X  
X  	if (is_u(etmp)? (Sleeping || Fumbling) : 
X! 		        (etmp->emon->mfroz || etmp->emon->msleep || 
X  			 !etmp->edata->mmove))
X  		return(FALSE);
X  
X--- 495,501 ----
X  	int tmp = 4; 		/* out of 10 */
X  
X  	if (is_u(etmp)? (Sleeping || Fumbling) : 
X! 		        (!etmp->emon->mcanmove || etmp->emon->msleep || 
X  			 !etmp->edata->mmove))
X  		return(FALSE);
X  
X***************
X*** 664,669 ****
X--- 698,704 ----
X  				pline("%s behind the drawbridge.",
X  		      	      	      E_phrase(etmp, "disappear"));
X  		if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X+ 			killer_format = KILLED_BY_AN;
X  			killer = "closing drawbridge";
X  			e_died(etmp, 0, CRUSHING); 		/* no message */
X  			return;
X***************
X*** 697,703 ****
X  				else
X  				      pline("%s into the moat.",
X  			      	            E_phrase(etmp, "fall"));
X! 		killer = "fall from a drawbridge";
X  		e_died(etmp, e_inview? 1 : 0,        /* CRUSHING is arbitrary */
X  		       (is_pool(etmp->ex, etmp->ey))? DROWNING : CRUSHING);
X  		       						    /* corpse */
X--- 732,739 ----
X  				else
X  				      pline("%s into the moat.",
X  			      	            E_phrase(etmp, "fall"));
X! 		killer_format = NO_KILLER_PREFIX;
X! 		killer = "fell from a drawbridge";
X  		e_died(etmp, e_inview? 1 : 0,        /* CRUSHING is arbitrary */
X  		       (is_pool(etmp->ex, etmp->ey))? DROWNING : CRUSHING);
X  		       						    /* corpse */
X***************
X*** 832,837 ****
X--- 868,874 ----
X  			if (e_inview)
X  				pline("%s blown apart by flying debris",
X  			      	      E_phrase(etmp2, "are"));
X+ 			killer_format = KILLED_BY_AN;
X  			killer = "exploding drawbridge";
X  			e_died(etmp2, e_inview? 2 : 3, CRUSHING);/* no corpse */
X  		}	      /* nothing which is vulnerable can survive this */
X***************
X*** 862,867 ****
X--- 899,905 ----
X  					pline("%s from shrapnel", 
X  					      E_phrase(etmp1, "die"));
X  #endif
X+ 			killer_format = KILLED_BY_AN;
X  			killer = "collapsing drawbridge";
X  			e_died(etmp1, e_inview? 0 : 1, CRUSHING);   /* corpse */
X  		}
X***************
X*** 869,873 ****
X--- 907,914 ----
X  	redosym(x,y);
X  	redosym(x2,y2);
X  }
X+ 
X+ 
X+ #endif /* OVLB */
X  
X  #endif /* STRONGHOLD /**/
X*** src/Old/decl.c	Mon Feb 19 17:56:16 1990
X--- src/decl.c	Sun Feb 18 16:37:36 1990
X***************
X*** 41,48 ****
X  int doorindex = 0;
X  
X  char *save_cm = 0;
X! char *killer = 0;
X! char *nomovemsg = 0;
X  const char nul[40] = DUMMY;		/* contains zeros */
X  char plname[PL_NSIZ] = DUMMY;		/* player name */
X  char pl_character[PL_CSIZ] = DUMMY;
X--- 41,49 ----
X  int doorindex = 0;
X  
X  char *save_cm = 0;
X! int killer_format = 0;
X! const char *killer = 0;
X! const char *nomovemsg = 0;
X  const char nul[40] = DUMMY;		/* contains zeros */
X  char plname[PL_NSIZ] = DUMMY;		/* player name */
X  char pl_character[PL_CSIZ] = DUMMY;
X***************
X*** 61,69 ****
X  #endif
X  
X  #ifdef SMALLDATA
X! char *occtxt = 0;
X  #else
X! char *occtxt = DUMMY;
X  #endif
X  const char quitchars[] = " \r\n\033";
X  const char vowels[] = "aeiouAEIOU";
X--- 62,70 ----
X  #endif
X  
X  #ifdef SMALLDATA
X! const char *occtxt = 0;
X  #else
X! const char *occtxt = DUMMY;
X  #endif
X  const char quitchars[] = " \r\n\033";
X  const char vowels[] = "aeiouAEIOU";
X***************
X*** 87,93 ****
X--- 88,98 ----
X  #endif
X  
X  #ifdef TEXTCOLOR
X+ # ifdef TOS
X+ const char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X+ # else
X  char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X+ # endif
X  #endif
X  #ifdef MSDOS
X  char hackdir[PATHLEN];		/* where rumors, help, record are */
X***************
X*** 202,239 ****
X  symbol_array savesyms = DUMMY;
X  #endif
X  
X! char *explainsyms[MAXPCHARS] = {
X! 	"a dark part of a room", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a doorway", "an open door",
X! 	"an open door", "a closed door", "the floor of a room",
X! 	"a corridor", "a staircase up", "a staircase down",
X! 	"a trap", "a web", "a water filled area",
X  #ifdef FOUNTAINS
X! 	"a fountain",
X  #else
X  	"",
X  #endif
X  #ifdef SINKS
X! 	"a sink",
X  #else
X  	"",
X  #endif
X  #ifdef THRONES
X! 	"an opulent throne",
X  #else
X  	"",
X  #endif
X  #ifdef ALTARS
X! 	"an altar",
X  #else
X  	"",
X  #endif
X  #ifdef STRONGHOLD
X! 	"a ladder up", "a ladder down", "a drawbridge", "a drawbridge"
X  #else
X  	"", "", "", ""
X  #endif
X--- 207,244 ----
X  symbol_array savesyms = DUMMY;
X  #endif
X  
X! const char *explainsyms[MAXPCHARS] = {
X! 	"dark part of a room", "wall", "wall",
X! 	"wall", "wall", "wall",
X! 	"wall", "wall", "wall",
X! 	"wall", "wall", "wall",
X! 	"wall", "wall", "wall",
X! 	"wall", "doorway", "open door",
X! 	"open door", "closed door", "floor of a room",
X! 	"corridor", "staircase up", "staircase down",
X! 	"trap", "web", "water filled area",
X  #ifdef FOUNTAINS
X! 	"fountain",
X  #else
X  	"",
X  #endif
X  #ifdef SINKS
X! 	"sink",
X  #else
X  	"",
X  #endif
X  #ifdef THRONES
X! 	"opulent throne",
X  #else
X  	"",
X  #endif
X  #ifdef ALTARS
X! 	"altar",
X  #else
X  	"",
X  #endif
X  #ifdef STRONGHOLD
X! 	"ladder up", "ladder down", "drawbridge", "drawbridge"
X  #else
X  	"", "", "", ""
X  #endif
X***************
X*** 273,275 ****
X--- 278,341 ----
X  
X  const char nothing_happens[] = "Nothing happens.";
X  const char thats_enough_tries[] = "That's enough tries!";
X+ 
X+ const char monsyms[] = { S_HUMAN, S_GHOST, S_ANT, S_BLOB, S_COCKATRICE, S_DOG,
X+ S_EYE, S_FELINE, S_GREMLIN, S_HUMANOID, S_IMP, S_JELLY, S_KOBOLD,
X+ S_LEPRECHAUN, S_MIMIC, S_NYMPH, S_ORC, S_PIERCER, S_QUADRUPED, S_RODENT,
X+ S_SPIDER, S_TRAPPER, S_UNICORN, S_VORTEX, S_WORM, S_XAN, S_YLIGHT, S_ZRUTY,
X+ S_APE, S_BAT, S_CENTAUR, S_DRAGON, S_ELEMENTAL, S_FUNGUS, S_GNOME, S_GIANT,
X+ S_STALKER, S_JABBERWOCK,
X+ #ifdef KOPS
X+ S_KOP,
X+ #endif
X+ S_LICH, S_MUMMY, S_NAGA, S_OGRE, S_PUDDING, S_QUANTMECH, S_RUSTMONST, S_SNAKE,
X+ S_TROLL, S_UMBER, S_VAMPIRE, S_WRAITH, S_XORN, S_YETI, S_ZOMBIE,
X+ #ifdef GOLEMS
X+ S_GOLEM,
X+ #endif
X+ S_DEMON, S_EEL, S_LIZARD,
X+ #ifdef WORM
X+ S_WORM_TAIL,
X+ #endif
X+ 0 };
X+ 
X+ const char objsyms[] = { WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM,
X+ WAND_SYM,
X+ #ifdef SPELLS
X+ SPBOOK_SYM,
X+ #endif
X+ RING_SYM, AMULET_SYM, FOOD_SYM, TOOL_SYM, GEM_SYM, GOLD_SYM,
X+ ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X+ 
X+ const char *monexplain[] = {
X+ "human", "ghost", "ant or other insect", "blob", "cockatrice",
X+ "dog or other canine", "eye or sphere", "feline", "gremlin", "humanoid",
X+ "imp or minor demon", "jelly", "kobold", "leprechaun", "mimic",
X+ "nymph", "orc", "piercer", "quadruped", "rodent",
X+ "spider", "trapper or lurker above", "unicorn", "vortex", "worm",
X+ "xan or other mythical/fantastic insect", "yellow light", "zruty",
X+ "ape", "bat", "centaur", "dragon", "elemental",
X+ "fungus or mold", "gnome", "giant humanoid", "invisible stalker", "jabberwock",
X+ #ifdef KOPS
X+ "Keystone Kop",
X+ #endif
X+ "lich", "mummy", "naga", "ogre", "pudding or ooze",
X+ "quantum mechanic", "rust monster", "snake", "troll", "umber hulk",
X+ "vampire", "wraith", "xorn", "yeti", "zombie",
X+ #ifdef GOLEMS
X+ "golem",
X+ #endif
X+ "demon",  "sea monster", "lizard",
X+ #ifdef WORM
X+ "long worm tail",
X+ #endif
X+ };
X+ 
X+ const char *objexplain[] = {
X+ "weapon", "suit or piece of armor", "potion", "scroll", "wand",
X+ #ifdef SPELLS
X+ "spell book",
X+ #endif
X+ "ring", "amulet", "piece of food", "useful item (pick-axe, key, lamp...)",
X+ "gem or rock", "pile of gold", "boulder or statue", "iron ball", "iron chain"
X+ };
X*** src/Old/demon.c	Mon Feb 19 17:56:35 1990
X--- src/demon.c	Wed Jan 31 19:34:15 1990
X***************
X*** 9,15 ****
X  	register struct permonst *ptr;
X  {
X  #ifdef INFERNO
X! 	register int dtype, cnt = 0;
X  
X  	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X  
X--- 9,15 ----
X  	register struct permonst *ptr;
X  {
X  #ifdef INFERNO
X! 	register int dtype = 0, cnt = 0;
X  
X  	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X  
X***************
X*** 44,53 ****
X  #define	Athome	(Inhell && !mtmp->cham)
X  
X  int
X! demon_talk(mtmp)		/* returns 1 if he won't attack. */
X  register struct monst *mtmp;
X  {
X- 	char	*x_monnam(), *Xmonnam();
X  	long	demand, offer;
X  
X  #ifdef NAMED_ITEMS
X--- 44,52 ----
X  #define	Athome	(Inhell && !mtmp->cham)
X  
X  int
X! demon_talk(mtmp)		/* returns 1 if it won't attack. */
X  register struct monst *mtmp;
X  {
X  	long	demand, offer;
X  
X  #ifdef NAMED_ITEMS
X***************
X*** 58,70 ****
X  	}
X  #endif /* NAMED_ITEMS */
X  
X- 	if(is_ndemon(mtmp->data)) {  /* not for regular '&'s */
X- 
X- 	    pline("%s mutters something about awful working conditions.",
X- 		  Xmonnam(mtmp));
X- 	    return(0);
X- 	}
X- 
X  	/* Slight advantage given. */
X  	if(is_dprince(mtmp->data) && mtmp->minvis) {
X  	    mtmp->minvis = 0;
X--- 57,62 ----
X***************
X*** 73,79 ****
X  	}
X  	if(u.usym == S_DEMON) {	/* Won't blackmail their own. */
X  
X! 	    pline("%s says, \"Good hunting %s.\" and vanishes.",
X  		  Xmonnam(mtmp), flags.female ? "Sister" : "Brother");
X  	    rloc(mtmp);
X  	    return(1);
X--- 65,71 ----
X  	}
X  	if(u.usym == S_DEMON) {	/* Won't blackmail their own. */
X  
X! 	    pline("%s says, \"Good hunting, %s.\" and vanishes.",
X  		  Xmonnam(mtmp), flags.female ? "Sister" : "Brother");
X  	    rloc(mtmp);
X  	    return(1);
X***************
X*** 87,93 ****
X  		  Xmonnam(mtmp), demand, plur(demand));
X  
X  	    if((offer = bribe(mtmp)) >= demand) {
X! 		pline("%s vanishes laughing about cowardly mortals.",
X  		      Xmonnam(mtmp));
X  	    } else {
X  		if((long)rnd(40) > (demand - offer)) {
X--- 79,85 ----
X  		  Xmonnam(mtmp), demand, plur(demand));
X  
X  	    if((offer = bribe(mtmp)) >= demand) {
X! 		pline("%s vanishes, laughing about cowardly mortals.",
X  		      Xmonnam(mtmp));
X  	    } else {
X  		if((long)rnd(40) > (demand - offer)) {
X*** src/Old/do.c	Mon Feb 19 17:56:55 1990
X--- src/do.c	Mon Feb 19 10:18:11 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do.c	3.0	89/11/20
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 6,21 ****
X  
X  #include "hack.h"
X  
X! #if defined(DGK) && !defined(OLD_TOS)
X  extern struct finfo fileinfo[];
X  #else
X  extern boolean level_exists[];
X  #endif
X  
X  #ifndef OVERLAY
X  static int FDECL(drop, (struct obj *));
X  #endif
X  
X  static const char drop_types[] = { '0', GOLD_SYM, '#', 0 };
X  
X  int
X--- 6,32 ----
X  
X  #include "hack.h"
X  
X! #if defined(DGK)
X  extern struct finfo fileinfo[];
X  #else
X  extern boolean level_exists[];
X  #endif
X  
X+ #ifdef SINKS
X+ static void FDECL(trycall, (struct obj *));
X+ static void FDECL(dosinkring, (struct obj *));
X+ #endif
X  #ifndef OVERLAY
X  static int FDECL(drop, (struct obj *));
X  #endif
X+ static void NDECL(litter);
X+ #ifndef OVERLAY
X+ static int NDECL(wipeoff);
X+ #endif
X+ boolean NDECL(drag_down);
X  
X+ #ifdef OVLB
X+ 
X  static const char drop_types[] = { '0', GOLD_SYM, '#', 0 };
X  
X  int
X***************
X*** 23,28 ****
X--- 34,42 ----
X  	return(drop(getobj(drop_types, "drop")));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /* Used for objects which sometimes do special things when dropped; must be
X   * called with the object not in any chain.  Returns 1 if the object is
X   * gone.
X***************
X*** 58,64 ****
X  		if (Blind) You("hear the boulder roll.");
X  		else pline("The boulder %sfills a %s.",
X  			t->tseen ? "" : "triggers and ",
X! 			t->ttyp == TRAPDOOR ? "trapdoor" : "pit");
X  		deltrap(t);
X  		if (u.utrap && x==u.ux && y==u.uy) {
X  		    u.utrap = 0;
X--- 72,78 ----
X  		if (Blind) You("hear the boulder roll.");
X  		else pline("The boulder %sfills a %s.",
X  			t->tseen ? "" : "triggers and ",
X! 			t->ttyp == TRAPDOOR ? "trap door" : "pit");
X  		deltrap(t);
X  		if (u.utrap && x==u.ux && y==u.uy) {
X  		    u.utrap = 0;
X***************
X*** 66,72 ****
X  		    if (!passes_walls(uasmon)) {
X  #endif
X  			pline("Unfortunately, you were still in it.");
X! 			losehp(rnd(15), "burial beneath a boulder");
X  #ifdef POLYSELF
X  		    }
X  #endif
X--- 80,88 ----
X  		    if (!passes_walls(uasmon)) {
X  #endif
X  			pline("Unfortunately, you were still in it.");
X! 			losehp(rnd(15),
X! 			  self_pronoun("dropped a boulder onto %sself","him"),
X! 			  NO_KILLER_PREFIX);
X  #ifdef POLYSELF
X  		    }
X  #endif
X***************
X*** 81,86 ****
X--- 97,105 ----
X  	return FALSE;
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  #ifdef ALTARS
X  void
X  doaltarobj(obj)  /* obj is an object dropped on an altar */
X***************
X*** 241,247 ****
X  boolean
X  canletgo(obj,word)
X  register struct obj *obj;
X! register char *word;
X  {
X  	if(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)){
X  	       if (*word)
X--- 260,266 ----
X  boolean
X  canletgo(obj,word)
X  register struct obj *obj;
X! register const char *word;
X  {
X  	if(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)){
X  	       if (*word)
X***************
X*** 249,259 ****
X  		return(FALSE);
X  	}
X  	if (obj->otyp == LOADSTONE && obj->cursed) {
X- 		obj->bknown = 1;
X  		if (*word)
X  			pline("For some reason, you cannot %s the stone%s!",
X  				word,
X  		      		plur((long)obj->quan));
X  		return(FALSE);
X  	}
X  #ifdef WALKIES
X--- 268,289 ----
X  		return(FALSE);
X  	}
X  	if (obj->otyp == LOADSTONE && obj->cursed) {
X  		if (*word)
X  			pline("For some reason, you cannot %s the stone%s!",
X  				word,
X  		      		plur((long)obj->quan));
X+ 		/* Kludge -- see invent.c */
X+ 		if (obj->corpsenm) {
X+ 			struct obj *otmp;
X+ 
X+ 			otmp = obj;
X+ 			obj = obj->nobj;
X+ 			obj->quan += otmp->quan;
X+ 			obj->owt = weight(obj);
X+ 			freeinv(otmp);
X+ 			obfree(otmp, obj);
X+ 		}
X+ 		obj->bknown = 1;
X  		return(FALSE);
X  	}
X  #ifdef WALKIES
X***************
X*** 400,406 ****
X  #ifdef STRONGHOLD
X  			levl[u.ux][u.uy].typ == LADDER ? "ladder" :
X  #endif
X! 			"trapdoor");
X  		return(0);
X  	}
X  
X--- 430,436 ----
X  #ifdef STRONGHOLD
X  			levl[u.ux][u.uy].typ == LADDER ? "ladder" :
X  #endif
X! 			"trap door");
X  		return(0);
X  	}
X  
X***************
X*** 415,421 ****
X  		if (levl[u.ux][u.uy].typ == LADDER) at_ladder = TRUE;
X  #endif
X  		if (trap)
X! 			pline("You jump into the trapdoor...");
X  		goto_level(dlevel+1, !trap, TRUE);
X  #ifdef STRONGHOLD
X  		at_ladder = FALSE;
X--- 445,456 ----
X  		if (levl[u.ux][u.uy].typ == LADDER) at_ladder = TRUE;
X  #endif
X  		if (trap)
X! #ifdef POLYSELF
X! 			You("%s into the trap door.",
X! 				locomotion(uasmon, "jump"));
X! #else
X! 			You("jump into the trap door.");
X! #endif
X  		goto_level(dlevel+1, !trap, TRUE);
X  #ifdef STRONGHOLD
X  		at_ladder = FALSE;
X***************
X*** 461,469 ****
X--- 496,512 ----
X  
X  #ifdef ENDGAME
X  	if (dlevel == 1) {
X+ #ifdef MACOS
X+ 		if(!flags.silent) SysBeep(20);
X+ 		if(UseMacAlertText(128,
X+ 			"Beware, there will be no return!  Still climb?") != 1) {
X+ 			return 0;
X+ 		}
X+ #else
X  		pline("Beware, there will be no return!  Still climb? ");
X  		if (yn() != 'y') return(0);
X  		else more();
X+ #endif /* MACOS */
X  	}
X  #endif
X  #ifdef WALKIES
X***************
X*** 537,554 ****
X  	if(forward) {
X  		if(rn2(6)) {
X  			You("get dragged downstairs by the iron ball.");
X! 			losehp(rnd(6), "iron ball accident");
X  			return(TRUE);
X  		}
X  	} else {
X  		if(rn2(2)) {
X  			pline("The iron ball smacks into you!");
X! 			losehp(rnd(20), "iron ball collision");
X  			dragchance -= 2;
X  		} 
X  		if(dragchance >= rnd(6)) {
X  			You("get dragged downstairs by the iron ball.");
X! 			losehp(rnd(3), "iron ball accident");
X  			return(TRUE);
X  		}
X  	}
X--- 580,599 ----
X  	if(forward) {
X  		if(rn2(6)) {
X  			You("get dragged downstairs by the iron ball.");
X! 			losehp(rnd(6), "dragged downstairs by an iron ball",
X! 				NO_KILLER_PREFIX);
X  			return(TRUE);
X  		}
X  	} else {
X  		if(rn2(2)) {
X  			pline("The iron ball smacks into you!");
X! 			losehp(rnd(20), "iron ball collision", KILLED_BY_AN);
X  			dragchance -= 2;
X  		} 
X  		if(dragchance >= rnd(6)) {
X  			You("get dragged downstairs by the iron ball.");
X! 			losehp(rnd(3), "dragged downstairs by an iron ball",
X! 				NO_KILLER_PREFIX);
X  			return(TRUE);
X  		}
X  	}
X***************
X*** 555,560 ****
X--- 600,607 ----
X  	return(FALSE);
X  }
X  
X+ int save_dlevel = 0;
X+ 
X  void
X  goto_level(newlevel, at_stairs, falling)
X  register int newlevel;
X***************
X*** 613,626 ****
X  	    if(Fire_resistance) {
X  		pline("But the fire doesn't seem to harm you.");
X  	    } else {
X! 		int save_dlevel = dlevel;
X! 
X  		You("burn to a crisp.");
X  		You("die...");
X  		dlevel = maxdlevel = newlevel;
X  		killer = "visit to hell";
X  		done(BURNING);
X  		dlevel = newlevel = save_dlevel; /* in case they survive */
X  	    }
X  	}
X  
X--- 660,674 ----
X  	    if(Fire_resistance) {
X  		pline("But the fire doesn't seem to harm you.");
X  	    } else {
X! 		save_dlevel = dlevel;
X  		You("burn to a crisp.");
X  		You("die...");
X  		dlevel = maxdlevel = newlevel;
X+ 		killer_format = KILLED_BY_AN;
X  		killer = "visit to hell";
X  		done(BURNING);
X  		dlevel = newlevel = save_dlevel; /* in case they survive */
X+ 		save_dlevel = 0;
X  	    }
X  	}
X  
X***************
X*** 645,651 ****
X  		if (FSOpen(fileName, t->system.sysVRefNum, &refNum)) {
X  				if (er = Create(&fileName,t->system.sysVRefNum,
X  							CREATOR,LEVEL_TYPE))
X! 					SysBeep(1);
X  		} else {
X  			(void)SetEOF(refNum,0L);
X  			(void)FSClose(refNum);
X--- 693,699 ----
X  		if (FSOpen(fileName, t->system.sysVRefNum, &refNum)) {
X  				if (er = Create(&fileName,t->system.sysVRefNum,
X  							CREATOR,LEVEL_TYPE))
X! 					SysBeep(20);
X  		} else {
X  			(void)SetEOF(refNum,0L);
X  			(void)FSClose(refNum);
X***************
X*** 694,701 ****
X  	if(u.uswallow)				/* idem */
X  		u.uswldtim = u.uswallow = 0;
X  	flags.nscrinh = 1;
X! 	u.ux = FAR;				/* hack */
X! 	(void) inshop();			/* probably was a trapdoor */
X  
X  #ifdef DGK
X  # ifdef ZEROCOMP
X--- 742,749 ----
X  	if(u.uswallow)				/* idem */
X  		u.uswldtim = u.uswallow = 0;
X  	flags.nscrinh = 1;
X! 	u.ux = u.ux0 = FAR;				/* hack */
X! 	(void) inshop();			/* probably was a trap door */
X  
X  #ifdef DGK
X  # ifdef ZEROCOMP
X***************
X*** 733,739 ****
X  # ifdef ENDGAME
X  	   dlevel == ENDLEVEL ||
X  # endif
X! #if defined(DGK) && !defined(OLD_TOS)
X  	/* If the level has no .where yet, it hasn't been made */
X  	   !fileinfo[dlevel].where)
X  #else
X--- 781,787 ----
X  # ifdef ENDGAME
X  	   dlevel == ENDLEVEL ||
X  # endif
X! #if defined(DGK)
X  	/* If the level has no .where yet, it hasn't been made */
X  	   !fileinfo[dlevel].where)
X  #else
X***************
X*** 741,747 ****
X  #endif
X  		mklev();
X  	else {
X! #if defined(DGK) && !defined(OLD_TOS)
X  		/* If not currently accessible, swap it in. */
X  		if (fileinfo[dlevel].where != ACTIVE)
X  			swapin_file(dlevel);
X--- 789,795 ----
X  #endif
X  		mklev();
X  	else {
X! #if defined(DGK)
X  		/* If not currently accessible, swap it in. */
X  		if (fileinfo[dlevel].where != ACTIVE)
X  			swapin_file(dlevel);
X***************
X*** 762,767 ****
X--- 810,825 ----
X  		(void) close(fd);
X  	}
X  
X+ #ifdef MACOS
X+ 	{
X+ 		OSErr	er;
X+ 		struct term_info	*t;
X+ 		extern WindowPtr	HackWindow;
X+ 		
X+ 		t = (term_info *)GetWRefCon(HackWindow);
X+ 		SetVol(0L,t->system.sysVRefNum);
X+ 	}
X+ #endif
X  #ifdef ENDGAME
X  	if(dlevel != ENDLEVEL)
X  #endif
X***************
X*** 820,830 ****
X  				}
X  				placebc(1);
X  			} 
X! 			losehp(rnd(3), "fall");
X  			selftouch("Falling, you");
X  		}
X  	    }
X! 	} else {	/* trapdoor or level_tele */
X  	    register int tryct = 0;
X  	    do {
X  #ifdef STRONGHOLD
X--- 878,888 ----
X  				}
X  				placebc(1);
X  			} 
X! 			losehp(rnd(3), "falling downstairs", KILLED_BY);
X  			selftouch("Falling, you");
X  		}
X  	    }
X! 	} else {	/* trap door or level_tele */
X  	    register int tryct = 0;
X  	    do {
X  #ifdef STRONGHOLD
X***************
X*** 865,871 ****
X  					body_part(HEAD));
X  				if (uarmh)
X  					Your("helmet doesn't help too much...");
X! 				losehp(rnd(25), "iron ball");
X  			}
X  		}
X  		placebc(1);
X--- 923,931 ----
X  					body_part(HEAD));
X  				if (uarmh)
X  					Your("helmet doesn't help too much...");
X! 				losehp(rnd(25),
X! 					"Crunched in the head by an iron ball",
X! 					NO_KILLER_PREFIX);
X  			}
X  		}
X  		placebc(1);
X***************
X*** 878,883 ****
X--- 938,947 ----
X  
X  	losedogs();
X  	if(MON_AT(u.ux, u.uy)) mnexto(m_at(u.ux, u.uy));
X+ 	if(MON_AT(u.ux, u.uy)) {
X+ 		impossible("mnexto failed (do.c)?");
X+ 		rloc(m_at(u.ux, u.uy));
X+ 	}
X  	flags.nscrinh = 0;
X  	setsee();
X  	seeobjs();	/* make old cadavers disappear - riv05!a3 */
X***************
X*** 949,963 ****
X  struct obj *
X  splitobj(obj, num) register struct obj *obj; register int num; {
X  register struct obj *otmp;
X! 	otmp = newobj(0);
X  	*otmp = *obj;		/* copies whole structure */
X  	otmp->o_id = flags.ident++;
X- 	otmp->onamelth = 0;
X  	obj->quan = num;
X  	obj->owt = weight(obj);
X  	otmp->quan -= num;
X  	otmp->owt = weight(otmp);	/* -= obj->owt ? */
X  	obj->nobj = obj->nexthere = otmp;
X  	if(obj->unpaid) splitbill(obj,otmp);
X  	return(otmp);
X  }
X--- 1013,1028 ----
X  struct obj *
X  splitobj(obj, num) register struct obj *obj; register int num; {
X  register struct obj *otmp;
X! 	otmp = newobj(obj->onamelth);
X  	*otmp = *obj;		/* copies whole structure */
X  	otmp->o_id = flags.ident++;
X  	obj->quan = num;
X  	obj->owt = weight(obj);
X  	otmp->quan -= num;
X  	otmp->owt = weight(otmp);	/* -= obj->owt ? */
X  	obj->nobj = obj->nexthere = otmp;
X+ 	if (obj->onamelth)
X+ 		(void)strncpy(ONAME(otmp), ONAME(obj), (int)obj->onamelth);
X  	if(obj->unpaid) splitbill(obj,otmp);
X  	return(otmp);
X  }
X***************
X*** 994,996 ****
X--- 1059,1063 ----
X  		Wounded_legs = 0;
X  	}
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/do_name.c	Mon Feb 19 17:57:44 1990
X--- src/do_name.c	Mon Feb 19 14:45:58 1990
X***************
X*** 4,9 ****
X--- 4,18 ----
X  
X  #include "hack.h"
X  
X+ #ifdef NAMED_ITEMS
X+ # include <ctype.h>
X+ #endif
X+ 
X+ static char *FDECL(visctrl, (CHAR_P));
X+ static void FDECL(do_oname, (struct obj *));
X+ 
X+ #ifdef OVLB
X+ 
X  static
X  char *
X  visctrl(c)
X***************
X*** 29,39 ****
X  void
X  getpos(cc,force,goal)
X  coord	*cc;
X! int force; char *goal;
X  {
X  	register int cx, cy, i, c;
X  	const char *sdp = flags.num_pad ? ndir : sdir;
X  	if(flags.verbose) pline("(For instructions type a ?)");
X  	cx = cc->x;
X  	cy = cc->y;
X  #ifdef CLIPPING
X--- 38,64 ----
X  void
X  getpos(cc,force,goal)
X  coord	*cc;
X! int force;
X! const char *goal;
X  {
X  	register int cx, cy, i, c;
X  	const char *sdp = flags.num_pad ? ndir : sdir;
X+ #ifdef MACOS
X+ 	extern short	macflags;
X+ 	Boolean	fUpdateFlagOn;
X+ 	long	ticks;
X+ #endif
X+ 
X  	if(flags.verbose) pline("(For instructions type a ?)");
X+ #ifdef MACOS	
X+ 	if ((macflags & fDoUpdate) && (macflags & fDoNonKeyEvt)) {
X+ 		fUpdateFlagOn = true;
X+ 	} else {
X+ 		fUpdateFlagOn = false;
X+ 		macflags |= (fDoUpdate | fDoNonKeyEvt);
X+ 	}
X+ 	macflags |= fMoveWRTMouse;
X+ #endif
X  	cx = cc->x;
X  	cy = cc->y;
X  #ifdef CLIPPING
X***************
X*** 63,68 ****
X--- 88,98 ----
X  						    "use hjkl or ." :
X  				    "aborted");
X  			if(force) goto nxtc;
X+ #ifdef MACOS
X+ 			macflags &= ~fMoveWRTMouse;
X+ 			if (!fUpdateFlagOn)
X+ 				macflags &= ~(fDoUpdate | fDoNonKeyEvt);
X+ #endif
X  			cc->x = -1;
X  			cc->y = 0;
X  			return;
X***************
X*** 75,91 ****
X  		curs(cx,cy+2);
X  #endif
X  	}
X  	cc->x = cx;
X  	cc->y = cy;
X  	return;
X  }
X  
X  int
X  do_mname(){
X  	char buf[BUFSZ];
X  	coord cc;
X! 	register int cx,cy,lth,i;
X! 	register struct monst *mtmp, *mtmp2;
X  	register char *curr;
X  	boolean blank;
X  
X--- 105,151 ----
X  		curs(cx,cy+2);
X  #endif
X  	}
X+ #ifdef MACOS
X+ 	macflags &= ~fMoveWRTMouse;
X+ 	if (!fUpdateFlagOn)
X+ 		macflags &= ~(fDoUpdate | fDoNonKeyEvt);
X+ #endif
X  	cc->x = cx;
X  	cc->y = cy;
X  	return;
X  }
X  
X+ struct monst *
X+ christen_monst(mtmp, name)
X+ struct monst *mtmp;
X+ const char *name;
X+ {
X+ 	register int lth,i;
X+ 	register struct monst *mtmp2;
X+ 
X+ 	/* dogname and catname are 63-character arrays; the generic naming
X+ 	 * function do_mname() below also cut names off at 63 characters */
X+ 	lth = strlen(name)+1;
X+ 	if(lth > 63){
X+ 		lth = 63;
X+ 	}
X+ 	mtmp2 = newmonst(mtmp->mxlth + lth);
X+ 	*mtmp2 = *mtmp;
X+ 	for(i=0; i<mtmp->mxlth; i++)
X+ 		((char *) mtmp2->mextra)[i] = ((char *) mtmp->mextra)[i];
X+ 	mtmp2->mnamelth = lth;
X+ 	(void)strncpy(NAME(mtmp2), name, lth);
X+ 	NAME(mtmp2)[lth-1] = 0;
X+ 	replmon(mtmp,mtmp2);
X+ 	return(mtmp2);
X+ }
X+ 
X  int
X  do_mname(){
X  	char buf[BUFSZ];
X  	coord cc;
X! 	register int cx,cy;
X! 	register struct monst *mtmp;
X  	register char *curr;
X  	boolean blank;
X  
X***************
X*** 127,144 ****
X   	    }
X   	    return(0);
X   	}
X! 	lth = strlen(buf)+1;
X! 	if(lth > 63){
X! 		buf[62] = 0;
X! 		lth = 63;
X! 	}
X! 	mtmp2 = newmonst(mtmp->mxlth + lth);
X! 	*mtmp2 = *mtmp;
X! 	for(i=0; i<mtmp->mxlth; i++)
X! 		((char *) mtmp2->mextra)[i] = ((char *) mtmp->mextra)[i];
X! 	mtmp2->mnamelth = lth;
X! 	Strcpy(NAME(mtmp2), buf);
X! 	replmon(mtmp,mtmp2);
X  	return(0);
X  }
X  
X--- 187,193 ----
X   	    }
X   	    return(0);
X   	}
X! 	(void) christen_monst(mtmp, buf);
X  	return(0);
X  }
X  
X***************
X*** 166,173 ****
X  	if(blank) *buf = '\0';
X  
X  #ifdef NAMED_ITEMS
X! 	if(is_artifact(obj) || restr_name(obj, buf))
X! 		pline("Somehow you can't seem to engrave that word.");
X  	else
X  #endif
X  		(void)oname(obj, buf, 1);
X--- 215,234 ----
X  	if(blank) *buf = '\0';
X  
X  #ifdef NAMED_ITEMS
X! 	if(is_artifact(obj))
X! 		pline("The artifact seems to resist the attempt.");
X! 	else if (restr_name(obj, buf) || exist_artifact(obj, buf)) {
X! 		int n = rn2(strlen(buf));
X! 		char c;
X! 
X! 		while (tolower(buf[n]) == (c = 'a' + rn2('z'-'a')));
X! 		if (isupper(buf[n])) buf[n] = toupper(c);
X! 		else buf[n] = c;
X! 		pline("While engraving your hand slips.");
X! 		more();
X! 		You("engrave: \"%s\".",buf);
X! 		(void)oname(obj, buf, 1);
X! 	}
X  	else
X  #endif
X  		(void)oname(obj, buf, 1);
X***************
X*** 176,182 ****
X  struct obj *
X  oname(obj, buf, ininv)
X  register struct obj *obj;
X! char	*buf;
X  register int ininv;
X  {
X  	register struct obj *otmp, *otmp2, *contents;
X--- 237,243 ----
X  struct obj *
X  oname(obj, buf, ininv)
X  register struct obj *obj;
X! const char	*buf;
X  register int ininv;
X  {
X  	register struct obj *otmp, *otmp2, *contents;
X***************
X*** 183,190 ****
X  	register int	lth;
X  
X  	lth = *buf ? strlen(buf)+1 : 0;
X  	if(lth > 63){
X- 		buf[62] = 0;
X  		lth = 63;
X  	}
X  	otmp2 = newobj(lth);
X--- 244,257 ----
X  	register int	lth;
X  
X  	lth = *buf ? strlen(buf)+1 : 0;
X+ #ifdef NAMED_ITEMS
X+ 	/* if named artifact exists in the game, do not create another */
X+ 	if (exist_artifact(obj, buf))
X+ 		lth = 0;
X+ 	else
X+ 		artifact_exists(obj, buf, TRUE);
X+ #endif
X  	if(lth > 63){
X  		lth = 63;
X  	}
X  	otmp2 = newobj(lth);
X***************
X*** 198,205 ****
X  	 */
X  	if (buf) (void)donull();
X  #endif
X! 	if(lth) Strcpy(ONAME(otmp2), buf);
X! 
X  	if (obj->owornmask) {
X  		/* Note: dying by burning in Hell causes problems if you
X  		 * try doing this when owornmask isn't set.
X--- 265,274 ----
X  	 */
X  	if (buf) (void)donull();
X  #endif
X! 	if(lth) {
X! 		(void)strncpy(ONAME(otmp2), buf, lth);
X! 		ONAME(otmp2)[lth-1] = 0;
X! 	}
X  	if (obj->owornmask) {
X  		/* Note: dying by burning in Hell causes problems if you
X  		 * try doing this when owornmask isn't set.
X***************
X*** 235,241 ****
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X! 	ARMOR_SYM, 0 };
X  
X  int
X  ddocall()
X--- 304,310 ----
X  #ifdef SPELLS
X  	SPBOOK_SYM,
X  #endif
X! 	ARMOR_SYM, TOOL_SYM, 0 };
X  
X  int
X  ddocall()
X***************
X*** 296,302 ****
X  
X  	/* clear old name */
X  	str1 = &(objects[obj->otyp].oc_uname);
X! 	if(*str1) free(*str1);
X  
X  	/* uncalls item if all spaces */
X  	for (str = buf, blank = 1; *str; blank = (*str++ == ' '));
X--- 365,371 ----
X  
X  	/* clear old name */
X  	str1 = &(objects[obj->otyp].oc_uname);
X! 	if(*str1) free((genericptr_t)*str1);
X  
X  	/* uncalls item if all spaces */
X  	for (str = buf, blank = 1; *str; blank = (*str++ == ' '));
X***************
X*** 311,323 ****
X  	*str1 = str;
X  }
X  
X! const char *ghostnames[] = {
X  	/* these names should have length < PL_NSIZ */
X  	/* Capitalize the names for aesthetics -dgk */
X  	"Adri", "Andries", "Andreas", "Bert", "David", "Dirk", "Emile",
X  	"Frans", "Fred", "Greg", "Hether", "Jay", "John", "Jon", "Karnov",
X  	"Kay", "Kenny", "Kevin", "Maud", "Michiel", "Mike", "Peter", "Robert",
X! 	"Ron", "Tom", "Wilmar", "Nick Danger", "Phoenix", "Miracleman",
X  	"Stephan", "Lance Braccus", "Shadowhawk"
X  };
X  
X--- 380,395 ----
X  	*str1 = str;
X  }
X  
X! #endif /*OVLB*/
X! #ifdef OVL0
X! 
X! static const char *ghostnames[] = {
X  	/* these names should have length < PL_NSIZ */
X  	/* Capitalize the names for aesthetics -dgk */
X  	"Adri", "Andries", "Andreas", "Bert", "David", "Dirk", "Emile",
X  	"Frans", "Fred", "Greg", "Hether", "Jay", "John", "Jon", "Karnov",
X  	"Kay", "Kenny", "Kevin", "Maud", "Michiel", "Mike", "Peter", "Robert",
X! 	"Ron", "Tom", "Wilmar", "Nick Danger", "Phoenix", "Havok",
X  	"Stephan", "Lance Braccus", "Shadowhawk"
X  };
X  
X***************
X*** 361,367 ****
X  		{ register const char *gn = (const char *) mtmp->mextra;
X  		  if(!*gn) {		/* might also look in scorefile */
X  		    gn = ghostnames[rn2(SIZE(ghostnames))];
X! 			Strcpy((char *) mtmp->mextra, !rn2(5) ? plname : gn);
X  		  }
X  		  Sprintf(buf, "%s's ghost", (char *) mtmp->mextra);
X  		}
X--- 433,439 ----
X  		{ register const char *gn = (const char *) mtmp->mextra;
X  		  if(!*gn) {		/* might also look in scorefile */
X  		    gn = ghostnames[rn2(SIZE(ghostnames))];
X! 		    Strcpy((char *) mtmp->mextra, !rn2(5) ? (const char *)plname : gn);
X  		  }
X  		  Sprintf(buf, "%s's ghost", (char *) mtmp->mextra);
X  		}
X***************
X*** 381,386 ****
X--- 453,461 ----
X  	return(buf);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  char *
X  lmonnam(mtmp)
X  register struct monst *mtmp;
X***************
X*** 388,393 ****
X--- 463,471 ----
X  	return(x_monnam(mtmp, 1));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  char *
X  mon_nam(mtmp)
X  register struct monst *mtmp;
X***************
X*** 405,414 ****
X  	return(bp);
X  }
X  
X  char *
X  a_monnam(mtmp,adj)
X  register struct monst *mtmp;
X! register char *adj;
X  {
X  	register char *bp = mon_nam(mtmp);
X  #ifdef LINT	/* static char buf[BUFSZ]; */
X--- 483,495 ----
X  	return(bp);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  char *
X  a_monnam(mtmp,adj)
X  register struct monst *mtmp;
X! register const char *adj;
X  {
X  	register char *bp = mon_nam(mtmp);
X  #ifdef LINT	/* static char buf[BUFSZ]; */
X***************
X*** 427,433 ****
X  char *
X  a2_monnam(mtmp,adj)
X  register struct monst *mtmp;
X! register char *adj;
X  {
X  	register char *bp = mon_nam(mtmp);
X  #ifdef LINT	/* static char buf[BUFSZ]; */
X--- 508,514 ----
X  char *
X  a2_monnam(mtmp,adj)
X  register struct monst *mtmp;
X! register const char *adj;
X  {
X  	register char *bp = mon_nam(mtmp);
X  #ifdef LINT	/* static char buf[BUFSZ]; */
X***************
X*** 446,452 ****
X  char *
X  Amonnam(mtmp, adj)
X  register struct monst *mtmp;
X! register char *adj;
X  {
X  	register char *bp = a_monnam(mtmp,adj);
X  
X--- 527,533 ----
X  char *
X  Amonnam(mtmp, adj)
X  register struct monst *mtmp;
X! register const char *adj;
X  {
X  	register char *bp = a_monnam(mtmp,adj);
X  
X***************
X*** 480,486 ****
X  	return(bp);
X  }
X  
X! char *
X  rndmonnam() {  /* Random name of monster type, if hallucinating */
X  	int name;
X  
X--- 561,567 ----
X  	return(bp);
X  }
X  
X! const char *
X  rndmonnam() {  /* Random name of monster type, if hallucinating */
X  	int name;
X  
X***************
X*** 491,498 ****
X  	return(mons[name].mname);
X  }
X  
X! #ifdef REINCARNATION
X  char *
X  roguename() /* Name of a Rogue player */
X  {
X  	char *i, *opts;
X--- 572,604 ----
X  	return(mons[name].mname);
X  }
X  
X! const char *pronoun_pairs[][2] = {
X! 	{"him", "her"}, {"Him", "Her"}, {"his", "her"}, {"His", "Her"},
X! 	{"he", "she"}, {"He", "She"},
X! 	{0, 0}
X! };
X! 
X  char *
X+ self_pronoun(str, pronoun)
X+ const char *str;
X+ const char *pronoun;
X+ {
X+ 	static char buf[BUFSZ];
X+ 	register int i;
X+ 
X+ 	for(i=0; pronoun_pairs[i][0]; i++) {
X+ 		if(!strncmp(pronoun, pronoun_pairs[i][0], 3)) {
X+ 			Sprintf(buf, str, pronoun_pairs[i][flags.female]);
X+ 			return buf;
X+ 		}
X+ 	}
X+ 	impossible("never heard of pronoun %s?", pronoun);
X+ 	Sprintf(buf, str, pronoun_pairs[i][0]);
X+ 	return buf;
X+ }
X+ 
X+ #ifdef REINCARNATION
X+ const char *
X  roguename() /* Name of a Rogue player */
X  {
X  	char *i, *opts;
X***************
X*** 511,513 ****
X--- 617,620 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X*** src/Old/do_wear.c	Mon Feb 19 17:58:13 1990
X--- src/do_wear.c	Wed Feb 14 17:54:32 1990
X***************
X*** 4,12 ****
X  
X  #include "hack.h"
X  
X  static int todelay;
X  
X! static long takeoff_mask = 0L, taking_off = 0L;
X  static const long takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X  	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X  	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X--- 4,23 ----
X  
X  #include "hack.h"
X  
X+ #ifdef OVLB
X+ 
X  static int todelay;
X  
X! #endif /*OVLB */
X! 
X! #ifndef OVLB
X! 
X! OSTATIC long takeoff_mask, taking_off;
X! 
X! #else /* OVLB */
X! 
X! XSTATIC long takeoff_mask = 0L, taking_off = 0L;
X! 
X  static const long takeoff_order[] = { WORN_BLINDF, 1L, /* weapon */
X  	WORN_SHIELD, WORN_GLOVES, LEFT_RING, RIGHT_RING, WORN_CLOAK,
X  	WORN_HELMET, WORN_AMUL, WORN_ARMOR,
X***************
X*** 15,20 ****
X--- 26,51 ----
X  #endif
X  	WORN_BOOTS, 0L };
X  
X+ static void FDECL(on_msg, (struct obj *));
X+ #ifndef OVERLAY
X+ static int NDECL(Armor_on);
X+ static int NDECL(Boots_on);
X+ #endif
X+ static int NDECL(Cloak_on);
X+ #ifndef OVERLAY
X+ static int NDECL(Helmet_on);
X+ static int NDECL(Gloves_on);
X+ #endif
X+ static void NDECL(Amulet_on);
X+ static void FDECL(Ring_off_or_gone, (struct obj *, BOOLEAN_P));
X+ #ifndef OVERLAY
X+ static int FDECL(select_off, (struct obj *));
X+ #endif
X+ static struct obj *NDECL(do_takeoff);
X+ #ifndef OVERLAY
X+ static int NDECL(take_off);
X+ #endif
X+ 
X  void
X  off_msg(otmp) register struct obj *otmp; {
X  	if(flags.verbose)
X***************
X*** 348,353 ****
X--- 379,385 ----
X  	You("wield the cockatrice corpse in your bare %s.",
X  	    makeplural(body_part(HAND)));
X  	You("turn to stone...");
X+ 	killer_format = KILLED_BY_AN;
X  	killer = "cockatrice corpse";
X  	done(STONING);
X      }
X***************
X*** 398,403 ****
X--- 430,436 ----
X  /* This must be done in worn.c, because one of the possible intrinsics conferred
X   * is fire resistance, and we have to immediately set HFire_resistance in worn.c
X   * since worn.c will check it before returning.
X+  */
X  #ifndef OVERLAY
X  static 
X  #endif
X***************
X*** 406,412 ****
X  {
X      return 0;
X  }
X-  */
X  
X  int
X  Armor_off()
X--- 439,444 ----
X***************
X*** 467,474 ****
X--- 499,516 ----
X  		regularize(SAVEF+7);
X  		Strcat(SAVEF, ";1");
X  #else
X+ # ifdef MSDOS
X+ 		(void)strcpy(SAVEF, SAVEP);
X+ 		{
X+ 			int i = strlen(SAVEF);
X+ 			(void)strncat(SAVEF, plname, 8);
X+ 			regularize(SAVEF+i);
X+ 		}
X+ 		(void)strcat(SAVEF, ".sav");
X+ # else
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X+ # endif
X  #endif
X  #ifdef WIZARD
X  		}
X***************
X*** 558,563 ****
X--- 600,606 ----
X  			Your("body takes on a %s transparency...",
X  				Hallucination ? "normal" : "strange");
X  		}
X+ 		break;
X  	case RIN_ADORNMENT:
X  		ABON(A_CHA) += obj->spe;
X  		flags.botl = 1;
X***************
X*** 699,705 ****
X  /* called in main to set intrinsics of worn start-up items */
X  void
X  set_wear() {
X! /*	if (uarm)  (void) Armor_on(); */
X  	if (uarmc) (void) Cloak_on();
X  	if (uarmf) (void) Boots_on();
X  	if (uarmg) (void) Gloves_on();
X--- 742,748 ----
X  /* called in main to set intrinsics of worn start-up items */
X  void
X  set_wear() {
X! 	if (uarm)  (void) Armor_on();
X  	if (uarmc) (void) Cloak_on();
X  	if (uarmf) (void) Boots_on();
X  	if (uarmg) (void) Gloves_on();
X***************
X*** 711,728 ****
X  donning(otmp)
X  register struct obj *otmp;
X  {
X!     return (otmp == uarmf && afternmv == Boots_on)
X! 	|| (otmp == uarmh && afternmv == Helmet_on)
X! 	|| (otmp == uarmg && afternmv == Gloves_on)
X! /*	|| (otmp == uarm && afternmv == Armor_on)*/;
X  }
X  
X  static const char clothes[] = {ARMOR_SYM, 0};
X  static const char accessories[] = {RING_SYM, AMULET_SYM, TOOL_SYM, 0};
X  
X  int
X  dotakeoff() {
X  	register struct obj *otmp;
X  	int armorpieces = 0;
X  
X  #define MOREARM(x) if (x) { armorpieces++; otmp = x; }
X--- 754,788 ----
X  donning(otmp)
X  register struct obj *otmp;
X  {
X!     return (otmp == uarmf && (afternmv == Boots_on || afternmv == Boots_off))
X! 	|| (otmp == uarmh && (afternmv == Helmet_on || afternmv == Helmet_off))
X! 	|| (otmp == uarmg && (afternmv == Gloves_on || afternmv == Gloves_off))
X! 	|| (otmp == uarm && (afternmv == Armor_on || afternmv == Armor_off));
X  }
X  
X+ void
X+ cancel_don()
X+ {
X+ 	/* the piece of armor we were donning/doffing has vanished, so stop
X+ 	 * wasting time on it (and don't dereference it when donning would
X+ 	 * otherwise finish)
X+ 	 */
X+ 	afternmv = 0;
X+ 	nomovemsg = NULL;
X+ 	multi = 0;
X+ }
X+ 
X  static const char clothes[] = {ARMOR_SYM, 0};
X  static const char accessories[] = {RING_SYM, AMULET_SYM, TOOL_SYM, 0};
X  
X  int
X  dotakeoff() {
X+ #ifdef __GNULINT__
X+ 	register struct obj *otmp = 0;
X+ 		/* suppress "may be used uninitialized" warning */
X+ #else
X  	register struct obj *otmp;
X+ #endif
X  	int armorpieces = 0;
X  
X  #define MOREARM(x) if (x) { armorpieces++; otmp = x; }
X***************
X*** 782,788 ****
X--- 842,853 ----
X  
X  int
X  doremring() {
X+ #ifdef __GNULINT__
X+ 	register struct obj *otmp = 0;
X+ 		/* suppress "may be used uninitialized" warning */
X+ #else
X  	register struct obj *otmp;
X+ #endif
X  	int Accessories = 0;
X  
X  #define MOREACC(x) if (x) { Accessories++; otmp = x; }
X***************
X*** 1017,1023 ****
X  		if(is_boots(otmp)) afternmv = Boots_on;
X  		if(is_helmet(otmp)) afternmv = Helmet_on;
X  		if(is_gloves(otmp)) afternmv = Gloves_on;
X! /*		if(otmp == uarm) afternmv = Armor_on; */
X  		nomovemsg = "You finish your dressing maneuver.";
X  	} else {
X  		if(is_cloak(otmp)) (void) Cloak_on();
X--- 1082,1088 ----
X  		if(is_boots(otmp)) afternmv = Boots_on;
X  		if(is_helmet(otmp)) afternmv = Helmet_on;
X  		if(is_gloves(otmp)) afternmv = Gloves_on;
X! 		if(otmp == uarm) afternmv = Armor_on;
X  		nomovemsg = "You finish your dressing maneuver.";
X  	} else {
X  		if(is_cloak(otmp)) (void) Cloak_on();
X***************
X*** 1144,1151 ****
X--- 1209,1220 ----
X  	return(1);
X  }
X  
X+ #endif /* OVLB */
X+ 
X  #define ARM_BONUS(obj)	((10 - objects[obj->otyp].a_ac) + obj->spe)
X  
X+ #ifdef OVL0
X+ 
X  void
X  find_ac() {
X  	register int uac = 10;
X***************
X*** 1172,1177 ****
X--- 1241,1249 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  glibr()
X  {
X***************
X*** 1431,1439 ****
X--- 1503,1517 ----
X  	return(1);		/* get busy */
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  reset_remarm() { taking_off = takeoff_mask =0L; }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  int
X  doddoremarm() {
X  
X***************
X*** 1460,1465 ****
X--- 1538,1545 ----
X  		(void) Cloak_off();
X  		useup(otmp);
X  	} else if((otmp = uarm) && (!atmp || atmp == uarm)) {
X+ 		/* may be disintegrated by spell or dragon breath... */
X+ 		if (donning(otmp)) cancel_don();
X  		Your("armor turns to dust and falls to the floor!");
X  		(void) Armor_gone();
X  		useup(otmp);
X***************
X*** 1469,1483 ****
X--- 1549,1566 ----
X  		useup(otmp);
X  #endif
X  	} else if((otmp = uarmh) && (!atmp || atmp == uarmh)) {
X+ 		if (donning(otmp)) cancel_don();
X  		Your("helmet turns to dust and is blown away!");
X  		(void) Helmet_off();
X  		useup(otmp);
X  	} else if((otmp = uarmg) && (!atmp || atmp == uarmg)) {
X+ 		if (donning(otmp)) cancel_don();
X  		Your("gloves vanish!");
X  		(void) Gloves_off();
X  		useup(otmp);
X  		selftouch("You");
X  	} else if((otmp = uarmf) && (!atmp || atmp == uarmf)) {
X+ 		if (donning(otmp)) cancel_don();
X  		Your("boots disintegrate!");
X  		(void) Boots_off();
X  		useup(otmp);
X***************
X*** 1505,1507 ****
X--- 1588,1592 ----
X  		flags.botl = 1;
X  	}
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/ioctl.c	Mon Feb 19 18:07:10 1990
X--- src/ioctl.c	Wed Jan 31 19:54:07 1990
X***************
X*** 11,31 ****
X  #define MONFLAG_H
X  #include "hack.h"
X  
X! #if defined(BSD) || defined(ULTRIX)
X  #include	<sgtty.h>
X  struct ltchars ltchars;
X  struct ltchars ltchars0 = { -1, -1, -1, -1, -1, -1 }; /* turn all off */
X  #else
X  #include	<termio.h>	/* also includes part of <sgtty.h> */
X  struct termio termio;
X! #ifdef AMIX
X  #include <sys/ioctl.h>
X! #endif /* AMIX */
X  #endif
X  
X  void
X  getioctls() {
X! #if defined(BSD) || defined(ULTRIX)
X  	(void) ioctl(fileno(stdin), (int) TIOCGLTC, (char *) &ltchars);
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars0);
X  #else
X--- 11,35 ----
X  #define MONFLAG_H
X  #include "hack.h"
X  
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX)
X! # ifdef HPUX
X! #include	<bsdtty.h>
X! # else
X  #include	<sgtty.h>
X+ # endif
X  struct ltchars ltchars;
X  struct ltchars ltchars0 = { -1, -1, -1, -1, -1, -1 }; /* turn all off */
X  #else
X  #include	<termio.h>	/* also includes part of <sgtty.h> */
X  struct termio termio;
X! # ifdef AMIX
X  #include <sys/ioctl.h>
X! # endif /* AMIX */
X  #endif
X  
X  void
X  getioctls() {
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX)
X  	(void) ioctl(fileno(stdin), (int) TIOCGLTC, (char *) &ltchars);
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars0);
X  #else
X***************
X*** 56,62 ****
X  
X  void
X  setioctls() {
X! #if defined(BSD) || defined(ULTRIX)
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars);
X  #else
X  	/* Now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X--- 60,66 ----
X  
X  void
X  setioctls() {
X! #if defined(BSD) || defined(ULTRIX) || defined(HPUX)
X  	(void) ioctl(fileno(stdin), (int) TIOCSLTC, (char *) &ltchars);
X  #else
X  	/* Now modified to run under Sys V R3.	- may have to be #ifdef'ed */
X
END_OF_FILE
if test 55250 -ne `wc -c <'patch7.02'`; then
    echo shar: \"'patch7.02'\" unpacked with wrong size!
fi
# end of 'patch7.02'
echo shar: End of archive 30 \(of 30\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
