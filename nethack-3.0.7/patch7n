Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!brutus.cs.uiuc.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i014:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7n
Message-ID: <5228@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:57:33 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2298
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 14
Archive-name: NetHack3/Patch7n
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 30)."
# Contents:  patch7.10
# Wrapped by billr@saab on Wed Feb 21 10:04:35 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.10' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.10'\" to \"'patch7.10.orig'\"
  mv -f 'patch7.10' 'patch7.10.orig'
fi
echo shar: Extracting \"'patch7.10'\" \(54708 characters\)
sed "s/^X//" >'patch7.10' <<'END_OF_FILE'
X*** src/Old/mail.c	Mon Feb 19 20:26:33 1990
X--- src/mail.c	Thu Jan 25 22:13:05 1990
X***************
X*** 7,12 ****
X--- 7,15 ----
X  #include "hack.h"	/* mainly for index() which depends on BSD */
X  
X  #ifdef MAIL
X+ static void FDECL(mdrush,(struct monst *,int,int));
X+ static void FDECL(mdappear,(struct monst *,BOOLEAN_P));
X+ static void NDECL(newmail);
X  
X  # ifdef UNIX
X  #  include <sys/stat.h>
X***************
X*** 55,64 ****
X--- 58,72 ----
X   *	- It may also do this with adjoining castle rooms.
X   */
X  
X+ #ifdef OVL0
X+ 
X  # if !defined(UNIX) && !defined(VMS)
X  int mustgetmail = -1;
X  # endif
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  # ifdef UNIX
X  extern struct passwd *getpwuid();
X  static struct stat omstat,nmstat;
X***************
X*** 65,70 ****
X--- 73,81 ----
X  static char *mailbox = NULL;
X  static long laststattime;
X  
X+ # ifdef AMS				/* Just a placeholder for AMS */
X+ #   define MAILPATH "/dev/null"
X+ # else
X  #  ifdef BSD
X  #   define MAILPATH "/usr/spool/mail/"
X  #  endif
X***************
X*** 71,84 ****
X--- 82,108 ----
X  #  ifdef SYSV
X  #   define MAILPATH "/usr/mail/"
X  #  endif
X+ # endif /* AMS */
X  
X  void
X  getmailstatus() {
X  	if(!mailbox && !(mailbox = getenv("MAIL"))) {
X  #  ifdef MAILPATH
X+ #   ifdef AMS
X+ 	        struct passwd ppasswd;
X+ 
X+ 		bcopy(getpwuid(getuid()), &ppasswd, sizeof(struct passwd));
X+ 		if (ppasswd.pw_dir) {
X+ 		     mailbox = (char *) alloc((unsigned) strlen(ppasswd.pw_dir)+sizeof(AMS_MAILBOX));
X+ 		     Strcpy(mailbox, ppasswd.pw_dir);
X+ 		     Strcat(mailbox, AMS_MAILBOX);
X+ 		} else
X+ 		  return;
X+ #   else
X  		mailbox = (char *) alloc(sizeof(MAILPATH)+8);
X  		Strcpy(mailbox, MAILPATH);
X  		Strcat(mailbox, getpwuid(getuid())->pw_name);
X+ #  endif /* AMS */
X  #  else
X  		return;
X  #  endif
X***************
X*** 217,225 ****
X--- 241,254 ----
X  # ifdef VMS
X  	pline("\"Hello, %s!  I have a message for you.\"", plname);
X  # else
X+ #  ifdef NO_MAILREADER
X+ 	pline("\"Hello, %s!  You have some mail in the outside world.\"", plname);
X+ #  else
X  	pline("\"Hello, %s!  I have some mail for you.\"", plname);
X  # endif
X+ # endif
X  
X+ # ifndef NO_MAILREADER
X  	if(dist(md->mx,md->my) > 2)
X  		verbalize("Catch!");
X  	more();
X***************
X*** 243,251 ****
X--- 272,286 ----
X  # ifdef VMS
X  	broadcasts--;
X  # endif
X+ # endif /* NO_MAILREADER */
X  }
X  
X+ #endif /* OVLB */
X+ 
X  # if !defined(UNIX) && !defined(VMS)
X+ 
X+ #ifdef OVL0
X+ 
X  void
X  ckmailstatus() {
X  	if (mustgetmail < 0)
X***************
X*** 256,269 ****
X--- 291,313 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  readmail()
X  {
X  	pline("It says:  \"Please disregard previous letter.\"");
X  }
X+ 
X+ #endif /* OVLB */
X+ 
X  # endif /* !UNIX && !VMS */
X  
X  # ifdef UNIX
X+ 
X+ #ifdef OVL0
X+ 
X  void
X  ckmailstatus() {
X  	if(!mailbox
X***************
X*** 288,293 ****
X--- 332,340 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  readmail() {
X  #  ifdef DEF_MAILREADER			/* This implies that UNIX is defined */
X***************
X*** 300,314 ****
X  		exit(1);
X  	}
X  #  else
X  	(void) page_file(mailbox, FALSE);
X! #  endif
X  	/* get new stat; not entirely correct: there is a small time
X  	   window where we do not see new mail */
X  	getmailstatus();
X  }
X  # endif /* UNIX */
X  
X  # ifdef VMS
X  void
X  ckmailstatus()
X  {
X--- 347,370 ----
X  		exit(1);
X  	}
X  #  else
X+ #   ifndef AMS  			/* AMS mailboxes are directories */
X  	(void) page_file(mailbox, FALSE);
X! #   endif /* AMS */
X! #  endif /* DEF_MAILREADER */
X! 
X  	/* get new stat; not entirely correct: there is a small time
X  	   window where we do not see new mail */
X  	getmailstatus();
X  }
X+ 
X+ #endif /* OVLB */
X+ 
X  # endif /* UNIX */
X  
X  # ifdef VMS
X+ 
X+ #ifdef OVL0
X+ 
X  void
X  ckmailstatus()
X  {
X***************
X*** 316,321 ****
X--- 372,380 ----
X  		newmail();
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  readmail()
X  {
X***************
X*** 330,334 ****
X--- 389,395 ----
X  	}
X  }
X  # endif /* VMS */
X+ 
X+ #endif /* OVLB */
X  
X  #endif /* MAIL */
X*** src/Old/makedefs.c	Mon Feb 19 20:26:53 1990
X--- src/makedefs.c	Thu Feb  8 17:33:49 1990
X***************
X*** 2,8 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* makedefs.c - NetHack version 3.0 */
X  
X- #define MAKEDEFS_C 1	/* needs to be defined to 1 for Mac */
X  
X  #define EXTERN_H
X  #include	"config.h"
X--- 2,7 ----
X***************
X*** 13,26 ****
X  #endif /* NULL */
X  #define NULL	((genericptr_t)0)
X  
X! #ifndef LINT
X  static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.0\t89/11/15";
X  #endif
X  
X  #ifdef MSDOS
X! #ifndef TOS
X  # define freopen _freopen
X! #endif
X  # undef	exit
X  extern void FDECL(exit, (int));
X  # define RDMODE	"r"
X--- 12,26 ----
X  #endif /* NULL */
X  #define NULL	((genericptr_t)0)
X  
X! #if !defined(LINT) && !defined(__GNULINT__)
X  static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.0\t89/11/15";
X  #endif
X  
X  #ifdef MSDOS
X! # if !defined(AMIGA) && !defined(TOS)
X  # define freopen _freopen
X! FILE *FDECL(_freopen, (char *,char *,FILE *));
X! # endif
X  # undef	exit
X  extern void FDECL(exit, (int));
X  # define RDMODE	"r"
X***************
X*** 29,56 ****
X  # define RDMODE  "r+"
X  # define WRMODE  "w+"
X  #endif
X! #if defined(SYSV) || defined(GENIX) || defined(UNIXDEBUG)
X! void rename();
X! #endif
X! #ifdef AMIGA
X! # undef freopen
X! # undef printf
X! # undef puts
X! # undef fflush
X! # define fflush FFLUSH
X! # undef fputs
X! # undef fprintf
X  #endif
X  
X  /* construct definitions of object constants */
X  
X  #ifdef AMIGA
X! # define MONST_FILE	 "include:pm.h"
X! # define ONAME_FILE	 "include:onames.h"
X! # define TRAP_FILE	 "include:trap.h"
X! # define DATE_FILE	 "include:date.h"
X! # define DATA_FILE	 "auxil:data"
X! # define RUMOR_FILE	 "auxil:rumors"
X  #else
X  # ifndef MACOS
X  /* construct definitions of object constants */
X--- 29,53 ----
X  # define RDMODE  "r+"
X  # define WRMODE  "w+"
X  #endif
X! 
X! #ifdef MACOS
X! Boolean FDECL(TouchFile,(char *));
X! Str255 VolName;
X! int vRef;
X! Str255 File;
X! FInfo info;
X! OSErr macErr;
X  #endif
X  
X  /* construct definitions of object constants */
X  
X  #ifdef AMIGA
X! # define MONST_FILE	 "Incl:pm.h"
X! # define ONAME_FILE	 "Incl:onames.h"
X! # define TRAP_FILE	 "Incl:trap.h"
X! # define DATE_FILE	 "Incl:date.h"
X! # define DATA_FILE	 "Auxil:data"
X! # define RUMOR_FILE	 "Auxil:rumors"
X  #else
X  # ifndef MACOS
X  /* construct definitions of object constants */
X***************
X*** 84,95 ****
X  
X  char	in_line[256];
X  extern char *FDECL(gets, (char *));
X! void do_objs(), do_traps(), do_data(), do_date(), do_permonst(), do_rumors();
X  #ifdef SMALLDATA
X! void do_monst(), save_resource();
X  #endif
X  char *FDECL(limit, (char *,BOOLEAN_P));
X! FILE *FDECL(_freopen, (char *,char *,FILE *));
X  
X  int
X  main(argc, argv)
X--- 81,114 ----
X  
X  char	in_line[256];
X  extern char *FDECL(gets, (char *));
X! 
X! int FDECL(main, (int, char **));
X! void NDECL(do_objs);
X! void NDECL(do_traps);
X! void NDECL(do_data);
X! void NDECL(do_date);
X! void NDECL(do_permonst);
X! void NDECL(do_rumors);
X! 
X! char * FDECL(tmpdup, (const char *));
X! 
X! #if defined(SYSV) || defined(GENIX) || defined(UNIXDEBUG)
X! void FDECL(rename, (char *, char *));
X! #endif
X! 
X  #ifdef SMALLDATA
X! void NDECL(do_monst);
X! void NDECL(save_resource);
X  #endif
X+ 
X  char *FDECL(limit, (char *,BOOLEAN_P));
X! 
X! #if defined(SMALLDATA) && defined(MACOS)
X! OSErr FDECL(write_resource, (Handle, short, Str255, short));
X! # if defined(AZTEC) || defined(THINKC4)
X! int NDECL(getpid);
X! # endif
X! #endif
X  
X  int
X  main(argc, argv)
X***************
X*** 113,119 ****
X  
X  	/* standard Mac initialization */
X  	InitGraf(&MAINGRAFPORT);
X! 	
X  	InitFonts();
X  	InitWindows();
X  	InitMenus();
X--- 132,138 ----
X  
X  	/* standard Mac initialization */
X  	InitGraf(&MAINGRAFPORT);
X! 
X  	InitFonts();
X  	InitWindows();
X  	InitMenus();
X***************
X*** 120,126 ****
X  	InitCursor();
X  	FlushEvents(everyEvent,0);
X  	InitDialogs(NULL);
X! 	
X  	params[0] = '-';
X  	options = "DVPRTOM";
X  	dialog = GetNewDialog(200, 0L, (WindowPtr) -1);
X--- 139,145 ----
X  	InitCursor();
X  	FlushEvents(everyEvent,0);
X  	InitDialogs(NULL);
X! 
X  	params[0] = '-';
X  	options = "DVPRTOM";
X  	dialog = GetNewDialog(200, 0L, (WindowPtr) -1);
X***************
X*** 154,160 ****
X  	if (itemHit == OK_BUTTON && lastItem >= FIRST_RADIO_BUTTON) {
X  		argc = 2;
X  		option = params;
X! 	
X  #else
X  	if(argc == 2) {
X  	    option = argv[1];
X--- 173,179 ----
X  	if (itemHit == OK_BUTTON && lastItem >= FIRST_RADIO_BUTTON) {
X  		argc = 2;
X  		option = params;
X! 
X  #else
X  	if(argc == 2) {
X  	    option = argv[1];
X***************
X*** 183,195 ****
X  		case 'r':
X  		case 'R':	do_rumors();
X  				break;
X! #if defined(SMALLDATA) && defined(MACOS)
X  		case 'm':
X  		case 'M':	do_monst();
X  				break;
X- 		
X- #endif	/* SMALLDATA && MACOS */
X  
X  		default:
X  				(void) fprintf(stderr,
X  					"Unknown option '%c'.\n", option[1]);
X--- 202,214 ----
X  		case 'r':
X  		case 'R':	do_rumors();
X  				break;
X! #if defined(SMALLDATA)
X  		case 'm':
X  		case 'M':	do_monst();
X  				break;
X  
X+ #endif	/* SMALLDATA */
X+ 
X  		default:
X  				(void) fprintf(stderr,
X  					"Unknown option '%c'.\n", option[1]);
X***************
X*** 260,266 ****
X  void
X  do_rumors(){
X  	char	infile[30];
X- 	FILE	*FDECL(freopen, (char *,char *,FILE *));
X  	long	true_rumor_size;
X  
X  	if(freopen(RUMOR_FILE, WRMODE, stdout) == (FILE *)0) {
X--- 279,284 ----
X***************
X*** 294,299 ****
X--- 312,326 ----
X  
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X+ #ifdef MACOS
X+ 	strcpy((char *)File, RUMOR_FILE);
X+ 	CtoPstr((char *)File);
X+ 	if(!GetVol(VolName, &vRef) && !GetFInfo(File, vRef, &info)){
X+ 		info.fdCreator = CREATOR;
X+ 		info.fdType = TEXT_TYPE;
X+ 		(void) SetFInfo(File, vRef, &info);
X+ 	}
X+ #endif
X  	return;
X  }
X  
X***************
X*** 321,326 ****
X--- 348,357 ----
X  #endif
X  	for(c = cbuf; *c != '\n'; c++);	*c = 0; /* strip off the '\n' */
X  	Printf("const char datestring[] = \"%s\";\n", cbuf);
X+ #ifdef MSDOS
X+       /* get the time we did a compile for checking save and level files */
X+ 	Printf("const long compiletime = %ld;\n", clock);
X+ #endif
X  
X  	(void) fclose(stdout);
X  	return;
X***************
X*** 329,335 ****
X  void
X  do_data(){
X  	char	tempfile[30];
X! 
X  	Sprintf(tempfile, "%s.base", DATA_FILE);
X  	if(freopen(tempfile, RDMODE, stdin) == (FILE *)0) {
X  		perror(tempfile);
X--- 360,368 ----
X  void
X  do_data(){
X  	char	tempfile[30];
X! #ifndef INFERNO
X! 	boolean	skipping_demons = TRUE;
X! #endif
X  	Sprintf(tempfile, "%s.base", DATA_FILE);
X  	if(freopen(tempfile, RDMODE, stdin) == (FILE *)0) {
X  		perror(tempfile);
X***************
X*** 342,365 ****
X  	}
X  
X  	while(gets(in_line) != NULL) {
X  #ifndef GOLEMS
X! 	    if(!strcmp(in_line, "'\ta golem;"))
X  		while(gets(in_line) != NULL && in_line[0] == '\t')
X  		    ; /* do nothing */
X  #endif
X! #ifndef	SPELLS
X! 	    if(!strcmp(in_line, "+\ta spell book"))
X! 		; /* do nothing */
X! 	    else
X! #endif
X! #ifndef KOPS
X! 	    if(!strcmp(in_line, "K\ta Keystone Kop"))
X! 		; /* do nothing */
X  	    else
X  #endif
X! #ifndef WORM
X! 	    if(!strcmp(in_line, "~\tthe tail of a long worm"))
X! 		; /* do nothing */
X  	    else
X  #endif
X  		(void) puts(in_line);
X--- 375,426 ----
X  	}
X  
X  	while(gets(in_line) != NULL) {
X+ #ifndef INFERNO
X+ 	    if(skipping_demons)
X+ 		while(gets(in_line) != NULL && strcmp(in_line, "*centaur"))
X+ 		    ; /* do nothing */
X+ 	    skipping_demons = FALSE;
X+ #endif
X+ #ifndef ARMY
X+ 	    if(!strcmp(in_line, "*soldier")) {
X+ 		while(gets(in_line) != NULL && in_line[0] != '\t') ;
X+ 		while(gets(in_line) != NULL && in_line[0] == '\t')
X+ 		    ; /* do nothing */
X+ 	    }
X+ 	    else
X+ #endif
X+ #ifndef WORM
X+ 	    if(!strcmp(in_line, "*long worm")) {
X+ 		while(gets(in_line) != NULL && in_line[0] != '\t') ;
X+ 		while(gets(in_line) != NULL && in_line[0] == '\t')
X+ 		    ; /* do nothing */
X+ 	    }
X+ 	    else
X+ #endif
X  #ifndef GOLEMS
X! 	    if(!strcmp(in_line, "*golem"))
X  		while(gets(in_line) != NULL && in_line[0] == '\t')
X  		    ; /* do nothing */
X+ 	    else
X  #endif
X! #ifndef MEDUSA
X! 	    if(!strcmp(in_line, "medusa"))
X! 		while(gets(in_line) != NULL && in_line[0] == '\t')
X! 		    ; /* do nothing */
X  	    else
X  #endif
X! #ifndef NAMED_ITEMS
X! 	    if(!strcmp(in_line, "snickersnee")
X! 		|| !strcmp(in_line, "orcrist")
X! 	      )
X! 		while(gets(in_line) != NULL && in_line[0] == '\t')
X! 		    ; /* do nothing */
X! 	    else
X! #endif
X! #ifndef TOLKIEN
X! 	    if(!strcmp(in_line, "hobbit"))
X! 		while(gets(in_line) != NULL && in_line[0] == '\t')
X! 		    ; /* do nothing */
X  	    else
X  #endif
X  		(void) puts(in_line);
X***************
X*** 366,379 ****
X  	}
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X! 	return;
X  }
X  
X  void
X! do_permonst() {
X! 
X  	int	i;
X! 	char	*c;
X  
X  	if(freopen(MONST_FILE, WRMODE, stdout) == (FILE *)0) {
X  		perror(MONST_FILE);
X--- 427,450 ----
X  	}
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X! #ifdef MACOS
X! 	Strcpy((char *)File, DATA_FILE);
X! 	CtoPstr((char *)File);
X! 	if(!GetVol(VolName, &vRef) && !GetFInfo(File, vRef, &info)){
X! 		info.fdCreator = CREATOR;
X! 		info.fdType = TEXT_TYPE;
X! 		(void) SetFInfo(File, vRef, &info);
X! 	}
X! #endif
X! 
X! 	return;
X  }
X  
X  void
X! do_permonst()
X! {
X  	int	i;
X! 	char	*c, *nam;
X  
X  	if(freopen(MONST_FILE, WRMODE, stdout) == (FILE *)0) {
X  		perror(MONST_FILE);
X***************
X*** 384,394 ****
X  
X  	for(i = 0; mons[i].mlet; i++) {
X  		Printf("\n#define\tPM_");
X! 		for(c = mons[i].mname; *c; c++) {
X  		    if((*c >= 'a') && (*c <= 'z')) *c -= (char)('a' - 'A');
X  		    else if(*c == ' ' || *c == '-')	*c = '_';
X  		}
X! 		Printf("%s\t%d", mons[i].mname, i);
X  	}
X  	Printf("\n\n#define\tNUMMONS\t%d\n", i);
X  	Printf("\n#endif /* PM_H /**/\n");
X--- 455,465 ----
X  
X  	for(i = 0; mons[i].mlet; i++) {
X  		Printf("\n#define\tPM_");
X! 		for(nam = c = tmpdup(mons[i].mname); *c; c++) {
X  		    if((*c >= 'a') && (*c <= 'z')) *c -= (char)('a' - 'A');
X  		    else if(*c == ' ' || *c == '-')	*c = '_';
X  		}
X! 		Printf("%s\t%d", nam, i);
X  	}
X  	Printf("\n\n#define\tNUMMONS\t%d\n", i);
X  	Printf("\n#endif /* PM_H /**/\n");
X***************
X*** 409,423 ****
X  }
X  
X  void
X! do_objs() {
X! 
X! 	register int i = 0, sum = 0;
X! 	register char *c;
X  #ifdef SPELLS
X! 	register int nspell = 0;
X  #endif
X! 	register boolean prefix = 0;
X! 	register char let = '\0';
X  	boolean	sumerr = FALSE;
X  
X  	if(freopen(ONAME_FILE, WRMODE, stdout) == (FILE *)0) {
X--- 480,494 ----
X  }
X  
X  void
X! do_objs()
X! {
X! 	int i = 0, sum = 0;
X! 	char *c, *objnam;
X  #ifdef SPELLS
X! 	int nspell = 0;
X  #endif
X! 	boolean prefix = 0;
X! 	char let = '\0';
X  	boolean	sumerr = FALSE;
X  
X  	if(freopen(ONAME_FILE, WRMODE, stdout) == (FILE *)0) {
X***************
X*** 428,434 ****
X  	Printf("#ifndef ONAMES_H\n#define ONAMES_H\n\n");
X  
X  	for(i = 0; !i || objects[i].oc_olet != ILLOBJ_SYM; i++) {
X! 		if (!(c = objects[i].oc_name)) continue;
X  
X  		/* make sure probabilities add up to 1000 */
X  		if(objects[i].oc_olet != let) {
X--- 499,505 ----
X  	Printf("#ifndef ONAMES_H\n#define ONAMES_H\n\n");
X  
X  	for(i = 0; !i || objects[i].oc_olet != ILLOBJ_SYM; i++) {
X! 		if (!(objnam = tmpdup(objects[i].oc_name))) continue;
X  
X  		/* make sure probabilities add up to 1000 */
X  		if(objects[i].oc_olet != let) {
X***************
X*** 442,448 ****
X  			sum = 0;
X  		}
X  
X! 		for(; *c; c++) {
X  		    if((*c >= 'a') && (*c <= 'z')) *c -= (char)('a' - 'A');
X  		    else if(*c == ' ' || *c == '-')	*c = '_';
X  		}
X--- 513,519 ----
X  			sum = 0;
X  		}
X  
X! 		for(c = objnam; *c; c++) {
X  		    if((*c >= 'a') && (*c <= 'z')) *c -= (char)('a' - 'A');
X  		    else if(*c == ' ' || *c == '-')	*c = '_';
X  		}
X***************
X*** 464,476 ****
X  			/* avoid trouble with stupid C preprocessors */
X  			if(objects[i].oc_material == GLASS) {
X  			    Printf("/* #define\t%s\t%d */\n",
X! 							objects[i].oc_name, i);
X  			    continue;
X  			}
X  		    default:
X  			Printf("#define\t");
X  		}
X! 		Printf("%s\t%d\n", limit(objects[i].oc_name, prefix), i);
X  		prefix = 0;
X  
X  		sum += objects[i].oc_prob;
X--- 535,547 ----
X  			/* avoid trouble with stupid C preprocessors */
X  			if(objects[i].oc_material == GLASS) {
X  			    Printf("/* #define\t%s\t%d */\n",
X! 							objnam, i);
X  			    continue;
X  			}
X  		    default:
X  			Printf("#define\t");
X  		}
X! 		Printf("%s\t%d\n", limit(objnam, prefix), i);
X  		prefix = 0;
X  
X  		sum += objects[i].oc_prob;
X***************
X*** 486,491 ****
X--- 557,573 ----
X  	return;
X  }
X  
X+ char *
X+ tmpdup(str)
X+ const char *str;
X+ {
X+ 	static char buf[128];
X+ 
X+ 	if (!str) return (char *)0;
X+ 	(void)strncpy(buf, str, 127);
X+ 	return buf;
X+ }
X+ 
X  #if defined(SYSV) || defined(GENIX) || defined(UNIXDEBUG)
X  void
X  rename(oldname, newname)
X***************
X*** 536,542 ****
X  #endif /* MSDOS */
X  
X  
X! #if defined(SMALLDATA) && defined(MACOS)
X  void
X  do_monst()
X  {
X--- 618,624 ----
X  #endif /* MSDOS */
X  
X  
X! #if defined(SMALLDATA)
X  void
X  do_monst()
X  {
X***************
X*** 548,559 ****
X  	Str255	name;
X  	short	findNamedFile();
X  	OSErr	write_resource();
X! 	
X  	for(i = 0; mons[i].mlet; i++) {
X  		;
X  	}
X  	i++;
X! 	
X  	/*
X  	 * convert to struct where character arrays instead of pointers to
X  	 * strings are used
X--- 630,641 ----
X  	Str255	name;
X  	short	findNamedFile();
X  	OSErr	write_resource();
X! 
X  	for(i = 0; mons[i].mlet; i++) {
X  		;
X  	}
X  	i++;
X! 
X  	/*
X  	 * convert to struct where character arrays instead of pointers to
X  	 * strings are used
X***************
X*** 564,572 ****
X  		BlockMove(&(mons[j].mlet), &(pmMonst[j].pmp.mlet),
X  				(long)sizeof(struct pmpart));
X  	}
X! 	
X  	PtrToHand((Ptr)pmMonst, &monstData, (long)(i * sizeof(struct pmstr)));
X! 	
X  	/* store the object data, in Nethack the char * will be copied in */
X  	for(i = 0; !i || objects[i].oc_olet != ILLOBJ_SYM; i++) {
X  		;
X--- 646,654 ----
X  		BlockMove(&(mons[j].mlet), &(pmMonst[j].pmp.mlet),
X  				(long)sizeof(struct pmpart));
X  	}
X! 
X  	PtrToHand((Ptr)pmMonst, &monstData, (long)(i * sizeof(struct pmstr)));
X! 
X  	/* store the object data, in Nethack the char * will be copied in */
X  	for(i = 0; !i || objects[i].oc_olet != ILLOBJ_SYM; i++) {
X  		;
X***************
X*** 573,579 ****
X  	}
X  	PtrToHand((Ptr)objects, &objData, ((i+1)*sizeof(struct objclass)));
X  
X! 	strcpy((char *)&name[0], "\014Nethack.rsrc");
X  	if (findNamedFile(&name[1], 0, &reply)) {
X  	    strncpy((char *)&name[0],(char *)&reply.fName[0], reply.fName[0]+1);
X  	    if ((refNum = OpenResFile(name)) != -1) {
X--- 655,661 ----
X  	}
X  	PtrToHand((Ptr)objects, &objData, ((i+1)*sizeof(struct objclass)));
X  
X! 	strcpy((char *)&name[0], "\010NH3.rsrc");
X  	if (findNamedFile(&name[1], 0, &reply)) {
X  	    strncpy((char *)&name[0],(char *)&reply.fName[0], reply.fName[0]+1);
X  	    if ((refNum = OpenResFile(name)) != -1) {
X***************
X*** 581,594 ****
X  		    strcpy((char *)&name[0], "\012MONST_DATA");
X  		    if (error = write_resource(monstData,
X  						MONST_DATA, name, refNum)) {
X! 		    	SysBeep(1);
X! 		    	Printf("Couldn't add monster data resource.\n");
X  		    }
X  		    strcpy((char *)&name[0], "\013OBJECT_DATA");
X  		    if (error = write_resource(objData,
X  						OBJECT_DATA, name, refNum)) {
X! 		    	SysBeep(1);
X! 		    	Printf("Couldn't add object data resource.\n");
X  		    }
X  		    CloseResFile(refNum);
X  		    if (ResError() != noErr) {
X--- 663,676 ----
X  		    strcpy((char *)&name[0], "\012MONST_DATA");
X  		    if (error = write_resource(monstData,
X  						MONST_DATA, name, refNum)) {
X! 			SysBeep(1);
X! 			Printf("Couldn't add monster data resource.\n");
X  		    }
X  		    strcpy((char *)&name[0], "\013OBJECT_DATA");
X  		    if (error = write_resource(objData,
X  						OBJECT_DATA, name, refNum)) {
X! 			SysBeep(1);
X! 			Printf("Couldn't add object data resource.\n");
X  		    }
X  		    CloseResFile(refNum);
X  		    if (ResError() != noErr) {
X***************
X*** 598,608 ****
X  		}
X  	    }
X  	}
X! 	
X  	DisposHandle(monstData);
X  	DisposHandle(objData);
X  }
X  
X  OSErr
X  write_resource(data, resID, resName, refNum)
X  Handle	data;
X--- 680,739 ----
X  		}
X  	    }
X  	}
X! 
X  	DisposHandle(monstData);
X  	DisposHandle(objData);
X+ 
X+ 	vRef = reply.vRefNum;
X+ 	(void) TouchFile(SHELP);
X+ 	(void) TouchFile(HELP);
X+ #ifdef NEWS
X+ 	(void) TouchFile("news");
X+ #endif
X+ 	if(!TouchFile(RECORD))
X+ 		(void) Create(File, vRef, CREATOR, TEXT_TYPE);
X+ 
X+ 	(void) TouchFile(CMDHELPFILE);
X+ 	(void) TouchFile(HISTORY);
X+ 	(void) TouchFile(OPTIONFILE);
X+ #ifdef ORACLE
X+ 	(void) TouchFile(ORACLEFILE);
X+ #endif
X+ 	(void) TouchFile(LICENSE);
X+ #ifdef MACOS
X+ 	(void) TouchFile(MACHELP);
X+ #endif
X+ }
X+ 
X+ Boolean
X+ TouchFile(fname)
X+ char *fname;
X+ {
X+ 	SFReply	reply;
X+ 	short	findNamedFile();
X+ 
X+ 	Strcpy((char *)File, fname);
X+ 	CtoPstr((char *)File);
X+ 	File[File[0]+1] = 0;
X+ 	reply.good = TRUE;
X+ 	if(GetFInfo(File, vRef, &info)){
X+ 		findNamedFile(&File[1], 2, &reply);
X+ 		if(reply.good){
X+ 			vRef = reply.vRefNum;
X+ 			GetFInfo(File, vRef, &info);
X+ 		}
X+ 	}
X+ 	if(reply.good){
X+ 		info.fdCreator = CREATOR;
X+ 		info.fdType = TEXT_TYPE;
X+ 		(void) SetFInfo(File, vRef, &info);
X+ 	}
X+ 
X+ 	return(reply.good);
X  }
X  
X+ 
X+ 
X  OSErr
X  write_resource(data, resID, resName, refNum)
X  Handle	data;
X***************
X*** 625,632 ****
X  			error = ResError();
X  		}
X  		if (error != noErr) {
X!     		return error;
X!     	}
X  	} else if (ResError() != resNotFound && ResError() != noErr) {
X  			return (ResError());
X  	}
X--- 756,763 ----
X  			error = ResError();
X  		}
X  		if (error != noErr) {
X! 			return error;
X! 		}
X  	} else if (ResError() != resNotFound && ResError() != noErr) {
X  			return (ResError());
X  	}
X***************
X*** 645,648 ****
X  	return 1;
X  }
X  # endif
X! #endif	/* SMALLDATA && MACOS */
X--- 776,779 ----
X  	return 1;
X  }
X  # endif
X! #endif	/* SMALLDATA */
X*** src/Old/makemon.c	Mon Feb 19 20:27:27 1990
X--- src/makemon.c	Wed Feb 14 18:38:13 1990
X***************
X*** 1,20 ****
X! /*	SCCS Id: @(#)makemon.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include	"hack.h"
X  
X- struct monst zeromonst;
X  static int FDECL(uncommon, (struct permonst *));
X  
X  int monstr[NUMMONS];
X  
X  #define m_initsgrp(mtmp, x, y)	m_initgrp(mtmp, x, y, 3)
X  #define m_initlgrp(mtmp, x, y)	m_initgrp(mtmp, x, y, 10)
X  #define toostrong(monindx, lev) (monstr[monindx] > lev)
X  #define tooweak(monindx, lev)	(monstr[monindx] < lev)
X  
X! static void
X  m_initgrp(mtmp, x, y, n)	/* make a group just like mtmp */
X  register struct monst *mtmp;
X  register int x, y, n;
X--- 1,38 ----
X! /*	SCCS Id: @(#)makemon.c	3.0	89/11/22
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #include "hack.h"
X! #ifdef REINCARNATION
X! # include <ctype.h>
X! #endif
X! 
X! VSTATIC struct monst zeromonst;
X  
X  static int FDECL(uncommon, (struct permonst *));
X+ OSTATIC void FDECL(m_initgrp,(struct monst *,int,int,int));
X+ static void FDECL(m_initthrow,(struct monst *,int,int));
X+ OSTATIC void FDECL(m_initweap,(struct monst *));
X+ static void FDECL(m_initinv,(struct monst *));
X+ static void FDECL(rloc_to,(struct monst *,int,int));
X+ static int FDECL(mstrength,(struct permonst *));
X  
X+ extern int monstr[];
X+ 
X+ #ifdef OVLB
X+ 
X  int monstr[NUMMONS];
X  
X+ #endif /* OVLB */
X+ 
X  #define m_initsgrp(mtmp, x, y)	m_initgrp(mtmp, x, y, 3)
X  #define m_initlgrp(mtmp, x, y)	m_initgrp(mtmp, x, y, 10)
X  #define toostrong(monindx, lev) (monstr[monindx] > lev)
X  #define tooweak(monindx, lev)	(monstr[monindx] < lev)
X  
X! #ifdef OVLB
X! 
X! XSTATIC void
X  m_initgrp(mtmp, x, y, n)	/* make a group just like mtmp */
X  register struct monst *mtmp;
X  register int x, y, n;
X***************
X*** 50,55 ****
X--- 68,74 ----
X  	}
X  }
X  
X+ 
X  static void
X  m_initthrow(mtmp,otyp,oquan)
X  struct monst *mtmp;
X***************
X*** 66,72 ****
X  	mpickobj(mtmp, otmp);
X  }
X  
X! static void
X  m_initweap(mtmp)
X  register struct monst *mtmp;
X  {
X--- 85,91 ----
X  	mpickobj(mtmp, otmp);
X  }
X  
X! XSTATIC void
X  m_initweap(mtmp)
X  register struct monst *mtmp;
X  {
X***************
X*** 118,124 ****
X  #ifdef TOLKIEN
X  		if (mm == PM_HOBBIT) {
X  		    switch (rn2(3)) {
X! 		  	case 0:
X  			    (void)mongets(mtmp, DAGGER);
X  			    break;
X  			case 1:
X--- 137,143 ----
X  #ifdef TOLKIEN
X  		if (mm == PM_HOBBIT) {
X  		    switch (rn2(3)) {
X! 			case 0:
X  			    (void)mongets(mtmp, DAGGER);
X  			    break;
X  			case 1:
X***************
X*** 134,143 ****
X  		    (void)mongets(mtmp, IRON_SHOES);
X  		    if (!rn2(4)) {
X  			(void)mongets(mtmp, DWARVISH_SHORT_SWORD);
X! 			(void)mongets(mtmp,
X! 			    rn2(3) ? DWARVISH_MATTOCK : AXE);
X  			(void)mongets(mtmp, DWARVISH_IRON_HELM);
X- 			(void)mongets(mtmp, DWARVISH_ROUNDSHIELD);
X  			if (!rn2(3))
X  			    (void)mongets(mtmp, DWARVISH_MITHRIL_COAT);
X  		    } else {
X--- 153,165 ----
X  		    (void)mongets(mtmp, IRON_SHOES);
X  		    if (!rn2(4)) {
X  			(void)mongets(mtmp, DWARVISH_SHORT_SWORD);
X! 			/* note: you can't use a mattock with a shield */
X! 			if (rn2(2)) (void)mongets(mtmp, DWARVISH_MATTOCK);
X! 			else {
X! 				(void)mongets(mtmp, AXE);
X! 				(void)mongets(mtmp, DWARVISH_ROUNDSHIELD);
X! 			}
X  			(void)mongets(mtmp, DWARVISH_IRON_HELM);
X  			if (!rn2(3))
X  			    (void)mongets(mtmp, DWARVISH_MITHRIL_COAT);
X  		    } else {
X***************
X*** 338,343 ****
X--- 360,368 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  static void
X  m_initinv(mtmp)
X  register struct	monst	*mtmp;
X***************
X*** 392,397 ****
X--- 417,424 ----
X  			if (!rn2(2)) (void) mongets(mtmp, C_RATION);
X  		    }
X  #endif
X+ 		} else if (ptr == &mons[PM_SHOPKEEPER]) {
X+ 		    (void) mongets(mtmp,SKELETON_KEY);
X  		}
X  		break;
X  
X***************
X*** 450,456 ****
X  	if(x == 0 && y == 0) {
X  		int uroom;
X  		int tryct = 0;	/* careful with bigrooms */
X! 
X  		if(!in_mklev) uroom = inroom(u.ux, u.uy);
X  
X  		do {
X--- 477,485 ----
X  	if(x == 0 && y == 0) {
X  		int uroom;
X  		int tryct = 0;	/* careful with bigrooms */
X! #ifdef __GNULINT__
X! 		uroom = 0;	/* supress used before set warning */
X! #endif
X  		if(!in_mklev) uroom = inroom(u.ux, u.uy);
X  
X  		do {
X***************
X*** 465,480 ****
X  		return((struct monst *) 0);
X  
X  	if(ptr){
X! 		/* if you are to make a specific monster and it has 
X  		   already been genocided, return */
X  		if(ptr->geno & G_GENOD) return((struct monst *) 0);
X  	} else {
X  		/* make a random (common) monster. */
X- #ifdef REINCARNATION
X- 		if (!(ptr = (dlevel==rogue_level) ? roguemon() : rndmonst()))
X- #else
X  		if(!(ptr = rndmonst()))
X- #endif
X  		{
X  #ifdef DEBUG
X  		    pline("Warning: no monster.");
X--- 494,505 ----
X  		return((struct monst *) 0);
X  
X  	if(ptr){
X! 		/* if you are to make a specific monster and it has
X  		   already been genocided, return */
X  		if(ptr->geno & G_GENOD) return((struct monst *) 0);
X  	} else {
X  		/* make a random (common) monster. */
X  		if(!(ptr = rndmonst()))
X  		{
X  #ifdef DEBUG
X  		    pline("Warning: no monster.");
X***************
X*** 489,496 ****
X  	*mtmp = zeromonst;		/* clear all entries in structure */
X  	for(ct = 0; ct < ptr->pxlth; ct++)
X  		((char *) &(mtmp->mextra[0]))[ct] = 0;
X-  	if(type_is_pname(ptr))
X-  		Strcpy(NAME(mtmp), ptr->mname);
X  	mtmp->nmon = fmon;
X  	fmon = mtmp;
X  	mtmp->m_id = flags.ident++;
X--- 514,519 ----
X***************
X*** 503,521 ****
X  	    mtmp->mhpmax = mtmp->mhp = golemhp(monsndx(ptr));
X  	else
X  #endif /* GOLEMS */
X!  	if(ptr->mlevel > 49) {
X  	    /* "special" fixed hp monster
X  	     * the hit points are encoded in the mlevel in a somewhat strange
X  	     * way to fit in the 50..127 positive range of a signed character
X  	     * above the 1..49 that indicate "normal" monster levels */
X!  	    mtmp->mhpmax = mtmp->mhp = 2*(ptr->mlevel - 6);
X!  	    mtmp->m_lev = mtmp->mhp / 4;	/* approximation */
X!  	} else if((ptr->mlet == S_DRAGON) && (ptr >= &mons[PM_GRAY_DRAGON]))
X  	    mtmp->mhpmax = mtmp->mhp = 80;
X  	else if(!mtmp->m_lev) mtmp->mhpmax = mtmp->mhp = rnd(4);
X  	else mtmp->mhpmax = mtmp->mhp = d((int)mtmp->m_lev, 8);
X  	place_monster(mtmp, x, y);
X! 	mtmp->mcansee = 1;
X  	mtmp->mpeaceful = peace_minded(ptr);
X  
X  	switch(ptr->mlet) {
X--- 526,544 ----
X  	    mtmp->mhpmax = mtmp->mhp = golemhp(monsndx(ptr));
X  	else
X  #endif /* GOLEMS */
X! 	if(ptr->mlevel > 49) {
X  	    /* "special" fixed hp monster
X  	     * the hit points are encoded in the mlevel in a somewhat strange
X  	     * way to fit in the 50..127 positive range of a signed character
X  	     * above the 1..49 that indicate "normal" monster levels */
X! 	    mtmp->mhpmax = mtmp->mhp = 2*(ptr->mlevel - 6);
X! 	    mtmp->m_lev = mtmp->mhp / 4;	/* approximation */
X! 	} else if((ptr->mlet == S_DRAGON) && (ptr >= &mons[PM_GRAY_DRAGON]))
X  	    mtmp->mhpmax = mtmp->mhp = 80;
X  	else if(!mtmp->m_lev) mtmp->mhpmax = mtmp->mhp = rnd(4);
X  	else mtmp->mhpmax = mtmp->mhp = d((int)mtmp->m_lev, 8);
X  	place_monster(mtmp, x, y);
X! 	mtmp->mcansee = mtmp->mcanmove = 1;
X  	mtmp->mpeaceful = peace_minded(ptr);
X  
X  	switch(ptr->mlet) {
X***************
X*** 543,553 ****
X  			if(rn2(5) && !u.uhave_amulet) mtmp->msleep = 1;
X  			break;
X  		case S_UNICORN:
X! 			if ((ptr==&mons[PM_WHITE_UNICORN] && 
X  				u.ualigntyp == U_LAWFUL) ||
X! 			(ptr==&mons[PM_GRAY_UNICORN] && 
X  				u.ualigntyp == U_NEUTRAL) ||
X! 			(ptr==&mons[PM_BLACK_UNICORN] && 
X  				u.ualigntyp == U_CHAOTIC))
X  				mtmp->mpeaceful = 1;
X  			break;
X--- 566,576 ----
X  			if(rn2(5) && !u.uhave_amulet) mtmp->msleep = 1;
X  			break;
X  		case S_UNICORN:
X! 			if ((ptr==&mons[PM_WHITE_UNICORN] &&
X  				u.ualigntyp == U_LAWFUL) ||
X! 			(ptr==&mons[PM_GRAY_UNICORN] &&
X  				u.ualigntyp == U_NEUTRAL) ||
X! 			(ptr==&mons[PM_BLACK_UNICORN] &&
X  				u.ualigntyp == U_CHAOTIC))
X  				mtmp->mpeaceful = 1;
X  			break;
X***************
X*** 565,571 ****
X  	} else if (ptr == &mons[PM_WIZARD_OF_YENDOR]) {
X  		mtmp->iswiz = 1;
X  		flags.no_of_wizards++;
X! 	}
X  
X  	if(in_mklev) {
X  		if(((is_ndemon(ptr)) ||
X--- 588,595 ----
X  	} else if (ptr == &mons[PM_WIZARD_OF_YENDOR]) {
X  		mtmp->iswiz = 1;
X  		flags.no_of_wizards++;
X! 	} else if (ptr == &mons[PM_QUANTUM_MECHANIC])
X! 		mtmp = qname(mtmp);
X  
X  	if(in_mklev) {
X  		if(((is_ndemon(ptr)) ||
X***************
X*** 676,684 ****
X  	    if (passes_walls(mdat)) return 1;
X  	}
X  	if (!ACCESSIBLE(levl[x][y].typ)) return 0;
X! 	if (IS_DOOR(levl[x][y].typ) &&
X! 		    (levl[x][y].doormask & (D_LOCKED | D_CLOSED)) &&
X! 		    (!mdat || !amorphous(mdat)))
X  		return 0;
X  	if (sobj_at(BOULDER, x, y) && (!mdat || !throws_rocks(mdat)))
X  		return 0;
X--- 700,706 ----
X  	    if (passes_walls(mdat)) return 1;
X  	}
X  	if (!ACCESSIBLE(levl[x][y].typ)) return 0;
X! 	if (closed_door(x, y) && (!mdat || !amorphous(mdat)))
X  		return 0;
X  	if (sobj_at(BOULDER, x, y) && (!mdat || !throws_rocks(mdat)))
X  		return 0;
X***************
X*** 685,690 ****
X--- 707,715 ----
X  	return 1;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  static void
X  rloc_to(mtmp, x, y)
X  struct monst *mtmp;
X***************
X*** 742,747 ****
X--- 767,775 ----
X  	rloc(mtmp);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  static int
X  cmnum()	{	/* return the number of "common" monsters */
X  
X***************
X*** 761,766 ****
X--- 789,797 ----
X  		(!Inhell ? ptr->geno & G_HELL : ptr->maligntyp > 0);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  /* This routine is designed to return an integer value which represents
X   * an approximation of monster strength.  It uses a similar method of
X   * determination as "experience()" to arrive at the strength.
X***************
X*** 771,777 ****
X  {
X  	int	i, tmp2, n, tmp = ptr->mlevel;
X  
X!  	if(tmp > 49)		/* special fixed hp monster */
X  	    tmp = 2*(tmp - 6) / 4;
X  
X  /*	For creation in groups */
X--- 802,808 ----
X  {
X  	int	i, tmp2, n, tmp = ptr->mlevel;
X  
X! 	if(tmp > 49)		/* special fixed hp monster */
X  	    tmp = 2*(tmp - 6) / 4;
X  
X  /*	For creation in groups */
X***************
X*** 830,843 ****
X  		monstr[ct] = mstrength(&(mons[ct]));
X  }
X  
X  struct	permonst *
X! rndmonst() {		/* select a random monster */
X  	register struct permonst *ptr;
X  	register int i, ct;
X  	register int zlevel;
X  	static int minmlev, maxmlev, accept;
X  	static long oldmoves = 0L;	/* != 1, starting value of moves */
X  
X  	if(oldmoves != moves) {		/* must recalculate accept */
X  	    oldmoves = moves;
X  	    zlevel = u.uhave_amulet ? MAXLEVEL : dlevel;
X--- 861,886 ----
X  		monstr[ct] = mstrength(&(mons[ct]));
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  struct	permonst *
X! rndmonst()		/* select a random monster */
X! {
X  	register struct permonst *ptr;
X  	register int i, ct;
X  	register int zlevel;
X  	static int minmlev, maxmlev, accept;
X  	static long oldmoves = 0L;	/* != 1, starting value of moves */
X+ #ifdef REINCARNATION
X+ 	static boolean upper;
X  
X+ 	upper = (dlevel == rogue_level);
X+ #endif
X+ 
X+ #ifdef __GNULINT__
X+ 	ptr = (struct permonst *)0; /* suppress "used uninitialized" warning */
X+ #endif
X  	if(oldmoves != moves) {		/* must recalculate accept */
X  	    oldmoves = moves;
X  	    zlevel = u.uhave_amulet ? MAXLEVEL : dlevel;
X***************
X*** 855,861 ****
X  /*
X   *	Find out how many monsters exist in the range we have selected.
X   */
X! 	    for(accept = ct = 0 ; mons[ct].mlet; ct++) {
X  		ptr = &(mons[ct]);
X  		if(uncommon(ptr)) continue;
X  		if(tooweak(ct, minmlev) || toostrong(ct, maxmlev))
X--- 898,910 ----
X  /*
X   *	Find out how many monsters exist in the range we have selected.
X   */
X! 	    accept = 0;
X! #ifdef REINCARNATION
X! 	    for(ct = (upper ? PM_APE : 0);
X! 			upper ? isupper(mons[ct].mlet) : mons[ct].mlet; ct++) {
X! #else
X! 	    for(ct = 0 ; mons[ct].mlet; ct++) {
X! #endif
X  		ptr = &(mons[ct]);
X  		if(uncommon(ptr)) continue;
X  		if(tooweak(ct, minmlev) || toostrong(ct, maxmlev))
X***************
X*** 874,880 ****
X--- 923,934 ----
X   *	Now, select a monster at random.
X   */
X  	ct = rnd(accept);
X+ #ifdef REINCARNATION
X+ 	for(i = (upper ? PM_APE : 0);
X+ 	    (upper ? isupper(mons[i].mlet) : mons[i].mlet) && ct > 0; i++) {
X+ #else
X  	for(i = 0; mons[i].mlet && ct > 0; i++) {
X+ #endif
X  		ptr = &(mons[i]);
X  		if(uncommon(ptr)) continue;
X  		if(tooweak(i, minmlev) || toostrong(i, maxmlev))
X***************
X*** 890,895 ****
X--- 944,952 ----
X  	return(ptr);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  /*	The routine below is used to make one of the multiple types
X   *	of a given monster class.  It will return 0 if no monsters
X   *	in that class can be made.
X***************
X*** 949,954 ****
X--- 1006,1014 ----
X  	return((tmp > tmp2) ? tmp2 : (tmp > 0 ? tmp : 0)); /* 0 lower limit */
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  struct permonst *
X  grow_up(mtmp)		/* mon mtmp "grows up" to a bigger version. */
X  register struct monst *mtmp;
X***************
X*** 976,981 ****
X--- 1036,1044 ----
X  	return(mtmp->data);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  int
X  mongets(mtmp, otyp)
X  register struct monst *mtmp;
X***************
X*** 989,1033 ****
X  		curse(otmp);
X  	    }
X  	    mpickobj(mtmp, otmp);
X! 	    return(otmp->spe);	    
X  	} else return(0);
X  }
X  
X! #ifdef REINCARNATION
X! struct permonst *
X! roguemon()
X! {
X! /* Make a monster for a Rogue-like level; only capital letters.  There are
X!  * no checks for "too hard" or "too easy", though dragons are specifically
X!  * ruled out because playtesting showed they made the level too hard.
X!  * Modified from rndmonst().
X!  */
X! #define isupper(x) ('A'<=(x) && (x)<='Z')
X! 	register struct permonst *ptr;
X! 	register int accept,ct,i;
X! 
X! 	/* See how many there are. */
X! 	accept = 0;
X! 	for(ct = PM_APE ; isupper(mons[ct].mlet); ct++) {
X! 		if (mons[ct].mlet == S_DRAGON) continue;
X! 		ptr = &(mons[ct]);
X! 		if(uncommon(ptr)) continue;
X! 		accept += (ptr->geno & G_FREQ);
X! 	}
X! 	if(!accept) return((struct permonst *) 0);
X! 
X! 	/* Now, select one at random. */
X! 	ct = rnd(accept);
X! 	for(i = PM_APE; isupper(mons[i].mlet) && ct > 0; i++) {
X! 		if (mons[i].mlet == S_DRAGON) continue;
X! 		ptr = &(mons[i]);
X! 		if(uncommon(ptr)) continue;
X! 		ct -= (ptr->geno & G_FREQ);
X! 	}
X! 	if(ct > 0) return((struct permonst *) 0);
X! 	return(ptr);
X! }
X! #endif
X  
X  #ifdef GOLEMS
X  int
X--- 1052,1063 ----
X  		curse(otmp);
X  	    }
X  	    mpickobj(mtmp, otmp);
X! 	    return(otmp->spe);
X  	} else return(0);
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVLB
X  
X  #ifdef GOLEMS
X  int
X***************
X*** 1048,1053 ****
X--- 1078,1086 ----
X  }
X  #endif /* GOLEMS */
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /*
X   *	Alignment vs. yours determines monster's attitude to you.
X   *	( some "animal" types are co-aligned, but also hungry )
X***************
X*** 1109,1115 ****
X  		mtmp->malign = abs(mal);
X  }
X  
X! static char syms[] = { 0, 0, RING_SYM, WAND_SYM, WEAPON_SYM, FOOD_SYM, GOLD_SYM,
X  	SCROLL_SYM, POTION_SYM, ARMOR_SYM, AMULET_SYM, TOOL_SYM, ROCK_SYM,
X  	GEM_SYM,
X  #ifdef SPELLS
X--- 1142,1151 ----
X  		mtmp->malign = abs(mal);
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVLB
X! 
X! static char syms[] = { 0, 1, RING_SYM, WAND_SYM, WEAPON_SYM, FOOD_SYM, GOLD_SYM,
X  	SCROLL_SYM, POTION_SYM, ARMOR_SYM, AMULET_SYM, TOOL_SYM, ROCK_SYM,
X  	GEM_SYM,
X  #ifdef SPELLS
X***************
X*** 1119,1169 ****
X  };
X  
X  void
X! set_mimic_sym(mtmp) /* KAA */
X  register struct monst *mtmp;
X  {
X  	int roomno, rt;
X! 	char sym;
X! 	if (!mtmp) return;
X! 
X! 	syms[0] = UP_SYM;
X! 	syms[1] = DN_SYM;
X  
X  	mtmp->mimic = 1;
X! 	roomno = inroom(mtmp->mx, mtmp->my);
X! 	if (levl[mtmp->mx][mtmp->my].gmask)
X! 		sym = GOLD_SYM;
X! 	else if (OBJ_AT(mtmp->mx, mtmp->my))
X! 		sym = level.objects[mtmp->mx][mtmp->my]->olet;
X! 	else if (IS_DOOR(levl[mtmp->mx][mtmp->my].typ) ||
X! 		 IS_WALL(levl[mtmp->mx][mtmp->my].typ) ||
X! 		 levl[mtmp->mx][mtmp->my].typ == SDOOR ||
X! 		 levl[mtmp->mx][mtmp->my].typ == SCORR)
X! 		sym = CLOSED_DOOR_SYM;
X! 	else if (is_maze_lev)
X! 		sym = rn2(2) ? ROCK_SYM : syms[rn2(sizeof syms)];
X! 	else if (roomno < 0)
X! 		sym = ROCK_SYM;
X! 	else if ((rt = rooms[roomno].rtype) == ZOO || rt == VAULT)
X! 		sym = GOLD_SYM;
X  #ifdef ORACLE
X! 	else if (rt == DELPHI)
X! 		sym = rn2(2) ? ROCK_SYM : FOUNTAIN_SYM;
X  #endif
X  #ifdef ALTARS
X! 	else if (rt == TEMPLE)
X! 		sym = ALTAR_SYM;
X  #endif
X  	/* We won't bother with beehives, morgues, barracks, throne rooms
X  	 * since they shouldn't contain too many mimics anyway...
X  	 */
X  	else if (rt >= SHOPBASE) {
X! 		int s_sym = get_shop_item(rt - SHOPBASE);
X! 
X! 		if (s_sym < 0) sym = objects[-s_sym].oc_olet;
X! 		else if (s_sym == RANDOM_SYM)
X! 			sym = syms[rn2(sizeof(syms)-2) + 2];
X! 		else sym = s_sym;
X! 	} else sym = syms[rn2(sizeof syms)];
X! 	mtmp->mappearance = sym;
X  }
X--- 1155,1260 ----
X  };
X  
X  void
X! set_mimic_sym(mtmp)		/* KAA, modified by ERS */
X  register struct monst *mtmp;
X  {
X  	int roomno, rt;
X! 	unsigned appear, ap_type;
X! 	int s_sym;
X! 	struct obj *otmp;
X! 	int mx, my;
X  
X+ 	if (!mtmp) return;
X+ 	mx = mtmp->mx; my = mtmp->my;
X  	mtmp->mimic = 1;
X! 	roomno = inroom(mx, my);
X! 	if (levl[mx][my].gmask) {
X! 		ap_type = M_AP_GOLD;
X! 		if (g_at(mx, my)->amount <= 32767)
X! 			appear = g_at(mx, my)->amount;
X! 		else
X! 			appear = 32000 + rnd(767);
X! 	}
X! 	else if (OBJ_AT(mx, my)) {
X! 		ap_type = M_AP_OBJECT;
X! 		appear = level.objects[mx][my]->otyp;
X! 	}
X! 	else if (IS_DOOR(levl[mx][my].typ) ||
X! 		 IS_WALL(levl[mx][my].typ) ||
X! 		 levl[mx][my].typ == SDOOR ||
X! 		 levl[mx][my].typ == SCORR) {
X! 		ap_type = M_AP_FURNITURE;
X! 		appear = S_cdoor;
X! 	}
X! 	else if (is_maze_lev && rn2(2)) {
X! 		ap_type = M_AP_OBJECT;
X! 		appear = STATUE;
X! 	}
X! 	else if (roomno < 0) {
X! 		ap_type = M_AP_OBJECT;
X! 		appear = BOULDER;
X! 	}
X! 	else if ((rt = rooms[roomno].rtype) == ZOO || rt == VAULT) {
X! 		ap_type = M_AP_GOLD;
X! 		appear = rn2(100)+10;	/* number of gold pieces in pile */
X! 	}
X  #ifdef ORACLE
X! 	else if (rt == DELPHI) {
X! 		if (rn2(2)) {
X! 			ap_type = M_AP_OBJECT;
X! 			appear = STATUE;
X! 		}
X! 		else {
X! 			ap_type = M_AP_FURNITURE;
X! 			appear = S_fountain;
X! 		}
X! 	}
X  #endif
X  #ifdef ALTARS
X! 	else if (rt == TEMPLE) {
X! 		ap_type = M_AP_FURNITURE;
X! 		appear = S_altar;
X! 	}
X  #endif
X  	/* We won't bother with beehives, morgues, barracks, throne rooms
X  	 * since they shouldn't contain too many mimics anyway...
X  	 */
X  	else if (rt >= SHOPBASE) {
X! 		s_sym = get_shop_item(rt - SHOPBASE);
X! 		if (s_sym < 0) {
X! 			ap_type = M_AP_OBJECT;
X! 			appear = -s_sym;
X! 		}
X! 		else {
X! 			if (s_sym == RANDOM_SYM)
X! 				s_sym = syms[rn2(sizeof(syms)-2) + 2];
X! 			goto assign_sym;
X! 		}
X! 	}
X! 	else {
X! 		s_sym = syms[rn2(sizeof syms)];
X! assign_sym:
X! 		if (s_sym < 2) {
X! 			ap_type = M_AP_FURNITURE;
X! 			appear = s_sym ? S_upstair : S_dnstair;
X! 		}
X! 		else if (s_sym == GOLD_SYM) {
X! 			ap_type = M_AP_GOLD;
X! 			appear = rn2(100)+100;
X! 		}
X! 		else {
X! 			ap_type = M_AP_OBJECT;
X! 			if (s_sym == S_MIMIC_DEF)
X! 				appear = STRANGE_OBJECT;
X! 			else {
X! 				otmp = mkobj( (char) s_sym, FALSE );
X! 				appear = otmp->otyp;
X! 				free((genericptr_t) otmp);
X! 			}
X! 		}
X! 	}
X! 	mtmp->m_ap_type = ap_type;
X! 	mtmp->mappearance = appear;
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/mcastu.c	Mon Feb 19 20:28:15 1990
X--- src/mcastu.c	Sat Feb  3 11:04:43 1990
X***************
X*** 4,9 ****
X--- 4,12 ----
X  
X  #include	"hack.h"
X  
X+ #ifdef OVL0
X+ 
X+ static void FDECL(cursetxt,(struct monst *));
X  const char *spelltyp[] = {
X  	"shower of missiles",
X  	"fireball",
X***************
X*** 22,33 ****
X  cursetxt(mtmp)
X  	register struct monst *mtmp;
X  {
X! 	if(canseemon(mtmp))
X  		pline("%s points at you, then curses.", Monnam(mtmp));
X! 	else if((!(moves%4) || !rn2(4)) && flags.soundok) 
X  		You("hear a mumbled curse.");
X  }
X  
X  int
X  castmu(mtmp, mattk)	/* monster casts spell at you */
X  	register struct monst *mtmp;
X--- 25,51 ----
X  cursetxt(mtmp)
X  	register struct monst *mtmp;
X  {
X! 	if(canseemon(mtmp)) {
X! 	    if ((Invis && !perceives(mtmp->data) &&
X! 				(mtmp->mux != u.ux || mtmp->muy != u.uy))
X! #ifdef POLYSELF
X! 			|| u.usym == S_MIMIC_DEF || u.uundetected
X! #endif
X! 									)
X! 		pline("%s points and curses in your general direction.",
X! 				Monnam(mtmp));
X! 	    else if (Displaced && (mtmp->mux != u.ux || mtmp->muy != u.uy))
X! 		pline("%s points and curses at your displaced image.",
X! 				Monnam(mtmp));
X! 	    else
X  		pline("%s points at you, then curses.", Monnam(mtmp));
X! 	} else if((!(moves%4) || !rn2(4)) && flags.soundok) 
X  		You("hear a mumbled curse.");
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  int
X  castmu(mtmp, mattk)	/* monster casts spell at you */
X  	register struct monst *mtmp;
X***************
X*** 41,47 ****
X  	} else {
X  	    nomul(0);
X  	    if(rn2(ml*10) < (mtmp->mconf ? 100 : 20)) {	/* fumbled attack */
X! 		if(canseemon(mtmp))
X  		    pline("The air crackles around %s.", mon_nam(mtmp));
X  		return(0);
X  	    }
X--- 59,69 ----
X  	} else {
X  	    nomul(0);
X  	    if(rn2(ml*10) < (mtmp->mconf ? 100 : 20)) {	/* fumbled attack */
X! 		if(canseemon(mtmp)
X! #ifdef SOUNDS
X! 				&& flags.soundok
X! #endif
X! 							)
X  		    pline("The air crackles around %s.", mon_nam(mtmp));
X  		return(0);
X  	    }
X***************
X*** 104,109 ****
X--- 126,132 ----
X  			    if(Hallucination)
X  				You("have an out of body experience.");
X  			    else  {
X+ 				killer_format = KILLED_BY_AN;
X  				killer = "touch of death";
X  				done(DIED);
X  			    }
X***************
X*** 300,305 ****
X--- 323,331 ----
X  	return(1);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  buzzmu(mtmp, mattk)		/* monster uses spell (ranged) */
X  	register struct monst *mtmp;
X***************
X*** 321,324 ****
X--- 347,352 ----
X  	}
X  	return(1);
X  }
X+ 
X+ #endif /* OVL0 */
X  
X*** src/Old/mhitm.c	Mon Feb 19 20:28:34 1990
X--- src/mhitm.c	Sun Feb  4 13:54:28 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mhitm.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitm.c	3.0	89/11/27
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 7,16 ****
X--- 7,20 ----
X  #  include "artifact.h"
X  #endif
X  
X+ #ifdef OVLB
X+ 
X  static boolean vis, far_noise;
X  static long noisetime;
X  static struct obj *otmp;
X  
X+ #endif /* OVLB */
X+ 
X  static void FDECL(mrustm, (struct monst *, struct monst *, struct obj *));
X  static int FDECL(hitmm, (struct monst *,struct monst *,struct attack *));
X  static int FDECL(gazemm, (struct monst *,struct monst *,struct attack *));
X***************
X*** 18,23 ****
X--- 22,31 ----
X  static int FDECL(explmm, (struct monst *,struct monst *,struct attack *));
X  static int FDECL(mdamagem, (struct monst *,struct monst *,struct attack *));
X  static void FDECL(mswingsm, (struct monst *, struct monst *, struct obj *));
X+ static void FDECL(noises,(struct monst *,struct attack *));
X+ static void FDECL(missmm,(struct monst *,struct monst *,struct attack *));
X+ 
X+ #ifdef OVLB
X  
X  static void
X  noises(magr, mattk)
X***************
X*** 55,69 ****
X  	} else  noises(magr, mattk);
X  }
X  
X  int
X  fightm(mtmp)		/* have monsters fight each other */
X  	register struct monst *mtmp;
X  {
X! register struct monst *mon;
X! /*	TODO:	this loop needs to be restructured, as we don't know if
X!  *		either "mon" or "mon->nmon" will exist after the attack.
X!  */
X! 	for(mon = fmon; mon; mon = mon->nmon)
X  	    if(mon != mtmp) {
X  		if(dist2(mon->mx,mon->my,mtmp->mx,mtmp->my) < 3)
X  		/* note: grid bug check needed here as well as in mattackm */
X--- 63,82 ----
X  	} else  noises(magr, mattk);
X  }
X  
X+ /*
X+  * fightm returns 3 if no attack, otherwise the results of mattackm
X+  */
X  int
X  fightm(mtmp)		/* have monsters fight each other */
X  	register struct monst *mtmp;
X  {
X! register struct monst *mon, *nmon;
X! #ifdef LINT
X! 	nmon = 0;
X! #endif
X! 	for(mon = fmon; mon; mon = nmon) {
X! 	    nmon = mon->nmon;
X! 	    if(nmon == mtmp) nmon = mtmp->nmon;
X  	    if(mon != mtmp) {
X  		if(dist2(mon->mx,mon->my,mtmp->mx,mtmp->my) < 3)
X  		/* note: grid bug check needed here as well as in mattackm */
X***************
X*** 71,77 ****
X  				|| mtmp->my==mon->my)
X  			return(mattackm(mtmp,mon));
X  	    }
X! 	return(-1);
X  }
X  
X  /*
X--- 84,91 ----
X  				|| mtmp->my==mon->my)
X  			return(mattackm(mtmp,mon));
X  	    }
X! 	}
X! 	return(3);
X  }
X  
X  /*
X***************
X*** 93,99 ****
X  
X  	if(!magr || !mdef) return(0);		/* mike@genat */
X  	pa = magr->data; pd = mdef->data;
X! 	if(magr->mfroz) return(0);		/* riv05!a3 */
X  	if(pa==&mons[PM_GRID_BUG] && magr->mx != mdef->mx
X  						&& magr->my != mdef->my)
X  		return(0);
X--- 107,113 ----
X  
X  	if(!magr || !mdef) return(0);		/* mike@genat */
X  	pa = magr->data; pd = mdef->data;
X! 	if(!magr->mcanmove) return(0);		/* riv05!a3 */
X  	if(pa==&mons[PM_GRID_BUG] && magr->mx != mdef->mx
X  						&& magr->my != mdef->my)
X  		return(0);
X***************
X*** 101,107 ****
X  /*	Calculate the armour class differential.	*/
X  
X  	tmp = pd->ac + magr->m_lev;
X! 	if(mdef->mconf || mdef->mfroz || mdef->msleep){
X  		tmp += 4;
X  		if(mdef->msleep) mdef->msleep = 0;
X  	}
X--- 115,121 ----
X  /*	Calculate the armour class differential.	*/
X  
X  	tmp = pd->ac + magr->m_lev;
X! 	if(mdef->mconf || !mdef->mcanmove || mdef->msleep){
X  		tmp += 4;
X  		if(mdef->msleep) mdef->msleep = 0;
X  	}
X***************
X*** 194,200 ****
X  		if(magr->mimic) seemimic(magr);
X  		if((compat = could_seduce(magr,mdef,mattk)) && !magr->mcan) {
X  			Sprintf(buf, "%s %s", Monnam(magr),
X! 				mdef->mblinded ? "talks to" : "smiles at");
X  			pline("%s %s %s.", buf, mon_nam(mdef),
X  				compat == 2 ?
X  					"engagingly" : "seductively");
X--- 208,214 ----
X  		if(magr->mimic) seemimic(magr);
X  		if((compat = could_seduce(magr,mdef,mattk)) && !magr->mcan) {
X  			Sprintf(buf, "%s %s", Monnam(magr),
X! 				mdef->mcansee ? "smiles at" : "talks to");
X  			pline("%s %s %s.", buf, mon_nam(mdef),
X  				compat == 2 ?
X  					"engagingly" : "seductively");
X***************
X*** 238,244 ****
X  		pline("%s %s.", buf, mon_nam(mdef));
X  	}
X  
X! 	if (mdef->mblinded || mdef->msleep) {
X  
X  	    if(vis) pline("but nothing happens.");
X  	    return(0);
X--- 252,258 ----
X  		pline("%s %s.", buf, mon_nam(mdef));
X  	}
X  
X! 	if (!mdef->mcansee || mdef->msleep) {
X  
X  	    if(vis) pline("but nothing happens.");
X  	    return(0);
X***************
X*** 255,260 ****
X--- 269,276 ----
X  	int	mx, my, tmp;
X  	char buf[BUFSZ];
X  
X+ 	if(mdef->data->msize >= MZ_HUGE) return 0;
X+ 
X  	if(vis) {
X  		Sprintf(buf,"%s swallows", Monnam(magr));
X  		pline("%s %s.", buf, mon_nam(mdef));
X***************
X*** 307,312 ****
X--- 323,331 ----
X  	return(2);
X  }
X  
X+ static const char psf[] =
X+ 	"have a peculiarly sad feeling for a moment, then it passes.";
X+ 
X  static int
X  mdamagem(magr, mdef, mattk)
X  	register struct monst	*magr, *mdef;
X***************
X*** 316,324 ****
X  	int	tmp = d((int)mattk->damn,(int)mattk->damd);
X  	char buf[BUFSZ];
X  
X  	switch(mattk->adtyp) {
X  	    case AD_DGST:
X! 		if(flags.verbose && flags.soundok) pline("\"Burrrrp!\"");
X  		tmp = mdef->mhp;
X  		break;
X  	    case AD_STUN:
X--- 335,355 ----
X  	int	tmp = d((int)mattk->damn,(int)mattk->damd);
X  	char buf[BUFSZ];
X  
X+ 	if(mdef->data == &mons[PM_COCKATRICE] && !resists_ston(magr->data) &&
X+ 	   (mattk->aatyp != AT_WEAP || !otmp) &&
X+ 	   (mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL) &&
X+ 	   (!is_mercenary(magr->data) || !m_carrying(magr, LEATHER_GLOVES))) {
X+ 	   /* Note: other monsters may carry gloves, only soldiers have them */
X+ 	   /* as their "armor" and can be said to wear them */
X+ 		if (vis) pline("%s turns to stone!", Monnam(magr));
X+ 		else if (magr->mtame) You(psf);
X+ 		monstone(magr);
X+ 		return -1;
X+ 	}
X+ 
X  	switch(mattk->adtyp) {
X  	    case AD_DGST:
X! 		if(flags.verbose && flags.soundok) verbalize("Burrrrp!");
X  		tmp = mdef->mhp;
X  		break;
X  	    case AD_STUN:
X***************
X*** 363,369 ****
X--- 394,402 ----
X  #ifdef GOLEMS
X  		golemeffects(mdef, AD_FIRE, tmp);
X  #endif /* GOLEMS */
X+ 		if(vis) pline("%s is on fire!", Monnam(mdef));
X  		if(resists_fire(pd)) {
X+ 		    pline("The fire doesn't seem to burn %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X  		} else {
X***************
X*** 382,388 ****
X--- 415,424 ----
X  #ifdef GOLEMS
X  		golemeffects(mdef, AD_COLD, tmp);
X  #endif /* GOLEMS */
X+ 		if(vis) pline("%s is covered in frost!", Monnam(mdef));
X  		if(resists_cold(pd)) {
X+ 		    pline("The frost doesn't seem to chill %s!",
X+ 			mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X  		} else tmp += destroy_mitem(mdef, POTION_SYM, AD_COLD);
X***************
X*** 395,401 ****
X--- 431,439 ----
X  #ifdef GOLEMS
X  		golemeffects(mdef, AD_ELEC, tmp);
X  #endif /* GOLEMS */
X+ 		if(vis) pline("%s gets zapped!", Monnam(mdef));
X  		if(resists_elec(pd)) {
X+ 		    pline("The zap doesn't shock %s!", mon_nam(mdef));
X  		    shieldeff(mdef->mx, mdef->my);
X  		    tmp = 0;
X  		}
X***************
X*** 405,411 ****
X  		    tmp = 0;
X  		    break;
X  		}
X! 		if(resists_acid(pd)) tmp = 0;
X  		break;
X  	    case AD_RUST:
X  #ifdef GOLEMS
X--- 443,456 ----
X  		    tmp = 0;
X  		    break;
X  		}
X! 		if(resists_acid(pd)) {
X! 		    pline("%s is covered in acid, but it seems harmless.",
X! 			Monnam(mdef));
X! 		    tmp = 0;
X! 		} else {
X! 		    pline("%s is covered in acid!", Monnam(mdef));
X! 		    pline("It burns %s!", mon_nam(mdef));
X! 		}
X  		break;
X  	    case AD_RUST:
X  #ifdef GOLEMS
X***************
X*** 442,449 ****
X  		if(!resists_ston(pd)) {
X  			magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X  			if(vis) pline("%s turns to stone!", Monnam(mdef));
X! 			else if(mdef->mtame)
X!      You("have a peculiarly sad feeling for a moment, then it passes.");
X  			monstone(mdef);
X  			ptr = grow_up(magr);
X  			if(!ptr) return(-1);
X--- 487,493 ----
X  		if(!resists_ston(pd)) {
X  			magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X  			if(vis) pline("%s turns to stone!", Monnam(mdef));
X! 			else if(mdef->mtame) You(psf);
X  			monstone(mdef);
X  			ptr = grow_up(magr);
X  			if(!ptr) return(-1);
X***************
X*** 459,479 ****
X  		}
X  		break;
X  	    case AD_SLEE:
X! 		if(!resists_sleep(pd) && !magr->mcan && vis && !mdef->msleep
X! 							&& !mdef->mfroz) {
X! 		    pline("%s falls asleep.", Monnam(mdef));
X! 		    mdef->msleep = 1;
X  		}
X  		break;
X  	    case AD_PLYS:
X! 		if(!magr->mcan && vis && !mdef->mfroz) {
X! 		    pline("%s stops moving.", Monnam(mdef));
X! 		    mdef->mfroz = 1;
X  		}
X  		break;
X  	    case AD_SLOW:
X  		if(!magr->mcan && vis && mdef->mspeed != MSLOW) {
X! 		    pline("%s slows down.", Monnam(mdef));
X  		    if (mdef->mspeed == MFAST) mdef->mspeed = 0;
X  		    else mdef->mspeed = MSLOW;
X  		}
X--- 503,531 ----
X  		}
X  		break;
X  	    case AD_SLEE:
X! 		if(!resists_sleep(pd) && !magr->mcan && !mdef->msleep
X! 							&& mdef->mcanmove) {
X! 		    if (vis) {
X! 			Strcpy(buf, Monnam(mdef));
X! 			pline("%s is put to sleep by %s.", buf, mon_nam(magr));
X! 		    }
X! 		    mdef->mcanmove = 0;
X! 		    mdef->mfrozen = rnd(10);
X  		}
X  		break;
X  	    case AD_PLYS:
X! 		if(!magr->mcan && mdef->mcanmove) {
X! 		    if (vis) {
X! 			Strcpy(buf, Monnam(mdef));
X! 			pline("%s is frozen by %s.", buf, mon_nam(magr));
X! 		    }
X! 		    mdef->mcanmove = 0;
X! 		    mdef->mfrozen = rnd(10);
X  		}
X  		break;
X  	    case AD_SLOW:
X  		if(!magr->mcan && vis && mdef->mspeed != MSLOW) {
X! 		    if (vis) pline("%s slows down.", Monnam(mdef));
X  		    if (mdef->mspeed == MFAST) mdef->mspeed = 0;
X  		    else mdef->mspeed = MSLOW;
X  		}
X***************
X*** 491,497 ****
X  	    case AD_BLND:
X  		if(!magr->mcan && haseyes(pd)) {
X  
X! 		    if(vis && !mdef->mblinded)
X  			pline("%s is blinded.", Monnam(mdef));
X  		    {
X  			register unsigned rnd_tmp;
X--- 543,549 ----
X  	    case AD_BLND:
X  		if(!magr->mcan && haseyes(pd)) {
X  
X! 		    if(vis && mdef->mcansee)
X  			pline("%s is blinded.", Monnam(mdef));
X  		    {
X  			register unsigned rnd_tmp;
X***************
X*** 606,612 ****
X  
X  	if((mdef->mhp -= tmp) < 1) {
X  	    magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X! 	    if(vis) pline("%s is killed!", Monnam(mdef));
X  	    else if(mdef->mtame)
X  		You("have a sad feeling for a moment, then it passes.");
X  	    mondied(mdef);
X--- 658,667 ----
X  
X  	if((mdef->mhp -= tmp) < 1) {
X  	    magr->mhpmax += 1 + rn2((int)mdef->m_lev+1);
X! 	    if(vis)
X! 		pline("%s is %s!", Monnam(mdef),
X! 			(is_demon(mdef->data) || is_undead(mdef->data)) ?
X! 			 "destroyed" : "killed");
X  	    else if(mdef->mtame)
X  		You("have a sad feeling for a moment, then it passes.");
X  	    mondied(mdef);
X***************
X*** 620,625 ****
X--- 675,683 ----
X  	return(1);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  noattacks(ptr)			/* returns 1 if monster doesn't attack */
X  	struct	permonst *ptr;
X***************
X*** 632,637 ****
X--- 690,698 ----
X  	return(1);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  static void
X  mrustm(magr, mdef, obj)
X  register struct monst *magr, *mdef;
X***************
X*** 671,673 ****
X--- 732,736 ----
X  	      is_human(magr->data) ? "his" : "its",
X  	      xname(otemp), buf);
X  }
X+ 
X+ #endif /* OVLB */
X
END_OF_FILE
if test 54708 -ne `wc -c <'patch7.10'`; then
    echo shar: \"'patch7.10'\" unpacked with wrong size!
fi
# end of 'patch7.10'
echo shar: End of archive 14 \(of 30\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
