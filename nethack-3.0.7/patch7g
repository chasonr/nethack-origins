Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!zaphod.mps.ohio-state.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i007:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7g
Message-ID: <5221@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:33:47 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2238
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 7
Archive-name: NetHack3/Patch7g
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 30)."
# Contents:  patch7.03
# Wrapped by billr@saab on Wed Feb 21 10:04:28 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.03' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.03'\" to \"'patch7.03.orig'\"
  mv -f 'patch7.03' 'patch7.03.orig'
fi
echo shar: Extracting \"'patch7.03'\" \(56128 characters\)
sed "s/^X//" >'patch7.03' <<'END_OF_FILE'
X*** src/Old/dog.c	Mon Feb 19 17:59:10 1990
X--- src/dog.c	Sun Feb 11 16:05:48 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dog.c	3.0	89/06/12
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dog.c	3.0	89/11/20
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,15 ****
X--- 5,21 ----
X  #include "hack.h"
X  #include "edog.h"
X  
X+ #ifdef OVLB
X+ 
X  char dogname[63] = DUMMY;
X  char catname[63] = DUMMY;
X  
X+ #endif /* OVLB */
X+ 
X  #define domestic(mtmp)	(mtmp->data->msound == MS_BARK || mtmp->data->msound == MS_MEW)
X  
X+ #ifdef OVLB
X+ 
X  void
X  initedog(mtmp)
X  register struct monst *mtmp;
X***************
X*** 59,64 ****
X--- 65,71 ----
X  	    return;
X  	}
X  	initedog(mtmp);
X+ 	mtmp->msleep = 0;
X  	if (otmp && otmp->cursed) { /* cursed figurine */
X  		You("get a bad feeling about this.");
X  		mtmp->mtame = mtmp->mpeaceful = 0;
X***************
X*** 85,100 ****
X  	if(!mtmp) return((struct monst *) 0); /* dogs were genocided */
X  
X  	if (petname[0]) {
X! 		register struct monst *mtmp2;
X! 
X! 		mtmp->mnamelth = strlen(petname) + 1;
X! 		mtmp2 = newmonst(sizeof(struct edog) + mtmp->mnamelth);
X! 		*mtmp2 = *mtmp;
X! 
X! 		replmon(mtmp, mtmp2);
X! 		mtmp = mtmp2;
X! 		Strcpy(NAME(mtmp), petname);
X  		petname[0] = '\0'; /* name first only; actually unnecessary */
X  	}
X  	initedog(mtmp);
X  	return(mtmp);
X--- 92,101 ----
X  	if(!mtmp) return((struct monst *) 0); /* dogs were genocided */
X  
X  	if (petname[0]) {
X! 		mtmp = christen_monst(mtmp, petname);
X! #ifndef MACOS
X  		petname[0] = '\0'; /* name first only; actually unnecessary */
X+ #endif
X  	}
X  	initedog(mtmp);
X  	return(mtmp);
X***************
X*** 102,109 ****
X  
X  /* attach the monsters that went down (or up) together with @ */
X  struct monst *mydogs = 0;
X! /* monsters that fell through a trapdoor or stepped on a tele-trap. */
X! /* 'down' is now true only of trapdooor falling, not for tele-trap. */
X  struct monst *fallen_down = 0;
X  				
X  void
X--- 103,110 ----
X  
X  /* attach the monsters that went down (or up) together with @ */
X  struct monst *mydogs = 0;
X! /* monsters that fell through a trap door or stepped on a tele-trap. */
X! /* 'down' is now true only of trap door falling, not for tele-trap. */
X  struct monst *fallen_down = 0;
X  				
X  void
X***************
X*** 116,122 ****
X  		fmon = mtmp;
X  		mnexto(mtmp);
X  	}
X! #ifdef LINT
X  	mtmp0 = (struct monst *)0;
X  #endif
X  	for(mtmp = fallen_down; mtmp; mtmp = mtmp2) {
X--- 117,123 ----
X  		fmon = mtmp;
X  		mnexto(mtmp);
X  	}
X! #if defined(LINT) || defined(__GNULINT__)
X  	mtmp0 = (struct monst *)0;
X  #endif
X  	for(mtmp = fallen_down; mtmp; mtmp = mtmp2) {
X***************
X*** 155,161 ****
X  		   the amulet; if you don't have it, will chase you
X  		   only if in range. -3. */
X  			(u.uhave_amulet && mtmp->iswiz))
X! 			&& !mtmp->msleep && !mtmp->mfroz) {
X  #ifdef WORM
X  		/* Bug "fix" for worm changing levels collapsing dungeon
X  		 */
X--- 156,162 ----
X  		   the amulet; if you don't have it, will chase you
X  		   only if in range. -3. */
X  			(u.uhave_amulet && mtmp->iswiz))
X! 			&& !mtmp->msleep && mtmp->mcanmove) {
X  #ifdef WORM
X  		/* Bug "fix" for worm changing levels collapsing dungeon
X  		 */
X***************
X*** 216,221 ****
X--- 217,225 ----
X  		/* so rloc() on next level doesn't affect MON_AT() state */
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /* return quality of food; the lower the better */
X  /* fungi will eat even tainted food */
X  int
X***************
X*** 244,254 ****
X  			return POISON;
X  		    return (carni ? CADAVER : MANFOOD);
X  		case CORPSE:
X! 		    if ((obj->age+50 <= moves && obj->corpsenm != PM_LIZARD
X  					    && mon->data->mlet != S_FUNGUS) ||
X  			(poisonous(&mons[obj->corpsenm]) &&
X  						!resists_poison(mon->data)))
X  			return POISON;
X  		    else return (carni ? CADAVER : MANFOOD);
X  		case CLOVE_OF_GARLIC:
X  		    return (is_undead(mon->data) ? TABU :
X--- 248,263 ----
X  			return POISON;
X  		    return (carni ? CADAVER : MANFOOD);
X  		case CORPSE:
X! 		    if ((obj->age+50 <= monstermoves
X! 					    && obj->corpsenm != PM_LIZARD
X  					    && mon->data->mlet != S_FUNGUS) ||
X+ 			(acidic(&mons[obj->corpsenm]) &&
X+ 						!resists_acid(mon->data)) ||
X  			(poisonous(&mons[obj->corpsenm]) &&
X  						!resists_poison(mon->data)))
X  			return POISON;
X+ 		    else if (mon->data->mlet == S_FUNGUS)
X+ 			return (herbi ? CADAVER : MANFOOD);
X  		    else return (carni ? CADAVER : MANFOOD);
X  		case CLOVE_OF_GARLIC:
X  		    return (is_undead(mon->data) ? TABU :
X***************
X*** 277,282 ****
X--- 286,294 ----
X  	}
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  /* return roomnumber or -1 */
X  int
X  inroom(x,y) xchar x,y; {
X***************
X*** 290,295 ****
X--- 302,310 ----
X  	return(-1);	/* not in room or on door */
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  int
X  tamedog(mtmp, obj)
X  register struct monst *mtmp;
X***************
X*** 306,312 ****
X  	/* If we cannot tame him, at least he's no longer afraid. */
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X! 	if(mtmp->mtame || mtmp->mfroz ||
X  #ifdef MEDUSA
X  	   mtmp->data == &mons[PM_MEDUSA] ||
X  #endif
X--- 321,327 ----
X  	/* If we cannot tame him, at least he's no longer afraid. */
X  	mtmp->mflee = 0;
X  	mtmp->mfleetim = 0;
X! 	if(mtmp->mtame || !mtmp->mcanmove ||
X  #ifdef MEDUSA
X  	   mtmp->data == &mons[PM_MEDUSA] ||
X  #endif
X***************
X*** 334,336 ****
X--- 349,353 ----
X  	replmon(mtmp,mtmp2);
X  	return(1);
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/dogmove.c	Mon Feb 19 17:59:33 1990
X--- src/dogmove.c	Mon Feb  5 18:09:09 1990
X***************
X*** 7,15 ****
X  #include "mfndpos.h"
X  #include "edog.h"
X  
X  static const char nofetch[] = { BALL_SYM, CHAIN_SYM, ROCK_SYM, 0 };
X  
X! static void
X  dog_eat(mtmp, obj, otyp, x, y)
X  register struct monst *mtmp;
X  register struct obj * obj;
X--- 7,23 ----
X  #include "mfndpos.h"
X  #include "edog.h"
X  
X+ #ifdef OVL0
X+ 
X  static const char nofetch[] = { BALL_SYM, CHAIN_SYM, ROCK_SYM, 0 };
X  
X! #endif /* OVL0 */
X! 
X! OSTATIC void FDECL(dog_eat, (struct monst *, struct obj *, XCHAR_P, int, int));
X! 
X! #ifdef OVLB
X! 
X! XSTATIC void
X  dog_eat(mtmp, obj, otyp, x, y)
X  register struct monst *mtmp;
X  register struct obj * obj;
X***************
X*** 54,59 ****
X--- 62,70 ----
X  	delobj(obj);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /* return 0 (no move), 1 (move) or 2 (dead) */
X  int
X  dog_move(mtmp, after)
X***************
X*** 75,80 ****
X--- 86,94 ----
X  #define GDIST(x,y) (dist2(x,y,gx,gy))
X  #define DDIST(x,y) (dist2(x,y,omx,omy))
X  
X+ #ifdef __GNULINT__
X+ 	chi = -1;	/* gcc warning from 'goto newdogpos' */
X+ #endif
X  	omx = mtmp->mx;
X  	omy = mtmp->my;
X  	whappr = (moves - edog->whistletime < 5);
X***************
X*** 134,139 ****
X--- 148,154 ----
X  			goto newdogpos;
X  		    }
X  		    if(can_carry(mtmp, obj))
X+ 		    if(!obj->cursed)
X  		    if(rn2(20) < edog->apport+3)
X  		    if(rn2(udist) || !rn2((int) edog->apport)){
X  			if (cansee(omx, omy) && flags.verbose)
X***************
X*** 243,248 ****
X--- 258,269 ----
X  	
X  	allowflags = ALLOW_M | ALLOW_TRAPS | ALLOW_SSM | ALLOW_SANCT;
X  	if (passes_walls(mtmp->data)) allowflags |= (ALLOW_ROCK|ALLOW_WALL);
X+ 	if (throws_rocks(mtmp->data)) allowflags |= ALLOW_ROCK;
X+ 	if (!nohands(mtmp->data) && !verysmall(mtmp->data)) {
X+ 		allowflags |= OPENDOOR;
X+ 		if (m_carrying(mtmp, SKELETON_KEY)) allowflags |= BUSTDOOR;
X+ 	}
X+ 	if (is_giant(mtmp->data)) allowflags |= BUSTDOOR;
X  	if (tunnels(mtmp->data) && !needspick(mtmp->data))
X  		allowflags |= ALLOW_DIG;
X  	cnt = mfndpos(mtmp, poss, info, allowflags);
X***************
X*** 258,263 ****
X--- 279,285 ----
X  #endif
X  		if(info[i] & ALLOW_M) {
X  			if(MON_AT(nx, ny)) {
X+ 			    int stat;
X  			    register struct monst *mtmp2 = m_at(nx,ny);
X  
X  			    if(mtmp2->m_lev >= mtmp->m_lev+2 ||
X***************
X*** 266,274 ****
X  				continue;
X  			    if(after) return(0); /* hit only once each move */
X  
X! 			    if(mattackm(mtmp, mtmp2) == 1 && rn2(4) &&
X  			      mtmp2->mlstmv != moves &&
X  			      mattackm(mtmp2, mtmp) == 2) return(2);
X  			    return(0);
X  			}
X  		}
X--- 288,297 ----
X  				continue;
X  			    if(after) return(0); /* hit only once each move */
X  
X! 			    if((stat = mattackm(mtmp, mtmp2)) == 1 && rn2(4) &&
X  			      mtmp2->mlstmv != moves &&
X  			      mattackm(mtmp2, mtmp) == 2) return(2);
X+ 			    if(stat == -1) return(2);
X  			    return(0);
X  			}
X  		}
X***************
X*** 377,379 ****
X--- 400,404 ----
X  #endif
X  	return(1);
X  }
X+ 
X+ #endif /* OVL0 */
X*** src/Old/dokick.c	Mon Feb 19 18:00:00 1990
X--- src/dokick.c	Tue Feb  6 19:54:46 1990
X***************
X*** 7,12 ****
X--- 7,14 ----
X  
X  #define martial()	((pl_character[0] == 'S' || pl_character[0] == 'P'))
X  
X+ static struct rm *maploc;
X+ 
X  #ifdef KICK
X  
X  # ifdef WORM
X***************
X*** 13,18 ****
X--- 15,26 ----
X  extern boolean notonhead;
X  # endif
X  
X+ static void FDECL(kickdmg, (struct monst *, BOOLEAN_P));
X+ static void FDECL(kick_monster, (int, int));
X+ static int FDECL(kick_object, (int, int));
X+ 
X+ static struct obj *obj = (struct obj *) 0;
X+ 
X  static void
X  kickdmg(mon, clumsy)
X  register struct monst *mon;
X***************
X*** 54,60 ****
X  		killed(mon);
X  		return;
X  	}
X! 	if(martial() && !bigmonst(mon->data) && !rn2(3) && !mon->mfroz) {
X  	    	/* see if the monster has a place to move into */
X  	    	mdx = mon->mx + u.dx;
X  	    	mdy = mon->my + u.dy;
X--- 62,68 ----
X  		killed(mon);
X  		return;
X  	}
X! 	if(martial() && !bigmonst(mon->data) && !rn2(3) && mon->mcanmove) {
X  	    	/* see if the monster has a place to move into */
X  	    	mdx = mon->mx + u.dx;
X  	    	mdy = mon->my + u.dy;
X***************
X*** 70,76 ****
X  
X  /*	it is unchivalrous to attack the defenseless or from behind */
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL && 
X! 		u.ualign > -10 && (mon->mfroz || mon->msleep || mon->mflee))
X  	    	adjalign(-1);
X  
X  }
X--- 78,84 ----
X  
X  /*	it is unchivalrous to attack the defenseless or from behind */
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL && 
X! 		u.ualign > -10 && (!mon->mcanmove || mon->msleep || mon->mflee))
X  	    	adjalign(-1);
X  
X  }
X***************
X*** 149,155 ****
X  	kludge("You kick %s.", mon_nam(mon));
X  	if(!rn2(clumsy ? 3 : 4) && (clumsy || !bigmonst(mon->data)) && 
X  	   mon->mcansee && !mon->mtrapped && !thick_skinned(mon->data) && 
X! 	   mon->data->mlet != S_EEL && haseyes(mon->data) && !mon->mfroz && 
X  	   !mon->mstun && !mon->mconf && !mon->msleep &&
X  	   mon->data->mmove >= 12) {
X  		if(!nohands(mon->data) && !rn2(martial() ? 5 : 3)) {
X--- 157,163 ----
X  	kludge("You kick %s.", mon_nam(mon));
X  	if(!rn2(clumsy ? 3 : 4) && (clumsy || !bigmonst(mon->data)) && 
X  	   mon->mcansee && !mon->mtrapped && !thick_skinned(mon->data) && 
X! 	   mon->data->mlet != S_EEL && haseyes(mon->data) && mon->mcanmove && 
X  	   !mon->mstun && !mon->mconf && !mon->msleep &&
X  	   mon->data->mmove >= 12) {
X  		if(!nohands(mon->data) && !rn2(martial() ? 5 : 3)) {
X***************
X*** 236,245 ****
X  bad_kick_throw_pos(x,y)
X  xchar x,y;
X  {
X! 	register struct rm *lvl = &(levl[x][y]);
X! 
X! 	return(!ACCESSIBLE(lvl->typ) || lvl->typ == SDOOR ||
X! 	    (IS_DOOR(lvl->typ) && (lvl->doormask & (D_CLOSED | D_LOCKED))) );
X  }
X  
X  struct monst *
X--- 244,250 ----
X  bad_kick_throw_pos(x,y)
X  xchar x,y;
X  {
X! 	return(!accessible(x, y) || levl[x][y].typ == SDOOR);
X  }
X  
X  struct monst *
X***************
X*** 286,292 ****
X  	int range, odx, ody, cnt = 0;
X  	register struct monst *mon;
X  	struct gold *gold;
X! 	register struct obj *otmp, *obj;
X  	boolean costly = FALSE;
X  
X  	/* if a pile, the "top" object gets kicked */
X--- 291,297 ----
X  	int range, odx, ody, cnt = 0;
X  	register struct monst *mon;
X  	struct gold *gold;
X! 	register struct obj *otmp;
X  	boolean costly = FALSE;
X  
X  	/* if a pile, the "top" object gets kicked */
X***************
X*** 469,479 ****
X  }
X  #endif /* KICK */
X  
X  
X  int
X  dokick() {		/* try to kick the door down - noisy! */
X          register int x, y;
X- 	register struct rm *maploc;
X  	register int avrg_attrib = (ACURR(A_STR)+ACURR(A_DEX)+ACURR(A_CON))/3;
X  
X  #ifdef POLYSELF
X--- 474,521 ----
X  }
X  #endif /* KICK */
X  
X+ char *
X+ kickstr() {
X+ 	static char buf[BUFSIZ];
X+ 
X+ #ifdef KICK
X+ 	if (obj) Sprintf(buf, "kicking %s", doname(obj));
X+ 	else
X+ #endif
X+ 	if (IS_STWALL(maploc->typ)) Strcpy(buf, "kicking a wall");
X+ 	else if (IS_ROCK(maploc->typ)) Strcpy(buf, "kicking a rock");
X+ #ifdef THRONES
X+ 	else if (IS_THRONE(maploc->typ)) Strcpy(buf, "kicking a throne");
X+ #endif
X+ #ifdef SINKS
X+ 	else if (IS_SINK(maploc->typ)) Strcpy(buf, "kicking a sink");
X+ #endif
X+ #ifdef ALTARS
X+ 	else if (IS_ALTAR(maploc->typ)) Strcpy(buf, "kicking an altar");
X+ #endif
X+ #ifdef STRONGHOLD
X+ 	else if (IS_DRAWBRIDGE(maploc->typ))
X+ 		Strcpy(buf, "kicking the drawbridge");
X+ #endif
X+ 	else {
X+ 		switch (maploc->typ) {
X+ 		case STAIRS:	
X+ 			Strcpy(buf, "kicking the stairs");
X+ 			break;
X+ #ifdef STRONGHOLD
X+ 		case LADDER:
X+ 			Strcpy(buf, "kicking a ladder");
X+ 			break;
X+ #endif
X+ 		}
X+ 	}
X+ 
X+ 	return buf;
X+ }
X  
X  int
X  dokick() {		/* try to kick the door down - noisy! */
X          register int x, y;
X  	register int avrg_attrib = (ACURR(A_STR)+ACURR(A_DEX)+ACURR(A_CON))/3;
X  
X  #ifdef POLYSELF
X***************
X*** 520,526 ****
X  		switch(rn2(3)) {
X  		case 0:  You("can't move your %s!", body_part(LEG));
X  			 break;
X! 		case 1:  pline("%s burps loudly.", Monnam(u.ustuck)); break;
X  		default: Your("feeble kick has no effect."); break;
X  		}
X  		return(1);
X--- 562,571 ----
X  		switch(rn2(3)) {
X  		case 0:  You("can't move your %s!", body_part(LEG));
X  			 break;
X! 		case 1:  if (is_animal(u.ustuck->data)) {
X! 			 	pline("%s burps loudly.", Monnam(u.ustuck)); 
X! 			       	break; 
X!                          }
X  		default: Your("feeble kick has no effect."); break;
X  		}
X  		return(1);
X***************
X*** 573,579 ****
X  # ifdef THRONES
X  		if(IS_THRONE(maploc->typ)) {
X  		    register int i;
X! 		    if((u.uluck < 0 || maploc->doormask) && !rn2(3)) {
X  			pline("CRASH!  You destroy the throne.");
X  			maploc->typ = ROOM;
X  			maploc->doormask = 0; /* don't leave loose ends.. */
X--- 618,624 ----
X  # ifdef THRONES
X  		if(IS_THRONE(maploc->typ)) {
X  		    register int i;
X! 		    if((Luck < 0 || maploc->doormask) && !rn2(3)) {
X  			pline("CRASH!  You destroy the throne.");
X  			maploc->typ = ROOM;
X  			maploc->doormask = 0; /* don't leave loose ends.. */
X***************
X*** 580,589 ****
X  			mkgold((long)rnd(200), x, y);
X  			prl(x, y);
X  			return(1);
X! 		    } else if(u.uluck && !rn2(3) && !maploc->looted) {
X  			You("kick loose some ornamental coins and gems!");
X  			mkgold((300L+(long)rn2(201)), x, y);
X! 			i = u.uluck + 1;
X  			if(i > 6) i = 6;
X  			while(i--) (void) mkobj_at(GEM_SYM, x, y);
X  			prl(x, y);
X--- 625,634 ----
X  			mkgold((long)rnd(200), x, y);
X  			prl(x, y);
X  			return(1);
X! 		    } else if(Luck > 0 && !rn2(3) && !maploc->looted) {
X  			You("kick loose some ornamental coins and gems!");
X  			mkgold((300L+(long)rn2(201)), x, y);
X! 			i = Luck + 1;
X  			if(i > 6) i = 6;
X  			while(i--) (void) mkobj_at(GEM_SYM, x, y);
X  			prl(x, y);
X***************
X*** 656,662 ****
X  ouch:
X  		    pline("Ouch!  That hurts!");
X  		    if(!rn2(3)) set_wounded_legs(RIGHT_SIDE, 5 + rnd(5));
X! 		    losehp(rnd(ACURR(A_CON) > 15 ? 3 : 5), "dumb move");
X  		    return(1);
X  		}
X  # ifdef STRONGHOLD
X--- 701,708 ----
X  ouch:
X  		    pline("Ouch!  That hurts!");
X  		    if(!rn2(3)) set_wounded_legs(RIGHT_SIDE, 5 + rnd(5));
X! 		    losehp(rnd(ACURR(A_CON) > 15 ? 3 : 5), kickstr(),
X! 			KILLED_BY);
X  		    return(1);
X  		}
X  # ifdef STRONGHOLD
X*** src/Old/dothrow.c	Mon Feb 19 18:00:36 1990
X--- src/dothrow.c	Fri Feb  2 18:23:55 1990
X***************
X*** 6,12 ****
X--- 6,14 ----
X  
X  #include "hack.h"
X  
X+ static void FDECL(hitfloor, (struct obj *));
X  static void FDECL(gem_accept, (struct monst *, struct obj *));
X+ static boolean NDECL(martial);
X  static int FDECL(throw_gold, (struct obj *));
X  static const char toss_objs[] = { '0', GOLD_SYM, '#', WEAPON_SYM, 0 };
X  #ifdef WORM
X***************
X*** 100,106 ****
X  		potionhit(&youmonst, obj);
X  	    else {
X  		if(uarmh) pline("Fortunately, you are wearing a helmet!");
X! 		losehp(uarmh ? 1 : rnd((int)(obj->owt)), "falling object");
X  		if (!breaks(obj, TRUE)) dropy(obj);
X  	    }
X  	  } else hitfloor(obj);
X--- 102,109 ----
X  		potionhit(&youmonst, obj);
X  	    else {
X  		if(uarmh) pline("Fortunately, you are wearing a helmet!");
X! 		losehp(uarmh ? 1 : rnd((int)(obj->owt)), "falling object",
X! 			KILLED_BY_AN);
X  		if (!breaks(obj, TRUE)) dropy(obj);
X  	    }
X  	  } else hitfloor(obj);
X***************
X*** 189,195 ****
X  					(side == LEFT_SIDE) ? "left" : "right",
X  					body_part(LEG));
X  				set_wounded_legs(side, 500+rn2(1000));
X! 				losehp(2, "thrown ball");
X  				}
X  				u.utrap = 0;
X  			}
X--- 192,199 ----
X  					(side == LEFT_SIDE) ? "left" : "right",
X  					body_part(LEG));
X  				set_wounded_legs(side, 500+rn2(1000));
X! 				losehp(2, "leg damage from being pulled out of a bear trap",
X! 					KILLED_BY);
X  				}
X  				u.utrap = 0;
X  			}
X***************
X*** 238,246 ****
X  		mon->msleep = 0;
X  		tmp += 2;
X  	}
X! 	if(mon->mfroz) {
X  		tmp += 4;
X! 		if(!rn2(10)) mon->mfroz = 0;
X  	}
X  	if (is_orc(mon->data) && pl_character[0]=='E') tmp++;
X  	if (u.uswallow && mon == u.ustuck) tmp += 1000; /* Guaranteed hit */
X--- 242,253 ----
X  		mon->msleep = 0;
X  		tmp += 2;
X  	}
X! 	if(!mon->mcanmove) {
X  		tmp += 4;
X! 		if(!rn2(10)) {
X! 			mon->mcanmove = 1;
X! 			mon->mfrozen = 0;
X! 		}
X  	}
X  	if (is_orc(mon->data) && pl_character[0]=='E') tmp++;
X  	if (u.uswallow && mon == u.ustuck) tmp += 1000; /* Guaranteed hit */
X***************
X*** 310,317 ****
X  	} else {
X  		pline("The %s misses %s.", xname(obj),
X  			cansee(bhitpos.x,bhitpos.y) ? mon_nam(mon) : "it");
X! 		if(obj->olet == FOOD_SYM &&
X! 		  (mon->data->mlet == S_DOG || mon->data->mlet == S_FELINE))
X  			if(tamedog(mon,obj)) return(1);
X  	}
X  	return(0);
X--- 317,323 ----
X  	} else {
X  		pline("The %s misses %s.", xname(obj),
X  			cansee(bhitpos.x,bhitpos.y) ? mon_nam(mon) : "it");
X! 		if(obj->olet == FOOD_SYM && is_domestic(mon->data))
X  			if(tamedog(mon,obj)) return(1);
X  	}
X  	return(0);
X***************
X*** 422,429 ****
X  	}
X  
X  	if(u.uswallow) {
X! 		pline("The gold disappears in the %s's entrails.", 
X! 					mon_nam(u.ustuck));
X  		u.ustuck->mgold += zorks;
X  		return(1);
X  	}
X--- 428,439 ----
X  	}
X  
X  	if(u.uswallow) {
X! 		if (is_animal(u.ustuck->data))
X! 			pline("The gold disappears in the %s's entrails.", 
X! 			      mon_nam(u.ustuck));
X! 		else
X! 			pline("The gold disappears into %s.",
X! 			      mon_nam(u.ustuck));
X  		u.ustuck->mgold += zorks;
X  		return(1);
X  	}
X*** src/Old/eat.c	Mon Feb 19 18:01:13 1990
X--- src/eat.c	Mon Feb 19 10:18:37 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)eat.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*      SCCS Id: @(#)eat.c      3.0     89/11/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 13,24 ****
X  # endif
X  #endif
X  
X! static void FDECL(fpostfx, (struct obj *));
X  static void FDECL(cpostfx, (int));
X  
X  char corpsename[60];
X  char msgbuf[BUFSZ];
X  
X  /* hunger texts used on bottom line (each 8 chars long) */
X  #define SATIATED	0
X  #define NOT_HUNGRY	1
X--- 13,61 ----
X  # endif
X  #endif
X  
X! static long FDECL(rounddiv, (long, long));
X! #ifndef OVERLAY
X! static int NDECL(Meatdone);
X! #endif
X! static void FDECL(choke, (struct obj *));
X! static void NDECL(recalc_wt);
X! static struct obj *FDECL(touchfood, (struct obj *));
X! static void NDECL(do_reset_eat);
X! #ifndef OVERLAY
X! static int NDECL(eatfood);
X! #endif
X! static void FDECL(done_eating, (BOOLEAN_P));
X! static void FDECL(cprefx, (int));
X  static void FDECL(cpostfx, (int));
X+ #ifndef OVERLAY
X+ static int NDECL(opentin);
X+ #endif
X+ static void FDECL(start_tin, (struct obj *));
X+ #ifdef POLYSELF
X+ static int FDECL(rottenfood, (struct obj *));
X+ #else
X+ static int NDECL(rottenfood);
X+ #endif
X+ static int FDECL(eatcorpse, (struct obj *));
X+ static void FDECL(start_eating, (struct obj *));
X+ static void FDECL(fprefx, (struct obj *));
X+ #ifdef POLYSELF
X+ static void NDECL(eatspecial);
X+ static const char * FDECL(foodword, (struct obj *));
X+ #endif
X+ static void FDECL(fpostfx, (struct obj *));
X+ static int NDECL(bite);
X+ #ifndef OVERLAY
X+ static int NDECL(unfaint);
X+ #endif
X+ 
X+ #ifdef OVLB
X  
X  char corpsename[60];
X  char msgbuf[BUFSZ];
X  
X+ #endif /* OVLB */
X+ 
X  /* hunger texts used on bottom line (each 8 chars long) */
X  #define SATIATED	0
X  #define NOT_HUNGRY	1
X***************
X*** 28,33 ****
X--- 65,72 ----
X  #define FAINTED		5
X  #define STARVED		6
X  
X+ #ifdef OVLB
X+ 
X  const char *hu_stat[] = {
X  	"Satiated",
X  	"        ",
X***************
X*** 39,44 ****
X--- 78,106 ----
X  };
X  
X  static const char comestibles[] = { FOOD_SYM, 0 };
X+ #ifdef POLYSELF
X+ static const char everything[] = { GOLD_SYM, /* must come first */
X+ 	WEAPON_SYM, ARMOR_SYM, POTION_SYM, SCROLL_SYM, WAND_SYM,
X+ #ifdef SPELLS
X+ 	SPBOOK_SYM,
X+ #endif
X+ 	RING_SYM, WAND_SYM, AMULET_SYM, FOOD_SYM, TOOL_SYM, GEM_SYM,
X+ 	ROCK_SYM, BALL_SYM, CHAIN_SYM, 0 };
X+ 
X+ boolean
X+ is_edible(obj)
X+ register struct obj *obj;
X+ {
X+ 	if (metallivorous(uasmon) && (obj->olet == GOLD_SYM ||
X+ 			(objects[obj->otyp].oc_material > WOOD &&
X+ 			objects[obj->otyp].oc_material < MINERAL)))
X+ 		return TRUE;
X+ 	if (u.umonnum == PM_GELATINOUS_CUBE &&
X+ 			objects[obj->otyp].oc_material <= WOOD)
X+ 		return TRUE;
X+ 	return !!index(comestibles, obj->olet);
X+ }
X+ #endif
X  
X  /* calculate x/y, rounding as appropriate */
X  
X***************
X*** 70,76 ****
X  	u.uhs = NOT_HUNGRY;
X  }
X  
X! const struct { char *txt; int nut; } tintxts[] = {
X  	"deep fried",	60,
X  	"pickled",	40,
X  	"soup made from", 20,
X--- 132,138 ----
X  	u.uhs = NOT_HUNGRY;
X  }
X  
X! const struct { const char *txt; int nut; } tintxts[] = {
X  	"deep fried",	60,
X  	"pickled",	40,
X  	"soup made from", 20,
X***************
X*** 137,147 ****
X  		morehungry(1000);	/* you just got *very* sick! */
X  		vomit();
X  	} else {
X  		if(food) {
X! 			killer = singular(food, xname);
X  		} else
X  			killer = "exuberant appetite";
X! 		You("choke over your food.");
X  		You("die...");
X  		done(CHOKING);
X  	}
X--- 199,221 ----
X  		morehungry(1000);	/* you just got *very* sick! */
X  		vomit();
X  	} else {
X+ 		killer_format = KILLED_BY_AN;
X  		if(food) {
X! #ifdef POLYSELF
X! 			if (food->olet == GOLD_SYM) {
X! 				killer_format = KILLED_BY;
X! 				killer = "eating too rich a meal";
X! 			} else
X! #endif
X! 				killer = singular(food, xname);
X  		} else
X  			killer = "exuberant appetite";
X! 		if (!food) You("choke over it.");
X! #ifdef POLYSELF
X! 		else You("choke over your %s.", foodword(food));
X! #else
X! 		else You("choke over your food.");
X! #endif
X  		You("die...");
X  		done(CHOKING);
X  	}
X***************
X*** 203,208 ****
X--- 277,294 ----
X  	return(otmp);
X  }
X  
X+ /* When food decays, in the middle of your meal, we don't want to dereference
X+  * any dangling pointers, so set it to null (which should still trigger
X+  * do_reset_eat() at the beginning of eatfood()) and check for null pointers
X+  * in do_reset_eat().
X+  */
X+ void
X+ food_disappears(obj)
X+ register struct obj *obj;
X+ {
X+ 	if (obj == victual.piece) victual.piece = (struct obj *)0;
X+ }
X+ 
X  static void
X  do_reset_eat() {
X  
X***************
X*** 209,218 ****
X  #ifdef DEBUG
X  	debug("do_reset_eat...");
X  #endif
X! 	victual.piece = touchfood(victual.piece);
X! 	recalc_wt();
X! 	victual.fullwarn = victual.eating = victual.doreset = 
X! 		victual.canchoke = FALSE;
X  	stop_occupation();
X  }
X  
X--- 295,310 ----
X  #ifdef DEBUG
X  	debug("do_reset_eat...");
X  #endif
X! 	if (victual.piece) {
X! 		victual.piece = touchfood(victual.piece);
X! 		recalc_wt();
X! 	}
X! 	victual.fullwarn = victual.eating = victual.doreset = FALSE;
X! 	/* Do not set canchoke to FALSE; if we continue eating the same object
X! 	 * we need to know if canchoke was set when they started eating it the
X! 	 * previous time.  And if we don't continue eating the same object
X! 	 * canchoke always gets recalculated anyway.
X! 	 */
X  	stop_occupation();
X  }
X  
X***************
X*** 227,284 ****
X  		return(0);
X  	}
X  	if(!victual.eating) return(0);
X- 	if(victual.usedtime++ < victual.reqtime) {
X- 	/* You can only choke if you were satiated before you started
X- 	 * eating.
X- 	 */
X- 	    if(victual.canchoke && u.uhunger >= 2000) {
X- 		choke(victual.piece);
X- 		do_reset_eat(); /* if they were lifesaved, stop eating */
X- 		return 0;
X- 	    }
X- 
X- 	    if(victual.nmod < 0)
X- 		lesshungry(-victual.nmod);
X- 	    else if(victual.nmod > 0 && (victual.usedtime % victual.nmod))
X- 		lesshungry(1);
X  
X! 	    if(victual.doreset) do_reset_eat();
X! 	    else {
X! 		/* We have to calculate this every move--sometimes the thing
X! 		 * which interrupts eating also needs to know the state of your
X! 		 * food, so it's no good to recalculate the state of your food
X! 		 * only after you stopped eating.  Currently, the only meal-
X! 		 * interruptor which needs to know it is troll revivication,
X! 		 * and it only needs to know oeaten and the weight.
X! 		 */
X! 		if (victual.nmod < 0)
X! 			victual.piece->oeaten -= -victual.nmod;
X! 		else if (victual.nmod > 0 && (victual.usedtime % victual.nmod))
X! 			victual.piece->oeaten--;
X! 		recalc_wt();
X! 	    }
X! 	    return 1;	/* still busy */
X  	} else {	/* done */
X  #ifndef NO_SIGNAL
X! 	    victual.piece->in_use = TRUE;
X  #endif
X! 	    if (nomovemsg) {
X! 		pline(nomovemsg);
X  		nomovemsg = 0;
X! 	    } else You("finish eating the %s.", singular(victual.piece, xname));
X  
X! 	    if(victual.piece->otyp == CORPSE)
X  		cpostfx(victual.piece->corpsenm);
X! 	    else
X  		fpostfx(victual.piece);
X  
X! 	    if (carried(victual.piece)) useup(victual.piece);
X! 	    else useupf(victual.piece);
X! 	    victual.piece = (struct obj *) 0;
X! 	    victual.fullwarn = victual.eating = victual.doreset = 
X! 		victual.canchoke = FALSE;
X! 	    return(0);
X! 	}
X  }
X  
X  static void
X--- 319,356 ----
X  		return(0);
X  	}
X  	if(!victual.eating) return(0);
X  
X! 	if(++victual.usedtime < victual.reqtime) {
X! 	    if(bite()) return(0);
X! 	    return(1);	/* still busy */
X  	} else {	/* done */
X+ 	    done_eating(TRUE);
X+ 	    return(0);
X+ 	}
X+ }
X+ 
X+ static void
X+ done_eating(message)
X+ boolean message;
X+ {
X  #ifndef NO_SIGNAL
X! 	victual.piece->in_use = TRUE;
X  #endif
X! 	if (nomovemsg) {
X! 		if (message) pline(nomovemsg);
X  		nomovemsg = 0;
X! 	} else if (message)
X! 		You("finish eating the %s.", singular(victual.piece, xname));
X  
X! 	if(victual.piece->otyp == CORPSE)
X  		cpostfx(victual.piece->corpsenm);
X! 	else
X  		fpostfx(victual.piece);
X  
X! 	if (carried(victual.piece)) useup(victual.piece);
X! 	else useupf(victual.piece);
X! 	victual.piece = (struct obj *) 0;
X! 	victual.fullwarn = victual.eating = victual.doreset = FALSE;
X  }
X  
X  static void
X***************
X*** 286,292 ****
X  register int pm;
X  {
X  	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X! 		You("cannibal!	You will regret this!");
X  		Aggravate_monster |= INTRINSIC;
X  	}
X  
X--- 358,364 ----
X  register int pm;
X  {
X  	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X! 		You("cannibal!  You will regret this!");
X  		Aggravate_monster |= INTRINSIC;
X  	}
X  
X***************
X*** 304,318 ****
X  	    case PM_MEDUSA:
X  #endif
X  #ifdef POLYSELF
X! 		if(!resists_ston(uasmon)) {
X  #endif
X! 			killer = (char *) alloc(40);
X  			You("turn to stone.");
X! 			Sprintf(killer, "%s meat", mons[pm].mname);
X  			done(STONING);
X  #ifdef POLYSELF
X- 		}
X- 		break;
X  	    case PM_LIZARD:
X  		/* Relief from cockatrices -dgk */
X  		if (Stoned) {
X--- 376,393 ----
X  	    case PM_MEDUSA:
X  #endif
X  #ifdef POLYSELF
X! 		if(!resists_ston(uasmon))
X  #endif
X! 			{
X! 			char *cruft;	/* killer is const char * */
X! 			killer_format = KILLED_BY;
X! 			killer = cruft = (char *) alloc(40);
X  			You("turn to stone.");
X! 			Sprintf(cruft, "%s meat", mons[pm].mname);
X  			done(STONING);
X+ 			}
X+ 			break;
X  #ifdef POLYSELF
X  	    case PM_LIZARD:
X  		/* Relief from cockatrices -dgk */
X  		if (Stoned) {
X***************
X*** 321,328 ****
X  		}
X  		break;
X  	    default:
X! 
X! 		if(dmgtype(&mons[pm], AD_ACID) && Stoned) {
X  		    pline("What a pity - you just destroyed a future piece of art!");
X  		    Stoned = 0;
X  		}
X--- 396,402 ----
X  		}
X  		break;
X  	    default:
X! 		if(acidic(&mons[pm]) && Stoned) {
X  		    pline("What a pity - you just destroyed a future piece of art!");
X  		    Stoned = 0;
X  		}
X***************
X*** 416,427 ****
X  		if (HStun > 2)  make_stunned(2L,FALSE);
X  		if (HConfusion > 2)  make_confused(2L,FALSE);
X  		break;
X- #ifdef POLYSELF
X  	    case PM_CHAMELEON:
X  		You("feel a change coming over you.");
X  		polyself();
X! 		break;
X  #endif
X  	    default: {
X  		register struct permonst *ptr = &mons[pm];
X  		if(dmgtype(ptr, AD_STUN) || ptr==&mons[PM_VIOLET_FUNGUS]) {
X--- 490,503 ----
X  		if (HStun > 2)  make_stunned(2L,FALSE);
X  		if (HConfusion > 2)  make_confused(2L,FALSE);
X  		break;
X  	    case PM_CHAMELEON:
X  		You("feel a change coming over you.");
X+ #ifdef POLYSELF
X  		polyself();
X! #else
X! 		newman();
X  #endif
X+ 		break;
X  	    default: {
X  		register struct permonst *ptr = &mons[pm];
X  		if(dmgtype(ptr, AD_STUN) || ptr==&mons[PM_VIOLET_FUNGUS]) {
X***************
X*** 428,433 ****
X--- 504,512 ----
X  		    pline ("Oh wow!  Great stuff!");
X  		    make_hallucinated(Hallucination + 200,FALSE);
X  		}
X+ 		/* prevent polymorph abuse by killing/eating your offspring */
X+ 		if(ptr >= &mons[PM_BABY_GRAY_DRAGON] &&
X+ 		   ptr <= &mons[PM_BABY_YELLOW_DRAGON]) return;
X  		if(is_giant(ptr)) gainstr((struct obj *)0, 0);
X  
X  		if(can_teleport(ptr) && ptr->mlevel > rn2(10)) {
X***************
X*** 435,456 ****
X  			You("feel very jumpy.");
X  			HTeleportation |= INTRINSIC;
X  		    }
X! 		} else if(control_teleport(ptr) && ptr->mlevel > rn2(20)) {
X  		    if (!(HTeleport_control & INTRINSIC)) {
X  			You("feel in control of yourself.");
X  			HTeleport_control |= INTRINSIC;
X  		    }
X! 		} else if(resists_fire(ptr) && ptr->mlevel > rn2(20)) {
X  		    if (!(HFire_resistance & INTRINSIC)) {
X  			You("feel a momentary chill.");
X  			HFire_resistance |= INTRINSIC;
X  		    }
X! 		} else if(resists_cold(ptr) && ptr->mlevel > rn2(20)) {
X  		    if (!(HCold_resistance & INTRINSIC)) {
X  			You("feel full of hot air.");
X  			HCold_resistance |= INTRINSIC;
X  		    }
X! 		} else if((ptr->mflags1 & M1_POIS_RES) && ptr->mlevel>rn2(20)) {
X  		/* Monsters with only M1_POIS are poison resistant themselves,
X  		 * but do not confer resistance when eaten
X  		 */
X--- 514,536 ----
X  			You("feel very jumpy.");
X  			HTeleportation |= INTRINSIC;
X  		    }
X! 		} else if(control_teleport(ptr) && ptr->mlevel > rn2(15)) {
X  		    if (!(HTeleport_control & INTRINSIC)) {
X  			You("feel in control of yourself.");
X  			HTeleport_control |= INTRINSIC;
X  		    }
X! 		} else if(resists_fire(ptr) && ptr->mlevel > rn2(15)) {
X  		    if (!(HFire_resistance & INTRINSIC)) {
X  			You("feel a momentary chill.");
X  			HFire_resistance |= INTRINSIC;
X  		    }
X! 		} else if(resists_cold(ptr) && ptr->mlevel > rn2(15)) {
X  		    if (!(HCold_resistance & INTRINSIC)) {
X  			You("feel full of hot air.");
X  			HCold_resistance |= INTRINSIC;
X  		    }
X! 		} else if(((ptr->mflags1 & M1_POIS_RES) && ptr->mlevel>rn2(15))
X! 		   || ((pm == PM_KILLER_BEE || pm == PM_SCORPION) && !rn2(4))) {
X  		/* Monsters with only M1_POIS are poison resistant themselves,
X  		 * but do not confer resistance when eaten
X  		 */
X***************
X*** 458,469 ****
X  			You("feel healthy.");
X  			HPoison_resistance |= INTRINSIC;
X  		    }
X! 		} else if(resists_elec(ptr) && ptr->mlevel > rn2(20)) {
X  		    if (!(HShock_resistance & INTRINSIC)) {
X  			Your("health currently feels amplified!");
X  			HShock_resistance |= INTRINSIC;
X  		    }
X! 		} else if((ptr->mflags1 & M1_SLEE_RES) && ptr->mlevel > rn2(20)) {
X  		/* Undead monsters never sleep,
X  		 * but also do not confer resistance when eaten
X  		 */
X--- 538,549 ----
X  			You("feel healthy.");
X  			HPoison_resistance |= INTRINSIC;
X  		    }
X! 		} else if(resists_elec(ptr) && ptr->mlevel > rn2(15)) {
X  		    if (!(HShock_resistance & INTRINSIC)) {
X  			Your("health currently feels amplified!");
X  			HShock_resistance |= INTRINSIC;
X  		    }
X! 		} else if((ptr->mflags1 & M1_SLEE_RES) && ptr->mlevel > rn2(15)) {
X  		/* Undead monsters never sleep,
X  		 * but also do not confer resistance when eaten
X  		 */
X***************
X*** 471,477 ****
X  			You("feel wide awake.");
X  			HSleep_resistance |= INTRINSIC;
X  		    }
X! 		} else if(resists_disint(ptr) && ptr->mlevel > rn2(20)) {
X  		    if (!(HDisint_resistance & INTRINSIC)) {
X  			You("feel very firm.");
X  			HDisint_resistance |= INTRINSIC;
X--- 551,557 ----
X  			You("feel wide awake.");
X  			HSleep_resistance |= INTRINSIC;
X  		    }
X! 		} else if(resists_disint(ptr) && ptr->mlevel > rn2(15)) {
X  		    if (!(HDisint_resistance & INTRINSIC)) {
X  			You("feel very firm.");
X  			HDisint_resistance |= INTRINSIC;
X***************
X*** 568,573 ****
X--- 648,659 ----
X  {
X  	register int tmp;
X  
X+ #ifdef POLYSELF
X+ 	if (metallivorous(uasmon)) {
X+ 		You("bite right into the metal can....");
X+ 		tmp = 1;
X+ 	} else
X+ #endif
X  	if (otmp->blessed) {
X  		pline("The tin opens like magic!");
X  		tmp = 1;
X***************
X*** 626,634 ****
X  }
X  
X  static int
X! rottenfood() {		/* called on the "first bite" of rotten food */
X! 
X  	pline("Blecch!  Rotten food!");
X  	if(!rn2(4)) {
X  		if (Hallucination) You("feel rather trippy.");
X  		else You("feel rather %s.", body_part(LIGHT_HEADED));
X--- 712,729 ----
X  }
X  
X  static int
X! #ifdef POLYSELF
X! rottenfood(obj)
X! struct obj *obj;
X! #else
X! rottenfood()
X! #endif
X! {		/* called on the "first bite" of rotten food */
X! #ifdef POLYSELF
X! 	pline("Blecch!  Rotten %s!", foodword(obj));
X! #else
X  	pline("Blecch!  Rotten food!");
X+ #endif
X  	if(!rn2(4)) {
X  		if (Hallucination) You("feel rather trippy.");
X  		else You("feel rather %s.", body_part(LIGHT_HEADED));
X***************
X*** 654,660 ****
X  eatcorpse(otmp)		/* called when a corpse is selected as food */
X  	register struct obj *otmp;
X  {
X! 	register char *cname = mons[otmp->corpsenm].mname;
X  	register int tp, rotted = 0;
X  
X  	tp = 0;
X--- 749,755 ----
X  eatcorpse(otmp)		/* called when a corpse is selected as food */
X  	register struct obj *otmp;
X  {
X! 	register const char *cname = mons[otmp->corpsenm].mname;
X  	register int tp, rotted = 0;
X  
X  	tp = 0;
X***************
X*** 680,686 ****
X  #endif
X  			make_sick(10L + rn2(10),FALSE);
X  			Sprintf(corpsename, "rotted %s corpse", cname);
X! 			u.usick_cause = corpsename;
X  			flags.botl = 1;
X  #ifdef POLYSELF
X  		}
X--- 775,781 ----
X  #endif
X  			make_sick(10L + rn2(10),FALSE);
X  			Sprintf(corpsename, "rotted %s corpse", cname);
X! 			u.usick_cause = (const char *)corpsename;
X  			flags.botl = 1;
X  #ifdef POLYSELF
X  		}
X***************
X*** 688,699 ****
X  		if (carried(otmp)) useup(otmp);
X  		else useupf(otmp);
X  		return(1);
X! 	} else if(poisonous(&mons[otmp->corpsenm]) && rn2(5)){
X  		tp++;
X  		pline("Ecch - that must have been poisonous!");
X  		if(!Poison_resistance) {
X  			losestr(rnd(4));
X! 			losehp(rnd(15), "poisonous corpse");
X  		} else	You("seem unaffected by the poison.");
X  	/* now any corpse left too long will make you mildly ill */
X  	} else if(((rotted > 5) || ((rotted > 3) && rn2(5)))
X--- 783,802 ----
X  		if (carried(otmp)) useup(otmp);
X  		else useupf(otmp);
X  		return(1);
X! 	} else if(acidic(&mons[otmp->corpsenm])
X! #ifdef POLYSELF
X! 		  && !resists_acid(uasmon)
X! #endif
X! 		 ) {
X! 		tp++;
X! 		You("have a very bad case of stomach acid.");
X! 		losehp(rnd(15), "acidic corpse", KILLED_BY_AN);
X! 	} else if(poisonous(&mons[otmp->corpsenm]) && rn2(5)) {
X  		tp++;
X  		pline("Ecch - that must have been poisonous!");
X  		if(!Poison_resistance) {
X  			losestr(rnd(4));
X! 			losehp(rnd(15), "poisonous corpse", KILLED_BY_AN);
X  		} else	You("seem unaffected by the poison.");
X  	/* now any corpse left too long will make you mildly ill */
X  	} else if(((rotted > 5) || ((rotted > 3) && rn2(5)))
X***************
X*** 703,713 ****
X  							){
X  		tp++;
X  		You("feel%s sick.", (Sick) ? " very" : "");
X! 		losehp(rnd(8), "cadaver");
X  	}
X  	if(!tp && otmp->corpsenm != PM_LIZARD && (otmp->orotten || !rn2(7))) {
X! 
X  	    if(rottenfood()) {
X  		otmp->orotten = TRUE;
X  		(void)touchfood(otmp);
X  		return(1);
X--- 806,819 ----
X  							){
X  		tp++;
X  		You("feel%s sick.", (Sick) ? " very" : "");
X! 		losehp(rnd(8), "cadaver", KILLED_BY_AN);
X  	}
X  	if(!tp && otmp->corpsenm != PM_LIZARD && (otmp->orotten || !rn2(7))) {
X! #ifdef POLYSELF
X! 	    if(rottenfood(otmp)) {
X! #else
X  	    if(rottenfood()) {
X+ #endif
X  		otmp->orotten = TRUE;
X  		(void)touchfood(otmp);
X  		return(1);
X***************
X*** 715,724 ****
X  	    otmp->oeaten >>= 2;
X  	} else {
X  #ifdef POLYSELF
X! 	    pline("That %s corpse %s!", cname,
X! 		carnivorous(uasmon) ? "was delicious" : "tasted terrible");
X  #else
X! 	    pline("That %s corpse tasted terrible!", cname);
X  #endif
X  	}
X  
X--- 821,830 ----
X  	    otmp->oeaten >>= 2;
X  	} else {
X  #ifdef POLYSELF
X! 	    pline("This %s corpse %s!", cname,
X! 		carnivorous(uasmon) ? "is delicious" : "tastes terrible");
X  #else
X! 	    pline("This %s corpse tastes terrible!", cname);
X  #endif
X  	}
X  
X***************
X*** 739,750 ****
X  	debug("oeaten = %d", otmp->oeaten);
X  #endif
X  	victual.fullwarn = victual.doreset = FALSE;
X- 	victual.canchoke = (u.uhs == SATIATED);
X  	victual.eating = TRUE;
X  
X  	if (otmp->otyp == CORPSE)
X  	    cprefx(victual.piece->corpsenm);
X  
X  	Sprintf(msgbuf, "eating the %s", singular(otmp, xname));
X  	set_occupation(eatfood, msgbuf, 0);
X  }
X--- 845,862 ----
X  	debug("oeaten = %d", otmp->oeaten);
X  #endif
X  	victual.fullwarn = victual.doreset = FALSE;
X  	victual.eating = TRUE;
X  
X  	if (otmp->otyp == CORPSE)
X  	    cprefx(victual.piece->corpsenm);
X  
X+ 	if (bite()) return;
X+ 
X+ 	if(++victual.usedtime >= victual.reqtime) {
X+ 	    done_eating(FALSE);
X+ 	    return;
X+ 	}
X+ 
X  	Sprintf(msgbuf, "eating the %s", singular(otmp, xname));
X  	set_occupation(eatfood, msgbuf, 0);
X  }
X***************
X*** 829,834 ****
X--- 941,992 ----
X  	}
X  }
X  
X+ #ifdef POLYSELF
X+ static void
X+ eatspecial() /* called after eating non-food */
X+ {
X+ 	register struct obj *otmp = victual.piece;
X+ 
X+ 	lesshungry(victual.nmod);
X+ 	victual.piece = (struct obj *)0;
X+ 	victual.eating = 0;
X+ 	if (otmp->olet == GOLD_SYM) { /* temporary gold object */
X+ 		free ((genericptr_t)otmp);
X+ 		return;
X+ 	}
X+ 	if (otmp->olet == POTION_SYM) {
X+ 		otmp->quan++; /* dopotion() does a useup() */
X+ 		(void)dopotion(otmp);
X+ 	}
X+ 	if (otmp == uball) unpunish();
X+ 	if (otmp == uchain) unpunish(); /* but no useup() */
X+ 	else if (carried(otmp)) useup(otmp);
X+ 	else useupf(otmp);
X+ }
X+ 
X+ static const char *
X+ foodword(otmp)
X+ register struct obj *otmp;
X+ {
X+ 	if (otmp->olet == FOOD_SYM) return "food";
X+ 	if (otmp->olet == GOLD_SYM) return "gold";
X+ 	if (objects[otmp->otyp].oc_material == GLASS) {
X+ 		if (otmp->olet == GEM_SYM && otmp->dknown)
X+ 			makeknown(otmp->otyp);
X+ 		return "glass";
X+ 	}
X+ 	if (objects[otmp->otyp].oc_material > WOOD &&
X+ 			objects[otmp->otyp].oc_material < MINERAL)
X+ 		return "metal";
X+ 	if (objects[otmp->otyp].oc_material == MINERAL)
X+ 		return (otmp->otyp <= LAST_GEM && otmp->olet == GEM_SYM)
X+ 			? "rich food" : "stone";
X+ 	if (objects[otmp->otyp].oc_material == WOOD) return "wood";
X+ 	if (otmp->olet == ARMOR_SYM) return "armor";
X+ 	return "stuff";
X+ }
X+ #endif
X+ 
X  static void
X  fpostfx(otmp)		/* called after consuming (non-corpse) food */
X  
X***************
X*** 859,865 ****
X  			if(!rn2(17)) u.uhpmax++;
X  			u.uhp = u.uhpmax;
X  		} else if(u.uhp <= 0) {
X! 			killer = "rotten jelly lump";
X  			done(POISONING);
X  		}
X  		if(!otmp->cursed) heal_legs();
X--- 1017,1024 ----
X  			if(!rn2(17)) u.uhpmax++;
X  			u.uhp = u.uhpmax;
X  		} else if(u.uhp <= 0) {
X! 			killer_format = KILLED_BY_AN;
X! 			killer = "rotten lump of royal jelly";
X  			done(POISONING);
X  		}
X  		if(!otmp->cursed) heal_legs();
X***************
X*** 870,875 ****
X--- 1029,1035 ----
X  		    if(!resists_ston(uasmon)) {
X  #endif
X  			if (!Stoned) Stoned = 5;
X+ 			killer_format = KILLED_BY_AN;
X  			killer = "cockatrice egg";
X  #ifdef POLYSELF
X  		    }
X***************
X*** 885,898 ****
X  	register struct obj *otmp;
X  	int basenutrit; 		/* nutrition of full item */
X  
X  	if (!(otmp = floorfood("eat", 0))) return 0;
X  
X  	if(otmp == victual.piece) {
X! 	    You("resume your meal.");
X  	    if(!carried(victual.piece)) {
X  		if(victual.piece->quan != 1)
X  			(void) splitobj(victual.piece, 1);
X  	    }
X  	    start_eating(victual.piece);
X  	    return(1);
X  	}
X--- 1045,1112 ----
X  	register struct obj *otmp;
X  	int basenutrit; 		/* nutrition of full item */
X  
X+ 	if (Strangled) {
X+ 		pline("If you can't breathe air, how can you consume solids?");
X+ 		return 0;
X+ 	}
X  	if (!(otmp = floorfood("eat", 0))) return 0;
X+ #ifdef POLYSELF
X+ 	/* We have to make non-foods take no time to eat, unless we want to
X+ 	 * do ridiculous amounts of coding to deal with partly eaten plate
X+ 	 * mails, players who polymorph back to human in the middle of their
X+ 	 * metallic meal, etc....
X+ 	 */
X+ 	if (!is_edible(otmp)) {
X+ 	    You("cannot eat that!");
X+ 	    if (otmp->olet == GOLD_SYM) { /* temp gold object */
X+ 		if (otmp->ox) mkgold(OGOLD(otmp), u.ux, u.uy);
X+ 		else u.ugold += OGOLD(otmp);
X+ 		free((genericptr_t) otmp);
X+ 	    }
X+ 	    return 0;
X+ 	}
X+ 	if (otmp->olet != FOOD_SYM) {
X+ 	    victual.reqtime = 1;
X+ 	    victual.piece = otmp;
X+ 		/* Don't split it, we don't need to if it's 1 move */
X+ 	    victual.usedtime = 0;
X+ 	    victual.canchoke = (u.uhs == SATIATED);
X+ 	    if (otmp->olet == GOLD_SYM)
X+ 		basenutrit = ((OGOLD(otmp) > 5000L) ? 5000 : (int)OGOLD(otmp));
X+ 	    else basenutrit = otmp->owt * 10 / otmp->quan;
X+ 	    victual.nmod = basenutrit;
X+ 	    victual.eating = TRUE; /* needed for lesshungry() */
X+ 		
X+ 	    if (otmp->cursed) 
X+ 		(void) rottenfood(otmp);
X+ 
X+ 	    if (otmp->olet == WEAPON_SYM && otmp->opoisoned) {
X+ 		pline("Ecch - that must have been poisonous!");
X+ 		if(!Poison_resistance) {
X+ 		    losestr(rnd(4));
X+ 		    losehp(rnd(15), xname(otmp), KILLED_BY_AN);
X+ 		} else
X+ 		    You("seem unaffected by the poison.");
X+ 	    } else if (!otmp->cursed)
X+ 		pline("This %s is delicious!",
X+ 		    otmp->olet == GOLD_SYM ? "gold" : xname(otmp));
X+ 	    eatspecial();
X+ 	    return 1;
X+ 	}
X+ #endif
X  
X  	if(otmp == victual.piece) {
X! 	/* If they weren't able to choke, they don't suddenly become able to
X! 	 * choke just because they were interrupted.  On the other hand, if
X! 	 * they were able to choke before, if they lost food it's possible
X! 	 * they shouldn't be able to choke now.
X! 	 */
X! 	    if (u.uhs != SATIATED) victual.canchoke = FALSE;
X  	    if(!carried(victual.piece)) {
X  		if(victual.piece->quan != 1)
X  			(void) splitobj(victual.piece, 1);
X  	    }
X+ 	    You("resume your meal.");
X  	    start_eating(victual.piece);
X  	    return(1);
X  	}
X***************
X*** 919,932 ****
X  	    victual.reqtime = objects[otmp->otyp].oc_delay;
X  	    if (otmp->otyp != FORTUNE_COOKIE &&
X  		(otmp->cursed ||
X! 		 ((monstermoves - otmp->age) > otmp->blessed ? 50 : 30)) &&
X! 		(otmp->orotten || !rn2(7))) {
X  
X! 		if(rottenfood()) {
X  		    otmp->orotten = TRUE;
X  		    return(1);
X  		}
X! 		otmp->oeaten /= 2;
X  	    } else fprefx(otmp);
X  	}
X  
X--- 1133,1150 ----
X  	    victual.reqtime = objects[otmp->otyp].oc_delay;
X  	    if (otmp->otyp != FORTUNE_COOKIE &&
X  		(otmp->cursed ||
X! 		 (((monstermoves - otmp->age) > otmp->blessed ? 50 : 30) &&
X! 		(otmp->orotten || !rn2(7))))) {
X  
X! #ifdef POLYSELF
X! 		if(rottenfood(otmp)) {
X! #else
X!   		if(rottenfood()) {
X! #endif
X  		    otmp->orotten = TRUE;
X  		    return(1);
X  		}
X! 		otmp->oeaten >>= 1;
X  	    } else fprefx(otmp);
X  	}
X  
X***************
X*** 956,966 ****
X--- 1174,1213 ----
X  	    victual.nmod = -(otmp->oeaten / victual.reqtime);
X  	else
X  	    victual.nmod = victual.reqtime % otmp->oeaten;
X+ 	victual.canchoke = (u.uhs == SATIATED);
X  
X  	start_eating(otmp);
X  	return(1);
X  }
X  
X+ /* Take a single bite from a piece of food, checking for choking and
X+  * modifying usedtime.  Returns 1 if they choked and survived, 0 otherwise.
X+  */
X+ static int
X+ bite()
X+ {
X+ 	if(victual.canchoke && u.uhunger >= 2000) {
X+ 		choke(victual.piece);
X+ 		return 1;
X+ 	}
X+ 	if (victual.doreset) {
X+ 		do_reset_eat();
X+ 		return 0;
X+ 	}
X+ 	if(victual.nmod < 0) {
X+ 		lesshungry(-victual.nmod);
X+ 		victual.piece->oeaten -= -victual.nmod;
X+ 	} else if(victual.nmod > 0 && (victual.usedtime % victual.nmod)) {
X+ 		lesshungry(1);
X+ 		victual.piece->oeaten--;
X+ 	}
X+ 	recalc_wt();
X+ 	return 0;
X+ }
X+ 
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  void
X  gethungry() {		/* as time goes by - called in main.c */
X  	--u.uhunger;
X***************
X*** 983,988 ****
X--- 1230,1237 ----
X  	newuhs(TRUE);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X  
X  void
X  morehungry(num)	/* called after vomiting and after performing feats of magic */
X***************
X*** 1002,1011 ****
X  #endif
X  	u.uhunger += num;
X  	if(u.uhunger >= 2000) {
X! 	    if (!victual.eating || victual.canchoke) {
X! 		choke((struct obj *) 0);
X! 		reset_eat(); /* stop eating if they were lifesaved */
X! 	    }
X  	} else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X--- 1251,1263 ----
X  #endif
X  	u.uhunger += num;
X  	if(u.uhunger >= 2000) {
X! 	    if (!victual.eating || victual.canchoke)
X! 		if (victual.eating) {
X! 			choke(victual.piece);
X! 			reset_eat();
X! 		} else
X! 			choke((struct obj *) 0);
X! 			/* no reset_eat(); it was a non-food such as juice */
X  	} else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X***************
X*** 1040,1045 ****
X--- 1292,1322 ----
X  	return 0;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X+ boolean
X+ is_fainted() {
X+ 	return(u.uhs == FAINTED);
X+ }
X+ 
X+ void
X+ reset_faint() {	/* call when a faint must be prematurely terminated */
X+ 	if(is_fainted()) nomul(0);
X+ }
X+ 
X+ void
X+ sync_hunger() {
X+ 
X+ 	if(is_fainted()) {
X+ 
X+ 		flags.soundok = 0;
X+ 		nomul(-10+(u.uhunger/10));
X+ 		nomovemsg = "You regain consciousness.";
X+ 		afternmv = unfaint;
X+ 	}
X+ }
X+ 
X  void
X  newuhs(incr)		/* compute and comment on your (new?) hunger status */
X  	boolean incr;
X***************
X*** 1052,1060 ****
X  		(h > 0) ? WEAK : FAINTING;
X  
X  	if(newhs == FAINTING) {
X! 		if(u.uhs == FAINTED) newhs = FAINTED;
X  		if(u.uhs <= WEAK || rn2(20-u.uhunger/10) >= 19) {
X! 			if(u.uhs != FAINTED && multi >= 0 /* %% */) {
X  				You("faint from lack of food.");
X  				flags.soundok = 0;
X  				nomul(-10+(u.uhunger/10));
X--- 1329,1337 ----
X  		(h > 0) ? WEAK : FAINTING;
X  
X  	if(newhs == FAINTING) {
X! 		if(is_fainted()) newhs = FAINTED;
X  		if(u.uhs <= WEAK || rn2(20-u.uhunger/10) >= 19) {
X! 			if(!is_fainted() && multi >= 0 /* %% */) {
X  				You("faint from lack of food.");
X  				flags.soundok = 0;
X  				nomul(-10+(u.uhunger/10));
X***************
X*** 1068,1073 ****
X--- 1345,1351 ----
X  			flags.botl = 1;
X  			bot();
X  			You("die from starvation.");
X+ 			killer_format = KILLED_BY;
X  			killer = "starvation";
X  			done(STARVING);
X  		}
X***************
X*** 1104,1109 ****
X--- 1382,1388 ----
X  		flags.botl = 1;
X  		if(u.uhp < 1) {
X  			You("die from hunger and exhaustion.");
X+ 			killer_format = KILLED_BY;
X  			killer = "exhaustion";
X  			done(STARVING);
X  		}
X***************
X*** 1110,1129 ****
X  	}
X  }
X  
X  /* Returns an object representing food.  Object may be either on floor or
X   * in inventory.
X   */
X  struct obj *
X  floorfood(verb,corpseonly)	/* get food from floor or pack */
X! 	char *verb;
X  	boolean corpseonly;
X  {
X  	register struct obj *otmp;
X! 
X  	/* Is there some food (probably a heavy corpse) here on the ground? */
X  	if(!Levitation && !u.uswallow) {
X  	    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere) {
X! 		if(corpseonly ? otmp->otyp==CORPSE : otmp->olet==FOOD_SYM) {
X  			pline("There %s %s here; %s %s? ",
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X--- 1389,1435 ----
X  	}
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  /* Returns an object representing food.  Object may be either on floor or
X   * in inventory.
X   */
X  struct obj *
X  floorfood(verb,corpseonly)	/* get food from floor or pack */
X! 	const char *verb;
X  	boolean corpseonly;
X  {
X  	register struct obj *otmp;
X! #ifdef POLYSELF
X! 	struct gold *gold = g_at(u.ux, u.uy);
X! 	boolean feeding = (!strcmp(verb, "eat"));
X! #endif
X! #ifdef POLYSELF
X! 	if (feeding && gold && metallivorous(uasmon)) {
X! 	    if (gold->amount == 1)
X! 		pline("There is 1 gold piece here; eat it? ");
X! 	    else pline("There are %ld gold pieces here; eat them? ",
X! 								gold->amount);
X! 	    if (yn() == 'y') {
X! 		otmp = newobj(0);
X! 		otmp->olet = GOLD_SYM;
X! 		otmp->ox = u.ux;
X! 		otmp->oy = u.uy;
X! 		OGOLD(otmp) = gold->amount;
X! 		freegold(gold);
X! 		return otmp;
X! 	    }
X! 	}
X! #endif
X  	/* Is there some food (probably a heavy corpse) here on the ground? */
X  	if(!Levitation && !u.uswallow) {
X  	    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere) {
X! 		if(corpseonly ? otmp->otyp==CORPSE : 
X! #ifdef POLYSELF
X! 		    feeding ? is_edible(otmp) :
X! #endif
X! 						otmp->olet==FOOD_SYM) {
X  			pline("There %s %s here; %s %s? ",
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X***************
X*** 1133,1139 ****
X--- 1439,1453 ----
X  		}
X  	    }
X  	}
X+ #ifdef POLYSELF
X+ 	/* We cannot use "#" since that causes getobj() to skip its
X+ 	 * "ugly checks" and we need to check for inedible items.
X+ 	 */
X+ 	return getobj (feeding ? (const char *)everything :
X+ 				 (const char *)comestibles, verb);
X+ #else
X  	return getobj(comestibles, verb);
X+ #endif
X  }
X  
X  /* Side effects of vomiting */
X***************
X*** 1152,1158 ****
X  {
X  	base *= obj->oeaten;
X  
X! 	if (obj->otyp == CORPSE) base /= mons[obj->corpsenm].cnutrit;
X! 	else base /= objects[obj->otyp].nutrition;
X  	return (base < 1) ? 1 : base;
X  }
X--- 1466,1477 ----
X  {
X  	base *= obj->oeaten;
X  
X! 	if (obj->otyp == CORPSE) 
X! 	    base = mons[obj->corpsenm].cnutrit ?
X! 				base / mons[obj->corpsenm].cnutrit : 0;
X! 	else base = objects[obj->otyp].nutrition ?
X! 				base / objects[obj->otyp].nutrition : 0;
X  	return (base < 1) ? 1 : base;
X  }
X+ 
X+ #endif /* OVLB */
X*** src/Old/getline.c	Mon Feb 19 18:04:54 1990
X--- src/getline.c	Mon Feb 19 14:45:59 1990
X***************
X*** 12,22 ****
X--- 12,30 ----
X  #if defined(SYSV) || defined(DGUX)
X  #define	NR_OF_EOFS	20
X  #endif
X+ #ifdef MACOS
X+ extern short macflags;
X+ #endif
X+ #ifdef OVL1
X  
X  char morc = 0;	/* tell the outside world what char he used */
X  
X+ #endif /* OVL1 */
X+ 
X  extern char erase_char, kill_char;	/* from appropriate tty.c file */
X  
X+ #ifdef OVL1
X+ 
X  /*
X   * Read a line closed with '\n' into the array char bufp[BUFSZ].
X   * (The '\n' is not stored. The string is closed with a '\0'.)
X***************
X*** 29,45 ****
X  {
X  	register char *obufp = bufp;
X  	register int c;
X! 
X  	flags.toplin = 2;		/* nonempty, no --More-- required */
X  	for(;;) {
X  		(void) fflush(stdout);
X  		if((c = Getchar()) == EOF) {
X  			*bufp = 0;
X  			return;
X  		}
X  		if(c == '\033') {
X  			*obufp = c;
X  			obufp[1] = 0;
X  			return;
X  		}
X  		if(c == erase_char || c == '\b') {
X--- 37,64 ----
X  {
X  	register char *obufp = bufp;
X  	register int c;
X! #ifdef MACOS
X! 	short	tmpflags;
X! 	
X! 	tmpflags = macflags;
X! 	macflags &= ~fDoNonKeyEvt;
X! #endif
X  	flags.toplin = 2;		/* nonempty, no --More-- required */
X  	for(;;) {
X  		(void) fflush(stdout);
X  		if((c = Getchar()) == EOF) {
X  			*bufp = 0;
X+ #ifdef MACOS
X+ 	macflags |= (tmpflags & fDoNonKeyEvt);
X+ #endif
X  			return;
X  		}
X  		if(c == '\033') {
X  			*obufp = c;
X  			obufp[1] = 0;
X+ #ifdef MACOS
X+ 	macflags |= (tmpflags & fDoNonKeyEvt);
X+ #endif
X  			return;
X  		}
X  		if(c == erase_char || c == '\b') {
X***************
X*** 49,54 ****
X--- 68,76 ----
X  			} else	bell();
X  		} else if(c == '\n') {
X  			*bufp = 0;
X+ #ifdef MACOS
X+ 	macflags |= (tmpflags & fDoNonKeyEvt);
X+ #endif
X  			return;
X  		} else if(' ' <= c && c < '\177' && 
X  			    (bufp-obufp < BUFSZ-1 || bufp-obufp < COLNO)) {
X***************
X*** 70,77 ****
X--- 92,105 ----
X  		} else
X  			bell();
X  	}
X+ #ifdef MACOS
X+ 	macflags |= (tmpflags & fDoNonKeyEvt);
X+ #endif
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  getret() {
X  	cgetret("");
X***************
X*** 79,85 ****
X  
X  void
X  cgetret(s)
X! register char *s;
X  {
X  	putsym('\n');
X  	if(flags.standout)
X--- 107,113 ----
X  
X  void
X  cgetret(s)
X! register const char *s;
X  {
X  	putsym('\n');
X  	if(flags.standout)
X***************
X*** 92,118 ****
X  	xwaitforspace(s);
X  }
X  
X  
X  void
X  xwaitforspace(s)
X! register char *s;	/* chars allowed besides space or return */
X  {
X  	register int c;
X  
X  	morc = 0;
X  
X  	while((c = readchar()) != '\n') {
X  	    if(flags.cbreak) {
X! 		if(c == ' ') break;
X! 		if(s && index(s,c)) {
X! 			morc = c;
X! 			break;
X! 		}
X! 		bell();
X  	    }
X  	}
X  }
X  
X  static int last_multi;
X  
X  char *
X--- 120,161 ----
X  	xwaitforspace(s);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X  
X  void
X  xwaitforspace(s)
X! register const char *s;	/* chars allowed besides space or return */
X  {
X  	register int c;
X  
X  	morc = 0;
X+ #ifdef MACOS
X+ 	flags.wantspace = TRUE;
X+ #endif
X  
X  	while((c = readchar()) != '\n') {
X+ #ifdef MACOS
X+ 		if(c == '\r' || c == 0x3 || c == 'p') break;
X+ #endif
X  	    if(flags.cbreak) {
X! 			if(c == ' ') break;
X! 			if(s && index(s,c)) {
X! 				morc = c;
X! 				break;
X! 			}
X! 			bell();
X  	    }
X  	}
X+ 
X+ #ifdef MACOS
X+ 	flags.wantspace = FALSE;
X+ #endif
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVL0
X+ 
X  static int last_multi;
X  
X  char *
X***************
X*** 131,156 ****
X  	curs_on_u();
X  
X  	if (!flags.num_pad || (foo = readchar()) == 'n')
X! 	    while((foo = readchar()) >= '0' && foo <= '9') {
X! 		multi = 10*multi+foo-'0';
X! 		if (multi < 0 || multi > LARGEST_INT)
X! 			multi = LARGEST_INT;
X! 		if (multi > 9) {
X! 			remember_topl();
X! 			home();
X! 			cl_end();
X! 			Printf("Count: %d", multi);
X! 		}
X! 		last_multi = multi;
X! 		if(!cnt && foo == '0') prezero = TRUE;
X! 		cnt++;
X! 	    }
X! 	    if (foo == '\033') {   /* esc cancels count (TH) */
X! 		remember_topl();
X! 		home();
X! 		cl_end();
X! 		multi = last_multi = 0;
X! 	    }
X  # ifdef REDO
X  	if (foo == DOAGAIN || in_doagain)
X  		multi = last_multi;
X--- 174,202 ----
X  	curs_on_u();
X  
X  	if (!flags.num_pad || (foo = readchar()) == 'n')
X! 	    do {
X! 	    	foo = readchar();
X! 	    	if(foo >= '0' && foo <= '9') {
X! 				multi = 10*multi+foo-'0';
X! 				if (multi < 0 || multi > LARGEST_INT)
X! 					multi = LARGEST_INT;
X! 				if (multi > 9) {
X! 					remember_topl();
X! 					home();
X! 					cl_end();
X! 					Printf("Count: %d", multi);
X! 				}
X! 				last_multi = multi;
X! 				if(!cnt && foo == '0') prezero = TRUE;
X! 				cnt++;
X! 		    }
X! 		    if (foo == '\033') {   /* esc cancels count (TH) */
X! 				remember_topl();
X! 				home();
X! 				cl_end();
X! 				multi = last_multi = 0;
X! 		    }
X! 		} while(foo >= '0' && foo <= '9');
X  # ifdef REDO
X  	if (foo == DOAGAIN || in_doagain)
X  		multi = last_multi;
X***************
X*** 184,189 ****
X--- 230,238 ----
X  	return(in_line);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  #ifdef UNIX
X  static void
X  end_of_input()
X***************
X*** 194,199 ****
X--- 243,251 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  char
X  readchar() {
X  	register int sym;
X***************
X*** 226,231 ****
X--- 278,286 ----
X  	return((char) sym);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X  #ifdef COM_COMPL
X  /* Read in an extended command - doing command line completion for
X   * when enough characters have been entered to make a unique command.
X***************
X*** 303,305 ****
X--- 358,362 ----
X  
X  }
X  #endif /* COM_COMPL */
X+ 
X+ #endif /* OVL2 */
X
END_OF_FILE
if test 56128 -ne `wc -c <'patch7.03'`; then
    echo shar: \"'patch7.03'\" unpacked with wrong size!
fi
# end of 'patch7.03'
echo shar: End of archive 7 \(of 30\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
