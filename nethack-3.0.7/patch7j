Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!zaphod.mps.ohio-state.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i010:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7j
Message-ID: <5224@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:36:04 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 2380
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 10
Archive-name: NetHack3/Patch7j
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 30)."
# Contents:  amiga/ami.lnk patch7.11
# Wrapped by billr@saab on Wed Feb 21 10:04:31 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/ami.lnk' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'amiga/ami.lnk'\" to \"'amiga/ami.lnk.orig'\"
  mv -f 'amiga/ami.lnk' 'amiga/ami.lnk.orig'
fi
echo shar: Extracting \"'amiga/ami.lnk'\" \(1526 characters\)
sed "s/^X//" >'amiga/ami.lnk' <<'END_OF_FILE'
X	O_Src1:allmain.o	O_Src1:alloc.o		O_Src1:apply.o
X	O_Src1:artifact.o	O_Src1:attrib.o		O_Src1:bones.o
X	O_Src1:cmd.o		O_Src1:dbridge.o	O_Src1:decl.o
X	O_Src1:demon.o		O_Src1:do.o		O_Src1:do_name.o
X	O_Src1:do_wear.o	O_Src1:dog.o		O_Src1:dogmove.o
X	O_Src1:dokick.o		O_Src1:dothrow.o	O_Src1:eat.o
X	O_Src1:end.o		O_Src1:engrave.o	O_Src1:exper.o
X	O_Src1:extralev.o	O_Src1:fountain.o	O_Src1:getline.o
X	O_Src1:hack.o		O_Src1:invent.o		O_Src1:lock.o
X
X	O_Src2:mail.o		O_Src2:makemon.o	O_Src2:mcastu.o
X	O_Src2:mhitm.o		O_Src2:mhitu.o		O_Src2:mklev.o
X	O_Src2:mkmaze.o		O_Src2:mkobj.o		O_Src2:mkroom.o
X	O_Src2:mon.o		O_Src2:mondata.o	O_Src2:monmove.o
X	O_Src2:monst.o		O_Src2:mthrowu.o	O_Src2:music.o
X	O_Src2:o_init.o		O_Src2:objects.o	O_Src2:objnam.o
X	O_Src2:options.o	O_Src2:pager.o		O_Src2:pickup.o
X	O_Src2:polyself.o	O_Src2:potion.o
X
X	O_Src3:pray.o		O_Src3:pri.o		O_Src3:priest.o
X	O_Src3:prisym.o		O_Src3:read.o		O_Src3:restore.o
X	O_Src3:rip.o		O_Src3:rnd.o		O_Src3:rumors.o
X	O_Src3:save.o		O_Src3:search.o		O_Src3:shk.o
X	O_Src3:shknam.o		O_Src3:sit.o		O_Src3:sounds.o
X	O_Src3:sp_lev.o		O_Src3:spell.o		O_Src3:steal.o
X	O_Src3:timeout.o	O_Src3:topl.o		O_Src3:topten.o
X	O_Src3:track.o		O_Src3:trap.o		O_Src3:u_init.o
X	O_Src3:uhitm.o		O_Src3:vault.o		O_Src3:version.o
X	O_Src3:weapon.o		O_Src3:were.o		O_Src3:wield.o
X	O_Src3:wizard.o		O_Src3:worm.o		O_Src3:worn.o
X	O_Src3:write.o		O_Src3:zap.o
X
X	O_Amiga:amidos.o	O_Amiga:amitcap.o	O_Amiga:amitty.o
X	O_Amiga:amiunix.o	O_Amiga:amiwbench.o	O_Amiga:amiwind.o
X
X	O_Others:pcmain.o	O_Others:random.o
END_OF_FILE
if test 1526 -ne `wc -c <'amiga/ami.lnk'`; then
    echo shar: \"'amiga/ami.lnk'\" unpacked with wrong size!
fi
# end of 'amiga/ami.lnk'
if test -f 'patch7.11' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.11'\" to \"'patch7.11.orig'\"
  mv -f 'patch7.11' 'patch7.11.orig'
fi
echo shar: Extracting \"'patch7.11'\" \(55515 characters\)
sed "s/^X//" >'patch7.11' <<'END_OF_FILE'
X*** src/Old/mhitu.c	Mon Feb 19 20:29:10 1990
X--- src/mhitu.c	Wed Feb 14 18:38:22 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mhitu.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitu.c	3.0	89/11/27
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 7,25 ****
X  #  include "artifact.h"
X  #endif
X  
X! static struct obj *otmp;
X  #ifdef POLYSELF
X! static void FDECL(urustm, (struct monst *, struct obj *));
X! static int FDECL(passiveum, (struct permonst *, struct monst *));
X  #endif
X  #ifdef SEDUCE
X! static void FDECL(mayberem, (struct obj *, char *));
X  #endif
X! static int FDECL(hitmu, (struct monst *,struct attack *));
X! static int FDECL(gulpmu, (struct monst *,struct attack *));
X! static int FDECL(explmu, (struct monst *,struct attack *));
X! static int FDECL(gazemu, (struct monst *,struct attack *));
X  
X  
X  static void
X  hitmsg(mtmp, mattk)
X--- 7,33 ----
X  #  include "artifact.h"
X  #endif
X  
X! VSTATIC struct obj *otmp;
X! 
X  #ifdef POLYSELF
X! OSTATIC void FDECL(urustm, (struct monst *, struct obj *));
X! static int FDECL(passiveum, (struct permonst *,struct monst *,struct attack *));
X  #endif
X  #ifdef SEDUCE
X! static void FDECL(mayberem, (struct obj *, const char *));
X  #endif
X! OSTATIC int FDECL(hitmu, (struct monst *,struct attack *));
X! OSTATIC int FDECL(gulpmu, (struct monst *,struct attack *));
X! OSTATIC int FDECL(explmu, (struct monst *,struct attack *));
X! OSTATIC int FDECL(gazemu, (struct monst *,struct attack *));
X! static void FDECL(hitmsg,(struct monst *,struct attack *));
X! OSTATIC void FDECL(missmu,(struct monst *,BOOLEAN_P,struct attack *));
X! OSTATIC void FDECL(mswings,(struct monst *,struct obj *));
X! OSTATIC void FDECL(wildmiss,(struct monst *));
X! 
X! OSTATIC void FDECL(hurtarmor,(struct permonst *,int));
X  
X+ #ifdef OVL1
X  
X  static void
X  hitmsg(mtmp, mattk)
X***************
X*** 61,67 ****
X  	    }
X  }
X  
X! static void
X  missmu(mtmp, nearmiss, mattk)		/* monster missed you */
X  register struct monst *mtmp;
X  register boolean nearmiss;
X--- 69,78 ----
X  	    }
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVLB
X! 
X! XSTATIC void
X  missmu(mtmp, nearmiss, mattk)		/* monster missed you */
X  register struct monst *mtmp;
X  register boolean nearmiss;
X***************
X*** 77,83 ****
X  	}
X  }
X  
X! static void
X  mswings(mtmp, otemp)		/* monster swings obj */
X  register struct monst *mtmp;
X  register struct obj *otemp;
X--- 88,94 ----
X  	}
X  }
X  
X! XSTATIC void
X  mswings(mtmp, otemp)		/* monster swings obj */
X  register struct monst *mtmp;
X  register struct obj *otemp;
X***************
X*** 94,100 ****
X  	      xname(otemp));
X  }
X  
X! static void
X  wildmiss(mtmp)		/* monster attacked your displaced image */
X  	register struct monst *mtmp;
X  {
X--- 105,111 ----
X  	      xname(otemp));
X  }
X  
X! XSTATIC void
X  wildmiss(mtmp)		/* monster attacked your displaced image */
X  	register struct monst *mtmp;
X  {
X***************
X*** 147,155 ****
X  }
X  
X  void
X! regurgitates(mtmp)
X  register struct monst *mtmp;
X  {
X  	unstuck(mtmp);
X  	mnexto(mtmp);
X  	prme();
X--- 158,199 ----
X  }
X  
X  void
X! expels(mtmp, mdat, message)
X  register struct monst *mtmp;
X+ register struct permonst *mdat; /* if mtmp is polymorphed, mdat != mtmp->data */
X+ boolean message;
X  {
X+ 	if (message) 
X+ 		if (is_animal(mdat)) 
X+ 			You("get regurgitated!");
X+ 		else {
X+ 			char blast[40];
X+ 			register int i;
X+ 
X+ 			blast[0] = '\0';
X+ 			for(i = 0; i < NATTK; i++)
X+ 				if(mdat->mattk[i].aatyp == AT_ENGL) 
X+ 					break;
X+ 			if (mdat->mattk[i].aatyp != AT_ENGL)
X+ 			      impossible("Swallower has no engulfing attack?"); 
X+ 			else {
X+ 				if (is_whirly(mdat)) {
X+ 					switch (mdat->mattk[i].adtyp) {
X+ 						case AD_ELEC:
X+ 							Strcpy(blast, 
X+ 						      " in a shower of sparks");
X+ 							break;
X+ 						case AD_COLD:
X+ 							Strcpy(blast, 
X+ 							" in a blast of frost");
X+ 							break;
X+ 					}
X+ 				} else
X+ 					Strcpy(blast, " with a squelch");
X+ 				You("get expelled from %s%s!", 
X+ 				    mon_nam(mtmp), blast);
X+ 			}
X+ 		}
X  	unstuck(mtmp);
X  	mnexto(mtmp);
X  	prme();
X***************
X*** 159,164 ****
X--- 203,211 ----
X  		pline("Brrooaa...  You land hard at some distance.");
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  /*
X   * mattacku: monster attacks you
X   *	returns 1 if monster dies (e.g. "yellow light"), 0 otherwise
X***************
X*** 201,217 ****
X  	    /* If the swallowing monster changes into a monster
X  	     * that is not capable of swallowing you, you get
X  	     * regurgitated - dgk
X  	     */
X- 	    for(i = 0; i < NATTK; i++)
X- 		if(mdat->mattk[i].aatyp == AT_ENGL) goto doattack;
X- 
X- 	    You("get regurgitated!");
X- 	    regurgitates(mtmp);
X- 	    return(0);
X  	}
X! doattack:
X  #ifdef POLYSELF
X! 	if (u.uundetected && !range2 && foundyou) {
X  		u.uundetected = 0;
X  		if (u.usym == S_PIERCER) {
X  		    coord cc; /* maybe we need a unexto() function? */
X--- 248,268 ----
X  	    /* If the swallowing monster changes into a monster
X  	     * that is not capable of swallowing you, you get
X  	     * regurgitated - dgk
X+ 	     *
X+ 	     * This code is obsolete: newcham() will handle this contingency 
X+ 	     * as soon as it occurs in the course of a round. - kcd
X+ 	     *
X+ 	     * for(i = 0; i < NATTK; i++)
X+ 	     *     if(mdat->mattk[i].aatyp == AT_ENGL) goto doattack;
X+ 	     *
X+ 	     * You("get regurgitated!");
X+ 	     * regurgitates(mtmp);
X+              * return(0);
X  	     */
X  	}
X! /* doattack:		use commented out above */
X  #ifdef POLYSELF
X! 	if (u.uundetected && !range2 && foundyou && !u.uswallow) {
X  		u.uundetected = 0;
X  		if (u.usym == S_PIERCER) {
X  		    coord cc; /* maybe we need a unexto() function? */
X***************
X*** 249,255 ****
X  		}
X  		return(0);
X  	}
X! 	if (u.usym == S_MIMIC_DEF && !range2 && foundyou) {
X  		if (Blind) pline("It gets stuck on you.");
X  		    else pline("Wait, %s!  That's a %s named %s!",
X  			mtmp->mnamelth ? NAME(mtmp) : mtmp->data->mname,
X--- 300,306 ----
X  		}
X  		return(0);
X  	}
X! 	if (u.usym == S_MIMIC_DEF && !range2 && foundyou && !u.uswallow) {
X  		if (Blind) pline("It gets stuck on you.");
X  		    else pline("Wait, %s!  That's a %s named %s!",
X  			mtmp->mnamelth ? NAME(mtmp) : mtmp->data->mname,
X***************
X*** 313,318 ****
X--- 364,371 ----
X  
X  	    sum[i] = 0;
X  	    mattk = &(mdat->mattk[i]);
X+ 	    if (u.uswallow && (mattk->aatyp != AT_ENGL))
X+ 		continue;
X  	    switch(mattk->aatyp) {
X  		case AT_CLAW:	/* "hand to hand" attacks */
X  		case AT_KICK:
X***************
X*** 337,343 ****
X  
X  		case AT_HUGS:	/* automatic if prev two attacks succeed */
X  			/* Note: if displaced, prev attacks never succeeded */
X! 			if(!range2 && sum[i-1] && sum[i-2])
X  				sum[i]= hitmu(mtmp, mattk);
X  			break;
X  
X--- 390,397 ----
X  
X  		case AT_HUGS:	/* automatic if prev two attacks succeed */
X  			/* Note: if displaced, prev attacks never succeeded */
X! 			if((!range2 && i>=2 && sum[i-1] && sum[i-2])
X! 							|| mtmp == u.ustuck)
X  				sum[i]= hitmu(mtmp, mattk);
X  			break;
X  
X***************
X*** 374,381 ****
X  				} else {
X  				    missmu(mtmp, (tmp == j), mattk);
X  				}
X! 			    } else pline("%s gulps some air!", youseeit ?
X! 				Monnam(mtmp) : "It");
X  			}
X  			break;
X  		case AT_BREA:
X--- 428,445 ----
X  				} else {
X  				    missmu(mtmp, (tmp == j), mattk);
X  				}
X!                            } else if (is_animal(mtmp->data))
X! 					pline("%s gulps some air!", youseeit ?
X! 					      Monnam(mtmp) : "It");
X! 				  else
X! 					if (youseeit)
X! 					 pline("%s lunges forward and recoils!",
X! 					       Monnam(mtmp));
X! 					else
X! 						You("hear a %s nearby.", 
X! 						    is_whirly(mtmp->data)? 
X! 						    "rushing noise" : 
X! 						    "\"splat!\"");
X  			}
X  			break;
X  		case AT_BREA:
X***************
X*** 383,389 ****
X  			/* Note: breamu takes care of displacement */
X  			break;
X  		case AT_SPIT:
X! 			if(range2) sum[i] = spitmu(mtmp);
X  			/* Note: spitmu takes care of displacement */
X  			break;
X  		case AT_WEAP:
X--- 447,453 ----
X  			/* Note: breamu takes care of displacement */
X  			break;
X  		case AT_SPIT:
X! 			if(range2) sum[i] = spitmu(mtmp, mattk);
X  			/* Note: spitmu takes care of displacement */
X  			break;
X  		case AT_WEAP:
X***************
X*** 436,455 ****
X  	return(0);
X  }
X  
X  /*
X   * helper function for some compilers that have trouble with hitmu
X   */
X  
X! static
X  void
X! hurtarmor(mdat, attack)
X  struct permonst *mdat;
X! int attack;
X  {
X  	boolean getbronze, rusting;
X  	int	hurt;
X  
X! 	rusting = (attack == AD_RUST);
X  	if (rusting) {
X  		hurt = 1;
X  		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X--- 500,522 ----
X  	return(0);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  /*
X   * helper function for some compilers that have trouble with hitmu
X   */
X  
X! XSTATIC
X  void
X! hurtarmor(mdat, attk)
X  struct permonst *mdat;
X! int attk;
X  {
X  	boolean getbronze, rusting;
X  	int	hurt;
X  
X! 	rusting = (attk == AD_RUST);
X  	if (rusting) {
X  		hurt = 1;
X  		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X***************
X*** 504,515 ****
X  	}
X  }
X  
X  /*
X   * hitmu: monster hits you
X   *	  returns 2 if monster dies (e.g. "yellow light"), 1 otherwise
X!  *	  3 if the monster lives but teleported, so it can't keep attacking you
X   */
X! static
X  int
X  hitmu(mtmp, mattk)
X  	register struct monst *mtmp;
X--- 571,586 ----
X  	}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  /*
X   * hitmu: monster hits you
X   *	  returns 2 if monster dies (e.g. "yellow light"), 1 otherwise
X!  *	  3 if the monster lives but teleported/paralyzed, so it can't keep
X!  *	       attacking you
X   */
X! XSTATIC
X  int
X  hitmu(mtmp, mattk)
X  	register struct monst *mtmp;
X***************
X*** 614,626 ****
X  		break;
X  	    case AD_DISE:
X  		hitmsg(mtmp, mattk);
X! 		You("feel very sick.");
X  		make_sick((long)rn1(25-ACURR(A_CON),15),FALSE);
X  		u.usick_cause = mdat->mname;
X  		break;
X  	    case AD_FIRE:
X  		hitmsg(mtmp, mattk);
X! 		if(ctmp && rn2(2)) {
X  		    pline("You're on fire!");
X  		    if (Fire_resistance) {
X  			pline("The fire doesn't feel hot!");
X--- 685,702 ----
X  		break;
X  	    case AD_DISE:
X  		hitmsg(mtmp, mattk);
X! #ifdef POLYSELF
X! 		if (u.usym == S_FUNGUS)
X! 		    You("feel a slight illness.");
X! 		else
X! #endif
X! 		    You("feel very sick.");
X  		make_sick((long)rn1(25-ACURR(A_CON),15),FALSE);
X  		u.usick_cause = mdat->mname;
X  		break;
X  	    case AD_FIRE:
X  		hitmsg(mtmp, mattk);
X! 		if(ctmp) {
X  		    pline("You're on fire!");
X  		    if (Fire_resistance) {
X  			pline("The fire doesn't feel hot!");
X***************
X*** 638,644 ****
X  		break;
X  	    case AD_COLD:
X  		hitmsg(mtmp, mattk);
X! 		if(ctmp && rn2(2)) {
X  		    pline("You're covered in frost!");
X  		    if (Cold_resistance) {
X  			pline("The frost doesn't seem cold!");
X--- 714,720 ----
X  		break;
X  	    case AD_COLD:
X  		hitmsg(mtmp, mattk);
X! 		if(ctmp) {
X  		    pline("You're covered in frost!");
X  		    if (Cold_resistance) {
X  			pline("The frost doesn't seem cold!");
X***************
X*** 650,656 ****
X  		break;
X  	    case AD_ELEC:
X  		hitmsg(mtmp, mattk);
X! 		if(ctmp && rn2(2)) {
X  		    You("get zapped!");
X  		    if (Shock_resistance) {
X  			pline("The zap doesn't shock you!");
X--- 726,732 ----
X  		break;
X  	    case AD_ELEC:
X  		hitmsg(mtmp, mattk);
X! 		if(ctmp) {
X  		    You("get zapped!");
X  		    if (Shock_resistance) {
X  			pline("The zap doesn't shock you!");
X***************
X*** 685,691 ****
X  			Sprintf(buf, "%s's %s",
X  				Hallucination ? rndmonnam() : mdat->mname,
X  				(mattk->aatyp == AT_BITE) ? "bite" : "sting");
X! 			poisoned(buf, ptmp, mdat->mname);
X  		}
X  		break;
X  	    case AD_PLYS:
X--- 761,767 ----
X  			Sprintf(buf, "%s's %s",
X  				Hallucination ? rndmonnam() : mdat->mname,
X  				(mattk->aatyp == AT_BITE) ? "bite" : "sting");
X! 			poisoned(buf, ptmp, mdat->mname, 30);
X  		}
X  		break;
X  	    case AD_PLYS:
X***************
X*** 871,884 ****
X  	    case AD_RUST:
X  		hitmsg(mtmp, mattk);
X  		if (mtmp->mcan) break;
X! #ifdef POLYSELF
X! #ifdef GOLEMS
X  		if (u.umonnum == PM_IRON_GOLEM) {
X  			You("rust!");
X  			rehumanize();
X  			break;
X  		}
X- #endif /* GOLEMS */
X  #endif
X  		hurtarmor(mdat, AD_RUST);
X  		break;
X--- 947,958 ----
X  	    case AD_RUST:
X  		hitmsg(mtmp, mattk);
X  		if (mtmp->mcan) break;
X! #if defined(POLYSELF) && defined(GOLEMS)
X  		if (u.umonnum == PM_IRON_GOLEM) {
X  			You("rust!");
X  			rehumanize();
X  			break;
X  		}
X  #endif
X  		hurtarmor(mdat, AD_RUST);
X  		break;
X***************
X*** 885,892 ****
X  	    case AD_DCAY:
X  		hitmsg(mtmp, mattk);
X  		if (mtmp->mcan) break;
X! #ifdef POLYSELF
X! #ifdef GOLEMS
X  		if (u.umonnum == PM_WOOD_GOLEM ||
X  		    u.umonnum == PM_LEATHER_GOLEM) {
X  			You("rot!");
X--- 959,965 ----
X  	    case AD_DCAY:
X  		hitmsg(mtmp, mattk);
X  		if (mtmp->mcan) break;
X! #if defined(POLYSELF) && defined(GOLEMS)
X  		if (u.umonnum == PM_WOOD_GOLEM ||
X  		    u.umonnum == PM_LEATHER_GOLEM) {
X  			You("rot!");
X***************
X*** 893,899 ****
X  			rehumanize();
X  			break;
X  		}
X- #endif /* GOLEMS */
X  #endif
X  		hurtarmor(mdat, AD_DCAY);
X  		break;
X--- 966,971 ----
X***************
X*** 981,990 ****
X  #endif
X  		dmg = 0;
X  		break;
X- 	    case AD_CUSS:
X- 		if(flags.soundok && !rn2(3)) cuss(mtmp);
X- 		dmg = 0;
X- 		break;
X  #ifdef INFERNO /* a non-gaze AD_CONF exists only for one of the demons */
X  	    case AD_CONF:
X  		hitmsg(mtmp, mattk);
X--- 1053,1058 ----
X***************
X*** 1013,1019 ****
X  	if(dmg) mdamageu(mtmp, dmg);
X  
X  #ifdef POLYSELF
X! 	res = passiveum(olduasmon, mtmp);
X  	stop_occupation();
X  	return res;
X  #else
X--- 1081,1087 ----
X  	if(dmg) mdamageu(mtmp, dmg);
X  
X  #ifdef POLYSELF
X! 	res = passiveum(olduasmon, mtmp, mattk);
X  	stop_occupation();
X  	return res;
X  #else
X***************
X*** 1022,1028 ****
X  #endif
X  }
X  
X! static
X  int
X  gulpmu(mtmp, mattk)	/* monster swallows you, or damage if u.uswallow */
X  	register struct monst *mtmp;
X--- 1090,1099 ----
X  #endif
X  }
X  
X! #endif /* OVL1 */
X! #ifdef OVLB
X! 
X! XSTATIC
X  int
X  gulpmu(mtmp, mattk)	/* monster swallows you, or damage if u.uswallow */
X  	register struct monst *mtmp;
X***************
X*** 1034,1045 ****
X  	int	i;
X  #endif
X  
X! 	if(!u.uswallow) {	/* swallow him */
X  		remove_monster(mtmp->mx, mtmp->my);
X  		place_monster(mtmp, u.ux, u.uy);
X  		u.ustuck = mtmp;
X  		pmon(mtmp);
X  		kludge("%s engulfs you!", Monnam(mtmp));
X  		if (u.utrap) {
X  			You("are released from the trap!");
X  			u.utrap = 0;
X--- 1105,1120 ----
X  	int	i;
X  #endif
X  
X! 	if(!u.uswallow) {	/* swallows you */
X! #ifdef POLYSELF
X! 		if (uasmon->msize >= MZ_HUGE) return(0);
X! #endif
X  		remove_monster(mtmp->mx, mtmp->my);
X  		place_monster(mtmp, u.ux, u.uy);
X  		u.ustuck = mtmp;
X  		pmon(mtmp);
X  		kludge("%s engulfs you!", Monnam(mtmp));
X+ 		stop_occupation();
X  		if (u.utrap) {
X  			You("are released from the trap!");
X  			u.utrap = 0;
X***************
X*** 1053,1059 ****
X  		}
X  #endif
X  #ifdef POLYSELF
X! 		if (u.umonnum==PM_COCKATRICE) {
X  			kludge("%s turns to stone!", Monnam(mtmp));
X  			stoned = 1;
X  			xkilled(mtmp, 0);
X--- 1128,1134 ----
X  		}
X  #endif
X  #ifdef POLYSELF
X! 		if (u.umonnum==PM_COCKATRICE && !resists_ston(mtmp->data)) {
X  			kludge("%s turns to stone!", Monnam(mtmp));
X  			stoned = 1;
X  			xkilled(mtmp, 0);
X***************
X*** 1151,1182 ****
X  	}
X  
X  	mdamageu(mtmp, tmp);
X  	if(u.uswldtim) --u.uswldtim;
X  	if(!u.uswldtim
X  #ifdef POLYSELF
X  	    || u.umonnum==PM_COCKATRICE
X  #endif
X  	    ) {
X  #ifdef POLYSELF
X  	    if (u.umonnum == PM_COCKATRICE) {
X! 		kludge("%s very hurriedly regurgitates you!",
X! 		       Monnam(mtmp));
X  		u.uswldtim = 0;
X  	    } else {
X  #endif
X! 		You("get regurgitated!");
X! 		if(flags.verbose)
X! 		    kludge("Obviously %s doesn't like your taste.",
X! 							mon_nam(mtmp));
X  #ifdef POLYSELF
X  	    }
X  #endif
X! 	    regurgitates(mtmp);
X  	}
X  	return(1);
X  }
X  
X! static
X  int
X  explmu(mtmp, mattk)	/* monster explodes in your face */
X  	register struct monst *mtmp;
X--- 1226,1260 ----
X  	}
X  
X  	mdamageu(mtmp, tmp);
X+ 	if(tmp) stop_occupation();
X  	if(u.uswldtim) --u.uswldtim;
X  	if(!u.uswldtim
X  #ifdef POLYSELF
X  	    || u.umonnum==PM_COCKATRICE
X+ 	    || uasmon->msize >= MZ_HUGE
X  #endif
X  	    ) {
X  #ifdef POLYSELF
X  	    if (u.umonnum == PM_COCKATRICE) {
X! 		kludge("%s very hurriedly %s you!", Monnam(mtmp), 
X! 		       is_animal(mtmp->data)? "regurgitates" : "expels");
X  		u.uswldtim = 0;
X  	    } else {
X  #endif
X! 		You("get %s!", 
X! 		    is_animal(mtmp->data)? "regurgitated" : "expelled");
X! 		if(flags.verbose && is_animal(mtmp->data))
X! 			kludge("Obviously %s doesn't like your taste.",
X! 			       mon_nam(mtmp));
X  #ifdef POLYSELF
X  	    }
X  #endif
X! 	    expels(mtmp, mtmp->data, FALSE);
X  	}
X  	return(1);
X  }
X  
X! XSTATIC
X  int
X  explmu(mtmp, mattk)	/* monster explodes in your face */
X  	register struct monst *mtmp;
X***************
X*** 1198,1205 ****
X  			tmp = 0;
X  		} else {
X  			if(ACURR(A_DEX) > rnd(20)) {
X! 				if (!flags.verbose)
X! 				    You("are caught in the blast!");
X  			} else {
X  				You("duck the blast...");
X  				tmp /= 2;
X--- 1276,1283 ----
X  			tmp = 0;
X  		} else {
X  			if(ACURR(A_DEX) > rnd(20)) {
X! 				if (flags.verbose)
X! 				    You("get blasted!");
X  			} else {
X  				You("duck the blast...");
X  				tmp /= 2;
X***************
X*** 1224,1230 ****
X  	return(2);	/* it dies */
X  }
X  
X! static
X  int
X  gazemu(mtmp, mattk)	/* monster gazes at you */
X  	register struct monst *mtmp;
X--- 1302,1308 ----
X  	return(2);	/* it dies */
X  }
X  
X! XSTATIC
X  int
X  gazemu(mtmp, mattk)	/* monster gazes at you */
X  	register struct monst *mtmp;
X***************
X*** 1239,1251 ****
X  		}
X  		if (canseemon(mtmp)) {
X  			You("look upon %s.", mon_nam(mtmp));
X! #ifdef POLYSELF
X  			if (resists_ston(uasmon)) {
X  				pline("So what?");
X  				break;
X  			}
X! #endif
X  			You("turn to stone...");
X  			killer = mons[PM_MEDUSA].mname;
X  			done(STONING);
X  	    	}
X--- 1317,1330 ----
X  		}
X  		if (canseemon(mtmp)) {
X  			You("look upon %s.", mon_nam(mtmp));
X! # ifdef POLYSELF
X  			if (resists_ston(uasmon)) {
X  				pline("So what?");
X  				break;
X  			}
X! # endif
X  			You("turn to stone...");
X+ 			killer_format = KILLED_BY_AN;
X  			killer = mons[PM_MEDUSA].mname;
X  			done(STONING);
X  	    	}
X***************
X*** 1282,1287 ****
X--- 1361,1369 ----
X  	return(1);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  void
X  mdamageu(mtmp, n)	/* mtmp hits you for n points damage */
X  	register struct monst *mtmp;
X***************
X*** 1301,1308 ****
X  		done_in_by(mtmp);
X  }
X  
X  #ifdef POLYSELF
X! static void
X  urustm(mon, obj)
X  register struct monst *mon;
X  register struct obj *obj;
X--- 1383,1393 ----
X  		done_in_by(mtmp);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifdef POLYSELF
X! XSTATIC void
X  urustm(mon, obj)
X  register struct monst *mon;
X  register struct obj *obj;
X***************
X*** 1330,1335 ****
X--- 1415,1423 ----
X  }
X  #endif
X  
X+ #endif /* OVLB */
X+ #ifdef OVL1
X+ 
X  int
X  could_seduce(magr,mdef,mattk)
X  struct monst *magr, *mdef;
X***************
X*** 1385,1390 ****
X--- 1473,1481 ----
X  		return (pagr->mlet == S_NYMPH) ? 2 : 0;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #ifdef SEDUCE
X  /* Returns 1 if monster teleported */
X  int
X***************
X*** 1527,1532 ****
X--- 1618,1624 ----
X  				    You("feel out of shape.");
X  				    losexp();
X  				    if(u.uhp <= 0) {
X+ 					killer_format = KILLED_BY;
X  					killer = "overexertion";
X  					done(DIED);
X  				    }
X***************
X*** 1535,1541 ****
X  #endif
X  				break;
X  			case 4: You("feel exhausted.");
X! 				losehp(5+rnd(10), "exhaustion");
X  				break;
X  		}
X  	} else {
X--- 1627,1633 ----
X  #endif
X  				break;
X  			case 4: You("feel exhausted.");
X! 				losehp(5+rnd(10), "exhaustion", KILLED_BY);
X  				break;
X  		}
X  	} else {
X***************
X*** 1606,1612 ****
X  static void
X  mayberem(obj, str)
X  register struct obj *obj;
X! char *str;
X  {
X  	if (!obj || !obj->owornmask) return;
X  
X--- 1698,1704 ----
X  static void
X  mayberem(obj, str)
X  register struct obj *obj;
X! const char *str;
X  {
X  	if (!obj || !obj->owornmask) return;
X  
X***************
X*** 1626,1631 ****
X--- 1718,1724 ----
X  			/* obj == uarmh */
X  			"let me run my fingers through your hair");
X  
X+ 	if (donning(obj)) cancel_don();
X  	if (obj == uarm)  (void) Armor_off();
X  	else if (obj == uarmc) (void) Cloak_off();
X  	else if (obj == uarmf) (void) Boots_off();
X***************
X*** 1635,1662 ****
X  }
X  #endif  /* SEDUCE */
X  
X  #ifdef POLYSELF
X  static int
X! passiveum(olduasmon,mtmp)
X  struct permonst *olduasmon;
X  register struct monst *mtmp;
X  {
X  	register struct permonst *mdat = mtmp->data;
X  	int dam = 0;
X  
X! 	if (olduasmon->mattk[0].aatyp != AT_NONE) return 1;
X  
X  	/* These affect the enemy even if you were "killed" (rehumanized) */
X! 	switch(olduasmon->mattk[0].adtyp) {
X  	    case AD_ACID:
X  		if (!rn2(2)) {
X  		    kludge("%s is splashed by your acid!", Monnam(mtmp));
X  		    if(!resists_acid(mdat))
X  			dam = d((int)olduasmon->mlevel+1,
X! 					(int)olduasmon->mattk[0].damd);
X  		    else pline("%s is not affected.", Monnam(mtmp));
X  		}
X  		break;
X  	    default:
X  		break;
X  	}
X--- 1728,1777 ----
X  }
X  #endif  /* SEDUCE */
X  
X+ #endif /* OVLB */
X+ 
X  #ifdef POLYSELF
X+ 
X+ #ifdef OVL1
X+ 
X  static int
X! passiveum(olduasmon,mtmp,mattk)
X  struct permonst *olduasmon;
X  register struct monst *mtmp;
X+ register struct attack *mattk;
X  {
X  	register struct permonst *mdat = mtmp->data;
X+ 	int i;
X  	int dam = 0;
X  
X! 	for(i = 0; ; i++) {
X! 	    if(i >= NATTK) return 1;
X! 	    if(olduasmon->mattk[i].aatyp == AT_NONE) break;
X! 	}
X  
X  	/* These affect the enemy even if you were "killed" (rehumanized) */
X! 	switch(olduasmon->mattk[i].adtyp) {
X  	    case AD_ACID:
X  		if (!rn2(2)) {
X  		    kludge("%s is splashed by your acid!", Monnam(mtmp));
X  		    if(!resists_acid(mdat))
X  			dam = d((int)olduasmon->mlevel+1,
X! 					(int)olduasmon->mattk[i].damd);
X  		    else pline("%s is not affected.", Monnam(mtmp));
X  		}
X  		break;
X+ 	    case AD_STON: /* cockatrice */
X+ 		if (!resists_ston(mdat) &&
X+ 		    (mattk->aatyp != AT_WEAP || !select_hwep(mtmp)) &&
X+ 		    mattk->aatyp != AT_GAZE && mattk->aatyp != AT_EXPL &&
X+ 		    mattk->aatyp != AT_MAGC &&
X+ 		    (!is_mercenary(mdat) ||
X+ 				      !m_carrying(mtmp, LEATHER_GLOVES))) {
X+ 		    kludge("%s turns to stone!", Monnam(mtmp));
X+ 		    stoned = 1;
X+ 		    xkilled(mtmp, 0);
X+ 		    return 2;
X+ 		}
X  	    default:
X  		break;
X  	}
X***************
X*** 1663,1682 ****
X  	if (!u.mtimedone) return 1;
X  
X  	/* These affect the enemy only if you are still a monster */
X! 	if (rn2(3)) switch(uasmon->mattk[0].adtyp) {
X  	    case AD_PLYS: /* Floating eye */
X! 		if (!mtmp->mblinded && rn2(3)) {
X! 		    if (Blind)
X! 			pline("As a blind %s, you cannot defend yourself.",
X  							uasmon->mname);
X! 		    else {
X! 			pline("%s is frozen by your gaze!", Monnam(mtmp));
X! 			mtmp->mfroz = 1;
X! 		    }
X  		}
X  		break;
X  	    case AD_COLD: /* Brown mold or blue jelly */
X! 		dam = d((int)uasmon->mlevel+1, (int)uasmon->mattk[0].damd);
X  		if(resists_cold(mdat)) {
X    		    shieldeff(mtmp->mx, mtmp->my);
X  		    kludge("%s is mildly chilly.", Monnam(mtmp));
X--- 1778,1810 ----
X  	if (!u.mtimedone) return 1;
X  
X  	/* These affect the enemy only if you are still a monster */
X! 	if (rn2(3)) switch(uasmon->mattk[i].adtyp) {
X  	    case AD_PLYS: /* Floating eye */
X! 		{int tmp = d((int)uasmon->mlevel+1, (int)uasmon->mattk[i].damd);
X! 		if (u.umonnum == PM_FLOATING_EYE) {
X! 		    if (!rn2(4)) tmp = 120;
X! 		    if (mtmp->mcansee && rn2(3) &&
X! 				(perceives(mdat) || !Invis)) {
X! 			if (Blind)
X! 			    pline("As a blind %s, you cannot defend yourself.",
X  							uasmon->mname);
X! 		        else {
X! 			    pline("%s is frozen by your gaze!", Monnam(mtmp));
X! 			    mtmp->mcanmove = 0;
X! 			    mtmp->mfrozen = tmp;
X! 			    return 3;
X! 			}
X! 		    }
X! 		} else { /* gelatinous cube */
X! 		    kludge("%s is frozen by you.", Monnam(mtmp));
X! 		    mtmp->mcanmove = 0;
X! 		    mtmp->mfrozen = tmp;
X! 		    return 3;
X  		}
X  		break;
X+ 		}
X  	    case AD_COLD: /* Brown mold or blue jelly */
X! 		dam = d((int)uasmon->mlevel+1, (int)uasmon->mattk[i].damd);
X  		if(resists_cold(mdat)) {
X    		    shieldeff(mtmp->mx, mtmp->my);
X  		    kludge("%s is mildly chilly.", Monnam(mtmp));
X***************
X*** 1704,1714 ****
X  	    case AD_STUN: /* Yellow mold */
X  		if (!mtmp->mstun) {
X  		    mtmp->mstun = 1;
X! 		    kludge("%s staggers...", Monnam(mtmp));
X  		}
X  		break;
X  	    case AD_FIRE: /* Red mold */
X! 		dam = d((int)uasmon->mlevel+1, (int)uasmon->mattk[0].damd);
X  		if(resists_fire(mdat)) {
X    		    shieldeff(mtmp->mx, mtmp->my);
X  		    kludge("%s is mildly warm.", Monnam(mtmp));
X--- 1832,1842 ----
X  	    case AD_STUN: /* Yellow mold */
X  		if (!mtmp->mstun) {
X  		    mtmp->mstun = 1;
X! 		    kludge("%s staggers.", Monnam(mtmp));
X  		}
X  		break;
X  	    case AD_FIRE: /* Red mold */
X! 		dam = d((int)uasmon->mlevel+1, (int)uasmon->mattk[i].damd);
X  		if(resists_fire(mdat)) {
X    		    shieldeff(mtmp->mx, mtmp->my);
X  		    kludge("%s is mildly warm.", Monnam(mtmp));
X***************
X*** 1719,1748 ****
X  		    break;
X  		}
X  		kludge("%s is suddenly very hot!", Monnam(mtmp));
X  	}
X  
X  	if((mtmp->mhp -= dam) <= 0) {
X  		kludge("%s dies!", Monnam(mtmp));
X  		xkilled(mtmp,0);
X! 		return(2);
X  	}
X  	return 1;
X  }
X  
X  #include "edog.h"
X  struct monst *
X  cloneu()
X  {
X  	register struct monst *mon;
X- 	register int nmlth = strlen(plname) + 1;
X  
X  	if (u.mh <= 1) return(struct monst *)0;
X! 	uasmon->pxlth += sizeof(struct edog) + nmlth;
X  	mon = makemon(uasmon, u.ux, u.uy);
X! 	uasmon->pxlth -= sizeof(struct edog) + nmlth;
X! 	mon->mxlth = sizeof(struct edog);
X! 	Strcpy(NAME(mon), plname);
X! 	mon->mnamelth = nmlth;
X  	initedog(mon);
X  	mon->m_lev = uasmon->mlevel;
X  	mon->mhp = u.mh /= 2;
X--- 1847,1877 ----
X  		    break;
X  		}
X  		kludge("%s is suddenly very hot!", Monnam(mtmp));
X+ 	    default: break;
X  	}
X  
X  	if((mtmp->mhp -= dam) <= 0) {
X  		kludge("%s dies!", Monnam(mtmp));
X  		xkilled(mtmp,0);
X! 		return 2;
X  	}
X  	return 1;
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  #include "edog.h"
X  struct monst *
X  cloneu()
X  {
X  	register struct monst *mon;
X  
X  	if (u.mh <= 1) return(struct monst *)0;
X! 	uasmon->pxlth += sizeof(struct edog);
X  	mon = makemon(uasmon, u.ux, u.uy);
X! 	uasmon->pxlth -= sizeof(struct edog);
X! 	mon = christen_monst(mon, plname);
X  	initedog(mon);
X  	mon->m_lev = uasmon->mlevel;
X  	mon->mhp = u.mh /= 2;
X***************
X*** 1749,1752 ****
X--- 1878,1885 ----
X  	mon->mhpmax = u.mhmax;
X  	return(mon);
X  }
X+ 
X+ #endif /* OVLB */
X+ 
X  #endif /* POLYSELF */
X+ 
X*** src/Old/mklev.c	Mon Feb 19 20:30:16 1990
X--- src/mklev.c	Fri Feb  2 18:21:28 1990
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mklev.c	3.0	88/11/24
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mklev.c	3.0	89/12/06
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 9,20 ****
X  /* conversion of result to int is reasonable */
X  
X  #ifdef SINKS
X! static void mksink();
X  #endif
X  #ifdef ALTARS
X! static void mkaltar();
X  #endif
X! static boolean occupied();
X  
X  int
X  somex(croom)
X--- 9,37 ----
X  /* conversion of result to int is reasonable */
X  
X  #ifdef SINKS
X! static void FDECL(mksink,(struct mkroom *));
X  #endif
X  #ifdef ALTARS
X! static void FDECL(mkaltar,(struct mkroom *));
X  #endif
X! static boolean FDECL(occupied,(XCHAR_P,XCHAR_P));
X! static void NDECL(makevtele);
X! static void NDECL(init_levels);
X! static void NDECL(makelevel);
X! static boolean FDECL(bydoor,(XCHAR_P,XCHAR_P));
X! static boolean FDECL(place_niche,(struct mkroom *,int*,int*,int*));
X! static void FDECL(makeniche,(int));
X! static void NDECL(make_niches);
X! static void NDECL(makebigroom);
X! static void FDECL(addrsx,(int,int,int,int,BOOLEAN_P));
X! static void FDECL(addrs,(int,int,int,int));
X! static int FDECL(comp,(genericptr_t,genericptr_t));
X! static void FDECL(dosdoor,(int,int,struct mkroom *,int));
X! static void NDECL(makecorridors);
X! static void FDECL(join,(int,int));
X! static int NDECL(makerooms);
X! static int FDECL(maker,(SCHAR_P,SCHAR_P,SCHAR_P,SCHAR_P,BOOLEAN_P));
X! static void FDECL(finddpos,(coord *,XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
X  
X  int
X  somex(croom)
X***************
X*** 115,126 ****
X  	}
X  }
X  
X  static int
X! comp(x,y)
X! register struct mkroom *x,*y;
X  {
X  	if(x->lx < y->lx) return(-1);
X  	return(x->lx > y->lx);
X  }
X  
X  static void
X--- 132,157 ----
X  	}
X  }
X  
X+ /* Args must be genericptr_t so that qsort will always be happy. */
X+ 
X  static int
X! comp(vx,vy)
X! genericptr_t vx, vy;
X  {
X+ #ifdef LINT
X+ /* lint complains about possible pointer alignment problems, but we know
X+    that vx and vy are always properly aligned. Hence, the following
X+    bogus definition:
X+ */
X+ 	return (vx == vy) ? 0 : -1;
X+ #else
X+ 	register struct mkroom *x, *y;
X+ 
X+ 	x = (struct mkroom *)vx;
X+ 	y = (struct mkroom *)vy;
X  	if(x->lx < y->lx) return(-1);
X  	return(x->lx > y->lx);
X+ #endif /* LINT */
X  }
X  
X  static void
X***************
X*** 793,799 ****
X  			x = somex(croom); y = somey(croom);
X  			if (goodpos(x,y,(struct permonst *)0)) {
X  				otmp = mk_tt_object(STATUE, x, y);
X! 				while(resists_ston(&mons[otmp->corpsenm])) {
X  					otmp->corpsenm = rndmonnum();
X  					otmp->owt = weight(otmp);
X  				}
X--- 824,831 ----
X  			x = somex(croom); y = somey(croom);
X  			if (goodpos(x,y,(struct permonst *)0)) {
X  				otmp = mk_tt_object(STATUE, x, y);
X! 				while(otmp &&
X! 				      resists_ston(&mons[otmp->corpsenm])) {
X  					otmp->corpsenm = rndmonnum();
X  					otmp->owt = weight(otmp);
X  				}
X***************
X*** 817,823 ****
X  #endif
X  	is_maze_lev = FALSE;
X  
X! #ifdef SYSV
X  	qsort((genericptr_t) rooms, (unsigned)nroom, sizeof(struct mkroom), comp);
X  #else
X  	qsort((genericptr_t) rooms, nroom, sizeof(struct mkroom), comp);
X--- 849,855 ----
X  #endif
X  	is_maze_lev = FALSE;
X  
X! #if defined(SYSV) || defined(DGUX)
X  	qsort((genericptr_t) rooms, (unsigned)nroom, sizeof(struct mkroom), comp);
X  #else
X  	qsort((genericptr_t) rooms, nroom, sizeof(struct mkroom), comp);
X***************
X*** 892,908 ****
X  
X  		/* put a sleeping monster inside */
X  		/* Note: monster may be on the stairs. This cannot be
X! 		   avoided: maybe the player fell through a trapdoor
X  		   while a monster was on the stairs. Conclusion:
X  		   we have to check for monsters on the stairs anyway. */
X  
X  		if(u.uhave_amulet || !rn2(3)) {
X  		    x = somex(croom); y = somey(croom);
X- #ifdef REINCARNATION
X- 		    if (dlevel == rogue_level)
X- 			tmonst = makemon(roguemon(), x, y);
X- 		    else
X- #endif
X  		    tmonst = makemon((struct permonst *) 0, x,y);
X  		    if (tmonst && tmonst->data == &mons[PM_GIANT_SPIDER])
X  			(void) maketrap (x,y,WEB);
X--- 924,935 ----
X  
X  		/* put a sleeping monster inside */
X  		/* Note: monster may be on the stairs. This cannot be
X! 		   avoided: maybe the player fell through a trap door
X  		   while a monster was on the stairs. Conclusion:
X  		   we have to check for monsters on the stairs anyway. */
X  
X  		if(u.uhave_amulet || !rn2(3)) {
X  		    x = somex(croom); y = somey(croom);
X  		    tmonst = makemon((struct permonst *) 0, x,y);
X  		    if (tmonst && tmonst->data == &mons[PM_GIANT_SPIDER])
X  			(void) maketrap (x,y,WEB);
X***************
X*** 1063,1068 ****
X--- 1090,1098 ----
X  
X  	xchar mx,my;
X  
X+ #ifdef __GNULINT__
X+ 	kind = nomimic = 0;
X+ #endif
X  	if(!num || num >= TRAPNUM) {
X  		nomonst = (dlevel < 4) ? 1 : 0;
X  		nolevltp = (dlevel < 5) ? 1 : 0;
X***************
X*** 1127,1133 ****
X  
X  		if((mtmp = makemon(mkclass(S_MIMIC), mx, my))) {
X  		    mtmp->mimic = 1;
X! 		    mtmp->mappearance = CLOSED_DOOR_SYM;
X  		}
X  		return;
X  	}
X--- 1157,1164 ----
X  
X  		if((mtmp = makemon(mkclass(S_MIMIC), mx, my))) {
X  		    mtmp->mimic = 1;
X! 		    mtmp->m_ap_type = M_AP_FURNITURE;
X! 		    mtmp->mappearance = S_cdoor;
X  		}
X  		return;
X  	}
X*** src/Old/mkmaze.c	Mon Feb 19 20:30:58 1990
X--- src/mkmaze.c	Wed Jan  3 22:06:51 1990
X***************
X*** 7,12 ****
X--- 7,16 ----
X  extern int x_maze_max, y_maze_max;
X  
X  #if defined(WALLIFIED_MAZE) || defined(STRONGHOLD)
X+ static int FDECL(iswall,(int,int));
X+ static boolean FDECL(okay,(int,int,int));
X+ static void FDECL(maze0xy,(coord *));
X+ 
X  static int
X  iswall(x,y)
X  int x,y;
X*** src/Old/mkobj.c	Mon Feb 19 20:31:18 1990
X--- src/mkobj.c	Thu Feb  8 17:18:40 1990
X***************
X*** 4,14 ****
X--- 4,18 ----
X  
X  #include "hack.h"
X  
X+ static void FDECL(mkbox_cnts,(struct obj *));
X+ 
X  struct icp {
X      int  iprob; /* probability of an item type */
X      char ilet;	/* item class */
X  };
X  
X+ #ifdef OVLB
X+ 
X  const struct icp mkobjprobs[] = {
X  {10, WEAPON_SYM},
X  {10, ARMOR_SYM},
X***************
X*** 110,121 ****
X  	register int tprob, i, prob = rnd(1000);
X  
X  	if(let == RANDOM_SYM) {
X! 		struct icp *iprobs =
X  #ifdef REINCARNATION
X! 				    (dlevel == rogue_level) ? rogueprobs :
X  #endif
X! 				    Inhell ? hellprobs :
X! 				    mkobjprobs;
X  
X  		for(tprob = rnd(100);
X  		    (tprob -= iprobs->iprob) > 0;
X--- 114,126 ----
X  	register int tprob, i, prob = rnd(1000);
X  
X  	if(let == RANDOM_SYM) {
X! 		const struct icp *iprobs =
X  #ifdef REINCARNATION
X! 				    (dlevel == rogue_level) ?
X! 				    (const struct icp *)rogueprobs :
X  #endif
X! 				    Inhell ? (const struct icp *)hellprobs :
X! 				    (const struct icp *)mkobjprobs;
X  
X  		for(tprob = rnd(100);
X  		    (tprob -= iprobs->iprob) > 0;
X***************
X*** 162,168 ****
X  		otmp->age = 0;
X  	    } else {
X  		register int tprob;
X! 		struct icp *iprobs = boxiprobs;
X  
X  		for(tprob = rnd(100);
X  		    (tprob -= iprobs->iprob) > 0;
X--- 167,173 ----
X  		otmp->age = 0;
X  	    } else {
X  		register int tprob;
X! 		const struct icp *iprobs = boxiprobs;
X  
X  		for(tprob = rnd(100);
X  		    (tprob -= iprobs->iprob) > 0;
X***************
X*** 239,245 ****
X  #endif
X  		break;
X  	case FOOD_SYM:
X! 		otmp->oeaten = FALSE;
X  		if(otmp->otyp == CORPSE) {
X  		    /* overridden by mkcorpstat() */
X  		    do otmp->corpsenm = rndmonnum();
X--- 244,250 ----
X  #endif
X  		break;
X  	case FOOD_SYM:
X! 		otmp->oeaten = 0;
X  		if(otmp->otyp == CORPSE) {
X  		    /* overridden by mkcorpstat() */
X  		    do otmp->corpsenm = rndmonnum();
X***************
X*** 412,417 ****
X--- 417,426 ----
X  {
X  	otmp->cursed = 0;
X  	otmp->blessed = 1;
X+ 	if (otmp->otyp == LUCKSTONE) {
X+ 		if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X+ 		else u.moreluck = -LUCKADD;
X+ 	}
X  	return;
X  }
X  
X***************
X*** 421,426 ****
X--- 430,439 ----
X  {
X  	otmp->blessed = 0;
X  	otmp->cursed = 1;
X+ 	if (otmp->otyp == LUCKSTONE) {
X+ 		if (stone_luck(TRUE) >= 0) u.moreluck = LUCKADD;
X+ 		else u.moreluck = -LUCKADD;
X+ 	}
X  	return;
X  }
X  
X***************
X*** 454,459 ****
X--- 467,475 ----
X  	return(('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z'));
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  weight(obj)
X  register struct obj *obj;
X***************
X*** 476,481 ****
X--- 492,500 ----
X  	return(wt ? wt*obj->quan : (obj->quan + 1)>>1);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  void
X  mkgold(num,x,y)
X  long num;
X***************
X*** 554,569 ****
X  	return(otmp);
X  }
X  
X- #ifdef STUPID_CPP
X  boolean
X  is_flammable(otmp)
X  register struct obj *otmp;
X  {
X! 	return((objects[otmp->otyp].oc_material == WOOD ||
X! 			objects[otmp->otyp].oc_material == 0));
X  
X  }
X  
X  boolean
X  is_rustprone(otmp)
X  register struct obj *otmp;
X--- 573,592 ----
X  	return(otmp);
X  }
X  
X  boolean
X  is_flammable(otmp)
X  register struct obj *otmp;
X  {
X! 	int otyp = otmp->otyp;
X! 
X! 	if (otyp == DRAGON_SCALE_MAIL && otmp->corpsenm == PM_RED_DRAGON)
X! 		return FALSE;
X! 	return((objects[otyp].oc_material == WOOD ||
X! 			objects[otyp].oc_material == 0));
X  
X  }
X  
X+ #ifdef STUPID_CPP
X  boolean
X  is_rustprone(otmp)
X  register struct obj *otmp;
X***************
X*** 629,632 ****
X      place_object(otmp, x, y);
X  }
X  
X! 
X--- 652,655 ----
X      place_object(otmp, x, y);
X  }
X  
X! #endif /* OVLB */
X*** src/Old/mkroom.c	Mon Feb 19 20:31:44 1990
X--- src/mkroom.c	Sun Feb  4 09:46:57 1990
X***************
X*** 11,33 ****
X   *	dist2() -- Euclidean square-of-distance function
X   *	courtmon() -- generate a court monster
X   */
X  #include "hack.h"
X  
X! static void mkshop(), mkzoo(), mkswamp();
X  #ifdef ORACLE
X! static void mkdelphi();
X  #endif
X  #if defined(ALTARS) && defined(THEOLOGY)
X! static void mktemple();
X  #endif
X  
X! static struct permonst *morguemon();
X  #ifdef ARMY
X! static struct permonst *squadmon();
X  #endif
X  
X  #define sq(x) ((x)*(x))
X  
X  static boolean
X  isbig(sroom)
X  register struct mkroom *sroom;
X--- 11,38 ----
X   *	dist2() -- Euclidean square-of-distance function
X   *	courtmon() -- generate a court monster
X   */
X+ 
X+ #define MONATTK_H	/* comment line for pre-compiled headers */
X+ /* block some unused #defines to avoid overloading some cpp's */
X  #include "hack.h"
X  
X! static void NDECL(mkshop), FDECL(mkzoo,(int)), NDECL(mkswamp);
X  #ifdef ORACLE
X! static void NDECL(mkdelphi);
X  #endif
X  #if defined(ALTARS) && defined(THEOLOGY)
X! static void NDECL(mktemple);
X  #endif
X  
X! static struct permonst * NDECL(morguemon);
X  #ifdef ARMY
X! static struct permonst * NDECL(squadmon);
X  #endif
X  
X  #define sq(x) ((x)*(x))
X  
X+ #ifdef OVLB
X+ 
X  static boolean
X  isbig(sroom)
X  register struct mkroom *sroom;
X***************
X*** 69,75 ****
X--- 74,84 ----
X  	register struct mkroom *sroom;
X  	int i = -1;
X  #ifdef WIZARD
X+ # ifdef __GNULINT__
X+ 	register char *ep = (char *)0;
X+ # else
X  	register char *ep;
X+ # endif
X  
X  	/* first determine shoptype */
X  	if(wizard){
X***************
X*** 192,197 ****
X--- 201,210 ----
X  	sroom->rtype = type;
X  	sh = sroom->fdoor;
X  	switch(type) {
X+ #ifdef __GNULINT__
X+ 	    default:
X+ 		/* make sure tx and ty are initialized */
X+ #endif
X  	    case COURT:
X  		tx = somex(sroom); ty = somey(sroom); break;
X  		/* TODO: try to ensure the enthroned monster is an M2_PRINCE */
X***************
X*** 332,343 ****
X  	oracl->mpeaceful = 1;
X  
X  	yy -= dy;
X! 	if(ACCESSIBLE(levl[xx-1][yy].typ))
X! 		(void) mkcorpstat(STATUE, &mons[PM_FOREST_CENTAUR], xx-1, yy);
X! 	if(ACCESSIBLE(levl[xx][yy].typ))
X! 		(void) mkcorpstat(STATUE, &mons[PM_MOUNTAIN_CENTAUR], xx, yy);
X! 	if(ACCESSIBLE(levl[xx+1][yy].typ))
X! 		(void) mkcorpstat(STATUE, &mons[PM_PLAINS_CENTAUR], xx+1, yy);
X  # ifdef FOUNTAINS
X  	mkfount(0,sroom);
X  # endif
X--- 345,356 ----
X  	oracl->mpeaceful = 1;
X  
X  	yy -= dy;
X! 	if(accessible(xx-1, yy))
X! 	    (void) mkcorpstat(STATUE, &mons[PM_FOREST_CENTAUR], xx-1, yy);
X! 	if(accessible(xx, yy))
X! 	    (void) mkcorpstat(STATUE, &mons[PM_MOUNTAIN_CENTAUR], xx, yy);
X! 	if(accessible(xx+1,yy))
X! 	    (void) mkcorpstat(STATUE, &mons[PM_PLAINS_CENTAUR], xx+1, yy);
X  # ifdef FOUNTAINS
X  	mkfount(0,sroom);
X  # endif
X***************
X*** 371,378 ****
X  	 */
X  	levl[sx][sy].typ = ALTAR;
X  	levl[sx][sy].scrsym = ALTAR_SYM;
X! 	levl[sx][sy].altarmask = rn2((int)A_LAW+1) | A_SHRINE;
X  	priestini(dlevel, sx, sy, (int) levl[sx][sy].altarmask);
X  }
X  #endif
X  
X--- 384,392 ----
X  	 */
X  	levl[sx][sy].typ = ALTAR;
X  	levl[sx][sy].scrsym = ALTAR_SYM;
X! 	levl[sx][sy].altarmask = rn2((int)A_LAW+1);
X  	priestini(dlevel, sx, sy, (int) levl[sx][sy].altarmask);
X+  	levl[sx][sy].altarmask |= A_SHRINE;
X  }
X  #endif
X  
X***************
X*** 405,410 ****
X--- 419,427 ----
X  		   sroom->ly <= yupstair && yupstair <= sroom->hy);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  dist2(x0,y0,x1,y1)
X  int x0, y0, x1, y1;
X***************
X*** 413,418 ****
X--- 430,438 ----
X  	return sq(dx) + sq(dy);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVLB
X+ 
X  #ifdef THRONES
X  struct permonst *
X  courtmon()
X***************
X*** 458,460 ****
X--- 478,482 ----
X  	else			    return((struct permonst *) 0);
X  }
X  #endif /* ARMY /* */
X+ 
X+ #endif /* OVLB */
X*** src/Old/mon.c	Mon Feb 19 20:32:07 1990
X--- src/mon.c	Fri Feb 16 22:07:48 1990
X***************
X*** 1,9 ****
X! /*	SCCS Id: @(#)mon.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #if (defined(MICROPORT_BUG) || !defined(LINT)) && !defined(__STDC__)
X  #define MKROOM_H
X  #endif
X  
X  #include "hack.h"
X--- 1,12 ----
X! /*	SCCS Id: @(#)mon.c	3.0	89/11/22
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! /* Aztec C on amiga doesn't recognize defined() at this point! */
X! #ifndef AZTEC_C
X! #if defined(MICROPORT_BUG) || (!defined(LINT) && !defined(__STDC__))
X  #define MKROOM_H
X+ #endif /* Avoid the microport bug */
X  #endif
X  
X  #include "hack.h"
X***************
X*** 14,29 ****
X  #endif
X  
X  #ifdef HARD
X! static boolean restrap();
X  #  include <ctype.h>
X  #endif
X  
X  long lastwarntime;
X  int lastwarnlev;
X! static const char *warnings[] = {
X  	"white", "pink", "red", "ruby", "purple", "black" };
X! struct monst *fdmon;	/* chain of dead monsters, need not be saved */
X  
X  /* Creates a monster corpse, a "special" corpse, or nothing if it doesn't
X   * leave corpses.  Monsters which leave "special" corpses should have
X   * G_NOCORPSE set in order to prevent wishing for one, finding tins of one,
X--- 17,45 ----
X  #endif
X  
X  #ifdef HARD
X! OSTATIC boolean FDECL(restrap,(struct monst *));
X! #endif
X! #ifdef INFERNO
X  #  include <ctype.h>
X  #endif
X  
X+ static struct obj *FDECL(make_corpse,(struct monst *));
X+ OSTATIC void NDECL(dmonsfree);
X+ static void FDECL(m_detach,(struct monst *));
X+ 
X+ #ifdef OVL1
X+ 
X  long lastwarntime;
X  int lastwarnlev;
X! const char *warnings[] = {
X  	"white", "pink", "red", "ruby", "purple", "black" };
X! 
X! #endif /* OVL1 */
X! #ifdef OVLB
X  
X+ struct monst *fdmon;  /* chain of dead monsters, need not be saved */
X+ 		      /* otherwise used only in priest.c */
X+ 
X  /* Creates a monster corpse, a "special" corpse, or nothing if it doesn't
X   * leave corpses.  Monsters which leave "special" corpses should have
X   * G_NOCORPSE set in order to prevent wishing for one, finding tins of one,
X***************
X*** 41,46 ****
X--- 57,72 ----
X  	int x = mtmp->mx, y = mtmp->my;
X  
X  	switch(monsndx(mdat)) {
X+ 	    case PM_WHITE_UNICORN:
X+ 	    case PM_GRAY_UNICORN:
X+ 	    case PM_BLACK_UNICORN:
X+ 		(void) mksobj_at(UNICORN_HORN, x, y);
X+ 		goto default_1;
X+ #ifdef WORM
X+ 	    case PM_LONG_WORM:
X+ 		(void) mksobj_at(WORM_TOOTH, x, y);
X+ 		goto default_1;
X+ #endif
X  	    case PM_KOBOLD_MUMMY:
X  		obj = mksobj_at(MUMMY_WRAPPING, x, y); /* and fall through */
X  	    case PM_KOBOLD_ZOMBIE:
X***************
X*** 115,120 ****
X--- 141,147 ----
X  			obj = mksobj_at(LEATHER_ARMOR, x, y);
X  		break;
X  #endif
X+ 	    default_1:
X  	    default:
X  		if (mdat->geno & G_NOCORPSE)
X  			return (struct obj *)0;
X***************
X*** 137,144 ****
X  	return obj;
X  }
X  
X  
X! static void
X  dmonsfree(){
X  register struct monst *mtmp;
X  	while(mtmp = fdmon){
X--- 164,173 ----
X  	return obj;
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X  
X! XSTATIC void
X  dmonsfree(){
X  register struct monst *mtmp;
X  	while(mtmp = fdmon){
X***************
X*** 147,157 ****
X  	}
X  }
X  
X  void
X  movemon()
X  {
X  	register struct monst *mtmp;
X- 	register int fr;
X  
X  	warnlevel = 0;
X  
X--- 176,188 ----
X  	}
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL1
X+ 
X  void
X  movemon()
X  {
X  	register struct monst *mtmp;
X  
X  	warnlevel = 0;
X  
X***************
X*** 223,228 ****
X--- 254,261 ----
X  		}
X  		if(mtmp->mblinded && !--mtmp->mblinded)
X  			mtmp->mcansee = 1;
X+ 		if(mtmp->mfrozen && !--mtmp->mfrozen)
X+ 			mtmp->mcanmove = 1;
X  		if(mtmp->mfleetim && !--mtmp->mfleetim)
X  			mtmp->mflee = 0;
X  #ifdef HARD
X***************
X*** 231,251 ****
X  #endif
X  		if(mtmp->mimic) continue;
X  		if(mtmp->mspeed != MSLOW || !(moves%2)){
X! 			/* continue if the monster died fighting */
X! 			fr = -1;
X! /* TODO:	Handle the case of the aggressor dying? */
X! 			if(Conflict && !mtmp->iswiz &&
X! 			   /* area you can see if you're not blind */
X! 			   (dist(mtmp->mx,mtmp->my) < 3 ||
X! 			    (levl[mtmp->mx][mtmp->my].lit &&
X! 			     ((seelx <= mtmp->mx && mtmp->mx <= seehx &&
X! 			       seely <= mtmp->my && mtmp->my <= seehy) ||
X! 			      (seelx2 <= mtmp->mx && mtmp->mx <= seehx2 &&
X! 			       seely2 <= mtmp->my && mtmp->my <= seehy2)))) &&
X! 			   (fr = fightm(mtmp)) == 2)
X! 				continue;
X!   			if(fr<0 && dochugw(mtmp))
X! 				continue;
X  		}
X  		if(mtmp->mspeed == MFAST && dochugw(mtmp))
X  			continue;
X--- 264,302 ----
X  #endif
X  		if(mtmp->mimic) continue;
X  		if(mtmp->mspeed != MSLOW || !(moves%2)){
X! 		/* continue if the monster died fighting */
X! 		  if (Conflict && !mtmp->iswiz && mtmp->mcansee) {
X! /* Note: A couple of notes on conflict here.
X! 	 1. Conflict does not take effect in the first round.  Therefore, 
X! 	    A monster in a stepping into the area will get to swing at you.
X! 	 2. Conflict still works when you are invisible.  (?)
X! 	 3. Certain areas (namely castle) you can be in 3 "rooms" at once!
X! 	    Polyself into Xorn wearing ring of conflict and it can be done.
X! 	    This code only allows for two.  This needs to be changed if more
X! 	    areas (with diggable walls and > 2 rooms) are put into the game.
X! */
X! 		    xchar clx = 0, chx = 0, cly = 0, chy = 0,
X! 			  clx2 = 0, chx2 = 0, cly2 = 0, chy2 = 0;
X! 		    /* seelx etc. are not set if blind or blindfolded! */
X! 		    getcorners(&clx, &chx, &cly, &chy,
X! 			       &clx2, &chx2, &cly2, &chy2);
X! 		    if ((dist(mtmp->mx,mtmp->my) < 3) || 
X! 		    /* if the monster is next to you OR */
X! 		 	(levl[u.ux][u.uy].lit &&
X! 			 levl[mtmp->mx][mtmp->my].lit &&
X! 		    /* both you and it are lit AND */
X! 			 ((clx <= mtmp->mx && mtmp->mx <= chx &&
X! 			   cly <= mtmp->my && mtmp->my <= chy) ||
X! 			  (clx2 <= mtmp->mx && mtmp->mx <= chx2 &&
X! 			   cly2 <= mtmp->my && mtmp->my <= chy2))))
X! 		    /* you *could* see it (ie it can see you) */
X! 		      if (fightm(mtmp) != 3)
X! 		      /* have it fight if it choses to */
X! 			continue;
X! 		  }
X! 		  if(dochugw(mtmp))
X! 		  /* otherwise just move the monster */
X! 		    continue;
X  		}
X  		if(mtmp->mspeed == MFAST && dochugw(mtmp))
X  			continue;
X***************
X*** 262,268 ****
X  		warnlevel = SIZE(warnings)-1;
X  	if(!Blind && warnlevel >= 0)
X  	if(warnlevel > lastwarnlev || moves > lastwarntime + 5){
X! 	    register char *rr;
X  	
X  	    switch((int) (Warning & (LEFT_RING | RIGHT_RING))){
X  	    case LEFT_RING:
X--- 313,319 ----
X  		warnlevel = SIZE(warnings)-1;
X  	if(!Blind && warnlevel >= 0)
X  	if(warnlevel > lastwarnlev || moves > lastwarntime + 5){
X! 	    register const char *rr;
X  	
X  	    switch((int) (Warning & (LEFT_RING | RIGHT_RING))){
X  	    case LEFT_RING:
X***************
X*** 289,294 ****
X--- 340,348 ----
X  	dmonsfree();	/* remove all dead monsters */
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  void
X  meatgold(mtmp)
X  	register struct monst *mtmp;
X***************
X*** 409,414 ****
X--- 463,471 ----
X  		}
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL0
X+ 
X  int
X  curr_mon_load(mtmp)
X  register struct monst *mtmp;
X***************
X*** 475,484 ****
X  	return(TRUE);
X  }
X  
X  void
X  mpickstuff(mtmp, str)
X  	register struct monst *mtmp;
X! 	register char *str;
X  {
X  	register struct obj *otmp;
X  
X--- 532,544 ----
X  	return(TRUE);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL2
X+ 
X  void
X  mpickstuff(mtmp, str)
X  	register struct monst *mtmp;
X! 	register const char *str;
X  {
X  	register struct obj *otmp;
X  
X***************
X*** 498,503 ****
X--- 558,566 ----
X  	    }
X  }
X  
X+ #endif /* OVL2 */
X+ #ifdef OVL0
X+ 
X  /* return number of acceptable neighbour positions */
X  int
X  mfndpos(mon, poss, info, flag)
X***************
X*** 532,553 ****
X  	    if(IS_ROCK(ntyp = levl[nx][ny].typ) && !(flag & ALLOW_WALL) &&
X  		!((flag & ALLOW_DIG) && may_dig(nx,ny))) continue;
X  	    if(IS_DOOR(ntyp) && !amorphous(mon->data) &&
X! 	       ((levl[nx][ny].doormask & D_LOCKED &&
X! 		   !is_giant(mon->data) && !mon->isshk) ||
X! 		(levl[nx][ny].doormask & D_CLOSED &&
X! 		   (verysmall(mon->data) ||
X! 		    (!is_giant(mon->data) && nohands(mon->data))))
X! 	       ) && !(flag & (ALLOW_WALL|ALLOW_DIG))) continue;
X  	    if(nx != x && ny != y &&
X  #ifdef REINCARNATION
X! 	       ((IS_DOOR(nowtyp) && ((levl[x][y].doormask & ~D_BROKEN)
X! 			|| dlevel == rogue_level)) ||
X! 		(IS_DOOR(ntyp) && ((levl[nx][ny].doormask & ~D_BROKEN)
X! 			|| dlevel == rogue_level))))
X  #else
X  	       ((IS_DOOR(nowtyp) && (levl[x][y].doormask & ~D_BROKEN)) ||
X! 		(IS_DOOR(ntyp) && (levl[nx][ny].doormask & ~D_BROKEN))))
X  #endif
X  		continue;
X  	    if(is_pool(nx,ny) == wantpool || poolok) {
X  		/* Displacement also displaces the Elbereth/scare monster,
X--- 595,614 ----
X  	    if(IS_ROCK(ntyp = levl[nx][ny].typ) && !(flag & ALLOW_WALL) &&
X  		!((flag & ALLOW_DIG) && may_dig(nx,ny))) continue;
X  	    if(IS_DOOR(ntyp) && !amorphous(mon->data) &&
X! 	       ((levl[nx][ny].doormask & D_CLOSED && !(flag & OPENDOOR)) ||
X! 		(levl[nx][ny].doormask & D_LOCKED && !(flag & UNLOCKDOOR))
X! 	       ) && !(flag & (ALLOW_WALL|ALLOW_DIG|BUSTDOOR))) continue;
X  	    if(nx != x && ny != y &&
X  #ifdef REINCARNATION
X! 	       ((IS_DOOR(nowtyp) &&
X! 	         ((levl[x][y].doormask & ~D_BROKEN) || dlevel == rogue_level)) ||
X! 		(IS_DOOR(ntyp) &&
X! 		 ((levl[nx][ny].doormask & ~D_BROKEN) || dlevel == rogue_level))
X  #else
X  	       ((IS_DOOR(nowtyp) && (levl[x][y].doormask & ~D_BROKEN)) ||
X! 		(IS_DOOR(ntyp) && (levl[nx][ny].doormask & ~D_BROKEN))
X  #endif
X+ 	       ))
X  		continue;
X  	    if(is_pool(nx,ny) == wantpool || poolok) {
X  		/* Displacement also displaces the Elbereth/scare monster,
X***************
X*** 636,641 ****
X--- 697,705 ----
X  	return(cnt);
X  }
X  
X+ #endif /* OVL0 */
X+ #ifdef OVL1
X+ 
X  int
X  dist(x, y)
X  register int x,y;
X***************
X*** 655,660 ****
X--- 719,727 ----
X  	return (distance < 3);
X  }
X  
X+ #endif /* OVL1 */
X+ #ifdef OVLB
X+ 
X  static const char *poiseff[] = {
X  
X  	" feel very weak", "r brain is on fire",
X***************
X*** 671,679 ****
X  }
X  
X  void
X! poisoned(string, typ, pname)
X! register char *string, *pname;
X! register int  typ;
X  {
X  	register int i, plural;
X  	boolean thrown_weapon = !strncmp(string, "poison", 6);
X--- 738,746 ----
X  }
X  
X  void
X! poisoned(string, typ, pname, fatal)
X! register const char *string, *pname;
X! register int  typ, fatal;
X  {
X  	register int i, plural;
X  	boolean thrown_weapon = !strncmp(string, "poison", 6);
X***************
X*** 699,715 ****
X  		pline("The poison doesn't seem to affect you.");
X  		return;
X  	}
X! 	i = rn2(10 + 20*thrown_weapon);
X  	if(i == 0 && typ != A_CHA) {
X  		u.uhp = -1;
X  		pline("The poison was deadly...");
X  	} else if(i <= 5) {
X! 		pline("You%s!", poiseff[typ]);
X  		adjattrib(typ, thrown_weapon ? -1 : -rn1(3,3), TRUE);
X  	} else {
X! 		losehp(thrown_weapon ? rnd(6) : rn1(10,6), pname);
X  	}
X  	if(u.uhp < 1) {
X  		killer = pname;
X  		done(POISONING);
X  	}
X--- 766,783 ----
X  		pline("The poison doesn't seem to affect you.");
X  		return;
X  	}
X! 	i = rn2(fatal + 20*thrown_weapon);
X  	if(i == 0 && typ != A_CHA) {
X  		u.uhp = -1;
X  		pline("The poison was deadly...");
X  	} else if(i <= 5) {
X! 		You("%s!", poiseff[typ]);
X  		adjattrib(typ, thrown_weapon ? -1 : -rn1(3,3), TRUE);
X  	} else {
X! 		losehp(thrown_weapon ? rnd(6) : rn1(10,6), pname, KILLED_BY_AN);
X  	}
X  	if(u.uhp < 1) {
X+ 		killer_format = KILLED_BY_AN;
X  		killer = pname;
X  		done(POISONING);
X  	}
X***************
X*** 749,755 ****
X  	}
X  #endif
X  	if(mtmp->isshk) shkdead(mtmp);
X- 	if(mtmp->isgd) gddead();
X  #ifdef WORM
X  	if(mtmp->wormno) wormdead(mtmp);
X  #endif
X--- 817,822 ----
X***************
X*** 774,780 ****
X  	fmon = mtmp2;
X  	if(u.ustuck == mtmp) u.ustuck = mtmp2;
X  	if(mtmp2->isshk) replshk(mtmp,mtmp2);
X- 	if(mtmp2->isgd) replgd(mtmp,mtmp2);
X  #ifdef WORM
X  	if(mtmp2->wormno) {
X  		/* Each square the worm is on has a pointer; fix them all */
X--- 841,846 ----
X***************
X*** 871,885 ****
X  	if(mdat == &mons[PM_RATWERE])
X  		mtmp->data = mdat = &mons[PM_WERERAT];
X  
X- 	if(u.umconf) {
X- 	    if(!Blind) {
X- 		Your("%s stop glowing %s.",
X- 		makeplural(body_part(HAND)),
X- 		Hallucination ? hcolor() : red);
X- 	    }
X- 	    u.umconf = 0;
X- 	}
X- 
X  	/* if we have killed MAXMONNO monsters of a given type, and it
X  	 * can be done, genocide that monster.
X  	 */
X--- 937,942 ----
X***************
X*** 949,966 ****
X  #endif
X  					) return;
X  
X- #ifdef WORM
X- 	if(mdat == &mons[PM_LONG_WORM]) {
X- 		(void) mksobj_at(WORM_TOOTH, x, y);
X- 		stackobj(fobj);
X- 		newsym(x,y);
X- 	}
X- #endif
X- 	if(mdat->mlet == S_UNICORN) {
X- 		(void) mksobj_at(UNICORN_HORN, x, y);
X- 		stackobj(fobj);
X- 		newsym(x,y);
X- 	}
X  #ifdef MAIL
X  	if(mdat == &mons[PM_MAIL_DAEMON]) {
X  		(void) mksobj_at(SCR_MAIL, x, y);
X--- 1006,1011 ----
X***************
X*** 968,976 ****
X  		newsym(x,y);
X  	}
X  #endif
X! 	if(!ACCESSIBLE(levl[x][y].typ) ||
X! 	   (IS_DOOR(levl[x][y].typ) &&
X! 	    levl[x][y].doormask & (D_CLOSED | D_LOCKED))) {
X  	    /* might be mimic in wall or dead eel*/
X   	    newsym(x,y);
X  	} else if(x != u.ux || y != u.uy) {
X--- 1013,1019 ----
X  		newsym(x,y);
X  	}
X  #endif
X! 	if(!accessible(x, y)) {
X  	    /* might be mimic in wall or dead eel*/
X   	    newsym(x,y);
X  	} else if(x != u.ux || y != u.uy) {
X***************
X*** 1050,1055 ****
X--- 1093,1099 ----
X  {
X  	register int mhp, hpn, hpd;
X  	int tryct;
X+        struct permonst *olddata = mtmp->data;
X  
X  	/* mdat = 0 -> caller wants a random monster shape */
X  	tryct = 0;
X***************
X*** 1109,1119 ****
X  	if (u.ustuck == mtmp) {
X  		if(u.uswallow) {
X  			if(!attacktype(mdat,AT_ENGL)) {
X! 				/* cf. digging out of monster with wand */
X! 				You("break out of %s's stomach!",
X! 					mon_nam(mtmp));
X! 				mtmp->mhp = 1;	/* almost dead */
X! 				regurgitates(mtmp);
X  			}
X  		} else {
X  			if(!sticks(mdat)
X--- 1153,1168 ----
X  	if (u.ustuck == mtmp) {
X  		if(u.uswallow) {
X  			if(!attacktype(mdat,AT_ENGL)) {
X! 				/* Does mdat care? */
X! 				if (!noncorporeal(mdat) && !amorphous(mdat) && 
X! 				    !is_whirly(mdat) && 
X! 				    (mdat != &mons[PM_YELLOW_LIGHT])) {
X! 					You("break out of %s%s!", mon_nam(mtmp),
X! 					    (is_animal(mdat)? 
X! 					    "'s stomach" : ""));
X! 					mtmp->mhp = 1;  /* almost dead */
X! 				}
X! 				expels(mtmp, olddata, FALSE);
X  			}
X  		} else {
X  			if(!sticks(mdat)
X***************
X*** 1164,1169 ****
X--- 1213,1221 ----
X  	set_apparxy(mtmp);
X  }
X  
X+ #endif /* OVLB */
X+ #ifdef OVL2
X+ 
X  void
X  setmangry(mtmp)
X  	register struct monst *mtmp;
X***************
X*** 1210,1216 ****
X  }
X  
X  #ifdef HARD
X! static boolean
X  restrap(mtmp)
X  /* unwatched hiders may hide again,
X   * if so, a 1 is returned.
X--- 1262,1268 ----
X  }
X  
X  #ifdef HARD
X! XSTATIC boolean
X  restrap(mtmp)
X  /* unwatched hiders may hide again,
X   * if so, a 1 is returned.
X***************
X*** 1237,1242 ****
X--- 1289,1297 ----
X  }
X  #endif
X  
X+ #endif /* OVL2 */
X+ #ifdef OVLB
X+ 
X  /* drop (perhaps) a cadaver and remove monster */
X  void
X  mondied(mdef)
X***************
X*** 1276,1282 ****
X  {
X  	struct obj *otmp;
X  
X! 	if(mdef->data->msize > MZ_TINY ||
X  	   !rn2(2 + ((mdef->data->geno & G_FREQ) > 2))) {
X  		otmp = mk_named_object(STATUE, mdef->data, mdef->mx, mdef->my,
X  			NAME(mdef), (int)mdef->mnamelth);
X--- 1331,1337 ----
X  {
X  	struct obj *otmp;
X  
X! 	if((int)mdef->data->msize > MZ_TINY ||
X  	   !rn2(2 + ((mdef->data->geno & G_FREQ) > 2))) {
X  		otmp = mk_named_object(STATUE, mdef->data, mdef->mx, mdef->my,
X  			NAME(mdef), (int)mdef->mnamelth);
X***************
X*** 1331,1333 ****
X--- 1386,1390 ----
X  	}
X  }
X  #endif /* GOLEMS */
X+ 
X+ #endif /* OVLB */
X
END_OF_FILE
if test 55515 -ne `wc -c <'patch7.11'`; then
    echo shar: \"'patch7.11'\" unpacked with wrong size!
fi
# end of 'patch7.11'
echo shar: End of archive 10 \(of 30\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
