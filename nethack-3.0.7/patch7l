Path: utzoo!utgpu!jarvis.csri.toronto.edu!cs.utexas.edu!usc!zaphod.mps.ohio-state.edu!uakari!caesar.cs.montana.edu!milton!uw-beaver!zephyr.ens.tek.com!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v09i012:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch7l
Message-ID: <5226@tekred.CNA.TEK.COM>
Date: 24 Feb 90 00:37:17 GMT
Sender: news@tekred.CNA.TEK.COM
Lines: 1921
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 9, Issue 12
Archive-name: NetHack3/Patch7l
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 30)."
# Contents:  patch7.20
# Wrapped by billr@saab on Wed Feb 21 10:04:33 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch7.20' -a "${1}" != "-c" ; then 
  echo shar: Renaming existing file \"'patch7.20'\" to \"'patch7.20.orig'\"
  mv -f 'patch7.20' 'patch7.20.orig'
fi
echo shar: Extracting \"'patch7.20'\" \(55350 characters\)
sed "s/^X//" >'patch7.20' <<'END_OF_FILE'
X*** /dev/null	Mon Feb 19 23:26:54 1990
X--- others/Makefile.lib	Sat Feb 17 20:36:02 1990
X***************
X*** 0 ****
X--- 1,22 ----
X+ #	SCCS Id: @(#)Makefile.lib	3.0	90/02/17
X+ #	Nethack makefile for Fred fish termlib -- Norman Meluch
X+ #
X+ CC	= cl /c
X+ MODEL	= L
X+ CFLAGS	= /A$(MODEL) /Os /Oa /Gs /Zp1 /W0
X+ #
X+ # Termcap routines.
X+ TERMLIB = termlib.lib
X+ #
X+ TL_LOBJECTS =	tgetent.o	tgetflag.o 	tgetnum.o	\
X+ 		tgetstr.o	tgoto.o		tputs.o		\
X+ 		isdigit.o	fgetlr.o
X+ #
X+ .SUFFIXES: .exe .o .c .obj .asm
X+ #
X+ .c.o:
X+ 	$(CC) $(CFLAGS) /Fo$*.o $*.c
X+ #
X+ $(TERMLIB):	$(TL_LOBJECTS)
X+ 	lib $(TERMLIB) -+ $(TL_LOBJECTS);
X+ 
X*** others/Old/Makefile.msc	Mon Feb 19 23:27:09 1990
X--- others/Makefile.msc	Sun Feb  4 15:22:47 1990
X***************
X*** 308,314 ****
X  o\topl.o:  $(HACK_H)
X  o\topten.o:  $(HACK_H)
X  o\track.o:  $(HACK_H)
X! o\trap.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\trapname.h
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X--- 308,314 ----
X  o\topl.o:  $(HACK_H)
X  o\topten.o:  $(HACK_H)
X  o\track.o:  $(HACK_H)
X! o\trap.o:  $(HACK_H) $(INCL)\edog.h
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X*** others/Old/Makefile.pc	Mon Feb 19 23:28:26 1990
X--- others/Makefile.pc	Sun Feb  4 15:23:19 1990
X***************
X*** 267,273 ****
X  o\topl.o:  $(HACK_H)
X  o\topten.o:  $(HACK_H)
X  o\track.o:  $(HACK_H)
X! o\trap.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\trapname.h
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X--- 267,273 ----
X  o\topl.o:  $(HACK_H)
X  o\topten.o:  $(HACK_H)
X  o\track.o:  $(HACK_H)
X! o\trap.o:  $(HACK_H) $(INCL)\edog.h
X  o\u_init.o:  $(HACK_H)
X  o\uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  o\vault.o:  $(HACK_H) $(INCL)\vault.h
X*** others/Old/Makefile.st	Mon Feb 19 23:28:41 1990
X--- others/Makefile.st	Fri Feb  9 19:55:41 1990
X***************
X*** 1,7 ****
X! #	SCCS Id: @(#)Makefile.st	3.0	89/07/07
X  #	ST NetHack 3.0 Makefile for GCC 1.34 or higher
X  #
X! #    NOTE: There's one really awful kludge here: I had to break
X  #    monst.o up into two pieces to get it to compile on my machine
X  #    (a Mega 2). You'll need "sed" to get this to work.
X  #    If you have 2.5 megs or more, you can probably delete the
X--- 1,11 ----
X! #	SCCS Id: @(#)Makefile.st	3.0	90/01/14
X  #	ST NetHack 3.0 Makefile for GCC 1.34 or higher
X  #
X! #    NOTE: There's a bug in the GCC 1.35 (and maybe 1.34) that
X! #    requires the omission of the -O flag on a couple of files;
X! #    see the comments further down.
X! #
X! #    Also: There's one really awful kludge here: I had to break
X  #    monst.o up into two pieces to get it to compile on my machine
X  #    (a Mega 2). You'll need "sed" to get this to work.
X  #    If you have 2.5 megs or more, you can probably delete the
X***************
X*** 26,37 ****
X  AUX	= ..\auxil
X  SRC	= ..\src
X  
X! CFLAGS	= $(MODEL) -O -fomit-frame-pointer -I..\include
X  LFLAGS	= $(MODEL) -s
X  TARG	= tos
X  PC	= pc
X  
X! # Optional high-quality BSD random number generation routines (see pcconf.h).
X  # Set to nothing if not used.
X  RANDOM = random.o
X  
X--- 30,48 ----
X  AUX	= ..\auxil
X  SRC	= ..\src
X  
X! #
X! # Use the following line for maximum warnings
X! WARN=-D__GNULINT__ -W -Wimplicit -Wreturn-type -Wunused -Wpointer-arith \
X!  -Wcast-qual -Wwrite-strings
X! #
X! # WARN =
X! #
X! CFLAGS = $(MODEL) -O -fomit-frame-pointer $(WARN) -I..\include
X  LFLAGS	= $(MODEL) -s
X  TARG	= tos
X  PC	= pc
X  
X! # Optional high-quality BSD random number generation routines (see tosconf.h).
X  # Set to nothing if not used.
X  RANDOM = random.o
X  
X***************
X*** 90,99 ****
X  $(GAME).ttp: $(HOBJ)
X  	$(CC) -o $(GAME).ttp $(LFLAGS) $(HOBJ) $(TERMCAP)
X  
X! $(GAMEDIR)\$(GAME).ttp: $(GAME).ttp
X! 	cp $(GAME).ttp $(GAMEDIR)
X! 
X! $(GAME): $(GAMEDIR)\$(GAME).ttp
X  
X  all:	$(GAME) lev_comp.ttp auxil
X  	@echo Done.
X--- 101,107 ----
X  $(GAME).ttp: $(HOBJ)
X  	$(CC) -o $(GAME).ttp $(LFLAGS) $(HOBJ) $(TERMCAP)
X  
X! $(GAME): $(GAME).ttp
X  
X  all:	$(GAME) lev_comp.ttp auxil
X  	@echo Done.
X***************
X*** 117,123 ****
X  #
X  # Also: for some reason the supplied lev_lex.c causes the GCC to abort
X  # on my machine (maybe not enough memory?) when compiled with -mshort.
X! # With MODEL=-mshort, I had to delete lev_lex.c and use these rules.
X  #
X  lev_comp.c:  lev_comp.y
X  	$(YACC) -d lev_comp.y
X--- 125,131 ----
X  #
X  # Also: for some reason the supplied lev_lex.c causes the GCC to abort
X  # on my machine (maybe not enough memory?) when compiled with -mshort.
X! # With MODEL=-mshort, I had to use the lev_lex.c from others.
X  #
X  lev_comp.c:  lev_comp.y
X  	$(YACC) -d lev_comp.y
X***************
X*** 166,180 ****
X  	$(CC) -c $(CFLAGS) $(PC)unix.c -o unix.o
X  
X  #
X! # GNU C doesn't like the array in rip.c!!!
X! rip.o:   $(HACK_H) 
X! 	$(CC) -c $(CFLAGS) -fwritable-strings rip.c
X! #
X! # GCC 1.35 + bones.c + -mshort + -O == incorrect code. Don't ask me why.
X! # So we just omit the -O on bones.c
X  #
X! bones.o: $(HACK_H)
X! 	$(CC) -c $(MODEL) -I$(INCL) bones.c
X  #
X  # Secondary targets
X  #
X--- 174,188 ----
X  	$(CC) -c $(CFLAGS) $(PC)unix.c -o unix.o
X  
X  #
X! # GCC 1.35 has trouble with the construct
X! #	for (x = ...) for(y = ...) levl[x][y].foo = stuff;
X! # this happens in (at least) bones.c and shknam.c. So if you're using
X! # 1.35, uncomment the following lines. The problem is fixed in 1.36.
X  #
X! #bones.o: $(HACK_H)
X! #	$(CC) $(MODEL) $(WARN) -I$(INCL) -c bones.c
X! #shknam.o: $(HACK_H) $(INCL)\eshk.h
X! #	$(CC) $(MODEL) $(WARN) -I$(INCL) -c shknam.c
X  #
X  # Secondary targets
X  #
X***************
X*** 221,227 ****
X  apply.o:  $(HACK_H) $(INCL)\edog.h
X  artifact.o:  $(HACK_H) $(INCL)\artifact.h
X  attrib.o:  $(HACK_H)
X! #bones.o:  $(HACK_H)
X  cmd.o:  $(HACK_H) $(INCL)\func_tab.h
X  dbridge.o: $(HACK_H)
X  decl.o:  $(HACK_H)
X--- 229,235 ----
X  apply.o:  $(HACK_H) $(INCL)\edog.h
X  artifact.o:  $(HACK_H) $(INCL)\artifact.h
X  attrib.o:  $(HACK_H)
X! bones.o:  $(HACK_H)
X  cmd.o:  $(HACK_H) $(INCL)\func_tab.h
X  dbridge.o: $(HACK_H)
X  decl.o:  $(HACK_H)
X***************
X*** 261,267 ****
X  # kludge for "monst.c: Virtual memory exhausted" errors
X  # we build monst.s in two pieces, then glue them together with
X  # "sed". if you don't have memory problems, uncomment out
X! # all but the next line. if you don't have sed, get it from
X  # a comp.binaries.atari.st site, or get gnu sed (the port to
X  # the atari GCC is easy).
X  
X--- 269,275 ----
X  # kludge for "monst.c: Virtual memory exhausted" errors
X  # we build monst.s in two pieces, then glue them together with
X  # "sed". if you don't have memory problems, uncomment out
X! # all but the line starting "monst.o:". if you don't have sed, get it from
X  # a comp.binaries.atari.st site, or get gnu sed (the port to
X  # the atari GCC is easy).
X  
X***************
X*** 291,297 ****
X  random.o:
X  read.o:  $(HACK_H)
X  restore.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X! #rip.o:  $(HACK_H)
X  rnd.o:  $(HACK_H)
X  rumors.o:  $(HACK_H)
X  save.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X--- 299,305 ----
X  random.o:
X  read.o:  $(HACK_H)
X  restore.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X! rip.o:  $(HACK_H)
X  rnd.o:  $(HACK_H)
X  rumors.o:  $(HACK_H)
X  save.o:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X***************
X*** 308,314 ****
X  topl.o:  $(HACK_H)
X  topten.o:  $(HACK_H)
X  track.o:  $(HACK_H)
X! trap.o:  $(HACK_H) $(INCL)\edog.h $(INCL)\trapname.h
X  u_init.o:  $(HACK_H)
X  uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  vault.o:  $(HACK_H) $(INCL)\vault.h
X--- 316,322 ----
X  topl.o:  $(HACK_H)
X  topten.o:  $(HACK_H)
X  track.o:  $(HACK_H)
X! trap.o:  $(HACK_H) $(INCL)\edog.h
X  u_init.o:  $(HACK_H)
X  uhitm.o:  $(HACK_H) $(INCL)\artifact.h
X  vault.o:  $(HACK_H) $(INCL)\vault.h
X*** others/Old/Makefile.tcc	Mon Feb 19 23:29:10 1990
X--- others/Makefile.tcc	Sun Feb  4 15:23:42 1990
X***************
X*** 1,22 ****
X! #	SCCS Id: @(#)Makefile.tcc	3.0	89/11/18
X  #	PC NetHack 3.0 Makefile for Turbo C 2.0
X  #	Perpetrator: Mike Threepoint, 890707
X  
X  ###
X- ### Directories
X- ###
X- # makedefs.c hardcodes the include and auxil directories, don't change them.
X- OBJ	= o
X- INCL	= ..\include
X- AUX	= ..\auxil
X- SRC	= ..\src
X- OTHERS	= ..\others
X- 
X- 
X- ###
X  ### Locals
X  ###
X- 
X  # the name of the game
X  GAME	= nethack
X  
X--- 1,10 ----
X! #	SCCS Id: @(#)Makefile.tcc	3.0	89/11/20
X  #	PC NetHack 3.0 Makefile for Turbo C 2.0
X  #	Perpetrator: Mike Threepoint, 890707
X  
X  ###
X  ### Locals
X  ###
X  # the name of the game
X  GAME	= nethack
X  
X***************
X*** 28,39 ****
X  
X  
X  ###
X  ### Compiler
X  ###
X  CC	= tcc
X  
X  # must use Huge model; Large is limited to 64K total global data.
X! MODEL	= h
X  
X  # signed chars, jump optimize, strict ANSI, register optimize, no stack frame
X  CFLAGS	= -c -no -m$(MODEL) -I$(INCL) -K- -O -A -Z -k- -w-pia -w-pro $(WIZARD)
X--- 16,44 ----
X  
X  
X  ###
X+ ### Directories
X+ ###
X+ # makedefs.c hardcodes the include and auxil directories, don't change them.
X+ OBJ	= o
X+ INCL	= ..\include
X+ AUX	= ..\auxil
X+ SRC	= ..\src
X+ OTHERS	= ..\others
X+ 
X+ # where the Turbo C libraries are kept
X+ LIB     = \turbo\c\lib
X+ 
X+ # directory NDMAKE uses for temporary files
X+ MAKE_TMP = $(TMP)
X+ 
X+ 
X+ ###
X  ### Compiler
X  ###
X  CC	= tcc
X  
X  # must use Huge model; Large is limited to 64K total global data.
X! MODEL   = h
X  
X  # signed chars, jump optimize, strict ANSI, register optimize, no stack frame
X  CFLAGS	= -c -no -m$(MODEL) -I$(INCL) -K- -O -A -Z -k- -w-pia -w-pro $(WIZARD)
X***************
X*** 40,46 ****
X  ## Note: Turbo C 2.0's -Z is bugged.  If you have weird problems, try -Z-.
X  
X  # wizardly defines
X! WIZARD	= -DDEBUG
X  
X  # linkers
X  TLINK	= tlink
X--- 45,51 ----
X  ## Note: Turbo C 2.0's -Z is bugged.  If you have weird problems, try -Z-.
X  
X  # wizardly defines
X! WIZARD  =
X  
X  # linkers
X  TLINK	= tlink
X***************
X*** 70,98 ****
X  ASM	= tasm
X  AFLAGS	= /MX
X  
X  
X  ###
X  ### Rules
X  ###
X  # search order
X  .SUFFIXES: .exe .obj .c .asm .y .l
X  # .c -> .obj
X  .c.obj:
X  	$(CC) $(CFLAGS) -c $<
X  # .asm -> .obj
X  .asm.obj:
X! 	$(ASM) $< $(AFLAGS);
X  # .obj -> .exe (for tlink)
X  .obj.exe:
X  	$(TLINK) $(TLFLAGS) $(C0) $<, $@,, $(LIBS);
X! ## Note: .y -> .c or .l -> .c rules are missing, because none of the developers
X! ##	 had a yacc or lex for the PC to write rules for.
X  
X  
X  ###
X  ### Optional features (see pcconf.h)
X  ###
X! # uncomment the blank definitions if not used
X  
X  # overlays
X  #OVERLAY = $(OBJ)\trampoli.obj ovlmgr.obj
X--- 75,122 ----
X  ASM	= tasm
X  AFLAGS	= /MX
X  
X+ # yacc/lex
X+ YACC	= bison
X+ LEX	= flex
X  
X+ 
X  ###
X  ### Rules
X  ###
X  # search order
X  .SUFFIXES: .exe .obj .c .asm .y .l
X+ 
X+ # .l -> .c (for flex)
X+ .l.c:
X+ 	$(LEX) $<
X+ 	del $@
X+ 	ren lex.yyc $@
X+ # .y -> .c (for bison)
X+ .y.c:
X+ 	$(YACC) $<
X+ 	del $@
X+ 	ren y.tbc $@
X+ 	del $*.h
X+ 	ren y.tbh $*.h
X  # .c -> .obj
X  .c.obj:
X  	$(CC) $(CFLAGS) -c $<
X  # .asm -> .obj
X  .asm.obj:
X! 	$(ASM) $(AFLAGS) $<;
X  # .obj -> .exe (for tlink)
X  .obj.exe:
X  	$(TLINK) $(TLFLAGS) $(C0) $<, $@,, $(LIBS);
X! 
X! # NDMAKE automatic response file generation
X! .RESPONSE_LINK: tlink
X! .RESPONSE_LIB:  tlib
X  
X  
X  ###
X  ### Optional features (see pcconf.h)
X  ###
X! # uncomment the definitions used
X  
X  # overlays
X  #OVERLAY = $(OBJ)\trampoli.obj ovlmgr.obj
X***************
X*** 139,146 ****
X  # panic.c is unnecessary for makedefs.exe and lev_comp.exe.
X  # ioctl.c is unnecessary for nethack.exe.
X  
X! ROOT =	$(OBJ)\main.obj 	$(OBJ)\allmain.obj	$(OBJ)\termcap.obj \
X! 	$(OBJ)\cmd.obj		$(OBJ)\hack.obj 	$(OBJ)\msdos.obj \
X  	$(OVERLAY)
X  
X  # the overlays -- the Microsoft Overlay Linker is limited to 63
X--- 163,170 ----
X  # panic.c is unnecessary for makedefs.exe and lev_comp.exe.
X  # ioctl.c is unnecessary for nethack.exe.
X  
X! ROOT =	$(OBJ)\main.obj    $(OBJ)\allmain.obj $(OBJ)\msdos.obj \
X! 	$(OBJ)\termcap.obj $(OBJ)\cmd.obj     $(OBJ)\hack.obj \
X  	$(OVERLAY)
X  
X  # the overlays -- the Microsoft Overlay Linker is limited to 63
X***************
X*** 150,200 ****
X  OVL03 = $(OBJ)\pri.obj $(OBJ)\prisym.obj
X  OVL04 = $(OBJ)\rnd.obj $(RANDOM)
X  OVL05 = $(OBJ)\timeout.obj
X! OVL06 = $(OBJ)\mon.obj $(OBJ)\exper.obj $(OBJ)\attrib.obj
X! OVL07 = $(OBJ)\monst.obj $(OBJ)\mondata.obj
X! OVL08 = $(OBJ)\monmove.obj $(OBJ)\track.obj
X! OVL09 = $(OBJ)\dog.obj $(OBJ)\dogmove.obj
X! OVL10 = $(OBJ)\makemon.obj
X! OVL11 = $(OBJ)\do_name.obj $(OBJ)\getline.obj
X! OVL12 = $(OBJ)\weapon.obj
X! OVL13 = $(OBJ)\wield.obj
X! OVL14 = $(OBJ)\invent.obj
X! OVL15 = $(OBJ)\objects.obj
X! OVL16 = $(OBJ)\mkobj.obj $(OBJ)\o_init.obj
X! OVL17 = $(OBJ)\objnam.obj
X! OVL18 = $(OBJ)\worn.obj
X! OVL19 = $(OBJ)\do_wear.obj
X! OVL20 = $(OBJ)\trap.obj
X! OVL21 = $(OBJ)\dothrow.obj
X! OVL22 = $(OBJ)\dokick.obj
X! OVL23 = $(OBJ)\uhitm.obj
X! OVL24 = $(OBJ)\mhitu.obj
X! OVL25 = $(OBJ)\mcastu.obj
X! OVL26 = $(OBJ)\mhitm.obj
X! OVL27 = $(OBJ)\mthrowu.obj
X! OVL28 = $(OBJ)\steal.obj
X! OVL29 = $(OBJ)\priest.obj
X! OVL30 = $(OBJ)\vault.obj
X! OVL31 = $(OBJ)\shk.obj $(OBJ)\shknam.obj
X! OVL32 = $(OBJ)\wizard.obj
X! OVL33 = $(OBJ)\worm.obj
X! OVL34 = $(OBJ)\were.obj
X! OVL35 = $(OBJ)\demon.obj
X! OVL36 = $(OBJ)\artifact.obj
X! OVL37 = $(OBJ)\music.obj $(OBJ)\dbridge.obj
X! OVL38 = $(OBJ)\sit.obj $(OBJ)\fountain.obj
X! OVL39 = $(OBJ)\sounds.obj
X! OVL40 = $(OBJ)\spell.obj
X! OVL41 = $(OBJ)\read.obj
X! OVL42 = $(OBJ)\potion.obj
X! OVL43 = $(OBJ)\zap.obj
X! OVL44 = $(OBJ)\eat.obj $(OBJ)\rumors.obj
X! OVL45 = $(OBJ)\do.obj
X! OVL46 = $(OBJ)\search.obj
X! OVL47 = $(OBJ)\lock.obj
X! OVL48 = $(OBJ)\apply.obj
X! OVL49 = $(OBJ)\engrave.obj
X! OVL50 = $(OBJ)\write.obj
X  OVL51 = $(OBJ)\pray.obj
X  OVL52 = $(OBJ)\options.obj
X  OVL53 = $(OBJ)\pickup.obj
X--- 174,224 ----
X  OVL03 = $(OBJ)\pri.obj $(OBJ)\prisym.obj
X  OVL04 = $(OBJ)\rnd.obj $(RANDOM)
X  OVL05 = $(OBJ)\timeout.obj
X! OVL06 = $(OBJ)\mon.obj $(OBJ)\exper.obj
X! OVL07 = $(OBJ)\attrib.obj
X! OVL08 = $(OBJ)\monst.obj $(OBJ)\mondata.obj
X! OVL09 = $(OBJ)\monmove.obj $(OBJ)\track.obj
X! OVL10 = $(OBJ)\dog.obj $(OBJ)\dogmove.obj
X! OVL11 = $(OBJ)\makemon.obj
X! OVL12 = $(OBJ)\do_name.obj $(OBJ)\getline.obj
X! OVL13 = $(OBJ)\weapon.obj
X! OVL14 = $(OBJ)\wield.obj
X! OVL15 = $(OBJ)\invent.obj
X! OVL16 = $(OBJ)\objects.obj
X! OVL17 = $(OBJ)\mkobj.obj $(OBJ)\o_init.obj
X! OVL18 = $(OBJ)\objnam.obj
X! OVL19 = $(OBJ)\worn.obj
X! OVL20 = $(OBJ)\do_wear.obj
X! OVL21 = $(OBJ)\trap.obj
X! OVL22 = $(OBJ)\dothrow.obj
X! OVL23 = $(OBJ)\dokick.obj
X! OVL24 = $(OBJ)\uhitm.obj
X! OVL25 = $(OBJ)\mhitu.obj
X! OVL26 = $(OBJ)\mcastu.obj
X! OVL27 = $(OBJ)\mhitm.obj
X! OVL28 = $(OBJ)\mthrowu.obj
X! OVL29 = $(OBJ)\steal.obj
X! OVL30 = $(OBJ)\priest.obj
X! OVL31 = $(OBJ)\vault.obj
X! OVL32 = $(OBJ)\shk.obj $(OBJ)\shknam.obj
X! OVL33 = $(OBJ)\wizard.obj
X! OVL34 = $(OBJ)\worm.obj
X! OVL35 = $(OBJ)\were.obj
X! OVL36 = $(OBJ)\demon.obj
X! OVL37 = $(OBJ)\artifact.obj
X! OVL38 = $(OBJ)\music.obj $(OBJ)\dbridge.obj
X! OVL39 = $(OBJ)\sit.obj $(OBJ)\fountain.obj
X! OVL40 = $(OBJ)\sounds.obj
X! OVL41 = $(OBJ)\spell.obj
X! OVL42 = $(OBJ)\read.obj
X! OVL43 = $(OBJ)\potion.obj
X! OVL44 = $(OBJ)\zap.obj
X! OVL45 = $(OBJ)\eat.obj $(OBJ)\rumors.obj
X! OVL46 = $(OBJ)\do.obj
X! OVL47 = $(OBJ)\search.obj
X! OVL48 = $(OBJ)\lock.obj
X! OVL49 = $(OBJ)\apply.obj
X! OVL50 = $(OBJ)\engrave.obj $(OBJ)\write.obj
X  OVL51 = $(OBJ)\pray.obj
X  OVL52 = $(OBJ)\options.obj
X  OVL53 = $(OBJ)\pickup.obj
X***************
X*** 496,506 ****
X  $(OBJ)\topten.obj:	$(HACK_H)
X  $(OBJ)\track.obj:	$(HACK_H)
X  $(OBJ)\trampoli.obj:	$(HACK_H)
X! $(OBJ)\trap.obj:	$(HACK_H)   $(INCL)\edog.h	 $(INCL)\trapname.h
X  $(OBJ)\u_init.obj:	$(HACK_H)
X  $(OBJ)\uhitm.obj:	$(HACK_H)   $(INCL)\artifact.h
X  $(OBJ)\vault.obj:	$(HACK_H)   $(INCL)\vault.h
X! $(OBJ)\version.obj:	$(HACK_H)   $(INCL)\date.h
X  $(OBJ)\weapon.obj:	$(HACK_H)
X  $(OBJ)\were.obj:	$(HACK_H)
X  $(OBJ)\wield.obj:	$(HACK_H)
X--- 520,530 ----
X  $(OBJ)\topten.obj:	$(HACK_H)
X  $(OBJ)\track.obj:	$(HACK_H)
X  $(OBJ)\trampoli.obj:	$(HACK_H)
X! $(OBJ)\trap.obj:	$(HACK_H)   $(INCL)\edog.h
X  $(OBJ)\u_init.obj:	$(HACK_H)
X  $(OBJ)\uhitm.obj:	$(HACK_H)   $(INCL)\artifact.h
X  $(OBJ)\vault.obj:	$(HACK_H)   $(INCL)\vault.h
X! $(OBJ)\version.obj:	$(HACK_H)   $(INCL)\date.h	 $(INCL)\patchlev.h
X  $(OBJ)\weapon.obj:	$(HACK_H)
X  $(OBJ)\were.obj:	$(HACK_H)
X  $(OBJ)\wield.obj:	$(HACK_H)
X*** /dev/null	Mon Feb 19 23:30:27 1990
X--- others/lev_lex.c	Fri Feb  9 20:03:52 1990
X***************
X*** 0 ****
X--- 1,1115 ----
X+ #define FLEX_COMPRESSED
X+ /* A lexical scanner generated by flex */
X+ 
X+ /* scanner skeleton version:
X+  * $Header: flex.skel,v 2.0 89/06/20 15:49:46 vern Locked $
X+  */
X+ 
X+ #include <stdio.h>
X+ 
X+ #define FLEX_SCANNER
X+ 
X+ /* amount of stuff to slurp up with each read */
X+ #ifndef YY_READ_BUF_SIZE
X+ #define YY_READ_BUF_SIZE 8192
X+ #endif
X+ 
X+ #ifndef YY_BUF_SIZE
X+ #define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of input buffer */
X+ #endif
X+ 
X+ /* returned upon end-of-file */
X+ #define YY_END_TOK 0
X+ 
X+ /* copy whatever the last rule matched to the standard output */
X+ 
X+ #define ECHO fputs( yytext, yyout )
X+ 
X+ /* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X+  * is returned in "result".
X+  */
X+ #ifdef atarist
X+ static __st_read(fd, buf, size)
X+ int fd; char *buf; int size;
X+ {
X+ 	int r, num = 0;
X+ 	char *from;
X+ 
X+ 	if ((r = read(fd, buf, size)) < 0)
X+ 		return r;
X+ 	from = buf;
X+ 	while (r-- > 0) {
X+ 		if (*from == '\r')
X+ 			from++;
X+ 		else {
X+ 			*buf++ = *from++;
X+ 			num++;
X+ 		}
X+ 	}
X+ 	return num;
X+ }
X+ 
X+ #define YY_INPUT(buf,result,max_size) \
X+ 	if ( (result = __st_read( fileno(yyin), buf, max_size )) < 0 ) \
X+ 	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X+ 
X+ #else
X+ 
X+ #define YY_INPUT(buf,result,max_size) \
X+ 	if ( (result = read( fileno(yyin), buf, max_size )) < 0 ) \
X+ 	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X+ #endif
X+ 
X+ #define YY_NULL 0
X+ #define yyterminate() return ( YY_NULL )
X+ 
X+ /* report a fatal error */
X+ #define YY_FATAL_ERROR(msg) \
X+ 	{ \
X+ 	fputs( msg, stderr ); \
X+ 	putc( '\n', stderr ); \
X+ 	exit( 1 ); \
X+ 	}
X+ 
X+ /* default yywrap function - always treat EOF as an EOF */
X+ #define yywrap() 1
X+ 
X+ /* enter a start condition.  This macro really ought to take a parameter,
X+  * but we do it the disgusting crufty way forced on us by the ()-less
X+  * definition of BEGIN
X+  */
X+ #define BEGIN yy_start = 1 + 2 *
X+ 
X+ /* action number for EOF rule of a given start state */
X+ #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X+ 
X+ /* special action meaning "start processing a new file" */
X+ #define YY_NEW_FILE goto new_file
X+ 
X+ /* default declaration of generated scanner - a define so the user can
X+  * easily add parameters
X+  */
X+ #ifdef __STDC__
X+ #define YY_DECL int yylex( void )
X+ #else
X+ #define YY_DECL int yylex()
X+ #endif
X+ 
X+ /* code executed at the end of each rule */
X+ #define YY_BREAK break;
X+ 
X+ #define YY_END_OF_BUFFER_CHAR 0
X+ 
X+ /* done after the current pattern has been matched and before the
X+  * corresponding action - sets up yytext
X+  */
X+ #define YY_DO_BEFORE_ACTION \
X+ 	yytext = yy_bp; \
X+ 	yy_hold_char = *yy_cp; \
X+ 	*yy_cp = '\0'; \
X+ 	yy_c_buf_p = yy_cp;
X+ 
X+ /* returns the length of the matched text */
X+ #define yyleng (int)(yy_cp - yy_bp)
X+ 
X+ #define EOB_ACT_RESTART_SCAN 0
X+ #define EOB_ACT_END_OF_FILE 1
X+ #define EOB_ACT_LAST_MATCH 2
X+ 
X+ /* return all but the first 'n' matched characters back to the input stream */
X+ #define yyless(n) \
X+ 	{ \
X+ 	*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
X+ 	yy_c_buf_p = yy_cp = yy_bp + n; \
X+ 	YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X+ 	}
X+ 
X+ #define unput(c) yyunput( c, yy_bp )
X+ 
X+ #define YY_USER_ACTION
X+ 
X+ FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
X+ char *yytext;
X+ 
X+ #ifndef __STDC__
X+ #define const
X+ #endif
X+ 
X+ # line 1 "lev_comp.l"
X+ #define INITIAL 0
X+ # line 2 "lev_comp.l"
X+ /*	SCCS Id: @(#)lev_lex.c	3.0	90/01/04
X+ /*	Copyright (c) 1989 by Jean-Christophe Collet */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ #define LEV_LEX_C
X+ 
X+ /* block some unused #defines to avoid overloading some cpp's */
X+ #define MONDATA_H	/* comment this line for pre-compiled headers */
X+ #define MONFLAG_H	/* comment this line for pre-compiled headers */
X+ 
X+ #include "hack.h"
X+ #include "lev_comp.h"
X+ #include "sp_lev.h"
X+ 
X+ /* Most of these don't exist in flex, yywrap is macro and
X+  * yyunput is properly declared in flex.skel.
X+  */
X+ #ifndef FLEX_SCANNER
X+ int FDECL (yyback, (int *, int));
X+ int NDECL (yylook);
X+ int NDECL (yyinput);
X+ int NDECL (yywrap);
X+ int NDECL (yylex);
X+ int FDECL (yyunput, (int));
X+ int FDECL (yyoutput, (int));
X+ #endif
X+ 
X+ #ifdef MSDOS
X+ #undef exit
X+ #endif
X+ 
X+ /* this doesn't always get put in lev_comp.h
X+  * (esp. when using older versions of bison)
X+  */
X+ 
X+ extern YYSTYPE yylval;
X+ 
X+ #ifdef MACOS
X+ #undef putchar
X+ #undef putc
X+ #undef printf
X+ #undef Printf
X+ #define Printf printf
X+ # ifdef LSC
X+ #define	putc(c,stream)	(fputc(c,stream))
X+ #define	putchar(c)	(fputc(c,stdout))
X+ # endif
X+ #endif
X+ int line_number = 1;
X+ 
X+ /* This is *** UGLY *** but I can't think a better way to do it
X+  * I really need a huge buffer to scan maps...
X+  */
X+ 
X+ #undef YYLMAX
X+ #define YYLMAX	2048
X+ 
X+ #define MAPC 1
X+ # line 61 "lev_comp.l"
X+ #define YY_END_OF_BUFFER 57
X+ typedef int yy_state_type;
X+ static const short int yy_accept[274] =
X+     {   0,
X+         0,    0,    0,    0,   57,   55,   53,   52,   55,   55,
X+        50,   55,   55,   55,   55,   55,   55,   55,   55,   55,
X+        55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
X+        55,   55,   55,   55,   55,   55,   55,    1,   53,   55,
X+        55,   55,   53,    0,   51,    0,   50,    0,    0,    0,
X+         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X+         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X+         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X+         0,    0,    0,    0,    0,   48,    0,    0,    3,    0,
X+         1,   53,    0,    0,    1,    0,   54,    0,    0,    0,
X+ 
X+         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X+         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X+        43,    0,   41,    0,    0,    0,    0,    0,    0,    0,
X+         0,    0,    0,    0,    0,   39,    0,    0,    0,    0,
X+         0,   11,    0,    0,    0,    0,    4,    0,    0,    0,
X+         0,    0,   21,   10,    0,    0,    0,    0,    0,    0,
X+         0,   49,   28,   36,    0,    0,    0,    0,    0,    0,
X+        22,    0,    0,    0,    0,    0,    0,   30,    7,    0,
X+        18,    0,    0,    0,    5,    0,    0,    0,    0,    0,
X+         0,   35,   47,    0,    0,    0,   45,    0,    0,    0,
X+ 
X+         0,    0,   27,    0,   34,    0,   37,    0,   29,   42,
X+         0,    0,    0,   19,    0,    0,    0,    8,    0,   14,
X+        40,   26,   38,   23,   24,    0,    0,   25,   32,   31,
X+        46,    0,    0,    0,    0,    9,    0,    0,   33,   44,
X+         2,    0,    6,   13,    0,    0,    0,    0,    0,    0,
X+         0,    0,    0,   12,    0,    0,    0,    0,    0,    0,
X+         0,    0,   20,    0,    0,    0,    0,    0,   17,    0,
X+        15,   16,    0
X+     } ;
X+ 
X+ static const char yy_ec[128] =
X+     {   0,
X+         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    4,    1,    5,    6,    1,    1,    1,    7,    1,
X+         1,    1,    8,    1,    8,    8,    1,    9,    9,    9,
X+         9,    9,    9,    9,    9,    9,    9,    1,    1,    1,
X+         1,    1,    1,    1,   10,   11,   12,   13,   14,    1,
X+        15,    1,   16,   17,   18,   19,   20,   21,   22,   23,
X+         1,   24,   25,   26,    1,   27,   28,    1,   29,   30,
X+         1,    8,    1,    1,   31,    1,   32,   33,   34,   35,
X+ 
X+        36,   37,   38,   39,   40,   41,   42,   43,   44,   45,
X+        46,   47,    1,   48,   49,   50,   51,    1,   52,    1,
X+         1,    1,    8,    8,    8,    1,    1
X+     } ;
X+ 
X+ static const char yy_meta[53] =
X+     {   0,
X+         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1
X+     } ;
X+ 
X+ static const short int yy_base[277] =
X+     {   0,
X+         0,   47,   51,   74,  343,  344,   54,  344,  337,    0,
X+       332,  321,   38,  325,   54,   51,  316,  326,   61,  312,
X+       292,   24,   48,  288,  301,   49,  286,   50,   46,  288,
X+        34,   51,  284,   53,  293,  325,   91,  344,  100,  106,
X+       306,  124,  103,  321,  344,  318,  315,  297,  300,  311,
X+       298,  306,  291,  287,  295,  294,  297,  292,  297,  289,
X+       300,   71,  259,  262,  262,  274,  259,  252,  254,  250,
X+       264,  250,  265,  253,  246,   81,  255,  259,  262,  248,
X+       254,  243,  239,  242,  245,  344,  238,  283,  344,   92,
X+       344,  132,  140,  272,  344,  148,  344,  274,  259,  254,
X+ 
X+       261,  267,  265,  264,  252,  245,  261,  261,  257,  252,
X+       248,  232,  237,  218,  225,  216,  219,  215,  218,  212,
X+       344,  211,  344,  218,  210,  208,  211,  206,  219,  209,
X+       219,  217,  212,  210,  199,  344,  208,  197,  243,  225,
X+       220,  344,  232,  228,  227,  221,  211,  212,  224,  224,
X+       213,  212,  344,  344,  188,  184,  185,  194,  193,  179,
X+       191,  344,  344,  344,  190,  175,  176,  177,  183,  187,
X+       344,  184,  173,  168,  172,  177,  165,  344,  344,  204,
X+       344,  189,  186,  187,  344,  200,  195,  192,  181,  186,
X+       184,  344,  344,  160,  158,  154,  344,  166,  165,  163,
X+ 
X+       166,  149,  344,  146,  344,  151,  344,  158,  344,  344,
X+       170,  176,  167,  344,  171,  165,  173,  344,  156,  344,
X+       344,  344,  344,  344,  344,  138,  142,  344,  344,  344,
X+       344,  181,  170,  153,  163,  344,  165,   97,  344,  344,
X+       344,  164,  344,  344,  168,  150,  160,  151,  155,  157,
X+       146,  147,  153,  344,  143,  136,  146,  147,  141,  127,
X+       135,  131,  344,  127,  113,  112,  109,  101,  344,   98,
X+       344,  344,  344,  173,   62,  175
X+     } ;
X+ 
X+ static const short int yy_def[277] =
X+     {   0,
X+       273,    1,    1,    1,  273,  273,  273,  273,  274,  275,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  276,  273,  273,  273,  273,
X+       273,  276,  273,  274,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  276,  273,  273,
X+       273,  273,  273,  273,  273,  276,  273,  273,  273,  273,
X+ 
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+ 
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,    0,  273,  273,  273
X+     } ;
X+ 
X+ static const short int yy_nxt[397] =
X+     {   0,
X+         6,    7,    8,    7,    9,    6,   10,    6,   11,   12,
X+         6,    6,   13,    6,   14,    6,    6,    6,   15,   16,
X+        17,   18,    6,   19,    6,   20,    6,    6,    6,    6,
X+         6,   21,   22,   23,   24,   25,    6,    6,    6,    6,
X+         6,    6,   26,   27,   28,   29,   30,   31,   32,   33,
X+        34,   35,   36,   38,   39,   43,   40,   43,   40,   49,
X+        54,   50,   46,   52,   41,   80,   37,   53,   40,   63,
X+        58,   64,   55,   81,   59,   40,   38,   39,   77,   42,
X+        70,   40,   60,   65,   71,   75,   66,   41,   72,   82,
X+        67,   40,   78,   37,   73,   76,   83,   85,   40,   86,
X+ 
X+        90,   43,   91,   92,   43,   93,   43,   93,   91,   93,
X+       112,   93,   55,   93,  139,  127,  246,   93,  247,  248,
X+       113,  104,  272,   93,   93,  271,   95,   96,  128,   96,
X+        93,   96,  270,   43,   91,   92,  269,   93,  268,   93,
X+       267,   96,   91,   93,  266,   93,  265,   93,   96,   93,
X+        95,   96,  264,   96,  263,   96,   93,   93,  262,  261,
X+       260,  259,  258,  257,   93,   96,  256,  255,  254,  253,
X+       252,  251,   96,   44,   44,   88,   88,  250,  249,  245,
X+       244,  243,  242,  241,  240,  239,  238,  237,  236,  235,
X+       234,  233,  232,  231,  230,  229,  228,  227,  226,  225,
X+ 
X+       224,  223,  222,  221,  220,  219,  218,  217,  216,  215,
X+       214,  213,  212,  211,  210,  209,  208,  207,  206,  205,
X+       204,  203,  202,  201,  200,  199,  198,  197,  196,  195,
X+       194,  193,  192,  191,  190,  189,  188,  187,  186,  185,
X+       184,  183,  182,  181,  180,  179,  178,  177,  176,  175,
X+       174,  173,  172,  171,  170,  169,  168,  167,  166,  165,
X+       164,  163,  162,  161,  160,  159,  158,  157,  156,  155,
X+       154,  153,  152,  151,  150,  149,  148,  147,  146,  145,
X+       144,  143,  142,  141,  140,   89,  138,  137,  136,  135,
X+       134,  133,  132,  131,  130,  129,  126,  125,  124,  123,
X+ 
X+       122,  121,  120,  119,  118,  117,  116,  115,  114,  111,
X+       110,  109,  108,  107,  106,  105,  104,  103,  102,  101,
X+       100,   99,   98,   47,   97,   45,   94,   89,   87,   84,
X+        79,   74,   69,   68,   62,   61,   57,   56,   51,   48,
X+        47,   45,  273,    5,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273
X+ 
X+     } ;
X+ 
X+ static const short int yy_chk[397] =
X+     {   0,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X+         1,    1,    2,    3,    3,    7,    3,    7,    3,   13,
X+        16,   13,  275,   15,    3,   31,    2,   15,    3,   22,
X+        19,   22,   16,   31,   19,    3,    4,    4,   29,    4,
X+        26,    4,   19,   23,   26,   28,   23,    4,   26,   32,
X+        23,    4,   29,    4,   26,   28,   32,   34,    4,   34,
X+ 
X+        37,   39,   39,   39,   43,   39,   43,   39,   40,   40,
X+        62,   40,   37,   40,   90,   76,  238,   39,  238,  238,
X+        62,   90,  270,   40,   39,  268,   42,   42,   76,   42,
X+        40,   42,  267,   92,   92,   92,  266,   92,  265,   92,
X+       264,   42,   93,   93,  262,   93,  261,   93,   42,   92,
X+        96,   96,  260,   96,  259,   96,   92,   93,  258,  257,
X+       256,  255,  253,  252,   93,   96,  251,  250,  249,  248,
X+       247,  246,   96,  274,  274,  276,  276,  245,  242,  237,
X+       235,  234,  233,  232,  227,  226,  219,  217,  216,  215,
X+       213,  212,  211,  208,  206,  204,  202,  201,  200,  199,
X+ 
X+       198,  196,  195,  194,  191,  190,  189,  188,  187,  186,
X+       184,  183,  182,  180,  177,  176,  175,  174,  173,  172,
X+       170,  169,  168,  167,  166,  165,  161,  160,  159,  158,
X+       157,  156,  155,  152,  151,  150,  149,  148,  147,  146,
X+       145,  144,  143,  141,  140,  139,  138,  137,  135,  134,
X+       133,  132,  131,  130,  129,  128,  127,  126,  125,  124,
X+       122,  120,  119,  118,  117,  116,  115,  114,  113,  112,
X+       111,  110,  109,  108,  107,  106,  105,  104,  103,  102,
X+       101,  100,   99,   98,   94,   88,   87,   85,   84,   83,
X+        82,   81,   80,   79,   78,   77,   75,   74,   73,   72,
X+ 
X+        71,   70,   69,   68,   67,   66,   65,   64,   63,   61,
X+        60,   59,   58,   57,   56,   55,   54,   53,   52,   51,
X+        50,   49,   48,   47,   46,   44,   41,   36,   35,   33,
X+        30,   27,   25,   24,   21,   20,   18,   17,   14,   12,
X+        11,    9,    5,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273,  273,  273,  273,  273,
X+       273,  273,  273,  273,  273,  273
X+ 
X+     } ;
X+ 
X+ /* the intent behind this definition is that it'll catch
X+  * any uses of REJECT which flex missed
X+  */
X+ #define REJECT reject_used_but_not_detected
X+ static char *yy_more_pos = (char *) 0;
X+ #define yymore() (yy_more_pos = yy_bp)
X+ 
X+ /* these variables are all declared out here so that section 3 code can
X+  * manipulate them
X+  */
X+ static char *yy_c_buf_p;	/* points to current character in buffer */
X+ static int yy_init = 1;		/* whether we need to initialize */
X+ static int yy_start = 0;	/* start state number */
X+ 
X+ /* true when we've seen an EOF for the current input file */
X+ static int yy_eof_has_been_seen;
X+ 
X+ static int yy_n_chars;		/* number of characters read into yy_ch_buf */
X+ 
X+ /* yy_ch_buf has to be 2 characters longer than YY_BUF_SIZE because we need
X+  * to put in 2 end-of-buffer characters (this is explained where it is
X+  * done) at the end of yy_ch_buf
X+  */
X+ static char yy_ch_buf[YY_BUF_SIZE + 2];
X+ 
X+ /* yy_hold_char holds the character lost when yytext is formed */
X+ static char yy_hold_char;
X+ 
X+ static yy_state_type yy_last_accepting_state;
X+ static char *yy_last_accepting_cpos;
X+ 
X+ #ifdef __STDC__
X+ static yy_state_type yy_get_previous_state( void );
X+ static int yy_get_next_buffer( void );
X+ static void yyunput( int c, char *buf_ptr );
X+ static int input( void );
X+ static void yyrestart( FILE *input_file );
X+ #else
X+ static yy_state_type yy_get_previous_state();
X+ static int yy_get_next_buffer();
X+ static void yyunput();
X+ static int input();
X+ static void yyrestart();
X+ #endif
X+ 
X+ YY_DECL
X+     {
X+     register yy_state_type yy_current_state;
X+     register char *yy_cp, *yy_bp;
X+     register int yy_act;
X+ 
X+ 
X+ 
X+     if ( yy_init )
X+ 	{
X+ 	if ( ! yy_start )
X+ 	    yy_start = 1;	/* first start state */
X+ 
X+ 	if ( ! yyin )
X+ 	    yyin = stdin;
X+ 
X+ 	if ( ! yyout )
X+ 	    yyout = stdout;
X+ 
X+ new_file:
X+ 	/* this is where we enter upon encountering an end-of-file and
X+ 	 * yywrap() indicating that we should continue processing
X+ 	 */
X+ 
X+ 	/* we put in the '\n' and start reading from [1] so that an
X+ 	 * initial match-at-newline will be true.
X+ 	 */
X+ 
X+ 	yy_ch_buf[0] = '\n';
X+ 	yy_n_chars = 1;
X+ 
X+ 	/* we always need two end-of-buffer characters.  The first causes
X+ 	 * a transition to the end-of-buffer state.  The second causes
X+ 	 * a jam in that state.
X+ 	 */
X+ 	yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X+ 	yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X+ 
X+ 	yy_eof_has_been_seen = 0;
X+ 
X+ 	yytext = yy_c_buf_p = &yy_ch_buf[1];
X+ 	yy_hold_char = *yy_c_buf_p;
X+ 	yy_init = 0;
X+ 	}
X+ 
X+     while ( 1 )		/* loops until end-of-file is reached */
X+ 	{
X+ 	yy_cp = yy_c_buf_p;
X+ 
X+ 	/* support of yytext */
X+ 	*yy_cp = yy_hold_char;
X+ 
X+ 	/* yy_bp points to the position in yy_ch_buf of the start of the
X+ 	 * current run.
X+ 	 */
X+ 	if ( yy_more_pos )
X+ 	    {
X+ 	    yy_bp = yy_more_pos;
X+ 	    yy_more_pos = (char *) 0;
X+ 	    }
X+ 	else
X+ 	    yy_bp = yy_cp;
X+ 
X+ 	yy_current_state = yy_start;
X+ 	if ( yy_bp[-1] == '\n' )
X+ 	    ++yy_current_state;
X+ 	do
X+ 	    {
X+ 	    register char yy_c = yy_ec[*yy_cp];
X+ 	    if ( yy_accept[yy_current_state] )
X+ 		{
X+ 		yy_last_accepting_state = yy_current_state;
X+ 		yy_last_accepting_cpos = yy_cp;
X+ 		}
X+ 	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X+ 		{
X+ 		yy_current_state = yy_def[yy_current_state];
X+ 		if ( yy_current_state >= 274 )
X+ 		    yy_c = yy_meta[yy_c];
X+ 		}
X+ 	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X+ 	    ++yy_cp;
X+ 	    }
X+ 	while ( yy_current_state != 273 );
X+ 	yy_cp = yy_last_accepting_cpos;
X+ 	yy_current_state = yy_last_accepting_state;
X+ 
X+ 	/* bogus while loop to let YY_BACK_TRACK, EOB_ACT_LAST_MATCH,
X+ 	 * and EOF actions branch here without introducing an optimizer-
X+ 	 * daunting goto
X+ 	 */
X+ 	while ( 1 )
X+ 	    {
X+ 	    yy_act = yy_accept[yy_current_state];
X+ 
X+ 	    YY_DO_BEFORE_ACTION;
X+ 	    YY_USER_ACTION;
X+ 
X+ #ifdef FLEX_DEBUG
X+ 	    fprintf( stderr, "--accepting rule #%d (\"%s\")\n",
X+ 		     yy_act, yytext );
X+ #endif
X+ 
X+ do_action:	/* this label is used only to access EOF actions */
X+ 	    switch ( yy_act )
X+ 		{
X+ 		case 0: /* must backtrack */
X+ 		/* undo the effects of YY_DO_BEFORE_ACTION */
X+ 		*yy_cp = yy_hold_char;
X+ 		yy_cp = yy_last_accepting_cpos;
X+ 		yy_current_state = yy_last_accepting_state;
X+ 		continue; /* go to "YY_DO_BEFORE_ACTION" */
X+ 
X+ case 1:
X+ # line 62 "lev_comp.l"
X+ { line_number++; yymore(); }	
X+ 	YY_BREAK
X+ case 2:
X+ # line 63 "lev_comp.l"
X+ { BEGIN 0;
X+ 		  line_number++;
X+ 		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X+ 		  yylval.map = (char *) alloc(strlen(yytext)+1);
X+ 		  strcpy(yylval.map, yytext);
X+ 		  return MAP_ID;
X+ 		}
X+ 	YY_BREAK
X+ case 3:
X+ # line 70 "lev_comp.l"
X+ { line_number++; }
X+ 	YY_BREAK
X+ case 4:
X+ # line 71 "lev_comp.l"
X+ return MAZE_ID;
X+ 	YY_BREAK
X+ case 5:
X+ # line 72 "lev_comp.l"
X+ return LEVEL_ID;
X+ 	YY_BREAK
X+ case 6:
X+ # line 73 "lev_comp.l"
X+ return GEOMETRY_ID;
X+ 	YY_BREAK
X+ case 7:
X+ # line 74 "lev_comp.l"
X+ { BEGIN MAPC; line_number++; }
X+ 	YY_BREAK
X+ case 8:
X+ # line 75 "lev_comp.l"
X+ return OBJECT_ID;
X+ 	YY_BREAK
X+ case 9:
X+ # line 76 "lev_comp.l"
X+ return MONSTER_ID;
X+ 	YY_BREAK
X+ case 10:
X+ # line 77 "lev_comp.l"
X+ return TRAP_ID;
X+ 	YY_BREAK
X+ case 11:
X+ # line 78 "lev_comp.l"
X+ return DOOR_ID;
X+ 	YY_BREAK
X+ case 12:
X+ # line 79 "lev_comp.l"
X+ return DRAWBRIDGE_ID;
X+ 	YY_BREAK
X+ case 13:
X+ # line 80 "lev_comp.l"
X+ return MAZEWALK_ID;
X+ 	YY_BREAK
X+ case 14:
X+ # line 81 "lev_comp.l"
X+ return REGION_ID;
X+ 	YY_BREAK
X+ case 15:
X+ # line 82 "lev_comp.l"
X+ return RANDOM_OBJECTS_ID;
X+ 	YY_BREAK
X+ case 16:
X+ # line 83 "lev_comp.l"
X+ return RANDOM_MONSTERS_ID;
X+ 	YY_BREAK
X+ case 17:
X+ # line 84 "lev_comp.l"
X+ return RANDOM_PLACES_ID;
X+ 	YY_BREAK
X+ case 18:
X+ # line 85 "lev_comp.l"
X+ return ALTAR_ID;
X+ 	YY_BREAK
X+ case 19:
X+ # line 86 "lev_comp.l"
X+ return LADDER_ID;
X+ 	YY_BREAK
X+ case 20:
X+ # line 87 "lev_comp.l"
X+ return NON_DIGGABLE_ID;
X+ 	YY_BREAK
X+ case 21:
X+ # line 88 "lev_comp.l"
X+ return ROOM_ID;
X+ 	YY_BREAK
X+ case 22:
X+ # line 89 "lev_comp.l"
X+ { yylval.i=D_ISOPEN; return DOOR_STATE; }
X+ 	YY_BREAK
X+ case 23:
X+ # line 90 "lev_comp.l"
X+ { yylval.i=D_CLOSED; return DOOR_STATE; }
X+ 	YY_BREAK
X+ case 24:
X+ # line 91 "lev_comp.l"
X+ { yylval.i=D_LOCKED; return DOOR_STATE; }
X+ 	YY_BREAK
X+ case 25:
X+ # line 92 "lev_comp.l"
X+ { yylval.i=D_NODOOR; return DOOR_STATE; }
X+ 	YY_BREAK
X+ case 26:
X+ # line 93 "lev_comp.l"
X+ { yylval.i=D_BROKEN; return DOOR_STATE; }
X+ 	YY_BREAK
X+ case 27:
X+ # line 94 "lev_comp.l"
X+ { yylval.i=W_NORTH; return DIRECTION; }
X+ 	YY_BREAK
X+ case 28:
X+ # line 95 "lev_comp.l"
X+ { yylval.i=W_EAST; return DIRECTION; }
X+ 	YY_BREAK
X+ case 29:
X+ # line 96 "lev_comp.l"
X+ { yylval.i=W_SOUTH; return DIRECTION; }
X+ 	YY_BREAK
X+ case 30:
X+ # line 97 "lev_comp.l"
X+ { yylval.i=W_WEST; return DIRECTION; }
X+ 	YY_BREAK
X+ case 31:
X+ # line 98 "lev_comp.l"
X+ { yylval.i = -1; return RANDOM_TYPE; }
X+ 	YY_BREAK
X+ case 32:
X+ # line 99 "lev_comp.l"
X+ return O_REGISTER;
X+ 	YY_BREAK
X+ case 33:
X+ # line 100 "lev_comp.l"
X+ return M_REGISTER;
X+ 	YY_BREAK
X+ case 34:
X+ # line 101 "lev_comp.l"
X+ return P_REGISTER;
X+ 	YY_BREAK
X+ case 35:
X+ # line 102 "lev_comp.l"
X+ return A_REGISTER;
X+ 	YY_BREAK
X+ case 36:
X+ # line 103 "lev_comp.l"
X+ { yylval.i=1; return LEFT_OR_RIGHT; }
X+ 	YY_BREAK
X+ case 37:
X+ # line 104 "lev_comp.l"
X+ { yylval.i=3; return LEFT_OR_RIGHT; }
X+ 	YY_BREAK
X+ case 38:
X+ # line 105 "lev_comp.l"
X+ { yylval.i=2; return CENTER; }
X+ 	YY_BREAK
X+ case 39:
X+ # line 106 "lev_comp.l"
X+ { yylval.i=1; return TOP_OR_BOT; }
X+ 	YY_BREAK
X+ case 40:
X+ # line 107 "lev_comp.l"
X+ { yylval.i=3; return TOP_OR_BOT; }
X+ 	YY_BREAK
X+ case 41:
X+ # line 108 "lev_comp.l"
X+ { yylval.i=1; return LIGHT_STATE; }
X+ 	YY_BREAK
X+ case 42:
X+ # line 109 "lev_comp.l"
X+ { yylval.i=0; return LIGHT_STATE; }
X+ 	YY_BREAK
X+ case 43:
X+ # line 110 "lev_comp.l"
X+ { yylval.i=A_LAW; return ALIGNMENT; }
X+ 	YY_BREAK
X+ case 44:
X+ # line 111 "lev_comp.l"
X+ { yylval.i=A_NEUTRAL; return ALIGNMENT; }
X+ 	YY_BREAK
X+ case 45:
X+ # line 112 "lev_comp.l"
X+ { yylval.i=A_CHAOS; return ALIGNMENT; }
X+ 	YY_BREAK
X+ case 46:
X+ # line 113 "lev_comp.l"
X+ { yylval.i=1; return ALTAR_TYPE; }
X+ 	YY_BREAK
X+ case 47:
X+ # line 114 "lev_comp.l"
X+ { yylval.i=0; return ALTAR_TYPE; }
X+ 	YY_BREAK
X+ case 48:
X+ # line 115 "lev_comp.l"
X+ { yylval.i=1; return UP_OR_DOWN; }
X+ 	YY_BREAK
X+ case 49:
X+ # line 116 "lev_comp.l"
X+ { yylval.i=0; return UP_OR_DOWN; }
X+ 	YY_BREAK
X+ case 50:
X+ # line 117 "lev_comp.l"
X+ { yylval.i=atoi(yytext); return INTEGER; }
X+ 	YY_BREAK
X+ case 51:
X+ # line 118 "lev_comp.l"
X+ { yytext[yyleng-1] = 0; /* Discard the trailing \" */
X+ 		  yylval.map = (char *) alloc(strlen(yytext+1)+1);
X+ 		  strcpy(yylval.map, yytext+1); /* Discard the first \" */
X+ 		  return STRING; }
X+ 	YY_BREAK
X+ case 52:
X+ # line 122 "lev_comp.l"
X+ { line_number++; }
X+ 	YY_BREAK
X+ case 53:
X+ # line 123 "lev_comp.l"
X+ ;
X+ 	YY_BREAK
X+ case 54:
X+ # line 124 "lev_comp.l"
X+ { yylval.i = yytext[1]; return CHAR; }
X+ 	YY_BREAK
X+ case 55:
X+ # line 125 "lev_comp.l"
X+ { return yytext[0]; }
X+ 	YY_BREAK
X+ case 56:
X+ # line 126 "lev_comp.l"
X+ ECHO;
X+ 	YY_BREAK
X+ case YY_STATE_EOF(INITIAL):
X+ case YY_STATE_EOF(MAPC):
X+     yyterminate();
X+ 
X+ 		case YY_END_OF_BUFFER:
X+ 		    /* undo the effects of YY_DO_BEFORE_ACTION */
X+ 		    *yy_cp = yy_hold_char;
X+ 
X+ 		    yytext = yy_bp;
X+ 
X+ 		    switch ( yy_get_next_buffer() )
X+ 			{
X+ 			case EOB_ACT_END_OF_FILE:
X+ 			    {
X+ 			    if ( yywrap() )
X+ 				{
X+ 				/* note: because we've taken care in
X+ 				 * yy_get_next_buffer() to have set up yytext,
X+ 				 * we can now set up yy_c_buf_p so that if some
X+ 				 * total hoser (like flex itself) wants
X+ 				 * to call the scanner after we return the
X+ 				 * YY_NULL, it'll still work - another YY_NULL
X+ 				 * will get returned.
X+ 				 */
X+ 				yy_c_buf_p = yytext;
X+ 
X+ 				yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X+ 				goto do_action;
X+ 				}
X+ 
X+ 			    else
X+ 				YY_NEW_FILE;
X+ 			    }
X+ 			    break;
X+ 
X+ 			case EOB_ACT_RESTART_SCAN:
X+ 			    yy_c_buf_p = yytext;
X+ 			    yy_hold_char = *yy_c_buf_p;
X+ 			    break;
X+ 
X+ 			case EOB_ACT_LAST_MATCH:
X+ 			    yy_c_buf_p = &yy_ch_buf[yy_n_chars];
X+ 
X+ 			    yy_current_state = yy_get_previous_state();
X+ 
X+ 			    yy_cp = yy_c_buf_p;
X+ 			    yy_bp = yytext;
X+ 			    continue; /* go to "YY_DO_BEFORE_ACTION" */
X+ 			}
X+ 		    break;
X+ 
X+ 		default:
X+ 		    printf( "action # %d\n", yy_act );
X+ 		    YY_FATAL_ERROR( "fatal flex scanner internal error" );
X+ 		}
X+ 
X+ 	    break; /* exit bogus while loop */
X+ 	    }
X+ 	}
X+     }
X+ 
X+ 
X+ /* yy_get_next_buffer - try to read in new buffer
X+  *
X+  * synopsis
X+  *     int yy_get_next_buffer();
X+  *     
X+  * returns a code representing an action
X+  *     EOB_ACT_LAST_MATCH - 
X+  *     EOB_ACT_RESTART_SCAN - restart the scanner
X+  *     EOB_ACT_END_OF_FILE - end of file
X+  */
X+ 
X+ static int yy_get_next_buffer()
X+ 
X+     {
X+     register char *dest = yy_ch_buf;
X+     register char *source = yytext - 1; /* copy prev. char, too */
X+     register int number_to_move, i;
X+     int ret_val;
X+     
X+     if ( yy_c_buf_p != &yy_ch_buf[yy_n_chars + 1] )
X+ 	{
X+ 	YY_FATAL_ERROR( "NULL in input" );
X+ 	/*NOTREACHED*/
X+ 	}
X+ 
X+     /* try to read more data */
X+ 
X+     /* first move last chars to start of buffer */
X+     number_to_move = yy_c_buf_p - yytext;
X+ 
X+     for ( i = 0; i < number_to_move; ++i )
X+ 	*(dest++) = *(source++);
X+ 
X+     if ( yy_eof_has_been_seen )
X+ 	/* don't do the read, it's not guaranteed to return an EOF,
X+ 	 * just force an EOF
X+ 	 */
X+ 	yy_n_chars = 0;
X+ 
X+     else
X+ 	{
X+ 	int num_to_read = YY_BUF_SIZE - number_to_move - 1;
X+ 
X+ 	if ( num_to_read > YY_READ_BUF_SIZE )
X+ 	    num_to_read = YY_READ_BUF_SIZE;
X+ 
X+ 	/* read in more data */
X+ 	YY_INPUT( (&yy_ch_buf[number_to_move]), yy_n_chars, num_to_read );
X+ 	}
X+ 
X+     if ( yy_n_chars == 0 )
X+ 	{
X+ 	if ( number_to_move == 1 )
X+ 	    ret_val = EOB_ACT_END_OF_FILE;
X+ 	else
X+ 	    ret_val = EOB_ACT_LAST_MATCH;
X+ 
X+ 	yy_eof_has_been_seen = 1;
X+ 	}
X+ 
X+     else
X+ 	ret_val = EOB_ACT_RESTART_SCAN;
X+ 
X+     yy_n_chars += number_to_move;
X+     yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X+     yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X+ 
X+     /* yytext begins at the second character in
X+      * yy_ch_buf; the first character is the one which
X+      * preceded it before reading in the latest buffer;
X+      * it needs to be kept around in case it's a
X+      * newline, so yy_get_previous_state() will have
X+      * with '^' rules active
X+      */
X+ 
X+     yytext = &yy_ch_buf[1];
X+ 
X+     return ( ret_val );
X+     }
X+ 
X+ 
X+ /* yy_get_previous_state - get the state just before the EOB char was reached
X+  *
X+  * synopsis
X+  *     yy_state_type yy_get_previous_state();
X+  */
X+ 
X+ static yy_state_type yy_get_previous_state()
X+ 
X+     {
X+     register yy_state_type yy_current_state;
X+     register char *yy_cp;
X+ 
X+     register char *yy_bp = yytext;
X+ 
X+     yy_current_state = yy_start;
X+     if ( yy_bp[-1] == '\n' )
X+ 	++yy_current_state;
X+ 
X+     for ( yy_cp = yytext; yy_cp < yy_c_buf_p; ++yy_cp )
X+ 	{
X+ 	register char yy_c = yy_ec[*yy_cp];
X+ 	if ( yy_accept[yy_current_state] )
X+ 	    {
X+ 	    yy_last_accepting_state = yy_current_state;
X+ 	    yy_last_accepting_cpos = yy_cp;
X+ 	    }
X+ 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X+ 	    {
X+ 	    yy_current_state = yy_def[yy_current_state];
X+ 	    if ( yy_current_state >= 274 )
X+ 		yy_c = yy_meta[yy_c];
X+ 	    }
X+ 	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X+ 	}
X+ 
X+     return ( yy_current_state );
X+     }
X+ 
X+ 
X+ #ifdef __STDC__
X+ static void yyunput( int c, register char *yy_bp )
X+ #else
X+ static void yyunput( c, yy_bp )
X+ int c;
X+ register char *yy_bp;
X+ #endif
X+ 
X+     {
X+     register char *yy_cp = yy_c_buf_p;
X+ 
X+     *yy_cp = yy_hold_char; /* undo effects of setting up yytext */
X+ 
X+     if ( yy_cp < yy_ch_buf + 2 )
X+ 	{ /* need to shift things up to make room */
X+ 	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X+ 	register char *dest = &yy_ch_buf[YY_BUF_SIZE + 2];
X+ 	register char *source = &yy_ch_buf[number_to_move];
X+ 
X+ 	while ( source > yy_ch_buf )
X+ 	    *--dest = *--source;
X+ 
X+ 	yy_cp += dest - source;
X+ 	yy_bp += dest - source;
X+ 
X+ 	if ( yy_cp < yy_ch_buf + 2 )
X+ 	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X+ 	}
X+ 
X+     if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X+ 	yy_cp[-2] = '\n';
X+ 
X+     *--yy_cp = c;
X+ 
X+     YY_DO_BEFORE_ACTION; /* set up yytext again */
X+     }
X+ 
X+ 
X+ static int input()
X+ 
X+     {
X+     int c;
X+     char *yy_cp = yy_c_buf_p;
X+ 
X+     *yy_cp = yy_hold_char;
X+ 
X+     if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X+ 	{ /* need more input */
X+ 	yytext = yy_c_buf_p;
X+ 	++yy_c_buf_p;
X+ 
X+ 	switch ( yy_get_next_buffer() )
X+ 	    {
X+ 	    /* this code, unfortunately, is somewhat redundant with
X+ 	     * that above
X+ 	     */
X+ 	    case EOB_ACT_END_OF_FILE:
X+ 		{
X+ 		if ( yywrap() )
X+ 		    {
X+ 		    yy_c_buf_p = yytext;
X+ 		    return ( EOF );
X+ 		    }
X+ 
X+ 		yy_ch_buf[0] = '\n';
X+ 		yy_n_chars = 1;
X+ 		yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X+ 		yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X+ 		yy_eof_has_been_seen = 0;
X+ 		yytext = yy_c_buf_p = &yy_ch_buf[1];
X+ 		yy_hold_char = *yy_c_buf_p;
X+ 
X+ 		return ( input() );
X+ 		}
X+ 		break;
X+ 
X+ 	    case EOB_ACT_RESTART_SCAN:
X+ 		yy_c_buf_p = yytext;
X+ 		break;
X+ 
X+ 	    case EOB_ACT_LAST_MATCH:
X+ 		YY_FATAL_ERROR( "unexpected last match in input()" );
X+ 	    }
X+ 	}
X+ 
X+     c = *yy_c_buf_p;
X+     yy_hold_char = *++yy_c_buf_p;
X+ 
X+     return ( c );
X+     }
X+ 
X+ 
X+ #ifdef __STDC__
X+ static void yyrestart( FILE *input_file )
X+ #else
X+ static void yyrestart( input_file )
X+ FILE *input_file;
X+ #endif
X+ 
X+     {
X+     if ( yyin != stdin )
X+ 	fclose( yyin );
X+ 
X+     yyin = input_file;
X+     yy_init = 1;
X+     }
X+ # line 126 "lev_comp.l"
X+ 
X+ #ifdef	AMIGA
X+ long *alloc(n)
X+ 	unsigned n;
X+ {
X+ 	return ((long *)malloc (n));
X+ }
X+ #endif
X*** others/Old/ovlmgr.doc	Mon Feb 19 23:34:04 1990
X--- others/ovlmgr.doc	Mon Feb 19 23:23:01 1990
X***************
X*** 1,6 ****
X  		     Brief notes about ovlmgr.asm
X  		     ----------------------------
X! 			 (revised 1989nov12)
X  
X  OVLMGR.ASM is a preliminary version of a multiple-residency overlay
X  manager for use with the Microsoft Overlay Linker. It is functionally
X--- 1,6 ----
X  		     Brief notes about ovlmgr.asm
X  		     ----------------------------
X! 		     (version 3.0.624: 1990Feb19)
X  
X  OVLMGR.ASM is a preliminary version of a multiple-residency overlay
X  manager for use with the Microsoft Overlay Linker. It is functionally
X***************
X*** 104,116 ****
X  NOTA BENE: This is a preliminary version of the overlay manager, but
X  by now it should be fairly well debugged. If you are considering
X  upgrading it please be aware that the following improvements are
X! planned for the next version (though who knows when delivery will
X! occur):
X  	Twice the speed
X  	EMS support
X! 	compatible versions of setjmp() and longjmp()
X! 	Integration with malloc() so the heap can grow
X  	Major code revamping
X  
X  Enjoy!
X  ------------------------------------------------------------------------
X--- 104,120 ----
X  NOTA BENE: This is a preliminary version of the overlay manager, but
X  by now it should be fairly well debugged. If you are considering
X  upgrading it please be aware that the following improvements are
X! planned for the next version (many of them are already written and are
X! now being debugged or tested):
X! 
X  	Twice the speed
X+ 	Better memory utilisation
X  	EMS support
X! 	i386 support
X! 	Compatible versions of setjmp() and longjmp()
X! 	A method of changing the C heap size without relinking
X  	Major code revamping
X+ 	Monitoring, tuning and debugging tools
X  
X  Enjoy!
X  ------------------------------------------------------------------------
X***************
X*** 160,165 ****
X--- 164,177 ----
X  
X  Locking overlays into memory is not really implemeted even though
X  reading the source code might make you think it was.
X+ 
X+ Although we have not found a way of supporting versions of DOS prior
X+ to 3.0, the overlay manager still does not check that it is running
X+ under 3.0 or better (a stupid oversight at the time of writing).
X+ 
X+ This is not actually the most recent version of the overlay manager,
X+ but it IS the most recent one that seems to run cleanly with NetHack.
X+ A phenomenon that we are still investigating....
X  ------------------------------------------------------------------------
X  BUG ALERT
X  
X***************
X*** 169,174 ****
X--- 181,203 ----
X  pointer, you *will* die with ours. Nothing in an overlay ever ends up
X  in the same segment as the linker anticipated.	You have been warned!
X  ------------------------------------------------------------------------
X+ BUGS FIXED
X+ 
X+ A couple of rather stupid and/or unpleasant bugs have been fixed in
X+ this version (unfortunately called 3.0.624):
X+ 
X+ The interrupt vectors are now restored correctly when the programme
X+ exits, making a number of strange and worrisome interactions with DOS
X+ go away.
X+ 
X+ The lru computation is now done correctly, reducing the amount of disk
X+ I/O dramatically, and bringing behaviour in line with the theoretical
X+ model.
X+ 
X+ The implementation of the exec() call is now significantly cleaner and
X+ the chance of unfortunate interactions with software run in a subshell
X+ is greatly reduced.
X+ ------------------------------------------------------------------------
X  FOOTNOTES
X  
X  (1) If you hunt through the code you will find a magic constant you
X***************
X*** 195,200 ****
X  part of NetHack and may be freely distributed as described in the
X  NetHack license.
X  ----------------------------------------------------------------------
X! Stephen P Spackman		       stephen@concour.cs.concordia.ca
X  ----------------------------------------------------------------------
X!      Copyright (C) 1989 Pierre G Martineau and Stephen P Spackman
X--- 224,230 ----
X  part of NetHack and may be freely distributed as described in the
X  NetHack license.
X  ----------------------------------------------------------------------
X! Stephen P Spackman		             stephen@tira.uchicago.edu
X! Pierre G Martineau             elevia!ozrout!pierre@clyde.concordia.ca
X  ----------------------------------------------------------------------
X!   Copyright (C) 1989, 1990 Pierre G Martineau and Stephen P Spackman
X*** others/Old/pctty.c	Mon Feb 19 23:35:31 1990
X--- others/pctty.c	Thu Jan 25 22:19:45 1990
X***************
X*** 3,9 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* tty.c - (PC) version */
X  
X! #define NEED_VARARGS
X  #include "hack.h"
X  
X  char erase_char, kill_char;
X--- 3,9 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* tty.c - (PC) version */
X  
X! #define NEED_VARARGS /* Uses ... */	/* comment line for pre-compiled headers */
X  #include "hack.h"
X  
X  char erase_char, kill_char;
X***************
X*** 25,31 ****
X  
X  /* reset terminal to original state */
X  void
X! settty(s) char *s; {
X  	end_screen();
X  	if(s) Printf(s);
X  	(void) fflush(stdout);
X--- 25,33 ----
X  
X  /* reset terminal to original state */
X  void
X! settty(s)
X! const char *s;
X! {
X  	end_screen();
X  	if(s) Printf(s);
X  	(void) fflush(stdout);
X***************
X*** 38,46 ****
X  /*VARARGS1*/
X  
X  void
X! error VA_DECL(char *,s)
X  	VA_START(s);
X! 	VA_INIT(s, char *);
X  	end_screen();
X  	putchar('\n');
X  	Vprintf(s,VA_ARGS);
X--- 40,48 ----
X  /*VARARGS1*/
X  
X  void
X! error VA_DECL(const char *,s)
X  	VA_START(s);
X! 	VA_INIT(s, const char *);
X  	end_screen();
X  	putchar('\n');
X  	Vprintf(s,VA_ARGS);
X
END_OF_FILE
if test 55350 -ne `wc -c <'patch7.20'`; then
    echo shar: \"'patch7.20'\" unpacked with wrong size!
fi
# end of 'patch7.20'
echo shar: End of archive 12 \(of 30\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
