Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: Notesfiles $Revision: 1.6.2.16 $; site pbear.UUCP
Path: utzoo!watmath!clyde!burl!ulysses!allegra!mit-eddie!think!pbear!peterb
From: peterb@pbear.UUCP
Newsgroups: net.sources.games
Subject: PC/IX Hack (2 of 5)
Message-ID: <2900005@pbear.UUCP>
Date: Tue, 28-May-85 18:05:00 EDT
Article-I.D.: pbear.2900005
Posted: Tue May 28 18:05:00 1985
Date-Received: Thu, 30-May-85 20:12:45 EDT
Lines: 2197
Nf-ID: #N:pbear:2900005:000:47017
Nf-From: pbear!peterb    May 28 18:05:00 1985


#!/bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #!/bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	hack.do.misc.c
#	hack.do.vars.h
#	hack.do1.c
#	hack.do_wear.c
#	hack.dog.c
#	hack.dog.h
#	hack.eat.c
#	hack.end.c
#	hack.foods.h
# This archive created: Tue May 28 17:52:18 1985
export PATH; PATH=/bin:$PATH
echo shar: extracting "'hack.do.misc.c'" '(7647 characters)'
if test -f 'hack.do.misc.c'
then
	echo shar: over-writing existing file "'hack.do.misc.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.do.misc.c'
X/*
X * Hack.do.misc.c
X */
X
X/* Routines to do various user commands */
X
X#include <signal.h>
X#include "hack.h"
X#include "hack.do.vars.h"
X /* (MT) has 'do' structures and lists */
X
Xextern char    *getenv (), UMISS[], WELDED[];
X
X#define MAXLEVEL       40
X
XOBJECT loseone ();
X
Xint     done1 ();
X
Xchar    upxstairs[MAXLEVEL], upystairs[MAXLEVEL];
X
Xrhack (cmd)
Xregister char  *cmd;
X{
X	register        FUNCTIONS * tlist = list;
X
X	if (!cmd) {
X		pline ("Rhack: 0");
X		impossible ();
X		return;
X	}
X	if (!*cmd || *cmd == -1)
X		return;		/* Probably interrupt? */
X	if (movecm (cmd)) {
X		if (multi)
X			flags.mv = 1;
X		domove ();
X		return;
X	}
X	if (movecm (lowc (cmd))) {
X		flags.run = 1;
X		multi = 80;
X		flags.mv = 1;
X		domove ();
X		return;
X	}
X	if (*cmd == 'f' && movecm (cmd + 1)) {
X		flags.run = 2;
X		multi = 80;
X		flags.mv = 1;
X		domove ();
X		return;
X	}
X	if (*cmd == 'F' && movecm (lowc (cmd + 1))) {
X		flags.run = 3;
X		multi = 80;
X		flags.mv = 1;
X		domove ();
X		return;
X	}
X	while (tlist -> f_char) {
X		if (*cmd == tlist -> f_char) {
X			(*(tlist -> f_funct)) ();
X			return;
X		}
X		tlist++;
X	}
X	pline ("Unknown command '%s'", cmd);
X	nomove ();
X}
X
Xdoredraw () {
X	docrt ();
X	nomove ();
X}
X
X/*
X * VARIABELE ARGUMENTS, but if not given the last argument will always
X * be a NULL.		(Michiel)
X */
X/*VARARGS*/
Xhackexec (num, file, arg1, arg2, arg3, arg4, arg5, arg6)
Xregister int    num;
Xregister char  *file, *arg1;
Xchar   *arg2, *arg3, *arg4, *arg5, *arg6;
X{
X	nomove ();
X	switch (fork ()) {
X		case -1: 
X			pline ("Fork failed. Will try again.");
X			hackexec (num, file, arg1, arg2, arg3, arg4,
X					arg5, arg6);
X			break;
X		case 0: 
X			if (num) {
X				signal (SIGINT, SIG_DFL);
X				setuid (getuid ());
X				hackmode (OFF);
X				cls ();
X				flush ();
X				if (num == 2)
X					chdir (getenv ("HOME"));
X			}
X			else
X				signal (SIGINT, SIG_IGN);
X			execl (file, file, arg1, arg2, arg3, arg4, arg5, arg6);
X			panic (NOCORE, "%s: cannot execute.", file);
X			break;
X		default: 
X			signal (SIGINT, SIG_IGN);
X			signal (SIGQUIT, SIG_IGN);
X			wait (0);
X			if (num) {
X				hackmode (ON);
X				docrt ();
X			}
X			signal (SIGINT, done1);
X			signal (SIGQUIT, SIG_DFL);
X			break;
X	}
X}
X
Xdohelp () {
X	hackexec (1, MORE, HELP, NULL);
X}
X
Xdosh () {
X	register char  *str;
X
X	if (str = getenv ("SHELL"))
X		hackexec (2, str, NULL);
X	else
X		hackexec (2, "/bin/sh", "-i", NULL);
X}
X
Xdowield () {
X	register        OBJECT wep;
X
X	multi = 0;
X	if (!(wep = getobj (")", "wield")))
X		flags.move = 0;
X	else if (uwep && uwep -> cursed)
X		pline (WELDED, weapons[uwep -> otyp].wepnam);
X	else {
X		uwep = wep;
X		if (uwep -> cursed)
X			pline ("The %s welds itself to your hand!",
X					weapons[uwep -> otyp].wepnam);
X		else
X			prinv (uwep);
X	}
X}
X
Xddodown () {
X	dostairs ("down");
X}
X
Xddoup () {
X	dostairs ("up");
X}
X
Xdostairs (dir)
Xregister char  *dir;
X{
X	if (u.ustuck ||
X			(*dir == 'd' && (u.ux != xdnstair || u.uy != ydnstair)) ||
X			(*dir == 'u' && (u.ux != xupstair || u.uy != yupstair))) {
X		pline ("You can't go %s here", dir);
X		nomove ();
X		return;
X	}
X	keepdogs (1);
X	unCoff (COFF, 1);
X	dosavelev ();
X	if (*dir == 'd')
X		dodown ();
X	else
X		doup ();
X	losedogs ();
X	if (u.ucham)
X		rescham ();
X	setCon (CON);
X	if (u.uhcursed)
X		docurse ();
X}
X
Xdosavelev () {
X	register        fd;
X
X	glo (dlevel);
X	fd = creat (lock, 0644);
X	savelev (fd);
X	close (fd);
X}
X
Xextern int      uid;
X
Xchecklev (dir)			/* Michiel: Geen geknoei */
Xregister char  *dir;
X{
X	if ((upxstairs[dlevel] != xupstair ||
X				upystairs[dlevel] != yupstair) && !wizard) {
X		clearlocks ();
X		panic (NOCORE, "Way %s has been changed...", dir);
X	}
X}
X
Xdodown () {
X	register        fd;
X
X	glo (++dlevel);
X	if ((fd = open (lock, 0)) < 0)
X		mklev ();
X	else {
X		if (maxdlevel < dlevel)
X			mklev ();/* Bad file  */
X		else
X			getlev (fd);
X		close (fd);
X		checklev ("down");
X	}
X	if (maxdlevel < dlevel)
X		maxdlevel = dlevel;/* Trapdoor/stairs */
X	u.ux = xupstair;
X	u.uy = yupstair;
X	inshop ();
X}
X
Xdoup () {
X	register        fd;
X
X	if (dlevel == 1)
X		done (ESCAPED);
X	glo (--dlevel);
X	if ((fd = open (lock, 0)) < 0)
X		panic (CORE, "Cannot open %s\n", lock);
X	getlev (fd);
X	close (fd);
X	checklev ("up");
X	u.ux = xdnstair;
X	u.uy = ydnstair;
X}
X
Xm_call () {
X	register        OBJECT obj;
X
X	obj = getobj ("?!=/", "call");
X	if (obj)
X		docall (obj);
X	flags.move = 0;
X}
X
Xdocall (obj)
Xregister        OBJECT obj;
X{
X	register char  *str, **str1;
X
X	pline ("Call it:");
X	getlin (buf);
X	flags.topl = 0;
X	if (!*buf)
X		return;
X	str = alloc (strlen (buf) + 1) -> Val;
X	strcpy (str, buf);
X	switch (obj -> olet) {
X		case '_': 
X			free (str);
X			return;
X		case '?': 
X			str1 = &scrcall[obj -> otyp];
X			break;
X		case '!': 
X			str1 = &potcall[obj -> otyp];
X			break;
X		case '/': 
X			str1 = &wandcall[obj -> otyp];
X			break;
X		case '=': 
X			str1 = &ringcall[obj -> otyp];
X			break;
X		default: 
X			pline ("What a weird(%c %d)thing to call", obj -> olet, obj -> otyp);
X
X	}
X	if (*str1)
X		free (*str1);
X	*str1 = str;
X}
X
Xdonull () {
X}
X
XMONSTER bhit ();
X
Xdothrow () {
X	register        OBJECT obj;
X	register        MONSTER monst;
X	register        tmp;
X	char    x, y;
X
X	obj = getobj ("#%)", "throw");
X /* One can also throw food */
X	if (!obj || !getdir ()) {
X		nomove ();
X		return;		/* Sets dx and dy to direction */
X	}
X	if (obj == uarm || obj == uarm2 || obj == uleft ||
X			obj == uright) {
X		pline ("You can't throw something you are wearing");
X		return;
X	}
X	if (obj == uwep && uwepcursed ())
X		return;
X	monst = bhit (dx, dy, 8);
X	x = dx;
X	y = dy;
X	obj = loseone (obj);	/* Separate one out from list */
X	if (monst) {
X		if (obj -> olet == ')') {
X			tmp = u.ulevel - 1 + monst -> data -> ac + abon ();
X			if (obj -> otyp <= W_AMMUNITION) {
X				if (!uwep || uwep -> otyp != obj -> otyp +
X						11)
X					tmp -= 4;
X				else {
X					if (uwep -> cursed)
X						tmp -= uwep -> spe;
X					else
X						tmp += uwep -> spe;
X				}
X			}
X			else {
X				if (obj -> cursed)
X					tmp -= obj -> spe;
X				else
X					tmp += obj -> spe;
X			}
X			if (tmp >= rnd (20)) {
X				if (hmon (monst, obj)) {
X					hit (weapons[obj -> otyp].wepnam,
X							monst);
X					cutworm (monst, x, y, obj -> otyp);
X				}
X				else
X					monst = 0;
X				if (obj -> otyp <= W_AMMUNITION &&
X						rn2 (2)) {
X					freeobj (obj);
X					if (!onbill (obj))
X						ofree (obj);
X					return;
X				}
X			}
X			else
X				miss (weapons[obj -> otyp].wepnam, monst);
X		}
X		else {
X			psee (IT1, x, y, UMISS, monst -> data -> mname, NULL);
X			if (obj -> olet == '%' && monst -> data -> mlet == 'd')
X				if (tamedog (monst, obj))
X					return;
X		}
X/* Awake monster if sleeping */
X		if (monst) {
X			monst -> msleep = 0;
X			if (monst == shopkeeper)
X				setangry ();
X		}
X	}
X	obj -> ox = x;
X	obj -> oy = y;
X	if (obj -> unpaid && inshproom (x, y))
X		subfrombill (obj);
X	if (!m_at (x, y))
X		newsym (x, y);
X}
X
X/* Create a new object (at fobj) of multiplicity 1
X				  remove obj from invent if necessary */
XOBJECT loseone (obj)
Xregister        OBJECT obj;
X{
X	register        OBJECT otmp;
X
X	if (!index ("/=", obj -> olet) && obj -> quan > 1) {
X		obj -> quan--;
X		otmp = newobj ();
X		*otmp = *obj;
X		otmp -> quan = 1;
X		otmp -> unpaid = 0;/* Obj is still on the bill */
X		otmp -> nobj = fobj;
X		fobj = otmp;
X	}
X	else {
X		if (obj == invent)
X			invent = invent -> nobj;
X		else {
X			for (otmp = invent; otmp -> nobj != obj;
X					otmp = otmp -> nobj);
X			otmp -> nobj = obj -> nobj;
X		}
X		obj -> nobj = fobj;
X		fobj = obj;
X	}
X	return (fobj);
X}
X
Xgetdir () {
X	pline ("What direction?");
X	flush ();
X	*buf = getchar ();
X	flags.topl = 0;
X	return (movecm (buf));
X}
X
Xdocurse () {
X	register        MONSTER mtmp;
X
X	for (mtmp = fmon; mtmp; mtmp = mtmp -> nmon) {
X		mtmp -> msleep = 0;
X		mtmp -> mtame = 0;
X	}
X	if (shopkeeper)
X		shopkeeper -> angry = 1;
X	if (vaultkeeper)
X		vaultkeeper -> angry = 1;
X}
SHAR_EOF
if test 7647 -ne "`wc -c 'hack.do.misc.c'`"
then
	echo shar: error transmitting "'hack.do.misc.c'" '(should have been 7647 characters)'
fi
echo shar: extracting "'hack.do.vars.h'" '(1033 characters)'
if test -f 'hack.do.vars.h'
then
	echo shar: over-writing existing file "'hack.do.vars.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.do.vars.h'
X/*
X * Hack.do.vars.h
X */
X
Xint 	doredraw(),  dodrop(),    dodrink(),    doread(),
X	dosearch(),  armwear(),   dowearring(), doremarm(),
X	doremring(), dopay(),     save(),       dowield(),
X	ddoinv(),    dozap(),     m_call(),     doset(),
X	dowhatis(),  dohelp(),    doeat(),      ddoup(),
X	ddodown(),   done1(),     donull(),     dothrow(),
X	doshow(),    dosh(),	  doreprint(),  gemsdrop();
X
X#ifdef DEBUG
Xint debug();
X#endif DEBUG
X
XFUNCTIONS list[] = {
X	'\020', doredraw, 	 /* was  '\014' */
X	'A', doreprint,	 /* Michiel: Repeat last message printed */
X#ifdef DEBUG
X	'D', debug,
X#endif DEBUG
X	'P', dowearring,
X	'Q', done1,
X	'R', doremring,
X	'G', gemsdrop,
X	'S', save,
X	'T', doremarm,
X	'W', armwear,
X	'a', doshow,	/* Michiel: show everything you're wearing */
X	'c', m_call,
X	'd', dodrop,
X	'e', doeat,
X	'i', ddoinv,
X	'o', doset,
X	'p', dopay,
X	'q', dodrink,
X	'r', doread,
X	's', dosearch,
X	't', dothrow,
X	'w', dowield,
X	'z', dozap,
X	'<', ddoup,
X	'>', ddodown,
X	'/', dowhatis,
X	'?', dohelp,
X	'!', dosh,
X	'\n', donull,
X	' ', donull,
X	0, 0
X};
SHAR_EOF
if test 1033 -ne "`wc -c 'hack.do.vars.h'`"
then
	echo shar: error transmitting "'hack.do.vars.h'" '(should have been 1033 characters)'
fi
echo shar: extracting "'hack.do1.c'" '(11115 characters)'
if test -f 'hack.do1.c'
then
	echo shar: over-writing existing file "'hack.do1.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.do1.c'
X/*
X * Hack.do1.c
X */
X
X#include "hack.h"
X
Xextern char     NOTHIN[], WAND[];
X
Xextern  MONSTER shopkeeper;
XMONSTER vaultkeeper;
X
Xchar   *wandeffect[] = {
X	"magic missile",
X	"bolt of fire",
X	"sleep ray",
X	"bolt of cold",
X	"death ray",
X	"bolt of confusion"
X};
X
X#define MAXLEVEL	40
X
Xchar    vaultflag[MAXLEVEL];
X
XMONSTER bhit ();
X
X
X
X/* More various user do commands */
X
X
X
X
Xdozap () {
X	register        OBJECT obj;
X	register        MONSTER mtmp;
X	char    zx, zy;
X	register        num;
X
X	if (!(obj = getobj ("/", "zap"))) {
X		nomove ();
X		return;
X	}
X	if (!obj -> spe) {
X		pline (NOTHIN);
X		return;
X	}
X	obj -> spe--;
X	if (obj -> otyp <= Z_CREATE_MON) {
X		switch (obj -> otyp) {
X
X			case Z_LIGHT: 
X				if (dlevel)
X					litroom ();
X				else
X					pline (NOTHIN);
X				break;
X
X			case Z_DETEC: 
X				if (!findit ())
X					return;
X				break;
X
X			case Z_CREATE_MON: 
X				makemon (0);
X				mnexto (fmon);
X				break;
X		}
X
X		if (oiden[obj -> otyp] & WANN)
X			return;
X		u.urexp += 10;
X		oiden[obj -> otyp] |= WANN;
X		return;
X	}
X	if (!getdir ()) {
X		obj -> spe++;
X		nomove ();
X		return;
X	}
X	if (obj -> otyp <= Z_TELEPORT) {
X		if (mtmp = bhit (dx, dy, rn1 (8, 6))) {
X			switch (obj -> otyp) {
X
X				case Z_EXHAUST: 
X					pline ("You fight and fight and fight......");
X					home ();
X					flush ();
X					sleep (2);
X					flags.topl = 0;
X					u.uhp -= mtmp -> mhp;
X					if (u.uhp <= 0) {
X						pseebl ("You cannot beat %s",
X								mtmp -> data -> mname);
X						pline ("You die....");
X						done (DIED);
X					}
X					else {
X						mtmp -> mhp = 0;
X						flags.dhp = 1;
X						killed (mtmp);
X					}
X					oiden[obj -> otyp] |= WANN;
X					break;
X
X				case Z_SLOW_MON: 
X					mtmp -> mspeed = MSLOW;
X					break;
X
X				case Z_SPEED_MON: 
X					mtmp -> mspeed = MFAST;
X					break;
X
X				case Z_UND_TUR: 
X					if (index (" WVZ&", mtmp -> data -> mlet)) {
X						mtmp -> mhp -= rnd (8);
X						if (alive (mtmp))
X							mtmp -> mflee = 1;
X					}
X					break;
X
X				case Z_POLYMORF: 
X					if (mtmp -> ale && !cansee (mtmp -> mx, mtmp -> my))
X						break;
X					if (mtmp == shopkeeper)
X						shkdead ();/* Michiel */
X					unstuck (mtmp);
X					newcham (mtmp, &mon[rn2 (8)][rn2 (7)]);
X					oiden[obj -> otyp] |= WANN;
X					return;
X
X				case Z_CAN: 
X					mtmp -> mcan = 1;
X					break;
X
X				case Z_TELEPORT: 
X					unstuck (u.ustuck);
X					oiden[obj -> otyp] |= WANN;
X					if (mtmp == shopkeeper)
X						setangry ();/* FRED */
X					else if (mtmp == vaultkeeper)
X						mtmp -> angry = 1;
X					rloc (mtmp);
X					break;
X
X			}
X		}
X		return;
X	}
X	if (obj -> otyp == Z_CLOSING) {
X		PART * room;
X
X		zx = u.ux + dx;
X		zy = u.uy + dy;
X		room = &levl[zx][zy];
X		while (room -> typ >= CORR) {
X			zx += dx;
X			zy += dy;
X			room = &levl[zx][zy];
X		}
X		if (room -> typ == DOOR || room -> typ == SDOOR) {
X			pline ("The %sdoor closes forever.",
X					room -> typ == SDOOR ? "secret " : "");
X			oiden[obj -> otyp] |= WANN;
X			room -> typ = WALL;
X			newsym (zx, zy);
X		}
X		return;
X	}
X	if (obj -> otyp == Z_DIGGING) {
X	/* This is further improved by Michiel and Fred */
X		PART * room;
X		int     range = 1;
X
X		zx = u.ux + dx;
X		zy = u.uy + dy;
X		num = ROOM;
X		for (;;) {
X			if (zx < 1 || zx > 78 || zy < 1 || zy > 21) {
X				zx -= dx;
X				zy -= dy;
X				break;
X			}
X			atl (zx, zy, '*');
X			at (zx, zy, '*');
X			++range;
X			room = &levl[zx][zy];
X			if (!xdnstair) {
X				if (zx < 3 || zx > 76 || zy < 3 ||
X						zy > 18)
X					break;
X				if (room -> typ == WALL) {
X					room -> typ = ROOM;
X					break;
X				}
X			}
X			else if (room -> typ == POOL)
X				goto check;
X			else if (num == ROOM || num == 10) {
X				if (room -> typ) {
X					if (room -> typ == VAULT)
X						vaultinit ();
X					if (room -> typ != ROOM) {
X						if (room -> typ == VAULT)
X							room -> typ = ROOM;
X						else
X						if (room -> typ != CORR)
X							room -> typ = DOOR;
X						if (num == 10)
X							break;
X						num = 10;
X					}
X				}
X				else
X					room -> typ = CORR;
X			}
X			else {
X				if (room -> typ == VAULT)
X					vaultinit ();
X				if (room -> typ % 4) {
X				/* WALL,(S)DOOR,ROOM */
X					room -> typ = DOOR;
X					break;
X				}
X				else
X					room -> typ = CORR;
X			}
X	check: 
X			newsym (zx, zy);
X			zx += dx;
X			zy += dy;
X		}
X		while (--range) {
X			newsym (zx, zy);
X			if (mtmp = m_at (zx, zy))
X				pmon (mtmp);
X			zx -= dx;
X			zy -= dy;
X		}
X	}
X	else
X		buzz (obj -> otyp, u.ux, u.uy, dx, dy);
X	oiden[obj -> otyp] |= WANN;
X}
X
Xhit (str, mtmp)
Xregister char  *str;
Xregister        MONSTER mtmp;
X{
X	psee (THEIT2, mtmp -> mx, mtmp -> my, "%s hits %s", str,
X			mtmp -> data -> mname);
X}
X
Xmiss (str, mtmp)
Xregister char  *str;
Xregister        MONSTER mtmp;
X{
X	psee (THEIT2, mtmp -> mx, mtmp -> my, "%s misses %s", str,
X			mtmp -> data -> mname);
X}
X
Xfindit () {
X	char    num, lx, hx, ly, hy;
X	register char   zx, zy;
X	register        GOLD_TRAP gtmp, gt1;
X
X	for (lx = u.ux; levl[lx - 1][u.uy].typ % CORR; lx--);/* typ!=0 */
X /* WALL, SDOOR, DOOR, or ROOM (see hack.h) */
X
X	for (hx = u.ux; levl[hx + 1][u.uy].typ % 4; hx++);
X	for (ly = u.uy; levl[u.ux][ly - 1].typ % 4; ly--);
X	for (hy = u.uy; levl[u.ux][hy + 1].typ % 4; hy++);
X	num = 0;
X	for (zy = ly; zy <= hy; zy++)
X		for (zx = lx; zx <= hx; zx++) {
X			if (levl[zx][zy].typ == SDOOR) {
X				levl[zx][zy].typ = DOOR;
X				atl (zx, zy, '+');
X				num++;
X			}
X			else if (gtmp = g_at (zx, zy, ftrap)) {
X				if (gtmp -> gflag == PIERC) {
X					mkmonat (PM_PIERC, zx, zy);
X					num++;
X					deltrap (gtmp);
X				}
X				else if (gtmp -> gflag == MIMIC) {
X					deltrap (gtmp);
X			M: 
X					mkmonat (PM_MIMIC, zx, zy);
X					num++;
X				}
X				else if (!gtmp -> gflag & SEEN) {
X					gtmp -> gflag |= SEEN;
X					atl (zx, zy, '^');
X					num++;
X				}
X			}
X			else if ((gtmp = g_at (zx, zy, fgold)) &&
X					!gtmp -> gflag) {
X				if (gtmp == fgold)
X					fgold = gtmp -> ngen;
X				else {
X					for (gt1 = fgold; gt1 -> ngen !=
X							gtmp; gt1 = gt1 -> ngen);
X					gt1 -> ngen = gtmp -> ngen;
X				}
X				free (gtmp);
X				goto M;
X			}
X		}
X	return (num);
X}
X
X/* Sets dx,dy to the final position of the weapon thrown */
XMONSTER bhit (ddx, ddy, range) {
X	register        MONSTER mtmp;
X
X	dx = u.ux;
X	dy = u.uy;
X	if (u.uswallow)
X		return u.ustuck;/* a3 */
X	while (range-- > 0) {
X		dx += ddx;
X		dy += ddy;
X		if (mtmp = m_at (dx, dy))
X			return (mtmp);
X		if (levl[dx][dy].typ < CORR) {
X			dx -= ddx;
X			dy -= ddy;
X			return (0);
X		}
X	}
X	return (0);
X}
X
Xbuzz (type, sx, sy, ddx, ddy)
Xregister        sx, sy;
X{
X	PART * lev;
X	register char   range, let;
X	register        MONSTER mtmp;
X	register        wandeftype = type - 11;
X
X	if (u.uswallow) {
X		pline ("The %s rips into the %s.",
X				wandeffect[wandeftype],
X				u.ustuck -> data -> mname);
X		zhit (u.ustuck, type);
X		alive (u.ustuck);/* a3 */
X		return;
X	}
X	range = rn1 (7, 7);
X	if (ddx == ddy)
X		let = '\\';
X	else if (ddx && ddy)
X		let = '/';
X	else if (ddx)
X		let = '-';
X	else
X		let = '|';
X	while (range-- > 0) {
X		sx += ddx;
X		sy += ddy;
X		if ((lev = &levl[sx][sy]) -> typ) {
X			at (sx, sy, let);
X			on (sx, sy);
X			lev -> new = 1;
X		}
X		if (mtmp = m_at (sx, sy)) {
X			if (mtmp == vaultkeeper)
X				mtmp -> angry = 1;
X			if (rnd (20) < 18 + mtmp -> data -> ac) {
X				zhit (mtmp, type);
X				if (alive (mtmp))
X					hit (wandeffect[wandeftype],
X							mtmp);
X				range -= 2;
X			}
X			else
X				miss (wandeffect[wandeftype], mtmp);
X		}
X		else if (sx == u.ux && sy == u.uy) {
X			if (rnd (20) < 18 + u.uac) {
X				range -= 2;
X				flags.dhp = 1;/* Michiel */
X				pline ("The %s hits you!",
X						wandeffect[wandeftype]);
X				switch (type) {
X					case Z_MAG_MISSILE: 
X						u.uhp -= d (2, 6);
X						break;
X					case Z_FIRE: 
X						if (u.ufireres) {
X							pline ("You don't feel hot!");
X							break;
X						}
X						u.uhp -= d (6, 6);
X						break;
X					case Z_SLEEP: 
X						nomul (-rnd (25));
X						break;
X					case Z_COLD: 
X						if (u.ucoldres) {
X							pline ("You don't feel cold!");
X							break;
X						}
X						u.uhp -= d (6, 6);
X						break;
X					case Z_DEATH: 
X						u.uhp = 0;
X						break;
X					case Z_CONF_MON: 
X						u.uconfused = d (4, 6);
X				}
X				if (u.uhp <= 0)
X					killer = wandeffect[wandeftype];
X			}
X			else
X				pline ("The %s wizzes by you!",
X						wandeffect[wandeftype]);
X		}
X		if (lev -> typ <= DOOR || lev -> typ == VAULT) {
X			psee (0, sx, sy, "%s bounces!",
X					wandeffect[wandeftype], NULL);
X			ddx = -ddx;
X			ddy = -ddy;
X			range--;
X		}
X	}
X}
X
Xzhit (mtmp, type)
Xregister        MONSTER mtmp;
Xregister        type;
X{
X	if (mtmp == shopkeeper)
X		setangry ();
X	switch (type) {
X		case Z_MAG_MISSILE: 
X			mtmp -> mhp -= d (2, 6);
X			break;
X		case Z_FIRE: 
X			if (index ("Dg", mtmp -> data -> mlet))
X				return;
X			mtmp -> mhp -= d (6, 6);
X			if (mtmp -> data -> mlet == 'Y')
X				mtmp -> mhp -= 7;
X			break;
X		case Z_SLEEP: 
X			mtmp -> mfroz = 1;
X			break;
X		case Z_COLD: 
X			if (index ("Ygf", mtmp -> data -> mlet))
X				return;
X			if (mtmp -> data -> mlet == 'D')
X				mtmp -> mhp -= 7;
X			mtmp -> mhp -= d (6, 6);
X			break;
X		case Z_DEATH: 
X			if (index ("WVZ ", mtmp -> data -> mlet))
X				return;
X			mtmp -> mhp = 0;
X			break;
X		case Z_CONF_MON: 
X			if (mtmp == u.ustuck)
X				return;
X			mtmp -> mconf = 1;
X			break;
X
X	}
X}
X
Xdowhatis () {
X	register        fd;
X	register char  *str;
X
X
X	pline ("Specify what? ");
X	flags.topl = 0;
X	getlin (buf);
X	str = buf;
X	while (*str == ' ')
X		str++;
X	nomove ();
X	buf[52] = '\0';
X	if (*(str + 1))
X		pline ("One character please.");
X	else if ((fd = open (DATA, 0)) < 0)
X		pline ("Cannot open data file!");
X	else {
X		lseek (fd, (long) (*str * 51), 0);
X		if (read (fd, buf, 51) > 0 && *buf != '\\')
X			pline (buf);
X		else
X			pline ("Unknown symbol.");
X		close (fd);
X	}
X}
X
Xdoshow () {			/* Michiel: Show everything you're wearing */
X	nomove ();
X	show (uarm2);
X	show (uarm);
X	show (uwep);
X	show (uleft);
X	show (uright);
X}
X
Xshow (otmp)
Xregister        OBJECT otmp;
X{
X	if (otmp)
X		prinv (otmp);
X}
X
Xdosearch () {
X	register char   x, y;
X	register        GOLD_TRAP tgen;
X
X	for (x = u.ux - 1; x < u.ux + 2; x++)
X		for (y = u.uy - 1; y < u.uy + 2; y++)
X			if (levl[x][y].typ == SDOOR && !rn2 (7)) {
X				levl[x][y].typ = DOOR;
X				atl (x, y, '+');
X				nomul (0);
X			}
X			else {
X				for (tgen = ftrap; tgen; tgen = tgen -> ngen)
X					if (tgen -> gx == x && tgen -> gy == y &&
X							(!rn2 (8) || ((!u.usearch) &&
X									tgen -> gflag & SEEN))) {
X						nomul (0);
X						pline ("You find a%s", traps[tgen -> gflag & 037]);
X						if ((tgen -> gflag & 037) ==
X								PIERC) {
X							deltrap (tgen);
X							mkmonat (PM_PIERC, x, y);
X							return;
X						}
X						if ((tgen -> gflag & 037) ==
X								MIMIC) {
X							deltrap (tgen);
X							mkmonat (PM_MIMIC, x, y);
X							return;
X						}
X						if (!(tgen -> gflag & SEEN)) {
X							tgen -> gflag |= SEEN;
X							atl (x, y, '^');
X						}
X					}
X			}
X}
X
Xdoset () {
X	pline ("Give one inventory per line? ");
X	flush ();
X	flags.oneline = (getchar () == 'y');
X	nomove ();
X}
X
X
X
X/*
X * The whole vault was implemented by Fred and Michiel 
X *
X */
X
X
Xstruct permonst treasurer = {
X	"treasurer", '@', 15, 12, -1, 4, 8, 0
X};
X
Xvaultinit () {
X	GOLD_TRAP gtmp;
X
X	if (vaultflag[dlevel])
X		return;
X	vaultflag[dlevel] = 1;;
X	makemon (&treasurer);
X	vaultkeeper = fmon;
X	for (gtmp = fgold; gtmp -> gflag < 10000; gtmp = gtmp -> ngen);
X	fmon -> mx = gtmp -> gx;
X	fmon -> my = gtmp -> gy;
X	if (!u.ublind)
X		pmon (fmon);
X}
SHAR_EOF
if test 11115 -ne "`wc -c 'hack.do1.c'`"
then
	echo shar: error transmitting "'hack.do1.c'" '(should have been 11115 characters)'
fi
echo shar: extracting "'hack.do_wear.c'" '(3655 characters)'
if test -f 'hack.do_wear.c'
then
	echo shar: over-writing existing file "'hack.do_wear.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.do_wear.c'
X/*
X * Hack.do_wear.c
X */
X
X#include "hack.h"
X
X#define CURSED		1
X#define NOTCURSED	0
X
Xoff_msg (otmp)
Xregister        OBJECT otmp;
X{
X	doname (otmp, buf);
X	pline ("You were wearing %s.", buf);
X}
X
Xdoremarm () {
X	register        OBJECT oldarm = uarm;
X
X	nomove ();
X	if (!uarm) {
X		pline ("Not wearing any armor.");
X		return;
X	}
X	flags.move = 1;
X	if (cursed (uarm))
X		return;
X	nomul (-armors[uarm -> otyp].delay);
X	u.uac += uarm -> spe;
X	uarm = uarm2;
X	uarm2 = 0;
X	off_msg (oldarm);
X	flags.dac = 1;
X}
X
Xdoremring () {
X
X	nomove ();
X	if (!uleft && !uright) {
X		pline ("Not wearing any ring.");
X		return;
X	}
X	if (!uleft)
X		dorr (&uright);
X	else if (!uright)
X		dorr (&uleft);
X	else
X		for (;;) {
X			pline ("What ring, Right or Left? ");
X			flush ();
X			*buf = getchar ();
X			flags.topl = 0;
X			if (*buf == '\n' || *buf == '\033')
X				return;
X			if (*buf == 'l' || *buf == 'L') {
X				dorr (&uleft);
X				return;
X			}
X			if (*buf == 'r' || *buf == 'R') {
X				dorr (&uright);
X				return;
X			}
X			if (*buf == '?')
X				doinv ("=", 0);
X		}
X}
X
Xdorr (ring)
Xregister        OBJECT * ring;
X{
X	register        OBJECT otmp = *ring;
X
X	if (cursed (otmp))
X		return;
X	*ring = 0;
X	doring (otmp, OFF);
X	off_msg (otmp);
X}
X
Xcursed (otmp)
Xregister        OBJECT otmp;
X{
X	if (otmp -> cursed) {
X		pline ("You can't. It appears to be cursed.");
X		return (CURSED);
X	}
X	return (NOTCURSED);
X}
X
Xarmwear () {
X	register        OBJECT otmp;
X
X	otmp = getobj ("[", "wear");
X	if (!otmp) {
X		nomove ();
X		return;
X	}
X	if (uarm) {
X		if (otmp -> otyp == A_ELVEN_CLOAK && !uarm2)
X			uarm2 = uarm;
X		else {
X			pline ("You are already wearing some armor.");
X			flags.move = 0;
X			return;
X		}
X	}
X	uarm = otmp;
X	nomul (-armors[otmp -> otyp].delay);
X	uarm -> known = 1;
X	u.uac -= uarm -> spe;
X	flags.dac = 1;
X}
X
Xdowearring () {
X	register        OBJECT otmp;
X
X	otmp = getobj ("=", "wear");
X	if (!otmp) {
XR: 
X		nomove ();
X		return;
X	}
X	if (uleft && uright) {
X		pline ("There are no more fingers to fill.");
X		goto R;
X	}
X	if (otmp == uleft || otmp == uright) {
X		pline ("You are already wearing that.");
X		goto R;
X	}
X	if (uleft)
X		uright = otmp;
X	else if (uright)
X		uleft = otmp;
X	else
X		while (!uright && !uleft) {
X			pline ("What finger, Right or Left? ");
X			flush ();
X			*buf = getchar ();
X			flags.topl = 0;
X			if (*buf == 'l' || *buf == 'L')
X				uleft = otmp;
X			else if (*buf == 'r' || *buf == 'R')
X				uright = otmp;
X		}
X	doring (otmp, ON);
X	prinv (otmp);
X}
X
Xdoring (obj, eff)
Xregister        OBJECT obj;
Xregister        eff;
X{
X	register        tmp;
X
X	if (!obj)
X		return;
X	tmp = obj -> spe;
X	if (eff == OFF)
X		tmp = -tmp;
X	if (uleft && uright && uleft == uright &&
X			obj -> otyp <= R_GAIN_STR)
X		return;
X /* If wearing the same ring sometimes the flag must remain actif. */
X	switch (obj -> otyp) {
X		case R_TELE: 
X			u.utel = eff;
X		case R_ADORNMENT: 
X			break;
X		case R_REGEN: 
X			u.uregen = eff;
X			break;
X		case R_SEARCH: 
X			u.usearch = eff;
X			break;
X		case R_SEE_INV: 
X			u.ucinvis = eff;
X			break;
X		case R_STEALTH: 
X			u.ustelth = eff;
X			break;
X		case R_FLOAT: 
X			u.ufloat = eff;
X			break;
X		case R_POISON_RES: 
X			u.upres = eff;
X			break;
X		case R_AGGRAV_MON: 
X			u.uagmon = eff;
X			break;
X		case R_HUNGER: 
X			u.ufeed = eff;
X			break;
X		case R_FIRE_RES: 
X			u.ufireres = eff;
X			break;
X		case R_COLD_RES: 
X			u.ucoldres = eff;
X			break;
X		case R_SHAPE: 
X			u.ucham = eff;
X			if (eff != OFF)
X				rescham ();
X			break;
X		case R_GAIN_STR: 
X			u.ustr += tmp;
X			u.ustrmax += tmp;
X			flags.dstr = 1;
X			break;
X		case R_DAM_INC: 
X			u.udaminc += tmp;
X			break;
X		case R_PROTECTION: 
X			u.uac -= tmp;
X			flags.dac = 1;
X			break;
X		default: 
X			pline ("Bad(%d)ring", obj -> otyp);
X			impossible ();
X	}
X}
SHAR_EOF
if test 3655 -ne "`wc -c 'hack.do_wear.c'`"
then
	echo shar: error transmitting "'hack.do_wear.c'" '(should have been 3655 characters)'
fi
echo shar: extracting "'hack.dog.c'" '(9408 characters)'
if test -f 'hack.dog.c'
then
	echo shar: over-writing existing file "'hack.dog.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.dog.c'
X/*
X * Hack.dog.c
X */
X
X#include        "hack.h"
X#include        "hack.dog.h"
X
X#define UNDEF   127		/* Some large number */
X#define EDOG(mp)        ( (struct edog *)(&(mp->mextra[0])) )
X
Xextern struct permonst  li_dog, dog, la_dog;
X
Xchar    SADFEEL[] = "You have a sad feeling for a moment, then it passes";
X
Xmakedog () {
X	if (makemon (&li_dog))
X		return;		/* Dogs were genocided */
X	mnexto (fmon);
X	initedog (fmon);
X}
X
Xinitedog (mtmp)
Xregister        MONSTER mtmp;
X{
X	mtmp -> mtame = 1;
X	EDOG (mtmp) -> hungrytime = 1000 + moves;
X	EDOG (mtmp) -> eattime = 0;
X	EDOG (mtmp) -> droptime = 0;
X	EDOG (mtmp) -> dropdist = 10000;
X	EDOG (mtmp) -> apport = 10;
X	EDOG (mtmp) -> carry = 0;
X}
X
X/* Attach the monsters that went down (or up) together with @ */
X
XMONSTER mydogs = 0;
X
Xlosedogs () {
X	register        MONSTER mtmp;
X
X	while (mtmp = mydogs) {
X		mydogs = mtmp -> nmon;
X		mtmp -> nmon = fmon;
X		fmon = mtmp;
X		mnexto (mtmp);
X	}
X}
X
Xkeepdogs (checkdist)
Xint     checkdist;
X{
X	register        MONSTER mtmp;
X	register        PART * dr;
X
X	for (mtmp = fmon; mtmp; mtmp = mtmp -> nmon)
X		if (mtmp -> mtame) {
X			if (checkdist && dist (mtmp -> mx, mtmp -> my) > 2) {
X				mtmp -> mtame = 0;/* Dog becomes wild */
X				mtmp -> mxlth = 0;
X				continue;
X			}
X			relmon (mtmp);
X			mtmp -> nmon = mydogs;
X			mydogs = mtmp;
X			dr = &levl[mtmp -> mx][mtmp -> my];
X			if (dr -> scrsym == mtmp -> data -> mlet)
X				dr -> scrsym = news0 (mtmp -> mx, mtmp -> my);
X		/* We destroyed the link, so use recursion */
X			keepdogs (checkdist);
X			return;	/* (admittedly somewhat primitive) */
X		}
X}
X
X#define GDIST(x, y) ((x - gx)*(x - gx) + (y - gy)*(y - gy) )
X#define DDIST(x, y) ((x - omx)*(x - omx) + (y - omy)*(y - omy) )
X
Xdog_move (mtmp, after)
Xregister        MONSTER mtmp;
X{
X	register        MONSTER mtmp2;
X	register struct edog   *edog = EDOG (mtmp);
X	int     nix, niy, omx, omy, appr, nearer, cnt, udist, zx, zy;
X	register        OBJECT obj;
X	register        GOLD_TRAP trap;
X	char    ddx, ddy, dogroom, uroom,
X	        gx = 0, gy = 0, gtyp;/* Current goal */
X
X	if (moves <= edog -> eattime)
X		return NOMOVE;	/* Dog is still eating */
X	omx = mtmp -> mx;
X	omy = mtmp -> my;
X	if (moves > edog -> hungrytime + 500 && !mtmp -> mconf) {
X		mtmp -> mconf = 1;
X		mtmp -> orig_hp /= 3;
X		if (mtmp -> mhp > mtmp -> orig_hp)
X			mtmp -> mhp = mtmp -> orig_hp;
X		psee (0, omx, omy, "%s is confused from hunger",
X				mtmp -> data -> mname);
X	}
X	else if (moves > edog -> hungrytime + 750 || mtmp -> mhp <= 0) {
X		if (!psee (0, omx, omy, "%s dies from hunger",
X					mtmp -> data -> mname))
X			pline (SADFEEL);
X		levlsym (omx, omy, mtmp -> data -> mlet);
X		delmon (mtmp);
X		return DEAD;
X	}
X	dogroom = inroom (omx, omy);
X	uroom = inroom (u.ux, u.uy);
X	udist = dist (omx, omy);
X
X/*
X * if we are carrying stg then we drop it (perhaps near @ )
X * Note: if apport == 1 then our behaviour is independent of udist
X */
X	if (edog -> carry) {
X		if (!rn2 (udist) || !rn2 (edog -> apport))
X			if (rn2 (10) < edog -> apport) {
X				relobj (mtmp);
X				if (edog -> apport > 1)
X					edog -> apport--;
X				edog -> carry = 0;
X			}
X	}
X	else {
X		if (obj = o_at (omx, omy))
X			if (rn2 (20) < edog -> apport + 3)
X				if (rn2 (udist) || !rn2 (edog -> apport)) {
X					edog -> carry = 1;
X					freeobj (obj);
X					levlsym (omx, omy, obj -> olet);
X					stlobj (mtmp, obj);
X				}
X	}
X
X/* First we look for food */
X	gtyp = UNDEF;		/* No goal as yet */
X	obj = fobj;
X	while (obj) {
X		if (obj -> olet == '%'
X				&& inroom (obj -> ox, obj -> oy) == dogroom
X				&& (gtyp == UNDEF || (gtyp != 1 && obj -> otyp == 1)
X					|| (((gtyp != 1 && obj -> otyp < 5)
X							|| (gtyp == 1 && obj -> otyp == 1))
X						&& DDIST (obj -> ox, obj -> oy) < DDIST (gx, gy)))) {
X			gx = obj -> ox;
X			gy = obj -> oy;
X			gtyp = obj -> otyp;
X		}
X		else if ((gtyp == UNDEF || gtyp == 67) && dogroom >= 0
X					&& inroom (obj -> ox, obj -> oy) == dogroom
X					&& uroom == dogroom
X				&& !edog -> carry && edog -> apport > rn2 (8)) {
X			gx = obj -> ox;
X			gy = obj -> oy;
X			gtyp = 66 + obj -> cursed;/* Random */
X		}
X		obj = obj -> nobj;
X	}
X	if (gtyp == UNDEF
X			|| (gtyp != 1 && gtyp != 66 && moves < edog -> hungrytime)) {
X		if (dogroom < 0 || dogroom == uroom) {
X			gx = u.ux;
X			gy = u.uy;
X		}
X		else {
X			int     tmp = rooms[dogroom].fdoor;
X
X			cnt = rooms[dogroom].doorct;
X			gx = gy = 100;/* Random, far away */
X			while (cnt--) {
X				if (dist (gx, gy) > dist (doors[tmp].x,
X							doors[tmp].y)) {
X					gx = doors[tmp].x;
X					gy = doors[tmp].y;
X				}
X				tmp++;
X
X			}
X			if (gy == 100)
X				panic (CORE, "No doors nearby?");
X			if (gx == omx && gy == omy) {
X				gx = u.ux;
X				gy = u.uy;
X			}
X		}
X		appr = 0;
X		if (udist >= 9)
X			appr++;
X		else if (mtmp -> mflee)
X			appr--;
X		if (after && udist <= 4 && gx == u.ux && gy == u.uy)
X			return NOMOVE;
X		if (udist > 1) {
X			if (levl[u.ux][u.uy].typ < ROOM || !rn2 (4) ||
X					(edog -> carry && rn2 (edog -> apport)))
X				appr = 1;
X		}
X/* If you have dog food he'll follow you more closely */
X		if (appr == 0) {
X			obj = invent;
X			while (obj) {
X				if (obj -> olet == '%' && obj -> otyp == 1) {
X					appr = 1;
X					break;
X				}
X				obj = obj -> nobj;
X			}
X		}
X	}
X	else
X		appr = 1;
X	if (mtmp -> mconf)
X		appr = 0;
X	nix = omx;
X	niy = omy;
X	cnt = 0;
X	for (ddx = -1; ddx <= 1; ddx++)
X		for (ddy = -1; ddy <= 1; ddy++) {
X			if (!ddx && !ddy)
X				continue;
X			zx = omx + ddx;
X			zy = omy + ddy;
X			if (mtmp2 = m_at (zx, zy)) {
X				if (mtmp2 -> data -> mhd >= mtmp -> data -> mhd + 2)
X					continue;
X				if (mtmp2 -> mtame)
X					continue;
X				if (after)
X					return NOMOVE;
X			/* Hit only once each move */
X				if (hitmm (mtmp, mtmp2) == HIT && rn2 (4) &&
X						hitmm (mtmp2, mtmp) == DEAD)
X					return DEAD;
X				return NOMOVE;
X			}
X			if (r_free (zx, zy, mtmp) && !(ddx && ddy
X						&& (levl[omx][omy].typ == DOOR
X							|| levl[zx][zy].typ == DOOR))) {
X/* M_at(zx,zy) is impossible here */
X
X/* Dog avoids unseen traps */
X				if ((trap = g_at (zx, zy, ftrap))
X						&& !(trap -> gflag & SEEN) && rn2 (10))
X					continue;
X
X/* Dog eschewes cursed objects but likes dog food */
X				obj = fobj;
X				while (obj) {
X					if (obj -> ox != zx || obj -> oy != zy)
X						goto nextobj;
X					if (obj -> cursed)
X						goto newdxy;
X					if (obj -> olet == '%' &&
X							(obj -> otyp == 1 || (obj -> otyp < 5 &&
X									edog -> hungrytime <= moves))) {
X						nix = zx;
X						niy = zy;
X						edog -> eattime = moves +
X							foods[obj -> otyp].delay;
X						edog -> hungrytime = moves + 5 *
X							foods[obj -> otyp].nutrition;
X						if (cansee (nix, niy)) {
X
X							char    buffer[BUFSZ];
X
X							doname (obj, buffer);
X							pline ("The %s ate %s.", mtmp -> data -> mname, buffer);
X						}
X						delobj (obj);
X/* perhaps this was a reward */
X						edog -> apport += 200 / (edog -> dropdist + moves - edog -> droptime);
X						goto newdogpos;
X					}
X			nextobj: 
X					obj = obj -> nobj;
X				}
X
X				nearer = GDIST (zx, zy) - GDIST (nix, niy);
X				nearer *= appr;
X				if (!nearer && !rn2 (++cnt) || nearer < 0
X						|| nearer > 0 && (omx == nix && omy ==
X							niy && !rn2 (3) || !rn2 (12))) {
X					nix = zx;
X					niy = zy;
X					if (nearer < 0)
X						cnt = 0;
X				}
X			}
X	newdxy: 	;
X		}
Xnewdogpos: 
X	if (nix != omx || niy != omy) {
X		mtmp -> mx = nix;
X		mtmp -> my = niy;
X	}
X	levlsym (omx, omy, mtmp -> data -> mlet);
X	pmon (mtmp);
X	return MOVE;
X}
X
Xhitmm (magr, mdef)
Xregister        MONSTER magr, mdef;
X{
X	register        MONSTDATA pa = magr -> data;
X	register        MONSTDATA pd = mdef -> data;
X	int     hit;
X	char    tmp, vis;
X
X	if (index ("Eay", magr -> data -> mlet))
X		return NOMOVE;
X	tmp = pd -> ac + pa -> mhd - 1;
X	if (mdef -> mconf || mdef -> mfroz || mdef -> msleep) {
X		tmp += 4;
X		mdef -> msleep = 0;
X	}
X	hit = (tmp >= rnd (20));
X	vis = (cansee (magr -> mx, magr -> my) &&
X			cansee (mdef -> mx, mdef -> my));
X	if (vis)
X		pline ("The %s %s the %s.", pa -> mname,
X				(hit) ? "hits" : "misses", pd -> mname);
X	else
X		pline ("You hear some noises %s.",
X				(dist (magr -> mx, magr -> my) > 15) ? "in the distance"
X				: "");
X	if (hit) {
X		if ((mdef -> mhp -= d (pa -> damn, pa -> damd)) <= 0) {
X			if (vis)
X				p2xthe ("%s is killed!", pd -> mname);
X			else
X			if (mdef -> mtame)
X				pline (SADFEEL);
X			unstuck (mdef);/* a3 */
X			relobj (mdef);
X			levlsym (mdef -> mx, mdef -> my, pd -> mlet);
X			magr -> orig_hp += rnd (pd -> mhd + 1);
X			if (magr -> mtame && magr -> orig_hp >
X					pa -> mhd << 3) {
X				if (pa == &li_dog)
X					magr -> data = pa = &dog;
X				else if (pa == &dog)
X					magr -> data = pa = &la_dog;
X			}
X			delmon (mdef);
X			hit = DEAD;
X		}
X	}
X	return hit;
X}
X
X/* Return roomnumber or -1 */
Xinroom (x, y)
Xchar    x, y;
X{
X	register        MKROOM * croom = &rooms[0];
X
X	if (xdnstair && dlevel)	/* a3 */
X		while (croom -> hx >= 0) {
X			if (croom -> hx >= x - 1 && croom -> lx <= x + 1
X					&& croom -> hy >= y - 1 && croom -> ly <= y + 1)
X				return (croom - rooms);
X			croom++;
X		}
X	return - 1;		/* In corridor or in maze */
X}
X
X#define NOTTAME 0
X#define TAME    1
X
Xtamedog (mtmp, obj)
Xregister        MONSTER mtmp;
Xregister        OBJECT obj;
X{
X	register        MONSTER mtmp2;
X
X	if (obj -> otyp >= 5 || mtmp -> mtame)
X		return NOTTAME;
X	psee (0, mtmp -> mx, mtmp -> my, "%s devours %s.",
X			mtmp -> data -> mname, foods[obj -> otyp].foodnam);
X	delobj (obj);
X	mtmp2 = newmonst (sizeof (struct edog));
X	*mtmp2 = *mtmp;
X	mtmp2 -> mxlth = sizeof (struct edog);
X	initedog (mtmp2);
X	mtmp2 -> nmon = fmon;
X	fmon = mtmp2;
X	delmon (mtmp);		/* %% */
X	return TAME;
X}
SHAR_EOF
if test 9408 -ne "`wc -c 'hack.dog.c'`"
then
	echo shar: error transmitting "'hack.dog.c'" '(should have been 9408 characters)'
fi
echo shar: extracting "'hack.dog.h'" '(375 characters)'
if test -f 'hack.dog.h'
then
	echo shar: over-writing existing file "'hack.dog.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.dog.h'
X/*
X * Hack.dog.h
X */
X
Xstruct edog {
X	unsigned        hungrytime;	/* At this time dog gets hungry */
X	unsigned        eattime;	/* Dog is eating */
X	unsigned        droptime;	/* Moment dog dropped object */
X	unsigned        dropdist;	/* Dist of drpped obj from @ */
X	unsigned        apport;		/* Amount of training */
X	unsigned        carry:	1;	/* The dog is carrying sth */
X};
SHAR_EOF
if test 375 -ne "`wc -c 'hack.dog.h'`"
then
	echo shar: error transmitting "'hack.dog.h'" '(should have been 375 characters)'
fi
echo shar: extracting "'hack.eat.c'" '(3170 characters)'
if test -f 'hack.eat.c'
then
	echo shar: over-writing existing file "'hack.eat.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.eat.c'
X/*
X * hack.eat.c
X */
X
X#include "hack.h"
X
Xextern char    *nomvmsg;
X
Xunsigned        starved = 0;	/* Michiel: after 30 times fainting you starve
X				   to death */
X
Xchar   *hu_stat[4] = {
X	"        ",
X	"Hungry  ",		/* Hunger texts used in main (each 8 chars
X				   long) */
X	"Weak    ",
X	"Fainting"
X};
X
Xdoeat () {
X	register        OBJECT otmp;
X	register        FOOD ftmp;
X
X	if (!(otmp = getobj ("%", "eat"))) {
X		nomove ();
X		return;
X	}
X	starved = 0;
X	ftmp = &foods[otmp -> otyp];
X	if (!rn2 (7)) {
X		pline ("Blecch!  Rotten food!");
X		if (!rn2 (4)) {
X			pline ("You feel rather light headed.");
X			u.uconfused += d (2, 4);
X		}
X		else if (!rn2 (4) && !u.ublind) {
X			pline ("Everything suddenly goes dark.");
X			u.ublind = d (2, 10);
X			unCoff (COFF, 0);
X		}
X		else if (!rn2 (3)) {
X			pline ("The world spins and goes dark.");
X			nomul (-rnd (10));
X			nomvmsg = "You are conscious again";
X		}
X		lesshungry (ftmp -> nutrition >> 2);
X	}
X	else {
X		multi = -ftmp -> delay;
X		switch (otmp -> otyp) {
X
X			case F_FOOD: 
X				if (u.uhunger < 500)
X					pline ("That food really hit the spot!");
X				else if (u.uhunger < 1000)
X					pline ("That satiated your stomach!");
X				else if (u.uhunger < 1500) {
X					pline ("You're having a hard time getting all that food down.");
X					multi -= 2;
X				}
X				else {
X					pline ("You choke over your food.");
X					more ();
X					killer = ftmp -> foodnam;
X					done (CHOKED);
X				}
X				lesshungry (ftmp -> nutrition);
X				if (multi < 0)
X					nomvmsg = "You finished your meal.";
X				break;
X
X			case F_TRIPE: 
X				pline ("Yak - dog food!");
X				if (rn2 (2)) {
X					pline ("You vomit.");
X					lesshungry (-20);
X				}
X				else
X					lesshungry (ftmp -> nutrition);
X				break;
X
X			default: 
X				pline ("That %s was delicious!", ftmp -> foodnam);
X				lesshungry (ftmp -> nutrition);
X				break;
X		}
X	}
X	if (multi < 0 && !nomvmsg) {
X		static char     msgbuf[40];
X
X		sprintf (msgbuf, "You finished eating your %s.",
X				ftmp -> foodnam);
X		nomvmsg = msgbuf;
X	}
X	useup (otmp);
X}
X
Xlesshungry (num)		/* Eat stg or drink fruit juice */
Xregister        num;
X{
X	register        newhunger;
X
X	newhunger = u.uhunger + num;
X	if (u.uhunger < 151 && newhunger > 150) {
X		if (u.uhunger < 51 && u.ustr < u.ustrmax)
X			losestr (-1);
X		u.uhs = 0;
X		goto Ldohs;
X	}
X	if (u.uhunger < 51 && newhunger > 50) {
X		pline ("You only feel hungry now.");
X		if (u.ustr < u.ustrmax)
X			losestr (-1);
X		u.uhs = 1;
X		goto Ldohs;
X	}
X	if (u.uhunger <= 0 && newhunger < 50) {
X		pline ("You feel weak now.");
X		u.uhs = 2;
XLdohs: 
X		flags.dhs = 1;
X	}
X	u.uhunger = newhunger;
X}
X
Xgethungry () {			/* Called in main */
X	--u.uhunger;
X	if ((u.uregen || u.ufeed) && moves % 2)
X		u.uhunger--;
X	if (u.uhunger <= 150 && !u.uhs) {
X		pline ("You are beginning to feel hungry.");
X		u.uhs = 1;
X		goto Ldohs;
X	}
X	if (u.uhunger <= 50 && u.uhs == 1) {
X		pline ("You are beginning to feel weak.");
X		losestr (1);
X		u.uhs = 2;
X		goto Ldohs;
X	}
X	if (u.uhunger <= 0) {
X		pline ("You faint from lack of food.");
X		if (starved++ == 100) {
X			pline ("You starve!");
X			more ();
X			done (STARVED);
X		}
X		nomul (-20);
X		u.uhunger = rn1 (4, 22);
X		if (u.uhs != 3) {
X			u.uhs = 3;
X	Ldohs: 
X			flags.dhs = 1;
X		}
X	}
X}
SHAR_EOF
if test 3170 -ne "`wc -c 'hack.eat.c'`"
then
	echo shar: error transmitting "'hack.eat.c'" '(should have been 3170 characters)'
fi
echo shar: extracting "'hack.end.c'" '(4599 characters)'
if test -f 'hack.end.c'
then
	echo shar: over-writing existing file "'hack.end.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.end.c'
X/*
X * Hack.end.c
X */
X
X#include "hack.h"
X#include <signal.h>
X
X#define MAXLEVEL	40
X
Xextern char     plname[], *itoa (), *setan ();
X
Xextern int      billct, rfile;
X
Xchar    maxdlevel = 0, *strcat ();
X
Xchar   *statxx[] = {
X	"choked",
X	"died",
X	"starved",
X	"drowned",
X	"quit",
X	"escaped"
X};
X
Xdone1 () {
X	register char   c;
X
X	nomove ();
X	signal (SIGINT, done1);
X	pline ("Really quit?");
X	flush ();
X	if ((c = getchar ()) == 'y')
X		done (QUIT);
X	else if (c == 'S')
X		hangup ();
X}
X
Xdone (status)
Xregister int    status;
X{
X	if (wizard && status != QUIT && status != ESCAPED) {
X		u.ustr = (u.ustrmax += 2);
X		u.uhp = (u.uhpmax += 10);
X		u.uac--;
X		if (uwep)
X			uwep -> spe++;
X		pline ("For some reason you are still alive.");
X		nomove ();
X		flags.botl = 1;
X		return;
X	}
X	if (status == QUIT && u.uhp <= 0)
X		status = DIED;
X	if (billct)
X		paybill ();
X	clearlocks ();
X	if (status < QUIT) {	/* Not when quit or escaped */
X#ifndef DEBUG
X		savebones ();
X#endif DEBUG
X		outrip ();
X	}
X	hackmode (OFF);
X	cls ();
X	printf ("Goodbye %s...\n\n", plname);
X	u.urexp += u.ugold;
X	if (status == DIED) {
X		strcpy (killer, setan (killer));
X		u.urexp -= u.ugold / 10;
X	}
X	else
X		killer = statxx[status];
X	if (status == ESCAPED) {
X		OBJECT otmp;
X
X		u.urexp += 150;
X		for (otmp = invent; otmp; otmp = otmp -> nobj) {
X			if (otmp -> olet == '*')
X				u.urexp += otmp -> quan * 10 * rnd (250);
X			else if (otmp -> olet == '"')
X				u.urexp += 25000;
X		}
X		printf ("You escaped from the dungeon");
X	}
X	else
X		printf ("You %s on dungeon level %d,", statxx[status],
X				dlevel);
X	printf (" with %lu points\n", u.urexp);
X	printf ("and %lu pieces of gold, after %u moves.\n",
X			u.ugold, moves);
X	printf ("You were level %d with a maximum of %d hit points when you %s.\n\n", u.ulevel, u.uhpmax, statxx[status]);
X	topten ();
X	flush ();
X	exit (0);
X}
X
X#define	NAMESIZE	 8
X#define	DEATHSIZE	40
X#define TOPPRINT	15	/* Aantal scores dat wordt afgedrukt */
X#define	TOPLIST		25	/* Length of 'top ten' list */
X
Xtopten () {
X	int     tmp;
X	struct recitem {
X		long    points;
X		int     level, maxlvl, hp, maxhp;
X		char    str[NAMESIZE + 1], death[DEATHSIZE + 1];
X	}               rec[TOPLIST + 1], *t1;
X	register        flg;
X
X	for (t1 = rec; t1 < &rec[TOPLIST]; t1++)
X		if (read (rfile, t1, sizeof (struct recitem)) <= 0)
X			                                                t1 -> points = 0;
X	flg = 0;
X	if (u.urexp > rec[TOPLIST - 1].points && !wizard) {
X		signal (SIGINT, SIG_IGN);
X		if (u.urexp > rec[TOPPRINT - 1].points)
X			printf ("You made the top %d list!\n", TOPPRINT);
X		if (lseek (rfile, 0L, 0) < 0)
X			panic (CORE, "Cannot lseek on record file");
X
X/* Stick in new entry. NB: we save the last few
X			entries that disappeared from the list */
X
X		for (tmp = TOPLIST - 2; tmp >= 0 && rec[tmp].points <
X				u.urexp; tmp--)
X			rec[tmp + 1] = rec[tmp];
X		tmp++;		/* Point to right place */
X		rec[tmp].points = u.urexp;
X		rec[tmp].level = dlevel;
X		rec[tmp].maxlvl = maxdlevel;
X		rec[tmp].hp = u.uhp;
X		rec[tmp].maxhp = u.uhpmax;
X		strncpy (rec[tmp].str, plname, NAMESIZE);
X		rec[tmp].str[NAMESIZE] = 0;
X		strncpy (rec[tmp].death, killer, DEATHSIZE);
X		rec[tmp].death[DEATHSIZE] = 0;
X		flg++;
X	}
X	printf ("Number Points Name\n");
X	for (t1 = rec, tmp = 1; t1 < &rec[TOPLIST]; tmp++, t1++) {
X		char    killed = 0;
X
X		if (flg && t1 -> points)
X			write (rfile, t1, sizeof (struct recitem));
X		if (t1 >= &rec[TOPPRINT] || t1 -> points == 0)
X			continue;
X		printf ("%2d  %6ld %8s ", tmp, t1 -> points, t1 -> str);
X		if (*t1 -> death == 'e')
X			printf ("escaped the dungeon [max level %d]", t1 -> maxlvl);
X		else {
X			switch (t1 -> death[1]) {
X				case 'u': 
X					printf ("quit");
X					break;
X				case 'h': 
X					printf ("choked on his food");
X					break;
X				case 't': 
X					printf ("starved");
X					break;
X				case 'r': 
X					printf ("drowned");
X					break;
X				default: 
X					printf ("was killed");
X					killed++;
X			}
X			printf (" on%s level %d",
X					killed ? "" : " dungeon", t1 -> level);
X			if (t1 -> maxlvl != t1 -> level)
X				printf (" [%d]", t1 -> maxlvl);
X		}
X		if (killed)
X			printf (" by %s", t1 -> death);
X		putchar ('.');
X		if (t1 -> maxhp)
X			printf (" Hp: %s [%d]", (t1 -> hp > 0) ?
X					itoa (t1 -> hp) : "-", t1 -> maxhp);
X		putchar ('\n');
X	}
X	close (rfile);
X}
X
Xchar   *
X        itoa (a)
Xregister int    a;
X{
X	static char     buffer[8];
X
X	sprintf (buffer, "%d", a);
X	return (buffer);
X}
X
Xclearlocks () {
X	register        x;
X
X	signal (SIGINT, SIG_IGN);
X	for (x = 1; x <= MAXLEVEL; x++) {
X		glo (x);
X		if (unlink (lock))
X			break;
X	}
X#ifdef DEBUG
X	glo (0);
X	unlink (lock);
X#endif DEBUG
X}
X
Xhangup () {
X	save ();
X	clearlocks ();
X	exit (1);
X}
SHAR_EOF
if test 4599 -ne "`wc -c 'hack.end.c'`"
then
	echo shar: error transmitting "'hack.end.c'" '(should have been 4599 characters)'
fi
echo shar: extracting "'hack.foods.h'" '(499 characters)'
if test -f 'hack.foods.h'
then
	echo shar: over-writing existing file "'hack.foods.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.foods.h'
X/*
X * Hack.foods.h
X */
X
X/* Dog eats foods 0-4 but prefers 1 above 0, 2, 3, 4 */
X
Xstruct food foods[] = {
X	{ "food ration",  50, 5, 800 },
X	{ "tripe ration", 20, 1, 200 },
X	{ "pancake",  	   3, 1, 200 },
X	{ "dead lizard",   3, 0,  40 },
X	{ "cookie",	   7, 0,  40 },
X	{ "orange",	   3, 0,  80 },
X	{ "apple",	   3, 0,  50 },
X	{ "pear",	   3, 0,  50 },
X	{ "melon",	   1, 0, 100 },
X	{ "banana",	   3, 0,  80 },
X	{ "candy bar",	   3, 0, 100 },
X	{ "egg",	   1, 0,  80 },
X	{ "PROG ERROR",  100, 0,   0 }
X};
SHAR_EOF
if test 499 -ne "`wc -c 'hack.foods.h'`"
then
	echo shar: error transmitting "'hack.foods.h'" '(should have been 499 characters)'
fi
#	End of shell archive
exit 0
