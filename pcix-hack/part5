Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: Notesfiles $Revision: 1.6.2.16 $; site pbear.UUCP
Path: utzoo!watmath!clyde!burl!ulysses!allegra!mit-eddie!think!pbear!peterb
From: peterb@pbear.UUCP
Newsgroups: net.sources.games
Subject: PC/IX Hack (5 of 5)
Message-ID: <2900008@pbear.UUCP>
Date: Tue, 28-May-85 18:07:00 EDT
Article-I.D.: pbear.2900008
Posted: Tue May 28 18:07:00 1985
Date-Received: Thu, 30-May-85 08:32:47 EDT
Lines: 2366
Nf-ID: #N:pbear:2900008:000:50494
Nf-From: pbear!peterb    May 28 18:07:00 1985


#!/bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #!/bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	hack.str.c
#	hack.vars.h
#	hack.weapons.h
#	hack.worm.c
#	mklev.c
#	mklev.make.c
#	mklev.mkobj.c
#	mklev.svlev.c
#	rnd.c
#	show.c
#	string.s
# This archive created: Tue May 28 17:53:52 1985
export PATH; PATH=/bin:$PATH
echo shar: extracting "'hack.str.c'" '(2444 characters)'
if test -f 'hack.str.c'
then
	echo shar: over-writing existing file "'hack.str.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.str.c'
X/*
X * Hack.str.c
X */
X
X/*
X * strprint() : Cheap alternative for sprintf() and printf(), by
X * Fred and Michiel. If you want the normal io just define NORMAL_IO
X */
X
X
X#include "hack.h"
X
X#ifndef NORMAL_IO
X
X#define ARINDEX		512
Xstatic char output_buffer[ARINDEX];
Xstatic arcount = 0;
X
Xchar *litoa();
X
X/*VARARGS10*/
Xstrprint( dest, src, argptr )
Xregister char *dest, *src;
Xregister int *argptr;
X{
X	register kar;
X	register char *string;
X	register field;
X	int negated;
X	int printflag = 0;
X	static char extra[512];
X
X	if ( dest == STDOUT ) {
X		dest = extra;
X		printflag++;
X	}
X
X	while( *src ) {
X		if ( *src == '%' ) {
X			field = 0;
X			negated = 0;
X			if ( *++src == '-' )
X				++negated;
X			else
X				--src;
X			while( *++src & 060 && *src <= '9' )
X				field = 10*field + ( *src & 017 );
X			if ( (kar = *src) == '%' )
X				*dest++ = '%';
X			else if ( kar == 'c' )
X				*dest++ = (char)*argptr++;
X			else {
X				switch ( kar ) {
X					
X				case 'd' :
X				case 'u' :
X					string = litoa((long)(*argptr++));
X					break;
X				case 'l' :
X					kar = *(++src);
X					string = litoa( *(((long*) argptr)++) );
X					break;
X				case 's' :
X					string = (char *)(*argptr++);
X					break;
X				default :
X					strcpy( string, "%'" );
X				}
X				if ( field )
X					field -= strlen( string );
X				if ( field > 0 && !negated )
X					while( --field >= 0 )
X						*dest++ = ' ';
X				while( *dest++ = *string++ )
X					;
X				dest--;  /* Remove '\0' character */
X				if ( field > 0 && negated )
X					while( --field >= 0 )
X						*dest++ = ' ';
X			}
X			src++;
X		}	
X		else
X			*dest++ = *src++;
X	}
X	*dest = 0;
X	if ( printflag ) {
X		WRITE( extra, strlen(extra) );
X	}
X}
X
Xchar *
Xlitoa( l_arg )
Xlong l_arg;
X{
X	static char string[20];
X	register int i = 0;
X	register char *str2 = string;
X	char pipo[20];
X
X	if ( !l_arg )
X		return( "0" );
X	if ( l_arg < 0L ) {
X		*str2++ = '-';
X		l_arg = -l_arg;
X	}
X
X	while( l_arg ) {
X		pipo[i++] = (int)( l_arg % 10L + '0');
X		l_arg /= 10L;
X	}
X	while( --i >= 0 ) /* Michiel */
X		*str2++ = pipo[i];
X	*str2 = '\0';
X	return( string );
X}
X
XWRITE( string , length )
Xregister char *string;
Xregister length;
X{
X	if ( arcount + length >= ARINDEX )
X		flush();
X	strcat( output_buffer, string );
X	arcount += length;
X}
X
Xflush()
X{
X	write( 1, output_buffer, arcount );
X	arcount = 0;
X	output_buffer[0] = 0;
X}
X
Xputchar ( c )
X{
X	WRITE( &c, 1 );
X}
X
Xprintf( fmt, args )
X{
X	strprint( STDOUT, fmt, &args );
X}
X
Xsprintf( buffer, fmt, args )
X{
X	strprint( buffer, fmt, &args );
X}
X#endif NORMAL_IO
SHAR_EOF
if test 2444 -ne "`wc -c 'hack.str.c'`"
then
	echo shar: error transmitting "'hack.str.c'" '(should have been 2444 characters)'
fi
echo shar: extracting "'hack.vars.h'" '(2824 characters)'
if test -f 'hack.vars.h'
then
	echo shar: over-writing existing file "'hack.vars.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.vars.h'
X/*
X * Hack.vars.h
X */
X
X#define	SIZE(x)	(sizeof x)/(sizeof x[0])
X
Xchar    NOTHIN[]   = "Nothing Happens",
X        WCLEV[]    = "Welcome to level %d.",
X        STOPGLOW[] = "Your hands stop glowing blue.",
X        UMISS[]    = "You miss %s.";
X
X
Xchar   *traps[] = {
X	" bear trap",
X	"n arrow trap",
X	" dart trap",
X	" trapdoor",
X	" teleportation trap",
X	" pit",
X	" sleeping gas trap",
X	" piercer",
X	" mimic"
X};
X
X#include "hack.foods.h"
X#include "hack.armors.h"
X#include "hack.weapons.h"
X
Xchar   *pottyp[] = {
X	"restore strength",
X	"confuse monster",
X	"invisibility",
X	"fruit juice",
X	"healing",
X	"paralysis",
X	"monster detection",
X	"object detection",
X	"sickness",
X	"confusion",
X	"gain strength",
X	"speed",
X	"blindness",
X	"gain level",
X	"extra healing"
X};
X
X
X
Xchar   *potcol[] = {
X	"ebony",
X	"magenta",
X	"clear",
X	"brilliant blue",
X	"sky blue",
X	"emerald",
X	"dark green",
X	"ruby",
X	"purple-red",
X	"swirly",
X	"white",
X	"yellow",
X	"purple",
X	"puce",
X	"pink",
X	"smokey",
X	"glowing",
X	"bubbly",
X	"orange"
X};
X
Xchar   *potcall[SIZE (pottyp)];
X
X /* SCROLLS */
X
Xchar   *scrtyp[] = {
X	"enchant armor",
X	"losing",
X	"curse levels",
X	"remove curse",
X	"enchant weapon",
X	"create monster",
X	"damage weapon",
X	"genocide",
X	"destroy armor",
X	"light",
X	"transportation",
X	"gold detection",
X	"identify",
X	"magic mapping",
X	"fire"
X};
X
X
Xchar   *scrnam[] = {
X	"VELOX NEB",
X	"FOOBIE BLETCH",
X	"TEMOV",
X	"GARVEN DEH",
X	"ZELGO MER",
X	"ANDOVA BEGARIN",
X	"ELAM EBOW",
X	"KERNOD WEL",
X	"THARR",
X	"VENZAR BORGAVVE",
X /* "ELBIB YLOH", */
X	"VERR YED HORRE",
X	"JUYED AWK YACC",
X	"HACKEM MUCHE",
X	"LEP GEX VEN ZEA",
X	"DAIYEN FOOELS"
X};
Xchar   *scrcall[SIZE (scrtyp)];
X
X
X /* WANDS */
X
Xchar   *wantyp[] = {
X	"light",
X	"secret door + trap detection",
X	"create monster",
X	"exhaustion",
X	"slow monster",
X	"speed monster",
X	"undead turning",
X	"polymorph",
X	"cancellation",
X	"teleport monster",
X	"digging",
X	"magic missile",
X	"fire",
X	"sleep",
X	"cold",
X	"death",
X	"confusion",
X	"door closing"
X};
X
X
Xchar   *wannam[] = {
X	"oak",
X	"ebony",
X	"runed",
X	"long",
X	"short",
X	"curved",
X	"steel",
X	"aluminium",
X	"iron",
X	"marble",
X	"pine",
X	"maple",
X	"brass",
X	"silver",
X	"copper",
X	"balsa",
X	"zinc",
X	"platinum"
X};
Xchar   *wandcall[SIZE (wantyp)];
X
X
X /* RINGS */
X
Xchar   *ringtyp[] = {
X	"adornment",
X	"teleportation",
X	"regeneration",
X	"searching",
X	"see invisible",
X	"stealth",
X	"floating",
X	"poison resistance",
X	"aggravate monster",
X	"hunger",
X	"fire resistance",
X	"cold resistance",
X	"protection from shape-changers",
X	"gain strength",
X	"increase damage",
X	"protection"
X};
X
X
Xchar   *rinnam[] = {
X	"blackened",
X /* "ivory", */
X	"granite",
X	"silver",
X	"ruby",
X	"jade",
X	"diamond",
X	"copper",
X	"gold",
X	"shining",
X	"tiger eye",
X	"agate",
X	"moonstone",
X	"sapphire",
X	"pearl",
X	"topaz",
X /* "black onix", */
X	"wired"
X};
X
Xchar   *ringcall[SIZE (ringtyp)], oiden[40], oldux, olduy;
SHAR_EOF
if test 2824 -ne "`wc -c 'hack.vars.h'`"
then
	echo shar: error transmitting "'hack.vars.h'" '(should have been 2824 characters)'
fi
echo shar: extracting "'hack.weapons.h'" '(537 characters)'
if test -f 'hack.weapons.h'
then
	echo shar: over-writing existing file "'hack.weapons.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.weapons.h'
X/*
X * Hack.weapons.h
X */
X
X/*
X * weapons 0-4 come several at a time
X * weapons 0-2 are shot using 11-13
X */
X
Xstruct weapon weapons[] = {
X	{ "arrow",		7, 6, 6 },
X	{ "sling bullet",	7, 4, 6 },
X	{ "crossbow bolt",	7, 4, 6 },
X	{ "dart",		7, 3, 2 },
X	{ "mace",		7, 6, 6 },
X	{ "axe",		7, 6, 4 },
X	{ "flail",		7, 6, 4 },
X	{ "long sword",		9, 8,12 },
X	{ "two handed sword",	7,10, 6 },
X	{ "dagger",		7, 4, 3 },
X	{ "spear",		7, 6, 8 },
X	{ "bow",		7, 4, 6 },
X	{ "sling",		7, 6, 6 },
X	{ "crossbow",		7, 4, 6 },
X	{ "PROG ERROR",	      100, 0, 0 }
X };
SHAR_EOF
if test 537 -ne "`wc -c 'hack.weapons.h'`"
then
	echo shar: error transmitting "'hack.weapons.h'" '(should have been 537 characters)'
fi
echo shar: extracting "'hack.worm.c'" '(3953 characters)'
if test -f 'hack.worm.c'
then
	echo shar: over-writing existing file "'hack.worm.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.worm.c'
X/*
X * Hack.worm.c
X */
X
X#include "hack.h"
X
X/* Linked list, tail first */
XWORMSEGMENT wsegs[32], wheads[32];
X
Xunsigned        wgrowtime[32];
X
Xgetwn (mtmp)
XMONSTER mtmp;
X{
X	register        tmp;
X
X	for (tmp = 1; tmp < 32; tmp++)
X		if (!wsegs[tmp]) {
X			mtmp -> wormno = tmp;
X			return 1;
X		}
X	return 0;		/* Level infested with worms */
X}
X
Xinitworm (mtmp)
XMONSTER mtmp;
X{
X	register        WORMSEGMENT wtmp;
X	register        tmp = mtmp -> wormno;
X
X	if (!tmp)
X		return;
X	wheads[tmp] = wsegs[tmp] = wtmp = newseg ();
X	wgrowtime[tmp] = 0;
X	wtmp -> wx = mtmp -> mx;
X	wtmp -> wy = mtmp -> my;
X	wtmp -> nseg = 0;
X}
X
Xworm_move (mtmp)
XMONSTER mtmp;
X{
X	register        WORMSEGMENT wtmp, whd;
X	register        tmp = mtmp -> wormno;
X
X	wtmp = newseg ();
X	wtmp -> wx = mtmp -> mx;
X	wtmp -> wy = mtmp -> my;
X	wtmp -> nseg = 0;
X	whd = wheads[tmp];
X	whd -> nseg = wtmp;
X	wheads[tmp] = wtmp;
X	seeatl (whd -> wx, whd -> wy, '~');
X	if (wgrowtime[tmp] <= moves) {
X		if (!wgrowtime[tmp])
X			wgrowtime[tmp] = moves + rnd (5);
X		else
X			wgrowtime[tmp] += 2 + rnd (15);
X		mtmp -> orig_hp++;
X		mtmp -> mhp++;
X		return;
X	}
X	whd = wsegs[tmp];
X	wsegs[tmp] = whd -> nseg;
X	remseg (whd);
X}
X
Xworm_nomove (mtmp)
Xregister        MONSTER mtmp;
X{
X	register        tmp;
X	register        WORMSEGMENT wtmp;
X
X	tmp = mtmp -> wormno;
X	wtmp = wsegs[tmp];
X	if (wtmp == wheads[tmp])
X		return;
X	wsegs[tmp] = wtmp -> nseg;
X	remseg (wtmp);
X	mtmp -> mhp--;		/* Orig_hp not changed! */
X}
X
Xwormdead (mtmp)
Xregister        MONSTER mtmp;
X{
X	register        tmp = mtmp -> wormno;
X	register        WORMSEGMENT wtmp, wtmp2;
X
X	if (!tmp)
X		return;
X	for (wtmp = wsegs[tmp]; wtmp; wtmp = wtmp2) {
X		wtmp2 = wtmp -> nseg;
X		remseg (wtmp);
X	}
X	wsegs[tmp] = 0;
X}
X
Xwormhit (mtmp)
Xregister        MONSTER mtmp;
X{
X	register        tmp = mtmp -> wormno;
X	register        MONSTDATA mdat = mtmp -> data;
X	register        WORMSEGMENT wtmp;
X
X	if (!tmp)
X		return;		/* Worm without tail */
X	for (wtmp = wsegs[tmp]; wtmp; wtmp = wtmp -> nseg)
X		hitu (mdat -> mhd, 1, mdat -> mname);
X}
X
Xwormsee (tmp)
Xregister        tmp;
X{
X	register        WORMSEGMENT wtmp;
X
X	for (wtmp = wsegs[tmp]; wtmp -> nseg; wtmp = wtmp -> nseg)
X		if (!cansee (wtmp -> wx, wtmp -> wy))
X			levlsym (wtmp -> wx, wtmp -> wy, '~');
X}
X
Xcutworm (mtmp, x, y, weptyp)
Xregister        MONSTER mtmp;
Xregister char   x, y;
Xregister unsigned       weptyp;
X{
X	register        WORMSEGMENT wtmp, wtmp2;
X	register        MONSTER mtmp2;
X	register        tmp, tmp2;
X
X	if (mtmp -> mx == x && mtmp -> my == y)
X		return;		/* Hit headon */
X
X/* Cutting goes best with axe or sword */
X	tmp = rnd (20);
X	if (weptyp == 7 || weptyp == 8 || weptyp == 5)
X		tmp += 5;
X	if (tmp < 16)
X		return;
X
X/* If tail then worm just loses a tail segment */
X	tmp = mtmp -> wormno;
X	wtmp = wsegs[tmp];
X	if (wtmp -> wx == x && wtmp -> wy == y) {
X		wsegs[tmp] = wtmp -> nseg;
X		remseg (wtmp);
X		return;
X	}
X
X/* Cut the worm in two halves */
X	mtmp2 = newmonst (0);
X	*mtmp2 = *mtmp;
X
X/* Sometimes the tail end dies */
X	if (rn2 (8) || !getwn (mtmp2)) {/* Michiel was rn2(3) */
X		free (mtmp2);
X		tmp2 = 0;
X	}
X	else {
X		tmp2 = mtmp2 -> wormno;
X		wsegs[tmp2] = wsegs[tmp];
X		wgrowtime[tmp2] = 0;
X	}
X	do {
X		if (wtmp -> nseg -> wx == x && wtmp -> nseg -> wy == y) {
X			if (tmp2)
X				wheads[tmp2] = wtmp;
X			wsegs[tmp] = wtmp -> nseg -> nseg;
X			remseg (wtmp -> nseg);
X			wtmp -> nseg = 0;
X			if (tmp2) {
X				pline ("You cut the worm in half.");
X				mtmp2 -> orig_hp = mtmp2 -> mhp =
X					d (mtmp2 -> data -> mhd, 8);
X				mtmp2 -> mx = wtmp -> wx;
X				mtmp2 -> my = wtmp -> wy;
X				mtmp2 -> nmon = fmon;
X				fmon = mtmp2;
X				pmon (mtmp2);
X			}
X			else {
X				pline ("You cut off part of the worm's tail.");
X				remseg (wtmp);
X			}
X			mtmp -> mhp >>= 1;
X			return;
X		}
X		wtmp2 = wtmp -> nseg;
X		if (!tmp2)
X			remseg (wtmp);
X		wtmp = wtmp2;
X	} while (wtmp -> nseg);
X	panic (CORE, "Cannot find worm segment");
X}
X
Xremseg (wtmp)
Xregister        WORMSEGMENT wtmp;
X{
X	levlsym (wtmp -> wx, wtmp -> wy, '~');
X	free (wtmp);
X}
SHAR_EOF
if test 3953 -ne "`wc -c 'hack.worm.c'`"
then
	echo shar: error transmitting "'hack.worm.c'" '(should have been 3953 characters)'
fi
echo shar: extracting "'mklev.c'" '(9468 characters)'
if test -f 'mklev.c'
then
	echo shar: over-writing existing file "'mklev.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'mklev.c'
X/*
X * Mklev.c
X */
X
X#define NORMAL_IO
X#include "hack.h"
X
Xchar   *tfile, *tspe, **args, nul[20];
X
X#include "mklev.svlev.c"
X
Xchar    mmon[8][8] = {
X	"BGHJKLr",
X	"aEhiOyZ",
X	"AfNpQqv",
X	"bCcgjkS",
X	"FoRstWw",
X	"dlMmTuY",
X	"IUVXxz:",
X	"De'n,P&"
X};
X
X#define MAZX ((rnd(37) << 1) + 1)
X#define MAZY ((rnd(8) << 1) + 1)
X
X#define somex() rn1( croom->hx - croom->lx + 1, croom->lx )
X#define somey() rn1( croom->hy - croom->ly + 1, croom->ly )
X
X#define NOT_HERE	0
X
XPART levl[80][22];
X
XMONSTER fmon;
XOBJECT fobj;
XGOLD_TRAP fgold, ftrap;
X
XMKROOM rooms[15], *croom, *troom;
X
XCOORDINATES doors[DOORMAX];
X
Xint     doorindex = 0, nroom, comp ();
X
Xchar    dlevel, *geno, goldseen,
X        xdnstair, xupstair, ydnstair, yupstair,
X        wizard, nxcor, x, y,
X        dx, dy, tx, ty;
X /* For corridors and other things... */
X
X#define RUIN	5
X#define MAZE	6
X
Xmain (argc, argv)
Xchar   *argv[];
X{
X	char    lowy, lowx;
X	register unsigned       tryct;
X
X	if (argc < 6)
X		panic ("Too few arguments!!");
X	args = argv;
X	tfile = argv[1];
X	tspe = argv[2];
X	dlevel = atoi (argv[3]);
X	if (dlevel >= 30)
X		dlevel = 30;
X	geno = argv[4];
X	wizard = (*argv[5] == 'w');
X	srand (getpid ());
X/* for( lowy=2;lowy<19;lowy++) for( lowx=2;lowx<77;lowx++ )
X	 				levl[lowx][lowy].typ = 0; * /
X
X/*
X * a: normal;
X * b: maze;
X * n: next level will be maze
X */
X	if (*tspe == 'b') {
X		makemaz ();
X		savelev ();
X		exit (1);
X	}
X
X/* Construct the rooms */
X	croom = rooms;
X	tryct = 0;
X	while (nroom < 7) {
X		for (lowy = rn1 (3, 3); lowy < 15; lowy += rn1 (2, 4))
X			for (lowx = rn1 (3, 4); lowx < 70; lowx +=
X					rn1 (2, 7)) {
X				if (++tryct > 10000) {
X					printf ("tryct overflow\n");
X					goto jumpout;
X				}
X				if ((lowy += rn1 (5, -2)) < 3)
X					lowy = 3;
X				else if (lowy > 16)
X					lowy = 16;
X				if (levl[lowx][lowy].typ)
X					continue;
X				if (maker (lowx, rn1 (9, lowx + 2), lowy,
X							rn1 (4, lowy + 2)) && nroom > 13)
X					goto jumpout;
X			}
X	}
Xjumpout: 
X	croom -> hx = -1;
X
X/* For each room: put things inside */
X	for (croom = rooms; croom -> hx > 0; croom++) {
X
X/* Put a sleeping monster inside */
X		if (!rn2 (3))
X			makemon (1, somex (), somey ());
X
X/* Put traps and mimics inside */
X		goldseen = 0;
X		while (!rn2 (8 - (dlevel / 6)))
X			mktrap (0, 0);
X		if (!goldseen && !rn2 (3))
X			mkgold (0, somex (), somey ());
X		tryct = 0;
X		if (!rn2 (3))
X			do {
X				mkobj (0);
X				levl[fobj -> ox = somex ()][fobj -> oy = somey ()].scrsym = fobj -> olet;
X				if (tryct++ > 100) {
X					printf ("tryct overflow4\n");
X					break;
X				}
X			} while (!rn2 (5));
X	}
X	tryct = 0;
X	do {
X		if (++tryct > 1000)
X			panic ("Cannot make dnstairs\n");
X		croom = &rooms[rn2 (nroom)];
X		xdnstair = somex ();
X		ydnstair = somey ();
X	} while ((*tspe == 'n' &&
X				(xdnstair % 2 == 0 || ydnstair % 2 == 0)) ||
X			g_at (xdnstair, ydnstair, ftrap));
X	levl[xdnstair][ydnstair].scrsym = '>';
X	troom = croom;
X	do {
X		if (++tryct > 2000)
X			panic ("Cannot make upstairs\n");
X		croom = &rooms[rn2 (nroom)];
X		xupstair = somex ();
X		yupstair = somey ();
X	} while (croom == troom || m_at (xupstair, yupstair) ||
X			o_at (xupstair, yupstair) ||
X			g_at (xupstair, yupstair, ftrap));
X	levl[xupstair][yupstair].scrsym = '<';
X	qsort (rooms, nroom, sizeof (MKROOM), comp);
X	croom = rooms;
X	troom = croom + 1;
X	nxcor = 0;
X	mkpos ();
X	do
X		makecor (x + dx, y + dy);
X	while (croom -> hx > 0 && troom -> hx > 0);
X	if ((dlevel < 10 && rn2 (2)) || (dlevel > 9 && !rn2 (3)) ||
X			wizard)
X		mkshop ();
X	if (dlevel > 7 && !rn2 (6))
X		mkzoo ();
X	else if (dlevel > 11 && !rn2 (6) || wizard)
X		mkyard ();
X	else if ((dlevel > 18 && !rn2 (6)))
X		mkswamp ();
X	else if ((dlevel > 8 && !rn2 (8)) || wizard)
X		mk_knox ();
X	savelev ();
X}
X
Xcomp (xcoord, ycoord)
Xregister        MKROOM * xcoord, *ycoord;
X{
X	if (xcoord -> lx < ycoord -> lx)
X		return - 1;
X	return (xcoord -> lx > ycoord -> lx);
X}
X
Xmkpos () {
X	if (troom -> hx < 0 || croom -> hx < 0)
X		return;
X	if (troom -> lx > croom -> hx) {
X		x = croom -> hx + 1;
X		dx = 1;
X		tx = troom -> lx - 1;
X	}
X	else if (troom -> hy < croom -> ly) {
X		y = croom -> ly - 1;
X		dy = -1;
X		dx = 0;
X		ty = troom -> hy + 1;
X	}
X	else if (troom -> hx < croom -> lx) {
X		x = croom -> lx - 1;
X		dx = -1;
X		tx = troom -> hx + 1;
X	}
X	else {
X		y = croom -> hy + 1;
X		dy = 1;
X		dx = 0;
X		ty = troom -> ly - 1;
X	}
X	if (dx) {
X		dy = 0;
X		y = croom -> ly + rn2 (croom -> hy - croom -> ly + 1);
X		ty = troom -> ly + rn2 (troom -> hy - troom -> ly + 1);
X	}
X	else {
X		x = croom -> lx + rn2 (croom -> hx - croom -> lx + 1);
X		tx = troom -> lx + rn2 (troom -> hx - troom -> lx + 1);
X	}
X	if (levl[x + dx][y + dy].typ) {
X		if (nxcor)
X			newloc ();
X		else {
X			dodoor (x, y, croom);
X			x += dx;
X			y += dy;
X		}
X		return;
X	}
X	dodoor (x, y, croom);
X}
X
Xdodoor (doorx, doory, aroom)
Xregister int    doorx, doory;
Xregister        MKROOM * aroom;
X{
X	register        MKROOM * broom;
X	register int    tmp;
X
X	if ((tmp = levl[doorx - 1][doory].typ) == DOOR || tmp == SDOOR)
X		return;
X	if ((tmp = levl[doorx + 1][doory].typ) == DOOR || tmp == SDOOR)
X		return;
X	if ((tmp = levl[doorx][doory - 1].typ) == DOOR || tmp == SDOOR)
X		return;
X	if ((tmp = levl[doorx][doory + 1].typ) == DOOR || tmp == SDOOR)
X		return;
X	if (levl[doorx][doory].typ != WALL || doorindex >= DOORMAX)
X		return;
X	if (!rn2 (8))
X		levl[doorx][doory].typ = SDOOR;
X	else {
X		levl[doorx][doory].scrsym = '+';
X		levl[doorx][doory].typ = DOOR;
X	}
X	aroom -> doorct++;
X	broom = aroom + 1;
X	if (broom -> hx < 0)
X		tmp = doorindex;
X	else
X		for (tmp = doorindex; tmp > broom -> fdoor; tmp--) {
X			doors[tmp].x = doors[tmp - 1].x;
X			doors[tmp].y = doors[tmp - 1].y;
X		}
X	doorindex++;
X	doors[tmp].x = doorx;
X	doors[tmp].y = doory;
X	for (; broom -> hx >= 0; broom++)
X		broom -> fdoor++;
X}
X
Xnewloc () {
X	register int    tryct = 0;
X
X	++croom;
X	++troom;
X	if (nxcor || croom -> hx < 0 || troom -> hx < 0) {
X		if (nxcor++ > rn1 (nroom, 4)) {
X			croom = &rooms[nroom];
X			return;
X		}
X		do {
X			if (++tryct > 100) {
X				printf ("tryct overflow5\n");
X				croom = &rooms[nroom];
X				return;
X			}
X			croom = &rooms[rn2 (nroom)];
X			troom = &rooms[rn2 (nroom)];
X		}
X		while (croom == troom || (troom == croom + 1 &&
X					!rn2 (3)));
X	}
X	mkpos ();
X}
X
Xmove (xdir, ydir, dir)
Xregister int   *xdir, *ydir, dir;
X{
X	switch (dir) {
X		case 0: 
X			--(*xdir);
X			break;
X		case 1: 
X			(*ydir)++;
X			break;
X		case 2: 
X			(*xdir)++;
X			break;
X		case 3: 
X			--(*ydir);
X			break;
X	}
X}
X
Xokay (xx, yy, dir)
Xint     xx, yy;
Xregister int    dir;
X{
X	move (&xx, &yy, dir);
X	move (&xx, &yy, dir);
X	if (xx < 3 || yy < 3 || xx > 17 || yy > 75 || levl[yy][xx].typ != 0)
X		return 0;
X	return 1;
X}
X
Xmaker (lowx, hix, lowy, hiy)
Xchar    lowx, hix, lowy, hiy;
X{
X	register        PART * ltmp, *lmax;
X	register int    tmpx;
X
X	if (hix > 75)
X		hix = 75;
X	if (hiy > 18)
X		hiy = 18;
X	for (tmpx = lowx - 4; tmpx < hix + 5; tmpx++)
X		for (ltmp = &levl[tmpx][lowy - 3],
X				lmax = &levl[tmpx][hiy + 4];
X				ltmp != lmax; ltmp++)
X			if (ltmp -> typ)
X				return 0;
X	if (10 > rnd (dlevel)) {
X		for (tmpx = lowx - 1; tmpx < hix + 2; tmpx++)
X			for (ltmp = &levl[tmpx][lowy - 1],
X					lmax = &levl[tmpx][hiy + 2];
X					ltmp != lmax; ltmp++)
X				ltmp -> lit = 1;
X	}
X	croom -> lx = lowx;
X	croom -> hx = hix;
X	croom -> ly = lowy;
X	croom -> hy = hiy;
X	croom -> rtype = 0;
X	croom -> doorct = 0;
X	croom -> fdoor = 0;
X	croom++;
X	for (tmpx = lowx - 1; tmpx <= hix + 1; tmpx++) {
X		ltmp = &levl[tmpx][lowy - 1];
X		lmax = &levl[tmpx][hiy + 1];
X		ltmp -> scrsym = '-';
X		ltmp -> typ = WALL;
X		while (++ltmp != lmax) {
X			if (tmpx >= lowx && tmpx <= hix) {
X				ltmp -> scrsym = '.';
X				ltmp -> typ = ROOM;
X			}
X			else {
X				ltmp -> scrsym = '|';
X				ltmp -> typ = WALL;
X			}
X		}
X		ltmp -> scrsym = '-';
X		ltmp -> typ = WALL;
X	}
X /* 
X  -------
X  |.....|
X  |.....|		(This sort of room is made) (a3)
X  |.....|
X  -------
X  */
X	++nroom;
X	return 1;
X}
X
Xmakecor (nx, ny)
Xregister int    nx, ny;
X{
X	register        PART * crm;
X	register int    dix, diy;
X
X	if (nxcor && !rn2 (35)) {
X		newloc ();
X		return;
X	}
X	dix = abs (nx - tx);
X	diy = abs (ny - ty);
X	if (nx == 79 || !nx || !ny || ny == 21) {
X		if (nxcor) {
X			newloc ();
X			return;
X		}
X		printf ("something went wrong. we try again...\n");
X		execl ("./mklev", args[0], tfile, tspe, args[3],
X				args[4], 0);
X		panic ("cannot execute ./mklev\n");
X	}
X	if (dy && dix > diy) {
X		dy = 0;
X		dx = (nx > tx) ? -1 : 1;
X	}
X	else if (dx && diy > dix) {
X		dx = 0;
X		dy = (ny > ty) ? -1 : 1;
X	}
X	crm = &levl[nx][ny];
X	if (!crm -> typ) {
X		crm -> typ = CORR;
X		crm -> scrsym = '#';
X		x = nx;
X		y = ny;
X		return;
X	}
X	if (crm -> typ == CORR) {
X		x = nx;
X		y = ny;
X		return;
X	}
X	if (nx == tx && ny == ty) {
X		dodoor (nx, ny, troom);
X		newloc ();
X		return;
X	}
X	if (x + dx != nx || y + dy != ny)
X		return;
X	if (dx) {
X		dy = 1;
X		if (ty < ny || levl[nx + dx][ny - 1].typ != ROOM)
X			dy = -1;
X		dx = 0;
X	}
X	else {
X		dx = 1;
X		if (tx < nx || levl[nx - 1][ny + dy].typ != ROOM)
X			dx = -1;
X		dy = 0;
X	}
X}
X
XMONSTER m_at (monx, mony)
Xregister int    monx, mony;
X{
X	register        MONSTER mtmp;
X
X	for (mtmp = fmon; mtmp; mtmp = mtmp -> nmon)
X		if (mtmp -> mx == monx && mtmp -> my == mony)
X			return (mtmp);
X	return (NOT_HERE);
X}
X
XOBJECT o_at (objx, objy)
Xregister int    objx, objy;
X{
X	register        OBJECT obj;
X
X	for (obj = fobj; obj; obj = obj -> nobj)
X		if (obj -> ox == objx && obj -> oy == objy)
X			return (obj);
X	return (NOT_HERE);
X}
X
XGOLD_TRAP g_at (gtx, gty, ptr)
Xregister int    gtx, gty;
Xregister        GOLD_TRAP ptr;
X{
X	while (ptr) {
X		if (ptr -> gx == gtx && ptr -> gy == gty)
X			return (ptr);
X		ptr = ptr -> ngen;
X	}
X	return NOT_HERE;
X}
SHAR_EOF
if test 9468 -ne "`wc -c 'mklev.c'`"
then
	echo shar: error transmitting "'mklev.c'" '(should have been 9468 characters)'
fi
echo shar: extracting "'mklev.make.c'" '(11782 characters)'
if test -f 'mklev.make.c'
then
	echo shar: over-writing existing file "'mklev.make.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'mklev.make.c'
X/*
X * Mklev.make.c
X */
X
X#define ZOO		1
X#define GRAVEYARD	2
X#define SWAMP		3
X#define FORT_KNOX	4
X#define MAZE		6
X
X#define NORMAL_IO
X#include "hack.h"
X
Xextern char     mmon[8][8];
X
X#define MAZX ((rnd(37) << 1) + 1)
X#define MAZY ((rnd(8) << 1) + 1)
X
X#define somex() rn1( croom->hx - croom->lx + 1, croom->lx )
X#define somey() rn1( croom->hy - croom->ly + 1, croom->ly )
X
Xextern  PART levl[80][22];
X
Xextern  MONSTER fmon;
Xextern  OBJECT fobj;
Xextern  GOLD_TRAP fgold, ftrap;
X
Xextern  MKROOM rooms[15], *croom;
X
Xextern  COORDINATES doors[DOORMAX];
X
Xextern int      doorindex, nroom, comp ();
X
Xextern char     dlevel, *geno, goldseen,
X                xdnstair, xupstair, ydnstair, yupstair,
X                wizard, nxcor, x, y,
X                dx, dy, tx, ty;
X /* For corridors and other things... */
X
Xmakemaz () {
X
X/* This is all Kenny's fault.  He seems to have his x and y reversed */
X
X	int     xx, yy, a, q, sp, dir, dirs[5], stack[200];
X	register int    zx, zy;
X	register        OBJECT otmp;
X
X	for (xx = 2; xx < 19; xx++)
X		for (yy = 2; yy < 77; yy++) {
X			if (xx % 2 == 0 || yy % 2 == 0)
X				levl[yy][xx].typ++;/* WALL==1 */
X		}
X	zx = MAZY;
X	zy = MAZX;
X	sp = 1;
X	stack[1] = 100 * zx + zy;
X	while (sp) {
X		xx = stack[sp] / 100;
X		yy = stack[sp] % 100;
X		levl[yy][xx].typ = 2;
X		q = 0;
X		for (a = 0; a < 4; a++)
X			if (okay (xx, yy, a))
X				dirs[q++] = a;
X		if (q) {
X			dir = dirs[rn2 (q)];
X			move (&xx, &yy, dir);
X			levl[yy][xx].typ = 0;
X			move (&xx, &yy, dir);
X			stack[++sp] = 100 * xx + yy;
X		}
X		else
X			sp--;
X	}
X	for (xx = 2; xx < 77; xx++)
X		for (yy = 2; yy < 19; yy++) {/* This was mine */
X			if (levl[xx][yy].typ == WALL)
X				levl[xx][yy].scrsym = '-';
X			else {
X				levl[xx][yy].typ = ROOM;
X				levl[xx][yy].scrsym = '.';
X			}
X		}
X	for (xx = rn1 (8, 11); xx; xx--) {
X		mkobj (0);
X		levl[(fobj -> ox = MAZX)][(fobj -> oy = MAZY)].scrsym = fobj -> olet;
X	}
X	for (xx = rn1 (5, 7); xx; xx--)
X		makemon (1, MAZX, MAZY);
X	for (xx = rn1 (6, 7); xx; xx--)
X		mkgold (0, MAZX, MAZY);
X	for (xx = rn1 (6, 7); xx; xx--)
X		mktrap (0, 1);
X	levl[(xupstair = MAZX)][(yupstair = MAZY)].scrsym = '<';
X	levl[zy][zx].scrsym = '"';
X	otmp = newobj ();
X	otmp -> nobj = fobj;
X	fobj = otmp;
X	otmp -> ox = zy;
X	otmp -> oy = zx;
X	otmp -> olet = '"';
X	xdnstair = 0;
X	ydnstair = 0;
X}
X
X/* Make a trap somewhere (in croom if mazeflag=0) */
Xmktrap (num, mazeflag)
Xregister int    num, mazeflag;
X{
X	register        GOLD_TRAP gtmp;
X	register int    nopierc;
X	int     nomimic, fakedoor, fakegold, tryct = 0;
X
X	gtmp = newgen ();
X	if (!num || num >= TRAPNUM) {
X		nopierc = (dlevel < 4);
X		nomimic = (dlevel < 9 || goldseen);
X		gtmp -> gflag = rn2 (TRAPNUM - nopierc - nomimic);
X/* Note: PIERC = 7, MIMIC = 8, TRAPNUM = 9 */
X	}
X	else
X		gtmp -> gflag = num;
X	fakedoor = (gtmp -> gflag == MIMIC && rn2 (2) && !mazeflag);
X	fakegold = (gtmp -> gflag == MIMIC && !fakedoor);
X	do {
X		if (++tryct > 200) {
X			printf ("tryct overflow7\n");
X			free (gtmp);
X			return;
X		}
X		if (mazeflag) {
X			gtmp -> gx = MAZX;
X			gtmp -> gy = MAZY;
X		}
X		else if (!fakedoor) {
X			gtmp -> gx = somex ();
X			gtmp -> gy = somey ();
X		}
X		else {
X			if (rn2 (2)) {
X				if (rn2 (2))
X					gtmp -> gx = croom -> hx + 1;
X				else
X					gtmp -> gx = croom -> lx - 1;
X				gtmp -> gy = somey ();
X			}
X			else {
X				if (rn2 (2))
X					gtmp -> gy = croom -> hy + 1;
X				else
X					gtmp -> gy = croom -> ly - 1;
X				gtmp -> gx = somex ();
X			}
X		}
X	} while (g_at (gtmp -> gx, gtmp -> gy, (fakegold) ? fgold : ftrap));
X	if (!fakegold) {
X		gtmp -> ngen = ftrap;
X		ftrap = gtmp;
X	}
X	else {
X		gtmp -> gflag = 0;
X		gtmp -> ngen = fgold;
X		fgold = gtmp;
X		goldseen++;
X	}
X	if (mazeflag && !rn2 (10) && gtmp -> gflag < PIERC)
X		gtmp -> gflag |= SEEN;
X	if (fakedoor)
X		num = '+';
X	else if (fakegold)
X		num = '$';
X	else
X		return;
X	levl[gtmp -> gx][gtmp -> gy].scrsym = num;
X}
X
Xmkgold (num, goldx, goldy)
Xregister int    num;
X{
X	register        GOLD_TRAP gtmp;
X
X	gtmp = newgen ();
X	gtmp -> ngen = fgold;
X	levl[gtmp -> gx = goldx][gtmp -> gy = goldy].scrsym = '$';
X	gtmp -> gflag = (num) ? num : 1 + rnd (dlevel + 2) * rnd (30);
X	fgold = gtmp;
X}
X
X/*VARARGS*/
Xpanic (str, arg1, arg2)
Xregister char  *str;
X{
X	fprintf (stderr, "\nMKLEV ERROR: ");
X	fprintf (stderr, str, arg1, arg2);
X	abort ();
X}
X
Xmakemon (sl, monx, mony)
Xregister int    sl, monx, mony;
X{
X	register        MONSTER mtmp;
X	register int    tryct = 0;
X
X	mtmp = newmonst (0);
X	mtmp -> mstole = STOLE_NULL;
X	mtmp -> msleep = sl;
X	mtmp -> mx = monx;
X	mtmp -> my = mony;
X	mtmp -> mfroz = 0;
X	mtmp -> mconf = 0;
X	mtmp -> mflee = 0;
X	mtmp -> mspeed = 0;
X	mtmp -> mtame = 0;
X	mtmp -> angry = 0;
X	mtmp -> mxlth = 0;
X	mtmp -> wormno = 0;
X	mtmp -> ale = 0;
X	if (levl[monx][mony].typ == POOL) {
X		mtmp -> ale = 1;
X		mtmp -> invis = 1;
X	}
X	else {
X		do {
X			if (++tryct > 100) {
X				printf ("tryct overflow8\n");
X				free (mtmp);
X				return;
X			}
X			mtmp -> mhp = rn2 (dlevel / 3 + 1) % 8;
X			mtmp -> orig_hp = rn2 (7);
X		} while (index (geno, mmon[mtmp -> mhp][mtmp -> orig_hp]));
X	}
X	mtmp -> nmon = fmon;
X	fmon = mtmp;
X}
X
X
Xchar    shtypes[] = "=/)%?![";	/* 8 shoptypes: 7 specialised, 1 mixed */
Xchar    shprobs[] = {
X	3, 3, 5, 5, 10, 10, 14, 50
X};				/* Their probabilities */
X
Xmkshop () {
X	register        MKROOM * sroom;
X	register int    sh, sx, sy, i;
X	register char   let;
X
X	for (sroom = &rooms[0];; sroom++) {
X		if (sroom -> hx < 0)
X			return;
X		if (ch_upstairs (sroom) || ch_dnstairs (sroom))
X			continue;
X		if (sroom -> doorct == 1)
X			break;
X	}
X	for (i = rn2 (100), let = 0; (i -= shprobs[let]) >= 0; let++)
X		if (!shtypes[let])
X			break;	/* Superfluous */
X	sroom -> rtype = 8 + let;
X	let = shtypes[let];
X	sh = sroom -> fdoor;
X	for (sx = sroom -> lx; sx <= sroom -> hx; sx++)
X		for (sy = sroom -> ly; sy <= sroom -> hy; sy++) {
X			if (sx == sroom -> lx && doors[sh].x == sx - 1 ||
X					sx == sroom -> hx && doors[sh].x == sx + 1 ||
X					sy == sroom -> ly && doors[sh].y == sy - 1 ||
X					sy == sroom -> hy && doors[sh].y == sy + 1)
X				continue;
X			mkobj (let);
X			levl[fobj -> ox = sx][fobj -> oy = sy].scrsym =
X				fobj -> olet;
X		}
X}
X
Xmkzoo () {
X	register        MKROOM * zroom;
X	register int    zx, zy;
X
X	for (;;) {
X		zroom = &rooms[rn2 (nroom)];
X		if (zroom -> hx < 0 || zroom -> rtype >= 8 ||
X				ch_upstairs (zroom))
X			continue;/* Niet in kamer met terugweg */
X		break;		/* Kamer gevonden */
X	}
X	zroom -> rtype = ZOO;
X	for (zx = zroom -> lx; zx <= zroom -> hx; zx++)
X		for (zy = zroom -> ly; zy <= zroom -> hy; zy++) {
X			if (!m_at (zx, zy)) {
X				mkgold (0, zx, zy);
X				makemon (1, zx, zy);
X			}
X		}
X}
X
X
Xmkyard () {
X	register        MKROOM * yroom;
X	register int    yx, yy;
X
X	for (;;) {
X		yroom = &rooms[rn2 (nroom)];
X		if (yroom -> hx < 0 || yroom -> rtype >= 8 ||
X				ch_upstairs (yroom))
X			continue;/* Niet in kamer met terugweg */
X		break;		/* Kamer gevonden */
X	}
X	yroom -> rtype = GRAVEYARD;
X	for (yx = yroom -> lx; yx <= yroom -> hx; yx++)
X		for (yy = yroom -> ly; yy <= yroom -> hy; yy++) {
X			if (!mymakemon (yx, yy)) {
X				if (fmon -> mhp == 7)
X					mymakemon (yx, yy);
X			/* Not so many demons */
X				mkgold (0, yx, yy);
X				if (fmon -> mhp != 1) {
X					mkobj (0);
X					if (rn2 (8))
X						fobj -> cursed = 1;
X					levl[fobj -> ox = yx][fobj -> oy = yy].scrsym = fobj -> olet;
X				}
X			}
X		}
X}
X
X#define NOMON	1
X#define MON	0
X
Xmymakemon (monx, mony) {
X	register        MONSTER mtmp;
X	register int    tryct = 0;
X	register int    tmp = 0;
X
X	if (m_at (monx, mony))
X		return NOMON;
X	mtmp = newmonst (0);
X	mtmp -> mstole = STOLE_NULL;
X	mtmp -> msleep = 1;
X	mtmp -> mx = monx;
X	mtmp -> my = mony;
X	mtmp -> mfroz = 0;
X	mtmp -> mconf = 0;
X	mtmp -> mflee = 0;
X	mtmp -> mspeed = 0;
X	mtmp -> mtame = 0;
X	mtmp -> angry = 0;
X	mtmp -> mxlth = 0;
X	mtmp -> wormno = 0;
X	do {
X		if (++tryct > 1000) {
X			printf ("tryct overflow yard\n");
X			free (mtmp);
X			return NOMON;
X		}
X		tmp = putyard (mtmp);
X	} while (index (geno, mmon[mtmp -> mhp][mtmp -> orig_hp]) || tmp);
X	mtmp -> nmon = fmon;
X	fmon = mtmp;
X	return 0;
X}
X
Xputyard (mtmp)
XMONSTER mtmp;
X{
X	switch (rn2 (5)) {
X		case 0: 
X			mtmp -> mhp = 1;/* level 3 */
X			mtmp -> orig_hp = 6;/* ZOMBIE */
X			break;
X		case 1: 
X			if (dlevel < 18)
X				return NOMON;
X			mtmp -> mhp = 6;/* level 18 */
X			mtmp -> orig_hp = 2;/* VAMPIRE */
X			break;
X		case 2: 
X			mtmp -> mhp = 4;/* level 12 */
X			mtmp -> orig_hp = 5;/* Wraith */
X			break;
X		case 3: 
X			if (dlevel < 21)
X				return NOMON;
X			mtmp -> mhp = 7;/* level 21 */
X			mtmp -> orig_hp = 6;/* DEMON */
X			break;
X		case 4: 
X			mtmp -> mhp = 10;/* altijd */
X			mtmp -> orig_hp = 10;/* GHOST */
X			break;
X		default: 
X			mtmp -> mhp = rn2 (dlevel / 3 + 1) % 8;
X			mtmp -> orig_hp = rn2 (7);
X	}
X	return MON;
X}
X
Xmkswamp () {
X	register        MKROOM * zroom;
X	register int    zx, zy;
X	register int    first = 0;
X
X	for (;;) {
X		zroom = &rooms[rn2 (nroom)];
X		if (zroom -> hx < 0)
X			return;
X		if (ch_upstairs (zroom) || ch_dnstairs (zroom))
X			continue;
X		if (zroom -> hx < 0 || zroom -> rtype >= 8)
X			continue;
X	/* Niet in kamer met terugweg of weg naar beneden */
X		break;		/* Kamer gevonden */
X	}
X	zroom -> rtype = SWAMP;
X	for (zx = zroom -> lx; zx <= zroom -> hx; zx++)
X		for (zy = zroom -> ly; zy <= zroom -> hy; zy++) {
X			if ((zx + zy) % 2 && !o_at (zx, zy) &&
X					!g_at (zx, zy, fgold) && !m_at (zx, zy) &&
X					ch_doors (zx, zy)) {
X				levl[zx][zy].typ = POOL;
X				levl[zx][zy].scrsym = '}';
X				if (!first) {
X					makemon (0, zx, zy);
X					++first;
X				}
X				else if (!rn2 (4))
X					makemon (0, zx, zy);
X			}
X		}
X}
X
Xch_doors (zx, zy)
Xregister int    zx, zy;
X{
X	register int    xx, yy;
X	register int    status = 1;
X
X	for (xx = zx - 1; xx <= zx + 1; xx++)
X		for (yy = zy - 1; yy <= zy + 1; yy++) {
X			if (levl[xx][yy].typ == DOOR)
X				status = 0;
X			else if (levl[xx][yy].typ == SDOOR) {
X				levl[xx][yy].typ = DOOR;
X				levl[xx][yy].scrsym = '+';
X				status = 0;
X			}
X		}
X	return status;
X}
X
Xmk_knox () {
X	register        MKROOM * kroom;
X	register int    kx, ky;
X	register int    tmp = 10000;
X	OBJECT otmp;
X	MONSTER mtmp;
X	GOLD_TRAP gtmp;
X
X	for (kroom = &rooms[0];; ++kroom) {
X		if (kroom -> hx < 0)
X			return;
X		if (ch_upstairs (kroom) || ch_dnstairs (kroom))
X			continue;
X		if ((kroom -> rtype >= 8 || kroom -> rtype <= SWAMP)
X				&& kroom -> rtype)
X				/* Shop or Zoo or Graveyard or Swamp */
X			continue;
X		if (kroom -> hx - kroom -> lx <= 3 || kroom -> hy - kroom -> ly <= 3)
X			continue;
X		break;
X	}
X	kroom -> rtype = FORT_KNOX;
X	kx = ((kroom -> hx - kroom -> lx) / 2) + kroom -> lx;
X	ky = ((kroom -> hy - kroom -> ly) / 2) + kroom -> ly;
X	for (tx = kx - 1; tx <= kx + 1; ++tx)
X		for (ty = ky - 1; ty <= ky + 1; ++ty) {
X			if (tx == kx && ty == ky)
X				continue;
X			if ((otmp = o_at (tx, ty))) {
X				otmp -> ox = kx;
X				otmp -> oy = ky;
X			}
X			if ((mtmp = m_at (tx, ty)))
X				delmon (mtmp);
X			if ((gtmp = g_at (tx, ty, fgold))) {
X				tmp += gtmp -> gflag;
X				delgen (gtmp, fgold);
X			}
X			if ((gtmp = g_at (tx, ty, ftrap)))
X				delgen (gtmp, ftrap);
X			levl[tx][ty].typ = VAULT;
X			levl[tx][ty].scrsym = (ty == ky) ? '|' : '-';
X		}
X	mkgold (tmp, kx, ky);
X}
X
Xch_upstairs (mroom)
Xregister        MKROOM * mroom;
X{
X	return (mroom -> lx <= xupstair && xupstair <= mroom -> hx &&
X			mroom -> ly <= yupstair && yupstair <= mroom -> hy);
X}
X
Xch_dnstairs (mroom)
Xregister        MKROOM * mroom;
X{
X	return (mroom -> lx <= xdnstair && xdnstair <= mroom -> hx &&
X			mroom -> ly <= ydnstair && ydnstair <= mroom -> hy);
X}
X
Xdelmon (mtmp)
Xregister        MONSTER mtmp;
X{
X	register        MONSTER mtmp2;
X
X	if (mtmp == fmon)
X		fmon = fmon -> nmon;
X	else {
X		for (mtmp2 = fmon; mtmp2 -> nmon != mtmp;
X				mtmp2 = mtmp2 -> nmon);
X		mtmp2 -> nmon = mtmp -> nmon;
X	}
X}
X
Xdelgen (gtmp, key)
Xregister        GOLD_TRAP gtmp, key;
X{
X	register        GOLD_TRAP gtmp2;
X
X	if (gtmp == key)
X		key = key -> ngen;
X	else {
X		for (gtmp2 = key; gtmp2 -> ngen != gtmp;
X				gtmp2 = gtmp2 -> ngen);
X		gtmp2 -> ngen = gtmp -> ngen;
X	}
X}
SHAR_EOF
if test 11782 -ne "`wc -c 'mklev.make.c'`"
then
	echo shar: error transmitting "'mklev.make.c'" '(should have been 11782 characters)'
fi
echo shar: extracting "'mklev.mkobj.c'" '(2350 characters)'
if test -f 'mklev.mkobj.c'
then
	echo shar: over-writing existing file "'mklev.mkobj.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'mklev.mkobj.c'
X/*
X * Mklev.mkobj.c
X */
X
X#define NORMAL_IO
X#include "hack.h"
X#include "hack.vars.h"
X
Xmkfood () {
X	register        FOOD fp;
X	register        i = rn2 (100);
X
X	fp = &foods[0];
X	while ((i -= fp -> prob) >= 0)
X		fp++;
X	return (fp - foods);
X}
X
Xmkarm () {
X	register        ARMOR ap;
X	register        i = rn2 (100);
X
X	ap = &armors[0];
X	while ((i -= ap -> prob) >= 0)
X		ap++;
X	return (ap - armors);
X}
X
Xmkwep () {
X	register        WEAPON wp;
X	register        i = rn2 (100);
X	wp = &weapons[0];
X	while ((i -= wp -> prob) >= 0)
X		wp++;
X	return (wp - weapons);
X}
X
Xchar    mkobjstr[] = "))[[!!!!????%%%%//=**";
X
Xmkobj (let)
Xregister        let;
X{
X	register        OBJECT otmp;
X
X	otmp = newobj ();
X	otmp -> nobj = fobj;
X	fobj = otmp;
X	otmp -> known = 0;
X	otmp -> cursed = 0;
X	otmp -> spe = 0;
X	otmp -> unpaid = 0;
X	otmp -> quan = 1;
X	if (!let)
X		let = mkobjstr[rn2 (sizeof (mkobjstr) - 1)];
X	otmp -> olet = let;
X	switch (let) {
X
X		case ')': 
X			otmp -> otyp = mkwep ();
X			if (otmp -> otyp <= W_AMMUNITION)
X				otmp -> quan = rn1 (6, 6);
X			if (!rn2 (11))
X				otmp -> spe = rnd (3);
X			else if (!rn2 (10)) {
X				otmp -> cursed = 1;
X				otmp -> spe = -rnd (3);
X			}
X			break;
X
X		case '*': 
X			otmp -> otyp = rn2 (SIZE (potcol));
X			otmp -> quan = rn2 (6) ? 1 : 2;
X			break;
X
X		case '[': 
X			otmp -> otyp = mkarm ();
X			if (!rn2 (8))
X				otmp -> cursed = 1;
X			if (!rn2 (10))
X				otmp -> spe = rnd (3);
X			else if (!rn2 (9)) {
X				otmp -> spe = -rnd (3);
X				otmp -> cursed = 1;
X			}
X			otmp -> spe += 10 - armors[otmp -> otyp].a_ac;
X			break;
X
X		case '!': 
X			otmp -> otyp = rn2 (SIZE (pottyp));
X			break;
X
X		case '?': 
X			otmp -> otyp = rn2 (SIZE (scrtyp));
X			break;
X
X		case '%': 
X			otmp -> otyp = mkfood ();
X			otmp -> quan = rn2 (6) ? 1 : 2;
X			break;
X
X		case '/': 
X			otmp -> otyp = rn2 (SIZE (wantyp));
X			if (otmp -> otyp == Z_DEATH)
X				otmp -> otyp = rn2 (SIZE (wantyp));
X			otmp -> spe = rn1 (5, (otmp -> otyp <= Z_CREATE_MON) ?
X					11 : 4);
X			break;
X
X		case '=': 
X			otmp -> otyp = rn2 (SIZE (ringtyp));
X			if (otmp -> otyp >= R_GAIN_STR) {
X				if (!rn2 (3)) {
X					otmp -> spe = -rnd (2);
X					otmp -> cursed = 1;
X				}
X				else
X					otmp -> spe = rnd (2);
X			}
X			else if (otmp -> otyp == R_TELE ||
X						otmp -> otyp == R_AGGRAV_MON ||
X					otmp -> otyp == R_HUNGER)
X				otmp -> cursed = 1;
X			break;
X
X		default: 
X			panic ("impossible mkobj");
X	}
X}
SHAR_EOF
if test 2350 -ne "`wc -c 'mklev.mkobj.c'`"
then
	echo shar: error transmitting "'mklev.mkobj.c'" '(should have been 2350 characters)'
fi
echo shar: extracting "'mklev.svlev.c'" '(1617 characters)'
if test -f 'mklev.svlev.c'
then
	echo shar: over-writing existing file "'mklev.svlev.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'mklev.svlev.c'
X/*
X * Mklev.savelev.c
X */
X
Xsavelev () {
X	register int    fd;
X	register        MONSTER mtmp, mtmp2;
X	register        GOLD_TRAP gtmp, gtmp2;
X	register        OBJECT otmp, otmp2;
X	int     minusone = -1;
X
X	if ((fd = creat (tfile, 0644)) < 0)
X		panic ("Cannot create %s\n", tfile);
X	bwrite (fd, levl, sizeof (levl));
X	bwrite (fd, nul, sizeof (unsigned));
X	bwrite (fd, (char *) & xupstair, 1);
X	bwrite (fd, (char *) & yupstair, 1);
X	bwrite (fd, (char *) & xdnstair, 1);
X	bwrite (fd, (char *) & ydnstair, 1);
X	for (mtmp = fmon; mtmp; mtmp = mtmp2) {
X		mtmp2 = mtmp -> nmon;
X		bwrite (fd, &mtmp -> mxlth, sizeof (int));
X		bwrite (fd, mtmp, mtmp -> mxlth + sizeof (struct monst));
X
X/* Michiel save stolen objects */
X		bwrite (fd, nul, sizeof (struct stole));
X	}
X	bwrite (fd, &minusone, sizeof (int));
X	for (gtmp = fgold; gtmp; gtmp = gtmp2) {
X		gtmp2 = gtmp -> ngen;
X		bwrite (fd, gtmp, sizeof (struct gen));
X		free (gtmp);
X	}
X	bwrite (fd, nul, sizeof (struct gen));
X	for (gtmp = ftrap; gtmp; gtmp = gtmp2) {
X		gtmp2 = gtmp -> ngen;
X		bwrite (fd, gtmp, sizeof (struct gen));
X		free (gtmp);
X	}
X	bwrite (fd, nul, sizeof (struct gen));
X	for (otmp = fobj; otmp; otmp = otmp2) {
X		otmp2 = otmp -> nobj;
X		bwrite (fd, otmp, sizeof (struct obj));
X		free (otmp);
X	}
X	bwrite (fd, nul, sizeof (struct obj));
X	bwrite (fd, rooms, sizeof (rooms));
X	bwrite (fd, doors, sizeof (doors));
X	fgold = TRAP_NULL;
X	ftrap = TRAP_NULL;
X	fmon = MON_NULL;
X	fobj = OBJ_NULL;
X}
X
X/*NOSTRICT*/
Xbwrite (fd, loc, num)
Xregister int    fd, num;
Xregister char  *loc;
X{
X	if (write (fd, loc, num) != num)
X		panic ("Cannot write %d bytes to file #%d", num, fd);
X}
SHAR_EOF
if test 1617 -ne "`wc -c 'mklev.svlev.c'`"
then
	echo shar: error transmitting "'mklev.svlev.c'" '(should have been 1617 characters)'
fi
echo shar: extracting "'rnd.c'" '(404 characters)'
if test -f 'rnd.c'
then
	echo shar: over-writing existing file "'rnd.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'rnd.c'
X/*
X * Rnd.c
X */
X
X#define RND(x)	((rand() >> 3) % x)
X
Xunsigned int rand();    /* it only returns 0 - 2**15 values, all POSITIVE */
X
Xrn1 (x, y)
Xregister        x, y;
X{
X	return (RND (x) + y);
X}
X
Xrn2 (x)
Xregister        x;
X{
X	return (RND (x));
X}
X
Xrnd (x)
Xregister        x;
X{
X	return (RND (x) + 1);
X}
X
Xd (n, x)
Xregister        n, x;
X{
X	register        tmp = n;
X
X	while (n--)
X		tmp += RND (x);
X	return tmp;
X}
SHAR_EOF
if test 404 -ne "`wc -c 'rnd.c'`"
then
	echo shar: error transmitting "'rnd.c'" '(should have been 404 characters)'
fi
echo shar: extracting "'show.c'" '(6304 characters)'
if test -f 'show.c'
then
	echo shar: over-writing existing file "'show.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'show.c'
X/*
X * Showlevel.c
X */
X
X#define NORMAL_IO
X#define SHOW
X#include "hack.h"
X
XPART levl[80][22];
X
Xchar    mmon[8][8] = {
X	"BGHJKLr",
X	"aEhiOyZ",
X	"AfNpQqv",
X	"bCcgjkS",
X	"FoRstWw",
X	"dlMmTuY",
X	"IUVXxz:",
X	"De'n,P&"
X};
X
Xchar    stairs[4], mbuf[1000], obuf[BUFSIZ];
X
Xunsigned        omoves;
Xextern char    *setan ();
X
Xmain (argc, argv)
Xint     argc;
Xchar  **argv;
X{
X	register        fd;
X	register        MONSTER mtmp = (MONSTER) mbuf;
X	char    buffer[100];
X	struct stole    stmp;
X	struct obj      otmp;
X	char    buf[BUFSZ];
X	int     xl;
X
X	setbuf (stdout, obuf);
X	if (!strcmp (argv[1], "-r")) {
X		showrecord ();
X		exit (0);
X	}
X	if (!strcmp (argv[1], "-d")) {
X		delrecord ();
X		exit (0);
X	}
X	while (--argc) {
X		printf ("Next file is %s\n", argv[argc]);
X		if ((fd = open (argv[argc], 0)) < 0) {
X			printf ("Cannot open %s\n", argv[argc]);
X			getret ();
X			continue;
X		}
X		if (read (fd, levl, sizeof levl) != sizeof levl) {
X			printf ("Error reading level\n");
X			getret ();
X			continue;
X		}
X		show ();
X		mread (fd, &omoves, sizeof (unsigned));
X		mread (fd, stairs, 4);
X		mread (fd, &xl, sizeof (int));
X		printf ("Show Monsters? (%sSpecified) ", omoves ? "Not " : "");
X		fflush (stdout);
X		gets (buffer);
X		if (strcmp (buffer, "y"))
X			continue;
X		while (xl != -1) {
X			mread (fd, mtmp, xl + sizeof (struct monst));
X			mread (fd, &stmp, sizeof (struct stole));
X			if (!omoves) {
X				if (mtmp -> mhp == 10 && mtmp -> orig_hp == 10)
X					printf ("\' \'");
X				else if (mtmp -> mhp == 9 && mtmp -> orig_hp == 9)
X					printf ("Ale");
X				else
X					printf ("%c",
X							mmon[mtmp -> mhp][mtmp -> orig_hp]);
X				printf (" at [%d,%d]", mtmp -> mx, mtmp -> my);
X			}
X			else {
X				printf ("monster at [%d,%d]", mtmp -> mx, mtmp -> my);
X				if (stmp.sgold || stmp.sobj) {
X					printf (" stole ");
X					if (stmp.sgold)
X						printf ("%u goldpieces", stmp.sgold);
X					for (;;) {
X						mread (fd, &otmp,
X								sizeof (struct obj));
X						if (!otmp.olet)
X							break;
X						doname (otmp.olet, buf);
X						printf (" %s", buf);
X					}
X				}
X			}
X			if (mtmp -> msleep)
X				printf (" SLEEP");
X			if (mtmp -> invis)
X				printf (" INVIS");
X			if (mtmp -> cham)
X				printf (" CHAM");
X			if (mtmp -> mspeed)
X				printf (" MSPEED");
X			if (mtmp -> mconf)
X				printf (" MCONF");
X			if (mtmp -> mflee)
X				printf (" MFLEE");
X			if (mtmp -> mcan)
X				printf (" MCAN");
X			if (mtmp -> mtame)
X				printf (" TAME");
X			if (mtmp -> angry)
X				printf (" MANGRY");
X			if (mtmp -> wormno)
X				printf (" WORM[%d]", mtmp -> wormno);
X			if (mtmp -> mxlth)
X				printf (" +%d extra", mtmp -> mxlth);
X			if (mtmp -> mfroz)
X				printf (" FROZ");
X			putchar ('\n');
X			mread (fd, &xl, sizeof (int));
X		}
X		getret ();
X	}
X}
X
Xmread (fd, buf, n) {
X	register        nn;
X
X	if ((nn = read (fd, buf, n)) != n) {
X		printf ("error: read %d instead of %d bytes\n", nn, n);
X		exit (2);
X	}
X}
X
Xshow () {
X	register        i, j;
X
X	for (j = 0; j < 22; j++)
X		for (i = 0; i < 80; i++)
X			pch (levl[i][j].scrsym);
X	printf ("***     ");
X}
X
Xpch (ch)
Xchar    ch;
X{
X	putchar (ch ? ch : '_');
X}
X
Xextern char    *malloc ();
X
Xchar   *
X        alloc (num)
Xregister        num;
X{
X	register char  *val;
X
X	if (!(val = malloc (num)))
X		error ("Cannot get %d bytes", num);
X	return val;
X}
X
Xerror (s) {
X	printf (s);
X	putchar ('\n');
X	fflush (stdout);
X	exit (1);
X}
X
Xextern char    *itoa ();
X
X#define	NAMESIZE	 8
X#define	DEATHSIZE	40
X
Xstruct recitem {
X	long    points;
X	int     level, maxlvl, hp, maxhp;
X	char    str[NAMESIZE + 1], death[DEATHSIZE + 1];
X}               record;
X
Xshowrecord () {
X	register        killed;
X	register        place = 0;
X	register        rfile;
X
X	if ((rfile = open (RECORD, 0)) < 0)
X		error ("Cannot open %s", RECORD);
X	printf ("Number Points Name\n");
X	while (read (rfile, &record, sizeof (struct recitem)) > 0) {
X		printf ("%2d  %6lu %8s ", ++place, record.points,
X			record.str);
X		killed = 0;
X		if (*record.death == 'e')
X			printf ("escaped the dungeon [max level %d]",
X				record.maxlvl);
X		else {
X			switch (record.death[1]) {
X				case 'u': 
X					printf ("quit");
X					break;
X				case 'h': 
X					printf ("choked in his/her food");
X					break;
X				case 't': 
X					printf ("starved");
X					break;
X				case 'r': 
X					printf ("drowned");
X					break;
X				default: 
X					printf ("was killed");
X					killed++;
X			}
X
X printf (" on%s level %d", killed ? "" : " dungeon", record.level);
X
X			if (record.maxlvl != record.level)
X				printf (" [%d]", record.maxlvl);
X		}
X		if (killed)
X			printf (" by %s", record.death);
X		putchar ('.');
X		if (record.maxhp)
X			printf (" Hp: %s [%d]", (record.hp > 0) ?
X					itoa (record.hp) : "-", record.maxhp);
X		putchar ('\n');
X	}
X	close (rfile);
X}
X
Xint     deleted[45];
X
Xdelrecord () {
X	register int    fd, fd2;
X	int     count = 0;
X
X	printf ("Delete (Terminate with a zero): ");
X	fflush (stdout);
X	fd = open (RECORD, 0);
X	fd2 = creat (".Temp", 0777);
X	if (fd < 0 || fd2 < 0) {
X		printf ("Cannot open files!\n");
X		exit (2);
X	}
X	do {
X		scanf ("%d", &count);
X		++deleted[count];
X	} while (count);
X	fprintf (stderr, "Deleted nr");
X	count = 1;
X	while (read (fd, &record, sizeof (struct recitem)) >    0) {
X		if (!deleted[count])
X			write (fd2, &record, sizeof (struct recitem));
X		else
X			                                                fprintf (stderr, " %d", count);
X		                                              ++count;
X	}
X	                                                        putc ('\n', stderr);
X	close (fd);
X	close (fd2);
X	execl ("/bin/mv", "mv", ".Temp", RECORD, NULL);
X}
X
Xchar   *
X        itoa (a)
Xregister int    a;
X{
X	static char     buf[8];
X
X	sprintf (buf, "%d", a);
X	return (buf);
X}
X
Xdoname (let, buf)
Xregister char   let;
Xregister char  *buf;
X{
X	switch (let) {
X
X		case '"': 
X			strcpy (buf, "The amulet of Frobozz");
X			break;
X
X		case '%': 
X			strcpy (buf, "some food");
X			break;
X
X		case ')': 
X			strcpy (buf, "a weapon");
X			break;
X
X		case '[': 
X			strcpy (buf, "armor");
X			break;
X
X		case '!': 
X			strcpy (buf, "a potion");
X			break;
X
X		case '?': 
X			strcpy (buf, "a scroll");
X			break;
X
X		case '/': 
X			strcpy (buf, "a wand");
X			break;
X
X		case '=': 
X			strcpy (buf, "a ring");
X			break;
X
X		case '*': 
X			strcpy (buf, "a gem");
X			break;
X
X		default: 
X			sprintf (buf, "a glorkum %c(0%o)", let, let);
X	}
X}
X
Xgetret () {
X	printf ("AHit j<return>k to continue");
X	fflush (stdout);
X	while (getchar () != '\n');
X}
SHAR_EOF
if test 6304 -ne "`wc -c 'show.c'`"
then
	echo shar: error transmitting "'show.c'" '(should have been 6304 characters)'
fi
echo shar: extracting "'string.s'" '(2574 characters)'
if test -f 'string.s'
then
	echo shar: over-writing existing file "'string.s'"
fi
sed 's/^X//' << \SHAR_EOF > 'string.s'
X	.text
X	.globl  _strcpy
X_strcpy:
X~~m=.
X|        sub     ax,ax           | tell csv that I don't have any locals
X|        call    csv             | check stack crash, save bp, si & di
X	push bp
X	mov bp,sp
X	push di
X	push si
X~dst=4
X~src=6
X~cnt=8
X	mov     si,*~src(bp)    | load si with source pointer
X	mov     di,*~dst(bp)    | load di with destination pointer
X	mov     bx, di          | save address to return
XL25:                            | start of loop
X	movb    al, (si)        | fetch source char in al
X	movb    (di), al        | place in destination
X	inc     si              | increment source pointer
X	inc     di              | increment destination pointer
X	andb    al, al          | set the flags
X	jnz     L25             | Loop until zf=1
X	mov     ax, bx          | return destination pointer
X	jmp     cret            | and return to caller.
X
X	.globl  _strncpy
X_strncpy:
X|        sub     ax,ax           | tell csv I don't have any local variables
X|        call    csv             | save si, di, bp, check for collision
X	push bp
X	mov bp,sp
X	push di
X	push si
X	mov     si,*~src(bp)    | load source operand
X	mov     di,*~dst(bp)    | load destination operand
X	mov     cx,*~cnt(bp)    | load count
X	mov     bx,di           | save address of source for return
X	cmp     cx,0            | see if cx set
X	je      L27             | loop out if so.
XL26:    movb    al,(si)         | fetch ahcecter to move
X	movb    (di),al         | store it.
X	inc     di              | increment destination
X	and     al, al          | set flags
X	jz      L28             | if char is null, skip
X	inc     si              |  increment of source (this will null pad)
XL28:    loop    L26             | loop until count is 0
XL27:    mov     ax, bx          | get address of dest in ax
X	jmp     cret            | and return it to caller.
X
X	.globl  _strchr
X
X_strchr:
X	mov     bx, sp          | usr bx as adr register
X	mov     ax, *4(bx)      | fetch charecter in al
X	mov     bx, *2(bx)      | fetch address in bx
X	j       L31             | skip to start of while loop
X
XL29:
X	cmpb    al, ah          | see if charecters match
X	je      L30             | jmp out if true
X	inc     bx              | move to next charecter in string
X
XL31:
X	movb    ah,(bx)         | fetch charecter in ah
X	andb    ah, ah          | set flags on that char
X	jnz     L29             | if not end of string, loop up
X	sub     ax, ax          | else at end of string,
X	ret                     | return with NULL in ax
X
XL30:    mov     ax, bx          | if found char, exit with
X	ret                     | address in ax
X
X	.data
SHAR_EOF
if test 2574 -ne "`wc -c 'string.s'`"
then
	echo shar: error transmitting "'string.s'" '(should have been 2574 characters)'
fi
#	End of shell archive
exit 0
