Relay-Version: version B 2.10 5/3/83; site utzoo.UUCP
Posting-Version: Notesfiles $Revision: 1.6.2.16 $; site pbear.UUCP
Path: utzoo!watmath!clyde!burl!ulysses!allegra!mit-eddie!think!pbear!peterb
From: peterb@pbear.UUCP
Newsgroups: net.sources.games
Subject: PC/IX Hack (1 of 5)
Message-ID: <2900004@pbear.UUCP>
Date: Tue, 28-May-85 18:05:00 EDT
Article-I.D.: pbear.2900004
Posted: Tue May 28 18:05:00 1985
Date-Received: Thu, 30-May-85 06:20:47 EDT
Lines: 1705
Nf-ID: #N:pbear:2900004:000:41517
Nf-From: pbear!peterb    May 28 18:05:00 1985


#!/bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #!/bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	Makefile
#	alloc.c
#	data
#	envir.h
#	hack.armors.h
#	hack.bones.c
#	hack.c
#	hack.debug.c
#	hack.do.c
# This archive created: Tue May 28 17:51:48 1985
export PATH; PATH=/bin:$PATH
echo shar: extracting "'Makefile'" '(2292 characters)'
if test -f 'Makefile'
then
	echo shar: over-writing existing file "'Makefile'"
fi
sed 's/^X//' << \SHAR_EOF > 'Makefile'
X# hack makefile.
X# layout en verdere verbeteringen Michiel en Fred
X
XPLAYDIR = /usr/games/playdir
XSAVEDIR = /usr/games/playdir/save
X
XCFLAGS = -O -i
XLIB = -ltermcap
X
XTARGET = hack
X
XHFILES = hack.c hack.lev.c hack.pri.c hack.do.c hack.do1.c hack.main.c\
Xhack.mon.c hack.dog.c hack.invent.c hack.eat.c hack.save.c\
Xhack.do_wear.c hack.shk.c hack.io.c hack.end.c hack.rip.c\
Xhack.bones.c hack.mkobj.c hack.monst.c hack.invinit.c hack.worm.c\
Xhack.debug.c hack.move.c hack.do.misc.c hack.mon.do.c hack.str.c\
Xhack.office.c
X
XMFILES = mklev.c mklev.make.c mklev.mkobj.c mklev.svlev.c 
X
XGFILES = alloc.c rnd.c
X
XHOBJ = hack.o hack.lev.o hack.pri.o hack.do.o hack.do1.o hack.main.o\
Xhack.mon.o hack.dog.o hack.invent.o hack.eat.o hack.save.o\
Xhack.do_wear.o hack.shk.o hack.io.o hack.end.o hack.rip.o\
Xhack.bones.o hack.mkobj.o hack.monst.o hack.invinit.o hack.worm.o\
Xhack.debug.o hack.move.o hack.do.misc.o hack.mon.do.o hack.str.o\
Xhack.office.o string.o
X
XGOBJ = rnd.o alloc.o
X
XMKOBJ = mklev.o mklev.make.o mklev.mkobj.o
X
Xall: hack mklev show
X
X$(TARGET)   : $(HOBJ) $(GOBJ)
X	@echo Loading...
X	@$(CC) $(CFLAGS) -o $(TARGET) $(GOBJ) $(HOBJ) $(LIB)
X	@size $(TARGET)
X	@echo 'Done Hack'
X
Xstring.o : string.s
X	as -g -o string.o string.s
X
X$(HOBJ) $(MKOBJ) :	hack.h
Xhack.do.misc.o:		hack.do.vars.h envir.h
Xhack.vars.h:		hack.foods.h hack.armors.h hack.weapons.h
Xhack.lev.o:		hack.savelev.c
Xhack.dog.o hack.monst.o:        hack.dog.h
Xhack.mkobj.o mklev.mkobj.o: 	hack.vars.h
Xhack.main.o hack.lev.o hack.debug.o \
Xhack.do.misc.o hack.end.o hack.invinit.o: envir.h
X
Xhack.invinit.o:
X	cc $(CFLAGS) -c hack.invinit.c
X
Xmklev.o: hack.h envir.h
X	cc $(CFLAGS) -c mklev.c
X
Xmklev:  $(MKOBJ) $(GOBJ) mklev.svlev.c
X	cc $(CFLAGS) $(MKOBJ) $(GOBJ) -o mklev
X	@echo 'Done mklev'
X
Xshow: show.c hack.h envir.h
X	cc -O show.c -o show
X	@echo 'Done show'
X
Xcleanup:
X	rm -f $(HOBJ) $(GOBJ) $(PLAYDIR)/show $(PLAYDIR)/makelev \
X	   $(PLAYDIR)/bones_* mklev.mkobj.o mklev.o
X
Xinstall: all 
X	rm -f $(PLAYDIR)/bones_*
X	install -c -m 4711 $(TARGET) $(PLAYDIR)/$(TARGET)
X	install -c -m 711 mklev $(PLAYDIR)/mklev
X	install -c -m 700 show $(PLAYDIR)/show
X
Xnew: dirs install
X
Xdirs:
X	mkdir $(PLAYDIR)
X	mkdir $(SAVEDIR)
X	mv help $(PLAYDIR)
X	cp /dev/null $(PLAYDIR)/record
X	chmod 700 $(PLAYDIR)/record
X
Xlint:
X	lint -phbxac mk*.c rnd.c alloc.c -lc
SHAR_EOF
if test 2292 -ne "`wc -c 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 2292 characters)'
fi
echo shar: extracting "'alloc.c'" '(389 characters)'
if test -f 'alloc.c'
then
	echo shar: over-writing existing file "'alloc.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'alloc.c'
X/*
X * Alloc.c
X *
X * Added new return values Michiel and Fred
X *
X */
X
X/*
X * The strange return value of alloc is implemented to shut lint up
X */
X
X#include "hack.h"
X
Xextern char    *malloc ();
X
Xunion PTRS ptrs;
X
Xunion PTRS *
Xalloc (num)
Xregister        num;
X{
X	register char  *val;
X
X	if (!(val = malloc (num)))
X		panic (CORE, "Cannot get %d bytes", num);
X	ptrs.Val = val;
X	return (&ptrs);
X}
SHAR_EOF
if test 389 -ne "`wc -c 'alloc.c'`"
then
	echo shar: error transmitting "'alloc.c'" '(should have been 389 characters)'
fi
echo shar: extracting "'data'" '(6528 characters)'
if test -f 'data'
then
	echo shar: over-writing existing file "'data'"
fi
sed 's/^X//' << \SHAR_EOF > 'data'
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X!       a potion                                 |
X"       The amulet of Frobozz                    |
X#       a corridor                               |
X$       a pile, pot or chest of gold             |
X%       a piece of food                          |
X&       a demon                                  |
X'       a lurker above                           |
X\                                                |
X)       a weapon                                 |
X*       a gem                                    |
X+       a door                                   |
X,       a trapper                                |
X-       a wall                                   |
X.       the floor of a room                      |
X/       a wand                                   |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X\                                                |
X:       a chameleon                              |
X;       a giant ale                              |
X<       the staircase to the previous level      |
X=       a ring                                   |
X>       the staircase to the next level          |
X?       a scroll                                 |
X@       a human (or you)                         |
XA       a giant ant                              |
XB       a giant bat                              |
XC       a centaur                                |
XD       a dragon                                 |
XE       a floating eye                           |
XF       a freezing sphere                        |
XG       a gnome                                  |
XH       a hobgoblin                              |
XI       an invisible stalker                     |
XJ       a jackal                                 |
XK       a kobold                                 |
XL       a leprechaun                             |
XM       a mimic                                  |
XN       a nymph                                  |
XO       an orc                                   |
XP       a purple worm                            |
XQ       a quasit                                 |
XR       a rust monster                           |
XS       a snake                                  |
XT       a troll                                  |
XU       an umber hulk                            |
XV       a vampire                                |
XW       a wraith                                 |
XX       a xorn                                   |
XY       a yeti                                   |
XZ       a zombie                                 |
X[       a suit of armor                          |
X\                                                |
X\                                                |
X^       a trap                                   |
X\                                                |
X\                                                |
Xa       an acid blob                             |
Xb       a giant beetle                           |
Xc       a cockatrice                             |
Xd       a dog                                    |
Xe       an ettin                                 |
Xf       a fog cloud                              |
Xg       a gelatinous cube                        |
Xh       a homunculus                             |
Xi       an imp                                   |
Xj       a jaguar                                 |
Xk       a killer bee                             |
Xl       a leocrotta                              |
Xm       a minouter                               |
Xn       a neo-otyugh                             |
Xo       an owlbear                               |
Xp       a piercer                                |
Xq       a quivering blob                         |
Xr       a giant rat                              |
Xs       a giant scorpion                         |
Xt       a teleporter                             |
Xu       a ugod                                   |
Xv       a violet fungi                           |
Xw       a long worm                              |
Xx       a xerp                                   |
Xy       a yellow light                           |
Xz       a zelomp                                 |
X\                                                |
X|       a wall                                   |
X}       a water filled area                      |
X~       a wormsegment                            |
X\                                                |
SHAR_EOF
if test 6528 -ne "`wc -c 'data'`"
then
	echo shar: error transmitting "'data'" '(should have been 6528 characters)'
fi
echo shar: extracting "'envir.h'" '(377 characters)'
if test -f 'envir.h'
then
	echo shar: over-writing existing file "'envir.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'envir.h'
X/*
X * Envir.h
X */
X
X#define	PLAYGROUND	"/usr/games/playdir"
X#define HELP 		"/usr/games/playdir/help"
X#define DATA            "/usr/games/playdir/data"
X#define RECORD		"/usr/games/playdir/record"
X#define LOCK		"/usr/games/playdir/hack.lock"
X#define WIZARD          "peterb"
X/*
X#define DEBUG
X*/
X
X#define SAVEDIR		"save/"
X#define MORE            "/usr/bin/more"
X#define VERSION		1
SHAR_EOF
if test 377 -ne "`wc -c 'envir.h'`"
then
	echo shar: error transmitting "'envir.h'" '(should have been 377 characters)'
fi
echo shar: extracting "'hack.armors.h'" '(429 characters)'
if test -f 'hack.armors.h'
then
	echo shar: over-writing existing file "'hack.armors.h'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.armors.h'
X/*
X * Hack.armors.h
X */
X
Xstruct armor armors[] = {
X	{ "plate mail",	 	    5,	5, 3, 2 },
X	{ "splint mail",	   10,	5, 4, 1 },
X	{ "banded mail",	   10,	5, 4, 0 },
X	{ "chain mail",		   10,	5, 5, 1 },
X	{ "scale mail",		   10,	5, 6, 0 },
X	{ "ring mail",		   15,	5, 7, 0 },
X	{ "studded leather armor", 15,	3, 7, 1 },
X	{ "leather armor",   	   20,	3, 8, 0 },
X	{ "elven cloak",	    5,	0, 9, 3 },
X	{ "PROG ERROR",	   	  100,	0, 0, 0 }
X };
SHAR_EOF
if test 429 -ne "`wc -c 'hack.armors.h'`"
then
	echo shar: error transmitting "'hack.armors.h'" '(should have been 429 characters)'
fi
echo shar: extracting "'hack.bones.c'" '(2293 characters)'
if test -f 'hack.bones.c'
then
	echo shar: over-writing existing file "'hack.bones.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.bones.c'
X/*
X * Hack.bones.c
X *
X * Added increased chances on bones files.
X * Fixed bug with mad shopkeeper.
X *
X */
X
X#include "hack.h"
X
X#define NOBONES	0
X#define BONES	1
X
Xextern char     plname[10];
Xextern  MONSTER shopkeeper;
X
Xstruct permonst pm_ghost = {
X	"ghost", '\t', 10, 3, -5, 1, 1, sizeof (plname)
X};
X
X/* (a3)#define	GHMAX	10 */
X
Xchar    bones[] = "bones_xx";
X
X/* Save bones and possessions of a deceased adventurer */
Xsavebones () {
X	register        fd;
X	register        OBJECT otmp;
X	register        GOLD_TRAP gtmp;
X	register        MONSTER mtmp;
X
X	if (!rn2 (1 + dlevel/2))
X		return;	/* not so many ghosts on low levels */
X	sprintf (&bones[6], "%d", dlevel);
X	if ((fd = open (bones, 0)) >= 0 ) {
X		close (fd);
X		return;
X	}
X
X /* Drop everything; the corpse's possessions are usually cursed */
X	otmp = invent;
X	while (otmp) {
X		otmp -> ox = u.ux;
X		otmp -> oy = u.uy;
X		otmp -> unpaid = 0;
X		otmp -> known = 0;
X		if (rn2 (5))
X			otmp -> cursed = 1;
X		if (!otmp -> nobj) {
X			otmp -> nobj = fobj;
X			fobj = invent;
X			invent = 0;/* Superfluous */
X			break;
X		}
X		otmp = otmp -> nobj;
X	}
X	if (makemon (&pm_ghost))
X		return;
X	fmon -> mx = u.ux;
X	fmon -> my = u.uy;
X	fmon -> msleep = 1;
X/* Added: sizeof fmon->extra */
X/* This is actually nonsens. Ghosts do not have names in this version */
X	strncpy (fmon -> mextra, plname, sizeof fmon -> mextra);
X	if (shopkeeper &&
X			inshproom (shopkeeper -> mx, shopkeeper -> my))
X		shopkeeper -> angry = 0;
X	gtmp = newgen ();
X	gtmp -> ngen = fgold;
X	fgold = gtmp;
X	gtmp -> gx = u.ux;
X	gtmp -> gy = u.uy;
X	gtmp -> gflag = somegold () + d (dlevel, 30);
X	u.ux = u.uy = 100;	/* Random outside map */
X	keepdogs (1);		/* All tame animals become wild again */
X	for (mtmp = fmon; mtmp; mtmp = mtmp -> nmon)
X		levlsym (mtmp -> mx, mtmp -> my, mtmp -> data -> mlet);
X	if ((fd = creat (bones, 0644)) < 0)
X		return;
X	savelev (fd);
X	close (fd);
X}
X
Xgetbones () {
X	register        fd, x, y;
X
X	sprintf (&bones[6], "%d", dlevel);
X	if ((fd = open (bones, 0)) < 0 || rn2 (3)) {
X		close (fd);	/* Sometimes we find bones */
X		return NOBONES;
X	}
X	getlev (fd);
X	close (fd);
X	if (unlink (bones) < 0) {
X		pline ("Cannot unlink %s", bones);
X		return NOBONES;
X	}
X	for (x = 0; x < 80; x++)
X		for (y = 0; y < 22; y++) {
X			levl[x][y].seen = 0;
X			levl[x][y].new = 0;
X		}
X	return BONES;
X}
SHAR_EOF
if test 2293 -ne "`wc -c 'hack.bones.c'`"
then
	echo shar: error transmitting "'hack.bones.c'" '(should have been 2293 characters)'
fi
echo shar: extracting "'hack.c'" '(10017 characters)'
if test -f 'hack.c'
then
	echo shar: over-writing existing file "'hack.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.c'
X/*
X * Hack.c
X */
X
X#include "hack.h"
X
Xextern char     news0 (), *setan ();
X
Xextern char     seelx, seehx, seely, seehy;/* Corners of lit room */
X /* l for Low, h for High */
X
X#define CANSEE 		1
X#define CANNOTSEE 	0
X#define HITYOU		1
X#define MISSYOU		0
X#define MONALIVE	1
X#define MONDEAD		0
X
X
Xchar   *
X        lowc (str)
Xregister char  *str;
X{
X	if (*str >= 'A' && *str <= 'Z')
X		*buf = *str + 'a' - 'A';
X	else
X		*buf = *str++;
X	buf[1] = 0;
X	return (buf);
X}
X
X/* (a3) mix van setsee() en seeon() */
XsetCon (setc) {			/* setc: 1-setsee, 0-seeon (we just went to a
X				   new level) */
X	register        x, y;
X	register        MONSTER mtmp;
X	int     lx, hx, ly, hy;
X
X	if (u.ublind) {
X		if (setc)
X			pru ();
X		else
X			docrt ();
X		return;
X	}
X	if (levl[u.ux][u.uy].lit) {
X		for (seelx = u.ux; levl[seelx - 1][u.uy].lit; seelx--);
X		for (seehx = u.ux; levl[seehx + 1][u.uy].lit; seehx++);
X		for (seely = u.uy; levl[u.ux][seely - 1].lit; seely--);
X		for (seehy = u.uy; levl[u.ux][seehy + 1].lit; seehy++);
X		lx = seelx;
X		hx = seehx;
X		ly = seely;
X		hy = seehy;
X	}
X	else {
X		seehx = 0;
X		lx = u.ux - 1;
X		hx = u.ux + 1;
X		ly = u.uy - 1;
X		hy = u.uy + 1;
X		if (setc) {
X			seelx = lx;
X			seehx = hx;
X			seely = ly;
X			seehy = hy;
X		}
X	}
X	for (x = lx; x <= hx; x++)
X		for (y = ly; y <= hy; y++) {
X			if (setc)
X				prl (x, y);
X			else {
X				if (!levl[u.ux][u.uy].lit &&
X						!levl[x][y].typ)
X					continue;
X				levl[x][y].seen = 1;
X				if (mtmp = m_at (x, y))
X					pmon (mtmp);
X			}
X		}
X	if (!setc) {
X		docrt ();
X		return;
X	}
X	if (!levl[u.ux][u.uy].lit)
X		seehx = 0;	/* Seems necessary elsewhere */
X	else {
X		if (seely == u.uy)
X			for (x = u.ux - 1; x <= u.ux + 1; x++)
X				prl (x, seely - 1);
X		if (seehy == u.uy)
X			for (x = u.ux - 1; x <= u.ux + 1; x++)
X				prl (x, seehy + 1);
X		if (seelx == u.ux)
X			for (y = u.uy - 1; y <= u.uy + 1; y++)
X				prl (seelx - 1, y);
X		if (seehx == u.ux)
X			for (y = u.uy - 1; y <= u.uy + 1; y++)
X				prl (seehx - 1, y);
X	}
X}
X
XunCoff (unc, mode) {
X /* 
X  * (a3) mix van unsee() en seeoff()
X  * unc: 1-unsee, 0-seeoff
X  * mode: 1-redo @ (misc movement),
X  * 0-leave them (blindness (Usually))
X  */
X
X	register        x, y;
X	register        PART * lev;
X	int     lx, hx, ly, hy;
X
X	if (seehx) {
X		lx = seelx;
X		hx = seehx;
X		ly = seely;
X		hy = seehy;
X	}
X	else {
X		lx = u.ux - 1;
X		hx = u.ux + 1;
X		ly = u.uy - 1;
X		hy = u.uy + 1;
X	}
X	for (x = lx; x <= hx; x++)
X		for (y = ly; y <= hy; y++) {
X			lev = &levl[x][y];
X			if (lev -> scrsym == '@' && mode) {
X				if (unc)
X					newsym (x, y);
X				else
X					lev -> scrsym = news0 (x, y);
X			}
X			else if (!seehx && lev -> scrsym == '.') {
X				if (mode) {
X					if (unc) {
X						lev -> scrsym = ' ';
X						lev -> new = 1;
X						on (x, y);
X					}
X				}
X				else
X					lev -> seen = 0;
X			}
X		}
X	seehx = 0;
X}
X
Xhitu (mlev, dam, name)
Xregister        mlev, dam;
Xregister char  *name;
X{
X	mlev += (u.uac - 1);
X	if (multi < 0)
X		mlev += 4;
X	if (u.uinvis)
X		mlev -= 2;
X	if (mlev < rnd (20)) {
X		pseebl ("%s misses", name);
X		return (MISSYOU);
X	}
X	pseebl ("%s hits!", name);
X	if (name == NULL)
X		impossible ();
X	losehp (dam, name);
X	return (HITYOU);
X}
X
Xcansee (x, y)
Xchar    x, y;
X{
X	if (u.ublind || u.uswallow)
X		return (CANNOTSEE);
X	if (dist (x, y) < 3)
X		return (CANSEE);
X	if (levl[x][y].lit && seelx <= x && x <= seehx && seely <= y &&
X			y <= seehy)
X		return (CANSEE);
X	return (CANNOTSEE);
X}
X
Xlong
X        pow (num)
Xregister        num;		/* Returns 2^num */
X{
X	return (1 << num);
X}
X
Xland () {			/* a3 */
X	do {
X		u.ux = rn2 (80);
X		u.uy = rn2 (22);
X	} while (levl[u.ux][u.uy].typ != ROOM || m_at (u.ux, u.uy));
X}
X
Xtele () {
X	unCoff (UNC, 0);	/* Dat was een 1 (a3) */
X	unstuck (u.ustuck);	/* a3 */
X	u.utrap = 0;
X	do
X		land ();
X	while (o_at (u.ux, u.uy) || g_at (u.ux, u.uy, ftrap) ||
X			g_at (u.ux, u.uy, fgold));
X	setCon (SETC);
X	inshop ();
X}
X
Xchar   *
X        sitoa (a)
Xregister int    a;
X{
X	static char     buffer[8];
X
X	sprintf (buffer, "+%d", a);
X	return ((a < 0) ? buffer + 1 : buffer);
X}
X
Xdoname (obj, buffer)
Xregister        OBJECT obj;
Xregister char  *buffer;
X{
X	switch (obj -> olet) {
X
X		case '"': 
X			strcpy (buffer, "The amulet of Frobozz");
X			break;
X
X		case '%': 
X			if (obj -> quan > 1)
X				sprintf (buffer, "%d %ss", obj -> quan,
X						foods[obj -> otyp].foodnam);
X			else
X				strcpy (buffer, setan (foods[obj -> otyp].foodnam));
X			break;
X
X		case ')': 
X			killer = weapons[obj -> otyp].wepnam;/* a3 */
X			if (obj -> known) {
X				if (obj -> quan > 1)
X					sprintf (buffer, "%d %s %ss", obj -> quan,
X							sitoa (obj -> spe), killer);
X				else
X					sprintf (buffer, "a %s %s", sitoa (obj -> spe),
X							killer);
X			}
X			else {
X				if (obj -> quan > 1)
X					sprintf (buffer, "%d %ss", obj -> quan,
X							killer);
X				else
X					strcpy (buffer, setan (killer));
X			}
X			if (obj == uwep)
X				strcat (buffer, " (weapon in hand)");
X			break;
X
X		case '[': 
X			if (obj -> known)
X				sprintf (buffer, "%s %s",
X						sitoa (obj -> spe - 10 + armors[obj -> otyp].a_ac),
X						armors[obj -> otyp].armnam);
X			else
X				strcpy (buffer, armors[obj -> otyp].armnam);
X			if (obj == uarm || obj == uarm2)
X				strcat (buffer, " (being worn)");
X			break;
X
X		case '!': 
X			if (oiden[obj -> otyp] & POTN || potcall[obj -> otyp]) {
X				if (obj -> quan > 1)
X					sprintf (buffer, "%d potions ", obj -> quan);
X				else
X					strcpy (buffer, "a potion ");
X				while (*buffer)
X					buffer++;
X				if (potcall[obj -> otyp])
X					sprintf (buffer, "called %s",
X							potcall[obj -> otyp]);
X				else
X					sprintf (buffer, "of %s",
X							pottyp[obj -> otyp]);
X			}
X			else {
X				killer = " potion";
X		P: 
X				if (obj -> quan > 1)
X					sprintf (buffer, "%d %s%ss", obj -> quan,
X							potcol[obj -> otyp], killer);
X				else
X					sprintf (buffer, "%s%s",
X							setan (potcol[obj -> otyp]),
X							killer);
X			}
X			break;
X
X		case '?': 
X			if (obj -> quan > 1)
X				sprintf (buffer, "%d scrolls ", obj -> quan);
X			else
X				strcpy (buffer, "a scroll ");
X			while (*buffer)
X				buffer++;
X			if (oiden[obj -> otyp] & SCRN)
X				sprintf (buffer, "of %s", scrtyp[obj -> otyp]);
X			else if (scrcall[obj -> otyp])
X				sprintf (buffer, "called %s", scrcall[obj -> otyp]);
X			else
X				sprintf (buffer, "labeled %s", scrnam[obj -> otyp]);
X			break;
X
X		case '/': 
X			if (oiden[obj -> otyp] & WANN)
X				sprintf (buffer, "a wand of %s", wantyp[obj -> otyp]);
X			else if (wandcall[obj -> otyp])
X				sprintf (buffer, "a wand called %s",
X						wandcall[obj -> otyp]);
X			else
X				sprintf (buffer, "%s wand",
X						setan (wannam[obj -> otyp]));
X			if (obj -> known) {
X				while (*buffer)
X					buffer++;
X				sprintf (buffer, " (%d)", obj -> spe);
X			}
X			break;
X
X		case '=': 
X			if (oiden[obj -> otyp] & RINN) {
X				if (obj -> known)
X					sprintf (buffer, "a %s ring of %s",
X							sitoa (obj -> spe),
X							ringtyp[obj -> otyp]);
X				else
X					sprintf (buffer, "a ring of %s",
X							ringtyp[obj -> otyp]);
X			}
X			else if (ringcall[obj -> otyp])
X				sprintf (buffer, "a ring called %s",
X						ringcall[obj -> otyp]);
X			else
X				sprintf (buffer, "%s ring",
X						setan (rinnam[obj -> otyp]));
X			if (obj == uright)
X				strcat (buffer, " (on right hand)");
X			if (obj == uleft)
X				strcat (buffer, " (on left hand)");
X			break;
X
X		case '*': 
X			killer = " gem";
X			goto P;
X
X		case '_': 
X			sprintf (buffer, "%s key",
X					setan (potcol[obj -> otyp - 30]));
X			break;
X
X		default: 
X			sprintf (buffer, "a%dglorkum %c(0%o)%d", obj -> otyp,
X					obj -> olet, obj -> olet, obj -> spe);
X	}
X	if (obj -> unpaid)
X		strcat (buffer, " (unpaid)");
X}
X
Xabon () {
X	if (u.ustr == 3)
X		return - 3;
X	if (u.ustr < 6)
X		return - 2;
X	if (u.ustr < 8)
X		return - 1;
X	if (u.ustr < 17)
X		return 0;
X	if (u.ustr < 69)
X		return 1;	/* up to 18/50 */
X	if (u.ustr < 118)
X		return 2;
X	return 3;
X}
X
Xdbon () {
X	if (u.ustr < 6)
X		return - 1;
X	if (u.ustr < 16)
X		return 0;
X	if (u.ustr < 18)
X		return 1;
X	if (u.ustr == 18)
X		return 2;	/* up to 18 */
X	if (u.ustr < 94)
X		return 3;	/* up to 18/75 */
X	if (u.ustr < 109)
X		return 4;	/* up to 18/90 */
X	if (u.ustr < 118)
X		return 5;	/* up to 18/99 */
X	return 6;		/* 18/00 */
X}
X
Xlosestr (num)
Xregister        num;
X{
X	u.ustr -= num;
X	while (u.ustr < 3) {
X		u.ustr++;
X		u.uhp -= 6;
X		u.uhpmax -= 6;
X		flags.dhp = flags.dhpmax = 1;
X	}
X	flags.dstr = 1;
X}
X
Xlosehp (n, knam)
Xregister        n;
Xchar   *knam;
X{
X	u.uhp -= n;
X	flags.dhp = 1;
X	if (u.uhp <= 0)
X		killer = knam;
X}
X
Xchar   *
X        setan (str)
Xregister char  *str;		/* a3 */
X{
X	static char     buffer[BUFSZ];
X
X	sprintf (buffer, "a%s %s", index ("aeiou", *str) ? "n" : "", str);
X	return buffer;
X}
X
Xweight (obj)
Xregister        OBJECT obj;
X{
X	switch (obj -> olet) {
X		case '"': 
X			return 2;
X		case '[': 
X			return 8;
X		case '%': 
X			if (obj -> otyp)/* Not a food ration */
X		case '*': 
X				return obj -> quan;
X		case '?': 
X			return (obj -> quan * 3);
X		case '!': 
X			return (obj -> quan << 1);
X		case ')': 
X			if (obj -> otyp == W_TWOH_SWORD)
X				return 4;
X			if (obj -> otyp <= W_AMMUNITION)/* darst arrows etc */
X				return (obj -> quan >> 1);
X		case '/': 
X			return 3;
X		case '_': 
X		case '=': 
X			return 1;
X		default: 
X			pline ("Weight: bad(%d) object 0%o.", obj -> otyp,
X					obj -> olet);
X			return 0;
X	}
X}
X
Xchar    mlarge[] = "bCDdegIlmnoPSsTUwY',&";
X
Xhmon (monst, obj)
Xregister        MONSTER monst;
Xregister        OBJECT obj;
X{
X	register        tmp;
X
X	if (!obj || obj == uwep && (obj -> otyp >= W_USE_AMMO ||
X				obj -> otyp <= W_AMMUNITION))
X		tmp = rnd (2);
X	else {
X		if (index (mlarge, monst -> data -> mlet)) {
X			tmp = rnd (weapons[obj -> otyp].wldam);
X			if (obj -> otyp == W_TWOH_SWORD)
X				tmp += d (2, 6);
X			else if (obj -> otyp == W_LONG_SWORD)
X				tmp += rnd (4);
X		}
X		else {
X			tmp = rnd (weapons[obj -> otyp].wsdam);
X			if (obj -> otyp == W_FLAIL || obj -> otyp == W_MACE)
X				tmp++;
X		}
X		tmp += obj -> spe;
X	}
X	tmp += u.udaminc + dbon ();
X	if (u.uswallow) {
X		if (monst -> data -> mlet == 'P')
X			tmp++;
X	}
X	else if (tmp <= 0)
X		tmp = 1;
X	monst -> mhp -= tmp;
X	return alive (monst);
X}
X
Xalive (monst)
Xregister        MONSTER monst;
X{
X	if (monst -> mhp > 0)
X		return (MONALIVE);
X	killed (monst);
X	return (MONDEAD);
X}
SHAR_EOF
if test 10017 -ne "`wc -c 'hack.c'`"
then
	echo shar: error transmitting "'hack.c'" '(should have been 10017 characters)'
fi
echo shar: extracting "'hack.debug.c'" '(214 characters)'
if test -f 'hack.debug.c'
then
	echo shar: over-writing existing file "'hack.debug.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.debug.c'
X/*
X * Hack.debug.c
X *
X * Debug function, only exists when DEBUG  if defined
X * Michiel and Fred
X */
X
X#include "hack.h"
X
X#ifdef DEBUG
Xdebug () {
X	nomove ();
X	pline( "You're in the debug function!" );
X}
X#endif DEBUG
SHAR_EOF
if test 214 -ne "`wc -c 'hack.debug.c'`"
then
	echo shar: error transmitting "'hack.debug.c'" '(should have been 214 characters)'
fi
echo shar: extracting "'hack.do.c'" '(14139 characters)'
if test -f 'hack.do.c'
then
	echo shar: over-writing existing file "'hack.do.c'"
fi
sed 's/^X//' << \SHAR_EOF > 'hack.do.c'
X/*
X * Hack.do.c
X */
X
X#include "hack.h"
X
Xextern char     NOTHIN[], WCLEV[], *nomvmsg;
X
Xchar    WELDED[] = "The %s is welded into your hand!";
X
X#define LETTER(ch)      ((ch >= '@' && ch <= 'Z' ) || \
X						       (ch >= 'a' && ch <= 'z'))
X#define CURSED		1
X#define NOTCURSED       0
X#define MAXLEVEL       40
X
X#define SIZE( x ) 	sizeof( x )/sizeof( x[0] )
X
X/* Routines to do various user commands */
X
Xdoglow (num)
Xregister        num;
X{
X	pline ("Your %s glows %s for a %s.", (flags.dac) ?
X		armors[uarm -> otyp].armnam : weapons[uwep -> otyp].wepnam,
X		(num < 0) ?
X		"black" : "green",
X		(num * num == 1) ?
X		"moment" : "while");
X}
X
Xdoread () {
X	register        OBJECT otmp;
X	register        MONSTER mtmp, mtmp2;
X	register        GOLD_TRAP gtmp;
X	OBJECT otmp2, otmp3;
X	int     num, zx, zy, xtmp, ytmp;
X
X	if (!(otmp = getobj ("?", "read"))) {
X		nomove ();
X		return;
X	}
X	pline ("As you read the scroll, it disappears.");
X
X /* 
X  Sometimes a scroll doesn't do anything
X  */
X	if (!rn2 (20)) {
X		pline ("You can't read the dialect!");
X		useup (otmp);
X		return;
X	}
X
X	switch (otmp -> otyp) {
X
X		case S_ENCH_ARMOR: 
X			if (!uarm) {
X				nothin (otmp);
X				return;
X			}
X			uarm -> cursed = 0;
X			uarm -> spe++;
X			u.uac--;
X			flags.dac = 1;
X			doglow (1);
X			break;
X
X		case S_DROP: 
X/*
X * New scroll instead of scroll of monster confusion. This scroll
X * drops everything you have on you. And put it somewhere on the level
X * Michiel and Fred
X */
X			pline ("Bloody hell, what's going on?");
X			do {
X				xtmp = rn2 (80);
X				ytmp = rn2 (22);
X			} while (levl[xtmp][ytmp].typ != ROOM);
X			useup (otmp);
X			oiden[S_DROP] |= SCRN;
X			doring (uleft, OFF);
X		/* Checked on existence in routine */
X			doring (uright, OFF);
X			for (otmp2 = invent; otmp2; otmp2 = otmp3) {
X				otmp3 = otmp2 -> nobj;
X				if (otmp2 == uarm || otmp2 == uarm2) {
X					u.uac += otmp2 -> spe;
X					flags.dac = 1;
X				}
X				otmp2 -> ox = xtmp;
X				otmp2 -> oy = ytmp;
X				subfrombill (otmp2);
X				otmp -> unpaid = 0;
X				otmp2 -> nobj = fobj;
X				fobj = otmp2;
X			}
X			if (u.ugold) {
X				gtmp = newgen ();
X				gtmp -> gx = xtmp;
X				gtmp -> gy = ytmp;
X				gtmp -> gflag = (unsigned) u.ugold;
X				gtmp -> ngen = fgold;
X				fgold = gtmp;
X				u.ugold = 0L;
X				flags.dgold = 1;
X			}
X			uright = NULL;
X			uleft = NULL;
X			uwep = NULL;
X			invent = NULL;
X			uarm = NULL;
X			uarm2 = NULL;
X			levl[xtmp][ytmp].scrsym = fobj -> olet;
X			levl[xtmp][ytmp].new = 0;
X			return;
X
X		case S_CURSE_LEV: /* Michiel */
X			pline ("Your body begins to glow black.");
X			docurse ();
X			u.uhcursed = 1;
X			break;
X
X		case S_REM_CURSE: 
X			pline ("You feel like someone is helping you.");
X			if (uleft)
X				uleft -> cursed = 0;
X			if (uright)
X				uright -> cursed = 0;
X			if (uarm)
X				uarm -> cursed = 0;
X			if (uarm2)
X				uarm2 -> cursed = 0;
X			if (uwep)
X				uwep -> cursed = 0;
X			break;
X
X		case S_ENCH_WEP: 
X		case S_DAM_WEP: 
X			if (!uwep) {
X				nothin (otmp);
X				return;
X			}
X			num = 5 - otmp -> otyp;/* 4 or 6 */
X			if (!rn2 (6))
X				num <<= 1;
X			uwep -> spe += num;
X			if (num > 0)
X				uwep -> cursed = 0;
X			doglow (num);
X			break;
X
X		case S_CREAT_MON: 
X			makemon (0);
X			mnexto (fmon);
X			break;
X
X		case S_GENOCIDE: 
X			pline ("You have found a scroll of genocide!");
X			do {
X				pline ("What monster do you want to genocide (Type the letter)? ");
X				flags.topl = 0;
X				getlin (buf);
X			} while (strlen (buf) != 1 || !LETTER (*buf) ||
X					 /* a3 */ index (genocided, *buf));
X			strcat (genocided, buf);
X			for (mtmp = fmon; mtmp; mtmp = mtmp2) {
X				mtmp2 = mtmp -> nmon;
X				if (mtmp -> data -> mlet == *buf)
X					cmdel (mtmp);
X			}
X			if (*buf == '@') {
X				killer = "scroll of genocide";
X				u.uhp = 0;
X			}
X			break;
X
X		case S_DESTR_ARMOR: 
X			if (!uarm) {
X				nothin (otmp);
X				return;
X			}
X			pline ("Your armor turns to dust and falls to the floor!");
X			u.uac += uarm -> spe;
X			flags.dac = 1;
X			useup (uarm);
X			uarm = uarm2;
X			uarm2 = 0;
X			break;
X
X		case S_LIGHT: 
X			litroom ();
X			break;
X
X		case S_TELEPORT: 
X/* 
X * Extended by Michiel and Fred:
X * One can jump between levels
X */
X			pline ("The scroll turns into an elevator.");
X			do {
X				pline ("Which stock please? ");
X				getlin (buf);
X				num = atoi (buf);
X			} while (num > MAXLEVEL - 3 && num != dlevel);
X			if (!*buf)
X				break;
X			if (num <= 0)
X				pline ("Don't fool around");
X			else if (num == dlevel)
X				tele ();
X			else if (u.ufloat || u.ustuck || getinventory ("\"")) {
X				nothin (otmp);
X				pline ("The elevator vanishes");
X				return;
X			}
X			else {
X				home ();
X				flush ();
X				keepdogs (1);
X				unCoff (COFF, 1);
X				dosavelev ();
X				if (num > dlevel) {
X					dlevel = (num > maxdlevel) ?
X						maxdlevel : num - 1;
X					while (dlevel < num) {
X						dodown ();
X						levl[u.ux][u.uy].scrsym = '<';
X					}
X				}
X				else {
X					dlevel = num + 1;
X					doup ();
X					levl[u.ux][u.uy].scrsym = '>';
X				}
X				land ();
X				losedogs ();
X				setCon (CON);
X				inshop ();/* a3: zie tele */
X			}
X			pline ("The elevator vanishes");
X			break;
X
X		case S_GOLD_DETEC: 
X			if (!fgold) {
X				nothin (otmp);
X				return;
X			}
X			cls ();
X			for (gtmp = fgold; gtmp; gtmp = gtmp -> ngen)
X				at (gtmp -> gx, gtmp -> gy, '$');
X			prme ();
X			pline ("You feel very greedy, and sense gold!");
X			more ();
X			docrt ();
X			break;
X
X		case S_IDENTIFY: 
X			pline ("This is an identify scroll.");
X			useup (otmp);
X			oiden[S_IDENTIFY] |= SCRN;
X			otmp = getobj (0, "identify");
X			if (otmp) {
X				switch (otmp -> olet) {
X					case '!': 
X						oiden[otmp -> otyp] |= POTN;
X						break;
X					case '?': 
X						oiden[otmp -> otyp] |= SCRN;
X						break;
X					case '/': 
X						oiden[otmp -> otyp] |= WANN;
X					case '[': 
X					case ')': 
X						otmp -> known = 1;
X						break;
X					case '=': 
X						oiden[otmp -> otyp] |= RINN;
X						if (otmp -> otyp >= R_GAIN_STR)
X							otmp -> known = 1;
X						break;
X				}
X				prinv (otmp);
X			}
X			return;
X
X		case S_MAG_MAP: 
X			pline ("On this scroll is a map!");
X			for (zy = 0; zy < 22; zy++)
X				for (zx = 0; zx < 80; zx++) {
X					if ((num = levl[zx][zy].typ) == SDOOR) {
X						levl[zx][zy].typ = DOOR;
X						atl (zx, zy, '+');
X					}
X					else if ((num >= WALL && num <= CORR) &&
X					/* or DOOR; no SDOOR */
X							!levl[zx][zy].seen)
X						newunseen (zx, zy);
X					else if (num >= 30 && num <= 41)
X						newunseen (zx, zy);
X				}
X			newunseen (xupstair, yupstair);
X			if (xdnstair)/* maze */
X				newunseen (xdnstair, ydnstair);
X			break;
X
X		case S_FIRE: 
X			pline ("The scroll erupts in a tower of flame!");
X			if (u.ufireres)
X				pline ("You are uninjured.");
X			else {
X				num = rnd (6);
X				losehp (num, "scroll of fire");
X				u.uhpmax -= num;
X				flags.dhpmax = 1;
X			}
X			break;
X
X		default: 
X			pline ("Bad(%d)scroll", otmp -> otyp);
X			impossible ();
X
X	}
X	if (!(oiden[otmp -> otyp] & SCRN)) {
X		if (otmp -> otyp > S_CREAT_MON && (otmp -> otyp != S_LIGHT
X					|| !u.ublind)) {
X			oiden[otmp -> otyp] |= SCRN;
X			u.urexp += 10;
X		}
X		else if (!scrcall[otmp -> otyp])
X			docall (otmp);
X	}
X	if (u.uhcursed && otmp -> otyp == S_REM_CURSE) {
X		u.uhcursed = 0;
X		pline ("Your body stops glowing black.");
X	}
X	useup (otmp);
X}
X
Xlitroom () {
X	register        zx, zy;
X
X	if (!xdnstair || !dlevel) {
X		pline (NOTHIN);
X		return;
X	}
X	if (levl[u.ux][u.uy].typ == CORR) {
X		if (!u.ublind)
X			pline ("The corridor lights up around you, then fades.");
X		return;
X	}
X	else if (!u.ublind)
X		if (levl[u.ux][u.uy].lit)
X			pline ("The room lights up around you.");
X		else
X			pline ("The room is lit.");
X	if (levl[u.ux][u.uy].lit)
X		return;
X	if (levl[u.ux][u.uy].typ == DOOR) {
X		if (levl[u.ux][u.uy + 1].typ == ROOM)
X			zy = u.uy + 1;
X		else if (levl[u.ux][u.uy - 1].typ == ROOM)
X			zy = u.uy - 1;
X		else
X			zy = u.uy;
X		if (levl[u.ux + 1][u.uy].typ == ROOM)
X			zx = u.ux + 1;
X		else if (levl[u.ux - 1][u.uy].typ == ROOM)
X			zx = u.ux - 1;
X		else
X			zx = u.ux;
X	}
X	else {
X		zx = u.ux;
X		zy = u.uy;
X	}
X	for (seelx = u.ux; levl[seelx - 1][zy].typ % 2; seelx--);
X /* ROOM or WALL or DOOR */
X	for (seehx = u.ux; levl[seehx + 1][zy].typ % 2; seehx++);
X	for (seely = u.uy; levl[zx][seely - 1].typ % 2; seely--);
X	for (seehy = u.uy; levl[zx][seehy + 1].typ % 2; seehy++);
X	for (zy = seely; zy <= seehy; zy++)
X		for (zx = seelx; zx <= seehx; zx++) {
X			levl[zx][zy].lit = 1;
X			if (!u.ublind && dist (zx, zy) > 2)
X				prl (zx, zy);
X		}
X}
X
Xdodrink () {
X	register        OBJECT otmp, objs;
X	register        MONSTER mtmp;
X	register        num;
X
X	if (!(otmp = getobj ("!", "drink"))) {
X		nomove ();
X		return;
X	}
X	switch (otmp -> otyp) {
X
X		case P_REST_STR: 
X			pline ("Wow!  This makes you feel great!");
X			if (u.ustr < u.ustrmax) {
X				u.ustr = u.ustrmax;
X				flags.dstr = 1;
X			}
X			break;
X
X		case P_BOOZE: 
X/*                        pline ("Ooph!  This tastes like liquid fire!");
X			u.uconfused += d (3, 8);
X			if (u.uhp < u.uhpmax)
X				losehp (-1, "");
X			if (!rn2 (4)) {
X				pline ("You pass out.");
X				multi = -rnd (15);
X				nomvmsg = "You awake with a headache.";
X			}   */
X			pline("Your hands start glowing blue!");
X			u.umconf=1;
X			break;
X
X		case P_INVIS: 
X			pline ("Gee!  All of a sudden, you can't see yourself.");
X			newsym (u.ux, u.uy);
X			u.uinvis += rn1 (15, 31);
X			break;
X
X		case P_JUICE: 
X			pline ("This tastes like fruit juice.");
X			lesshungry (20);
X			break;
X
X		case P_HEALING: 
X			pline ("You begin to feel better.");
X			num = rnd (10);
X	H: 
X			if (u.uhp + num > u.uhpmax) {
X				u.uhp = ++u.uhpmax;
X				if (otmp -> otyp == P_EXTRA_HEALING)
X					u.uhp = ++u.uhpmax;
X				flags.dhpmax = 1;
X			}
X			else
X				u.uhp += num;
X			flags.dhp = 1;
X			if (u.ublind)
X				u.ublind = 1;
X			break;
X
X		case P_FROZEN: 
X			pline ("Your feet are frozen to the floor!");
X			nomul (-rn1 (10, 25));
X			break;
X
X		case P_MONDETEC: 
X			if (!fmon) {
X				nothin (otmp);
X				return;
X			}
X			cls ();
X			for (mtmp = fmon; mtmp; mtmp = mtmp -> nmon)
X				at (mtmp -> mx, mtmp -> my, mtmp -> data -> mlet);
X			killer = "monster";
X	P: 
X			prme ();
X			pline ("You sense the presence of %ss.", killer);
X			more ();
X			docrt ();
X			break;
X
X		case P_OBJDETEC: 
X			if (!fobj) {
X				nothin (otmp);
X				return;
X			}
X			cls ();
X			for (objs = fobj; objs; objs = objs -> nobj)
X				at (objs -> ox, objs -> oy, objs -> olet);
X			killer = "object";
X			goto P;
X
X		case P_POISON: 
X			pline ("Yech! This stuff tastes like poison.");
X			losestr (rn1 (4, 3));
X			losehp (rnd (10), "poison potion");
X			break;
X
X		case P_CONF: 
X			pline ("Huh, What?  Where am I?");
X			u.uconfused += rn1 (7, 16);
X			break;
X
X		case P_GAIN_STR: 
X			if (u.ustr == 118) {
X				pline ("You've had enough of it!");
X				break;/* Michiel */
X			}
X			pline ("Wow do you feel strong!");
X			if (u.ustr > 17)
X				u.ustr += rnd (118 - u.ustr);
X			else
X				u.ustr++;
X			if (u.ustr > u.ustrmax)
X				u.ustrmax = u.ustr;
X			flags.dstr = 1;
X			break;
X
X		case P_SPEED: 
X			pline ("You are suddenly moving much faster.");
X			u.ufast += rn1 (10, 100);
X			break;
X
X		case P_BLIND: 
X			pline ("A cloud of darkness falls upon you.");
X			u.ublind += rn1 (100, 250);
X			unCoff (COFF, 0);
X			break;
X
X		case P_GAIN_LEV: 
X			num = rnd (10);
X			u.uhpmax += num;
X			u.uhp += num;
X			if (u.ulevel < 14) {/* a3 */
X				pline ("You feel more experienced.");
X				u.uexp = (10 * pow (u.ulevel - 1)) + 1;
X				pline (WCLEV, ++u.ulevel);
X				flags.dulev = 1;
X				flags.dexp = 1;
X			}
X			else
X				pline ("You feel more capable.");
X			flags.dhpmax = 1;
X			flags.dhp = 1;
X			break;
X
X		case P_EXTRA_HEALING: 
X			pline ("You feel much better.");
X			num = d (2, 20) + 1;
X			goto H; /* a3 */
X
X		default: 
X			pline ("Bad(%d)potion", otmp -> otyp);
X			impossible ();
X	}
X
X	if (!(oiden[otmp -> otyp] & POTN)) {
X		if (otmp -> otyp > P_BOOZE) {
X			oiden[otmp -> otyp] |= POTN;
X			u.urexp += 10;
X		}
X		else if (!potcall[otmp -> otyp])
X			docall (otmp);
X	}
X	useup (otmp);
X}
X
Xnothin (obj)
Xregister        OBJECT obj;
X{
X	pline ("You have a strange feeling for a moment, then it passes.");
X	if (obj -> olet == '?') {
X		if ((!(oiden[obj -> otyp] & SCRN)) &&
X				(!scrcall[obj -> otyp]))
X			docall (obj);
X	}
X	else if ((!(oiden[obj -> otyp] & POTN)) &&
X			(!potcall[obj -> otyp]))
X		docall (obj);
X	useup (obj);
X}
X
Xdodrop () {
X	register        OBJECT obj, otmp;
X	register int    num;
X
X	if (!(obj = getobj (0, "drop"))) {
X		nomove ();
X		return;
X	}
X	if (obj -> quan > 1 && !obj -> unpaid) {
X		pline ("How many do you want to drop (%d max) ?",
X				obj -> quan);
X		getlin (buf);
X		num = atoi (buf);
X
X		if (num > obj -> quan || (num <= 0 && *buf) ||
X				*buf == 0) {
X			if (num != 0)
X				pline ("You can't drop that %s!",
X						(num > 0) ? "many" : "few");
X			nomove ();
X			return;
X		}
X		if (num != obj -> quan) {
X			otmp = newobj ();
X			*otmp = *obj;/* Copies whole structure */
X			obj -> quan = num;
X			otmp -> quan -= num;
X			obj -> nobj = otmp;
X		}
X	}
X	if (obj == uarm || obj == uarm2 ||
X			obj == uright || obj == uleft) {
X		pline ("You cannot drop something you are wearing.");
X		nomove ();
X		return;
X	}
X /* (a3) i.p.v. `if( obj==uwep) uwep=0;':  */
X	if (obj == uwep && uwepcursed ())
X		return;
X	dropit (obj);
X	doname (fobj, buf);
X	pline ("You dropped %s.", buf);
X	subfrombill (obj);
X}
X
Xgemsdrop () {
X	register        OBJECT obj;
X	register        counting = 0;
X
X	for (obj = invent; obj;) {
X		if (obj -> olet == '*') {
X			counting += obj -> quan;
X			dropit (obj);
X			subfrombill (obj);
X			obj = invent;
X		}
X		else
X			obj = obj -> nobj;
X	}
X	if (!counting) {
X		nomove ();
X		pline ("You ain't got no gems, Hacker!");
X	}
X	else
X		pline ("You dropped %d gem%s.", counting,
X				counting == 1 ? "" : "s");
X}
X
Xuwepcursed () {			/* a3,drop or throw uwep */
X	if (uwep -> cursed) {
X		multi = 0;	/* Dowield() */
X		pline (WELDED, weapons[uwep -> otyp].wepnam);
X		return CURSED;
X	}
X	uwep = 0;
X	return NOTCURSED;
X}
X
Xgetinventory (string)
Xchar   *string;
X{
X	register        OBJECT otmp;
X
X	for (otmp = invent; otmp && !index (string, otmp -> olet); otmp =
X			otmp -> nobj);
X	return (otmp ? 1 : 0);
X}
X
Xdropit (obj)
Xregister        OBJECT obj;
X{
X	register        OBJECT otmp;
X
X	if (obj == invent)
X		invent = invent -> nobj;
X	else {
X		for (otmp = invent; otmp -> nobj != obj;
X				otmp = otmp -> nobj);
X		otmp -> nobj = obj -> nobj;
X	}
X	obj -> ox = u.ux;
X	obj -> oy = u.uy;
X	obj -> nobj = fobj;
X	fobj = obj;
X	if (u.uinvis)
X		newsym (u.ux, u.uy);
X}
SHAR_EOF
if test 14139 -ne "`wc -c 'hack.do.c'`"
then
	echo shar: error transmitting "'hack.do.c'" '(should have been 14139 characters)'
fi
#	End of shell archive
exit 0
