Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i043:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch4g
Message-ID: <4633@tekred.CNA.TEK.COM>
Date: 29 Sep 89 21:12:32 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2079
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 43
Archive-name: NetHack3/Patch4g
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 11)."
# Contents:  patches04g
# Wrapped by billr@saab on Fri Sep 29 13:24:55 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches04g' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches04g'\"
else
echo shar: Extracting \"'patches04g'\" \(57252 characters\)
sed "s/^X//" >'patches04g' <<'END_OF_FILE'
X*** amiga/Old/Install.ami	Wed Sep 27 10:12:13 1989
X--- amiga/Install.ami	Thu Sep 14 23:30:52 1989
X***************
X*** 43,51 ****
X  For floppy users (as I am), source is split over two diskettes, SRC1 and
X  SRC2. The first contains roughly [a-l]*.c, the second [m-z]*.c. Include
X  files are in the Assigned directory INCLUDE:, on SRC1:include. You may want
X! to rename hack.h to _hack.h, see below. Amiga specific files are in AMIGA:,
X! in SRC1:amiga. The modified stdio.h and friends also go there. There must
X! also be an AUXIL: somewhere.
X  
X  On a harddisk, you can either Assign SRC1: and SRC2: to the same directory,
X  or change the makefile slightly.
X--- 43,53 ----
X  For floppy users (as I am), source is split over two diskettes, SRC1 and
X  SRC2. The first contains roughly [a-l]*.c, the second [m-z]*.c. Include
X  files are in the Assigned directory INCLUDE:, on SRC1:include. You may want
X! to (initially) copy hack.h to _hack.h, see below. Amiga specific files are
X! in AMIGA:, in SRC1:amiga. The modified stdio.h and friends also go there.
X! There must also be an AUXIL: somewhere. I put all files that are not
X! necessary for the Amiga version on the same disk as AUXIL:, otherwise it
X! will not fit.
X  
X  On a harddisk, you can either Assign SRC1: and SRC2: to the same directory,
X  or change the makefile slightly.
X***************
X*** 114,131 ****
X    hh				      2606
X    history			      1503
X    license			      4417
X!   NetHack			    654324  #
X!   NetHack.cnf			      1990  #
X    opthelp			      3549
X    oracles			      3370
X    perm					 0
X!   record			       197  #
X    rumors			     16899
X    tower1			       369
X    tower2			       337
X    tower3			       371
X  
X! # These sizes may vary
X  
X  Happy NetHacking!
X  
X--- 116,133 ----
X    hh				      2606
X    history			      1503
X    license			      4417
X!   NetHack			    654324
X!   NetHack.cnf			      1990
X    opthelp			      3549
X    oracles			      3370
X    perm					 0
X!   record			       197
X    rumors			     16899
X    tower1			       369
X    tower2			       337
X    tower3			       371
X  
X! These sizes may vary from version to version
X  
X  Happy NetHacking!
X  
X*** amiga/Old/Makefile.ami	Wed Sep 27 10:12:29 1989
X--- amiga/Makefile.ami	Tue Sep 26 19:37:26 1989
X***************
X*** 41,58 ****
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, amiconf.h}, and possibly system.h
X  
X! # HACKCSRC = alloc.c apply.c artifact.c attrib.c bones.c cmd.c dbridge.c \
X! #	    decl.c demon.c do.c do_name.c do_wear.c dog.c dogmove.c dokick.c \
X! #	    dothrow.c eat.c end.c engrave.c exper.c extralev.c fountain.c \
X! #	    getline.c hack.c invent.c lock.c mail.c makemon.c mcastu.c mhitm.c \
X! #	    mhitu.c mklev.c mkmaze.c mkobj.c mkroom.c mon.c mondata.c \
X! #	    monmove.c monst.c mthrowu.c music.c o_init.c objects.c objnam.c \
X! #	    options.c pager.c pickup.c polyself.c potion.c pray.c pri.c \
X! #	    priest.c prisym.c read.c restore.c rip.c rnd.c rumors.c save.c \
X! #	    search.c shk.c shknam.c sit.c sounds.c sp_lev.c spell.c steal.c \
X! #	    termcap.c timeout.c topl.c topten.c track.c trap.c u_init.c \
X! #	    uhitm.c vault.c version.c weapon.c were.c wield.c wizard.c worm.c \
X! #	    worn.c write.c zap.c
X  
X  # all .c files but msdos.c, tos.c, *main.c, *tty.c, *unix.c, (system specific)
X  # and makedefs.c, lev_comp.c, panic.c (not part of any nethack)
X--- 41,58 ----
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, amiconf.h}, and possibly system.h
X  
X! # HACKCSRC = allmain.c alloc.c apply.c artifact.c attrib.c bones.c cmd.c \
X! #	    dbridge.c decl.c demon.c do.c do_name.c do_wear.c dog.c dogmove.c \
X! #	    dokick.c dothrow.c eat.c end.c engrave.c exper.c extralev.c \
X! #	    fountain.c getline.c hack.c invent.c lock.c mail.c makemon.c \
X! #	    mcastu.c mhitm.c mhitu.c mklev.c mkmaze.c mkobj.c mkroom.c mon.c \
X! #	    mondata.c monmove.c monst.c mthrowu.c music.c o_init.c objects.c \
X! #	    objnam.c options.c pager.c pickup.c polyself.c potion.c pray.c \
X! #	    pri.c priest.c prisym.c read.c restore.c rip.c rnd.c rumors.c \
X! #	    save.c search.c shk.c shknam.c sit.c sounds.c sp_lev.c spell.c \
X! #	    steal.c termcap.c timeout.c topl.c topten.c track.c trap.c \
X! #	    u_init.c uhitm.c vault.c version.c weapon.c were.c wield.c \
X! #	    wizard.c worm.c worn.c write.c zap.c
X  
X  # all .c files but msdos.c, tos.c, *main.c, *tty.c, *unix.c, (system specific)
X  # and makedefs.c, lev_comp.c, panic.c (not part of any nethack)
X***************
X*** 73,82 ****
X  # SOURCES = $(CSOURCES) $(HSOURCES)
X  
X  AOBJ  = amidos.o amitcap.o amitty.o amiunix.o amiwind.o
X! HOBJ1 = alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o decl.o \
X! 	demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o dothrow.o \
X! 	eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o hack.o \
X! 	invent.o lock.o
X  HOBJ2 = mail.o main.o makemon.o mcastu.o mhitm.o mhitu.o mklev.o mkmaze.o \
X  	mkobj.o mkroom.o mon.o mondata.o monmove.o monst.o mthrowu.o music.o \
X  	o_init.o objects.o objnam.o options.o pager.o pickup.o polyself.o \
X--- 73,82 ----
X  # SOURCES = $(CSOURCES) $(HSOURCES)
X  
X  AOBJ  = amidos.o amitcap.o amitty.o amiunix.o amiwind.o
X! HOBJ1 = allmain.o alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o \
X! 	decl.o demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o \
X! 	dothrow.o eat.o end.o engrave.o exper.o extralev.o fountain.o \
X! 	getline.o hack.o invent.o lock.o
X  HOBJ2 = mail.o main.o makemon.o mcastu.o mhitm.o mhitu.o mklev.o mkmaze.o \
X  	mkobj.o mkroom.o mon.o mondata.o monmove.o monst.o mthrowu.o music.o \
X  	o_init.o objects.o objnam.o options.o pager.o pickup.o polyself.o \
X***************
X*** 201,206 ****
X--- 201,207 ----
X  
X  # DO NOT DELETE THIS LINE
X  
X+ allmain.o:  include:hack.h
X  alloc.o:  include:config.h
X  apply.o:  include:hack.h include:edog.h
X  artifact.o:  include:hack.h include:artifact.h
X*** amiga/Old/amidos.c	Wed Sep 27 10:13:14 1989
X--- amiga/amidos.c	Sun Sep 17 14:26:11 1989
X***************
X*** 10,15 ****
X--- 10,16 ----
X  #undef COUNT
X  #undef NULL
X  
X+ #define NEED_VARARGS
X  #include "hack.h"
X  
X  extern char Initialized;
X***************
X*** 77,95 ****
X      return x < 0? -x: x;
X  }
X  
X- #ifdef REDO
X- 
X- int
X- tgetch()
X- {
X-     char ch, popch();
X- 
X-     if (!(ch = popch())) {
X- 	ch = WindowGetchar();
X-     }
X-     return ((ch == '\r') ? '\n' : ch);
X- }
X- #else /* REDO /**/
X  int
X  tgetch() {
X      char ch;
X--- 78,83 ----
X***************
X*** 97,105 ****
X      ch = WindowGetchar();
X      return ((ch == '\r') ? '\n' : ch);
X  }
X- #endif /* REDO /**/
X  
X- 
X  #ifdef DGK
X  # include <ctype.h>
X  /* # include <fcntl.h> */
X--- 85,91 ----
X***************
X*** 221,233 ****
X  	dirLock = CurrentDir(dirLock);
X  
X  	strcpy(buf, files);
X! 	for (i = 0; i < MAXLEVEL; i++) {
X  	    name_file(buf, i);
X  	    if (fileLock = Lock(buf, SHARED_LOCK)) {
X  		UnLock(fileLock);
X  		DeleteFile(buf);
X  	    }
X- 	}
X  
X  	UnLock(CurrentDir(dirLock));
X      }
X--- 207,220 ----
X  	dirLock = CurrentDir(dirLock);
X  
X  	strcpy(buf, files);
X! 	for (i = 0; i <= MAXLEVEL; i++) {
X  	    name_file(buf, i);
X  	    if (fileLock = Lock(buf, SHARED_LOCK)) {
X  		UnLock(fileLock);
X  		DeleteFile(buf);
X+ 	    } else if (IoErr() == ERROR_DEVICE_NOT_MOUNTED)
X+ 		break;
X  	    }
X  
X  	UnLock(CurrentDir(dirLock));
X      }
X***************
X*** 298,303 ****
X--- 285,293 ----
X  	    UnLock(fileLock);
X  	    if (status = CopyFile(from, to))
X  		goto failed;
X+ 	} else if (IoErr() == ERROR_DEVICE_NOT_MOUNTED) {
X+ 	    status = "disk not present";
X+ 	    goto failed;
X  	}
X      }
X  
X***************
X*** 488,494 ****
X  	    int  lth;
X  
X  	    if ((lth = sscanf(bufp,
X! 		 "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X  				&translate[6], &translate[7], &translate[8],
X--- 478,484 ----
X  	    int  lth;
X  
X  	    if ((lth = sscanf(bufp,
X! 	     "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X  				&translate[6], &translate[7], &translate[8],
X***************
X*** 497,502 ****
X--- 487,493 ----
X  				&translate[15], &translate[16], &translate[17],
X  				&translate[18], &translate[19], &translate[20],
X  				&translate[21], &translate[22], &translate[23],
X+ 				&translate[24], &translate[25], &translate[26],
X  				&translate[27], &translate[28], &translate[29],
X  				&translate[30], &translate[31])) < 0) {
X  		    msmsg ("Syntax error in GRAPHICS\n");
X***************
X*** 572,583 ****
X  }
X  
X  void
X! msmsg(fmt, a1, a2, a3)
X! char *fmt;
X! long a1, a2, a3;
X! {
X!     printf(fmt, a1, a2, a3);
X      (void) fflush(stdout);
X  }
X  
X  /* Follow the PATH, trying to fopen the file.
X--- 563,574 ----
X  }
X  
X  void
X! msmsg VA_DECL(char *, fmt)
X!     VA_START(fmt);
X!     VA_INIT(fmt, char *);
X!     vprintf(fmt, VA_ARGS);
X      (void) fflush(stdout);
X+     VA_END();
X  }
X  
X  /* Follow the PATH, trying to fopen the file.
X***************
X*** 710,715 ****
X--- 701,707 ----
X   *  memcmp - used to compare two struct symbols, in lev.c
X   */
X  
X+ #ifndef memcmp
X  memcmp(a, b, size)
X  register unsigned char *a, *b;
X  register int size;
X***************
X*** 721,723 ****
X--- 713,728 ----
X  
X      return 0;		/* equal */
X  }
X+ #endif
X+ 
X+ #ifndef memcpy
X+ char *
X+ memcpy(dest, source, size)
X+ register char *dest;
X+ char *source;
X+ int size;
X+ {
X+     movmem(source, dest, size);
X+     return dest;
X+ }
X+ #endif
X*** amiga/Old/amimenu.c	Wed Sep 27 10:14:01 1989
X--- amiga/amimenu.c	Thu Sep 14 23:30:47 1989
X***************
X*** 10,16 ****
X    {0,1,JAM2,0,0,(struct TextAttr*)NULL,(UBYTE*)str,(struct IntuiText*)NULL}
X  
X  	/* Commands */
X! 	TEXT(T_HELP,  "?   Display help");
X  	TEXT(T_O,     "O   Set options");
X  	TEXT(T_SHELL, "!   AmigaDos commands");
X  	TEXT(T_v,     "v   Version number");
X--- 10,17 ----
X    {0,1,JAM2,0,0,(struct TextAttr*)NULL,(UBYTE*)str,(struct IntuiText*)NULL}
X  
X  	/* Commands */
X! 	TEXT(T_HELP,  "?   Display help menu");
X! 	TEXT(T_amp,   "&   Explain a command");
X  	TEXT(T_O,     "O   Set options");
X  	TEXT(T_SHELL, "!   AmigaDos commands");
X  	TEXT(T_v,     "v   Version number");
X***************
X*** 33,43 ****
X  	TEXT(T_a,     "a   Apply/use something");
X  	TEXT(T_e,     "e   Eat something");
X  	TEXT(T_q,     "q   Quaff a potion");
X! 	TEXT(T_r,     "r   Read a scroll");
X  	TEXT(T_t,     "t   Throw/shoot weapon");
X  	TEXT(T_z,     "z   Zap a wand");
X  	TEXT(T_Z,     "Z   Cast a spell");
X- 	TEXT(T_X,     "X   Learn a spell");
X  	TEXT(T_HASH,  "#   Extended command");
X  
X  	/* Preparations */
X--- 34,43 ----
X  	TEXT(T_a,     "a   Apply/use something");
X  	TEXT(T_e,     "e   Eat something");
X  	TEXT(T_q,     "q   Quaff a potion");
X! 	TEXT(T_r,     "r   Read scroll/book");
X  	TEXT(T_t,     "t   Throw/shoot weapon");
X  	TEXT(T_z,     "z   Zap a wand");
X  	TEXT(T_Z,     "Z   Cast a spell");
X  	TEXT(T_HASH,  "#   Extended command");
X  
X  	/* Preparations */
X***************
X*** 73,91 ****
X  
X  static struct MenuItem cmdsub[] = {
X      { &cmdsub[1], IDATA('?', T_HELP,   0) }, /*   Display help */
X!     { &cmdsub[2], IDATA('O', T_O,     10) }, /*   Set options */
X!     { &cmdsub[3], IDATA('!', T_SHELL, 20) }, /*   AmigaDos commands */
X!     { &cmdsub[4], IDATA('v', T_v,     30) }, /*   Version number */
X!     { &cmdsub[5], IDATA(022, T_CR,    40) }, /*R  Redraw screen */
X!     { &cmdsub[6], IDATA(020 ,T_CP,    50) }, /*P  Repeat last message */
X!     { &cmdsub[7], IDATA('Q', T_Q,     60) }, /*   Quit game */
X!     { NULL,	  IDATA('S', T_S,     70) }, /*   Save the game */
X  };
X  
X  /* Inventory */
X  
X  #undef	WDT
X! #define WDT 200
X  
X  static struct MenuItem invsub[] = {
X      { &invsub[1], IDATA('i', T_i,      0) }, /*   Inventory */
X--- 73,92 ----
X  
X  static struct MenuItem cmdsub[] = {
X      { &cmdsub[1], IDATA('?', T_HELP,   0) }, /*   Display help */
X!     { &cmdsub[2], IDATA('&', T_amp,   10) }, /*   Explain a command */
X!     { &cmdsub[3], IDATA('O', T_O,     20) }, /*   Set options */
X!     { &cmdsub[4], IDATA('!', T_SHELL, 30) }, /*   AmigaDos commands */
X!     { &cmdsub[5], IDATA('v', T_v,     40) }, /*   Version number */
X!     { &cmdsub[6], IDATA(022, T_CR,    50) }, /*R  Redraw screen */
X!     { &cmdsub[7], IDATA(020 ,T_CP,    60) }, /*P  Repeat last message */
X!     { &cmdsub[8], IDATA('Q', T_Q,     70) }, /*   Quit game */
X!     { NULL,	  IDATA('S', T_S,     80) }, /*   Save the game */
X  };
X  
X  /* Inventory */
X  
X  #undef	WDT
X! #define WDT 184
X  
X  static struct MenuItem invsub[] = {
X      { &invsub[1], IDATA('i', T_i,      0) }, /*   Inventory */
X***************
X*** 106,117 ****
X      { &actsub[1], IDATA('a', T_a,     0) }, /*   Apply/use something */
X      { &actsub[2], IDATA('e', T_e,    10) }, /*   Eat something */
X      { &actsub[3], IDATA('q', T_q,    20) }, /*   Quaff a potion */
X!     { &actsub[4], IDATA('r', T_r,    30) }, /*   Read a scroll */
X      { &actsub[5], IDATA('t', T_t,    40) }, /*   Throw/shoot weapon */
X      { &actsub[6], IDATA('z', T_z,    50) }, /*   Zap a wand */
X      { &actsub[7], IDATA('Z', T_Z,    60) }, /*   Cast a spell */
X!     { &actsub[8], IDATA('X', T_X,    70) }, /*   Learn a spell */
X!     { NULL	, IDATA('#', T_HASH, 80) }, /*   Extended command */
X  };
X  
X  /* Preparations */
X--- 107,117 ----
X      { &actsub[1], IDATA('a', T_a,     0) }, /*   Apply/use something */
X      { &actsub[2], IDATA('e', T_e,    10) }, /*   Eat something */
X      { &actsub[3], IDATA('q', T_q,    20) }, /*   Quaff a potion */
X!     { &actsub[4], IDATA('r', T_r,    30) }, /*   Read a scroll/spellbook */
X      { &actsub[5], IDATA('t', T_t,    40) }, /*   Throw/shoot weapon */
X      { &actsub[6], IDATA('z', T_z,    50) }, /*   Zap a wand */
X      { &actsub[7], IDATA('Z', T_Z,    60) }, /*   Cast a spell */
X!     { NULL	, IDATA('#', T_HASH, 70) }, /*   Extended command */
X  };
X  
X  /* Preparations */
X*** amiga/Old/amitty.c	Wed Sep 27 10:14:25 1989
X--- amiga/amitty.c	Sun Sep 17 14:26:15 1989
X***************
X*** 4,9 ****
X--- 4,10 ----
X  /* tty.c - (Amiga) version */
X  
X  
X+ #define NEED_VARARGS
X  #include "hack.h"
X  
X  extern int Enable_Abort;
X***************
X*** 40,51 ****
X  
X  /* fatal error */
X  /*VARARGS1*/
X! void error(s,x,y)
X! char *s;
X! {
X  	end_screen();
X  	putchar('\n');
X! 	printf(s,x,y);
X  	putchar('\n');
X  	abort(1);
X  }
X--- 41,53 ----
X  
X  /* fatal error */
X  /*VARARGS1*/
X! void error VA_DECL(char *, s)
X! 	VA_START(s);
X! 	VA_INIT(s, char *);
X  	end_screen();
X  	putchar('\n');
X! 	vprintf(s,VA_ARGS);
X  	putchar('\n');
X+ 	VA_END();
X  	abort(1);
X  }
X*** amiga/Old/amiwind.c	Wed Sep 27 10:14:45 1989
X--- amiga/amiwind.c	Fri Sep 15 10:42:23 1989
X***************
X*** 10,16 ****
X  
X  #define MANX			/* Define for the Manx compiler */
X  
X- 
X  #include <exec/types.h>
X  #include <exec/alerts.h>
X  #include <exec/io.h>
X--- 10,15 ----
X***************
X*** 39,44 ****
X--- 38,44 ----
X  struct MenuItem *ItemAddress();
X  struct Process *FindTask();         /* Cheating */
X  long DeadKeyConvert(), OpenDevice(), CloseDevice();
X+ struct MsgPort *CreatePort();
X  extern struct Library *IconBase;
X  void abort();
X  
X***************
X*** 100,106 ****
X      TOPAZ_EIGHTY, FS_NORMAL, FPF_DISKFONT | FPF_ROMFONT
X  };
X  
X- 
X  #define BARHEIGHT	11
X  #define WINDOWHEIGHT	192
X  #define WIDTH		640
X--- 100,105 ----
X***************
X*** 124,130 ****
X  #ifdef MAIL
X  		      | DISKINSERTED
X  #endif
X- 
X      , BORDERLESS | BACKDROP | ACTIVATE,
X      NULL, NULL, NULL,
X      NULL, NULL, -1,-1,-1,-1, CUSTOMSCREEN
X--- 123,128 ----
X***************
X*** 178,189 ****
X  
X      control = (qualifier &  IEQUALIFIER_CONTROL) != 0;
X      shift   = (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) != 0;
X  
X      /*
X!      *	Shortcut for HELP and arrow keys... I suppose this is allowed...
X!      *	the defines are in intuition/intuition.h, and the keys
X!      *	don't serve 'text' input, normally.
X!      *	Also, parsing their escape sequences is such a mess...
X       */
X  
X      switch (message->Code) {
X--- 176,191 ----
X  
X      control = (qualifier &  IEQUALIFIER_CONTROL) != 0;
X      shift   = (qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) != 0;
X+     alt     = (qualifier & (IEQUALIFIER_LALT   | IEQUALIFIER_RALT  )) != 0;
X+     /* Allow ALT to function as a META key ... */
X+     qualifier &= ~(IEQUALIFIER_LALT | IEQUALIFIER_RALT);
X+     numeric_pad = (qualifier & IEQUALIFIER_NUMERICPAD) != 0;
X  
X      /*
X!      *	Shortcut for HELP and arrow keys. I suppose this is allowed.
X!      *	The defines are in intuition/intuition.h, and the keys don't
X!      *	serve 'text' input, normally. Also, parsing their escape
X!      *	sequences is such a mess...
X       */
X  
X      switch (message->Code) {
X***************
X*** 199,208 ****
X      case CURSORRIGHT:
X  	length = 'l';
X      arrow:
X! 	if (control)
X! 	    length &= 0x1F;	    /* ToControl... */
X! 	else if (shift)
X! 	    length &= 0x5F;	    /* ToUpper... */
X      no_arrow:
X  	BufferQueueChar(length);
X  	return;
X--- 201,208 ----
X      case CURSORRIGHT:
X  	length = 'l';
X      arrow:
X! 	if (!flags.num_pad)	/* Give digits if set, letters otherwise */
X! 	    goto wasarrow;
X      no_arrow:
X  	BufferQueueChar(length);
X  	return;
X***************
X*** 215,225 ****
X      }
X  #endif
X  
X-     numeric_pad = (qualifier & IEQUALIFIER_NUMERICPAD) != 0;
X-     if (alt = (qualifier & (IEQUALIFIER_LALT | IEQUALIFIER_RALT)) != 0)
X- 		/* Don't want dead keys... */
X- 	qualifier &= ~(IEQUALIFIER_LALT | IEQUALIFIER_RALT);
X- 
X      theEvent.ie_Class = IECLASS_RAWKEY;
X      theEvent.ie_Code = message->Code;
X      theEvent.ie_Qualifier = numeric_pad ? IEQUALIFIER_NUMERICPAD :
X--- 215,220 ----
X***************
X*** 230,236 ****
X  
X      if (length == 1) {   /* Plain ASCII character */
X  	length = buffer[0];
X! 	if (numeric_pad && length >= '1' && length <= '9') {
X  	    length -= '1';
X  	    if (control) {
X  		length = ctrl_numpad[length];
X--- 225,232 ----
X  
X      if (length == 1) {   /* Plain ASCII character */
X  	length = buffer[0];
X! 	if (!flags.num_pad && numeric_pad && length >= '1' && length <= '9') {
X! wasarrow:
X  	    length -= '1';
X  	    if (control) {
X  		length = ctrl_numpad[length];
X***************
X*** 240,245 ****
X--- 236,243 ----
X  		length = numpad[length];
X  	    }
X  	}
X+ 	if (alt)
X+ 	    length |= 0x80;
X  	BufferQueueChar(length);
X      } /* else shift, ctrl, alt, amiga, F-key, shift-tab, etc */
X  }
X***************
X*** 314,321 ****
X  
X  int WindowGetchar()
X  {
X!     while ( !kbhit() ) {
X! 	Wait( 1L << HackWindow->UserPort->mp_SigBit );
X      }
X      return BufferGetchar();
X  }
X--- 312,319 ----
X  
X  int WindowGetchar()
X  {
X!     while (!kbhit()) {
X! 	WaitPort(HackWindow->UserPort);
X      }
X      return BufferGetchar();
X  }
X***************
X*** 346,352 ****
X   *  Queue a single character for output to the console screen.
X   */
X  
X! int WindowPutchar(c)
X  char c;
X  {
X      if (Buffered >= CONBUFFER)
X--- 344,350 ----
X   *  Queue a single character for output to the console screen.
X   */
X  
X! void WindowPutchar(c)
X  char c;
X  {
X      if (Buffered >= CONBUFFER)
X***************
X*** 429,434 ****
X--- 427,434 ----
X  	CloseDevice(&ConsoleIO);
X  	ConsoleDevice = NULL;
X      }
X+     if (ConsoleIO.io_Message.mn_ReplyPort)
X+ 	DeletePort(ConsoleIO.io_Message.mn_ReplyPort);
X      if (HackWindow) {
X  	register struct IntuiMessage *msg;
X  
X***************
X*** 561,566 ****
X--- 561,567 ----
X  
X      ConsoleIO.io_Data = (APTR) HackWindow;
X      ConsoleIO.io_Length = sizeof(*HackWindow);
X+     ConsoleIO.io_Message.mn_ReplyPort = CreatePort(NULL, 0L);
X      if (OpenDevice("console.device", 0L, &ConsoleIO, 0L) != 0)
X  	abort(AG_OpenDev | AO_ConsoleDev);
X  
X*** amiga/Old/stdio.h	Wed Sep 27 10:15:22 1989
X--- amiga/stdio.h	Thu Sep 14 23:31:10 1989
X***************
X*** 56,61 ****
X--- 56,63 ----
X  FILE *freopen();
X  char *gets();
X  
X+ typedef long off_t;
X+ 
X  #define getchar()   WindowGetchar()
X  #define putchar(c)  WindowPutchar(c)
X  #define puts(s)     WindowPuts(s)
X***************
X*** 63,69 ****
X  #define printf      WindowPrintf
X  #define fflush(fp)  WindowFlush()
X  
X! #define xputs(s)    WindowFPuts(s)
X! #define xputc(c)    WindowPutchar(c)
X  
X  #endif
X--- 65,71 ----
X  #define printf      WindowPrintf
X  #define fflush(fp)  WindowFlush()
X  
X! #define xputs	    WindowFPuts
X! #define xputc	    WindowPutchar
X  
X  #endif
X*** amiga/Old/ami.lnk	Wed Sep 27 10:12:59 1989
X--- amiga/ami.lnk	Thu Sep 14 23:26:35 1989
X***************
X*** 1,15 ****
X- -w
X  -o Ram:NetHack
X  +ss
X! amidos.o amitcap.o amitty.o amiunix.o amiwind.o alloc.o apply.o artifact.o
X! attrib.o bones.o cmd.o dbridge.o decl.o demon.o do.o do_name.o do_wear.o
X! dog.o dogmove.o dothrow.o eat.o end.o engrave.o exper.o extralev.o
X! fountain.o hack.o invent.o lock.o main.o makemon.o mcastu.o mhitm.o mhitu.o
X! mklev.o mkmaze.o mkobj.o mkshop.o mon.o mondata.o monmove.o monst.o
X! mthrowu.o music.o o_init.o objects.o objnam.o options.o pager.o pickup.o
X! polyself.o potion.o pray.o pri.o prisym.o random.o read.o restore.o rip.o
X! rnd.o rumors.o save.o search.o shk.o shknam.o sit.o sounds.o sp_lev.o
X! spell.o steal.o timeout.o topl.o topten.o track.o trap.o u_init.o uhitm.o
X! vault.o version.o weapon.o were.o wield.o wizard.o worm.o worn.o write.o
X! zap.o
X  -lml -lcl
X--- 1,14 ----
X  -o Ram:NetHack
X  +ss
X! allmain.o alloc.o amidos.o amitcap.o amitty.o amiunix.o amiwind.o apply.o
X! artifact.o attrib.o bones.o cmd.o dbridge.o decl.o demon.o do.o dog.o dogmove.o
X! dokick.o dothrow.o do_name.o do_wear.o eat.o end.o engrave.o exper.o
X! extralev.o fountain.o getline.o hack.o invent.o lock.o mail.o main.o
X! makemon.o mcastu.o mhitm.o mhitu.o mklev.o mkmaze.o mkobj.o mkroom.o mon.o
X! mondata.o monmove.o monst.o mthrowu.o music.o objects.o objnam.o options.o
X! o_init.o pager.o pickup.o polyself.o potion.o pray.o pri.o priest.o
X! prisym.o random.o read.o restore.o rip.o rnd.o rumors.o save.o search.o
X! shk.o shknam.o sit.o sounds.o spell.o sp_lev.o steal.o timeout.o topl.o
X! topten.o track.o trap.o uhitm.o u_init.o vault.o version.o weapon.o were.o
X! wield.o wizard.o worm.o worn.o write.o zap.o
X  -lml -lcl
X*** others/Old/Makefile.msc	Wed Sep 27 10:20:04 1989
X--- others/Makefile.msc	Wed Sep 27 09:39:19 1989
X***************
X*** 47,54 ****
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJ =	o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o o\cmd.o \
X! 	o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X  	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X  	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X  	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X--- 47,54 ----
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJ =	o\allmain.o o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o \
X! 	o\cmd.o o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X  	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X  	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X  	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X***************
X*** 230,235 ****
X--- 230,236 ----
X  
X  # GO AHEAD, DELETE THIS LINE
X  
X+ o\allmain.o:  $(HACK_H)
X  o\alloc.o:  $(CONFIG_H)
X  o\apply.o:  $(HACK_H) $(INCL)\edog.h
X  o\artifact.o:  $(HACK_H) $(INCL)\artifact.h
X*** others/Old/Makefile.os2	Wed Sep 27 10:20:19 1989
X--- others/Makefile.os2	Wed Sep 27 09:40:24 1989
X***************
X*** 88,95 ****
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJ =	o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o o\cmd.o \
X! 	o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X  	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X  	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X  	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X--- 88,95 ----
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJ =	o\allmain.o o\alloc.o o\apply.o o\artifact.o o\attrib.o o\bones.o \
X! 	o\cmd.o o\dbridge.o o\decl.o o\demon.o o\do.o o\do_name.o o\do_wear.o \
X  	o\dog.o o\dogmove.o o\dokick.o o\dothrow.o o\eat.o o\end.o o\engrave.o \
X  	o\exper.o o\extralev.o o\fountain.o o\getline.o o\hack.o o\invent.o \
X  	o\lock.o o\mail.o o\main.o o\makemon.o o\mcastu.o o\mhitm.o o\mhitu.o \
X***************
X*** 245,250 ****
X--- 245,251 ----
X  
X  # GO AHEAD, DELETE THIS LINE
X  
X+ o\allmain.o:  $(HACK_H)
X  o\alloc.o:  $(CONFIG_H)
X  o\apply.o:  $(HACK_H) $(INCL)\edog.h
X  o\artifact.o:  $(HACK_H) $(INCL)\artifact.h
X*** others/Old/Makefile.st	Wed Sep 27 10:20:52 1989
X--- others/Makefile.st	Wed Sep 27 09:30:11 1989
X***************
X*** 56,62 ****
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJ = alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o decl.o \
X  	demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o dothrow.o \
X   	eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o hack.o \
X  	invent.o lock.o main.o makemon.o mcastu.o mhitm.o \
X--- 56,63 ----
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJ = allmain.o alloc.o apply.o artifact.o attrib.o bones.o cmd.o \
X! 	dbridge.o decl.o \
X  	demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o dothrow.o \
X   	eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o hack.o \
X  	invent.o lock.o main.o makemon.o mcastu.o mhitm.o \
X***************
X*** 211,216 ****
X--- 212,218 ----
X  
X  # GO AHEAD, DELETE THIS LINE
X  
X+ allmain.o: $(HACK_H)
X  alloc.o:  $(CONFIG_H)
X  apply.o:  $(HACK_H) $(INCL)\edog.h
X  artifact.o:  $(HACK_H) $(INCL)\artifact.h
X*** others/Old/Makefile.tcc	Wed Sep 27 10:21:14 1989
X--- others/Makefile.tcc	Wed Sep 27 09:42:50 1989
X***************
X*** 16,22 ****
X  # no stack frame.
X  # Note: There is a bug in Turbo C 2.0's -Z.  If you have weird problems,
X  #	use -Z-.
X! CFLAGS	= -m$(MODEL) -I$(INCL) $(WIZARD) -K- -O -A -Z -k- -w-pia -w-pro
X  CC	= tcc
X  
X  TARG	= pc
X--- 16,22 ----
X  # no stack frame.
X  # Note: There is a bug in Turbo C 2.0's -Z.  If you have weird problems,
X  #	use -Z-.
X! CFLAGS	= -c -no -m$(MODEL) -I$(INCL) -K- -O -A -Z -k- -w-pia -w-pro $(WIZARD)
X  CC	= tcc
X  
X  TARG	= pc
X***************
X*** 30,36 ****
X  # 	High-quality BSD random number generation routines.
X  RANDOM = o\random.obj
X  
X! LFLAGS	= /noi
X  TLFLAGS = /x/c
X  # No need to link in the floating point library
X  LIBS	= $(LIB)\c$(MODEL)
X--- 30,36 ----
X  # 	High-quality BSD random number generation routines.
X  RANDOM = o\random.obj
X  
X! LFLAGS  = /noi
X  TLFLAGS = /x/c
X  # No need to link in the floating point library
X  LIBS	= $(LIB)\c$(MODEL)
X***************
X*** 75,101 ****
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJS = o\main.obj o\tty.obj o\unix.obj o\hack.obj \
X! 	o\pri.obj o\prisym.obj o\topl.obj o\cmd.obj o\getline.obj \
X! 	o\decl.obj o\monst.obj o\objects.obj o\timeout.obj $(RANDOM) \
X! 	o\mkobj.obj o\makemon.obj o\mon.obj o\monmove.obj o\mondata.obj
X! VOBJM = o\apply.obj o\artifact.obj o\attrib.obj o\bones.obj o\dbridge.obj \
X! 	o\demon.obj o\do.obj o\do_name.obj o\do_wear.obj o\dog.obj \
X! 	o\dogmove.obj o\dokick.obj o\dothrow.obj o\eat.obj o\engrave.obj \
X! 	o\exper.obj o\fountain.obj o\invent.obj o\lock.obj \
X! 	o\mcastu.obj o\mhitm.obj o\mhitu.obj o\msdos.obj o\mthrowu.obj \
X! 	o\music.obj o\objnam.obj o\options.obj o\pager.obj o\pickup.obj \
X! 	o\polyself.obj o\potion.obj o\pray.obj o\priest.obj o\read.obj \
X! 	o\restore.obj o\rip.obj o\rnd.obj o\rumors.obj o\save.obj \
X! 	o\search.obj o\shk.obj o\sit.obj o\sounds.obj o\spell.obj \
X! 	o\steal.obj o\termcap.obj o\track.obj o\trap.obj o\uhitm.obj \
X  	o\vault.obj o\weapon.obj o\were.obj o\wield.obj o\wizard.obj \
X  	o\worm.obj o\worn.obj o\write.obj o\zap.obj
X! VOBJL = o\mklev.obj o\mkmaze.obj o\extralev.obj o\sp_lev.obj o\mkroom.obj \
X! 	o\shknam.obj o\topten.obj o\end.obj o\o_init.obj o\u_init.obj
X! VOBJ  = $(VOBJS) $(VOBJM) $(VOBJL)
X! HOBJ  = $(VOBJ) o\version.obj
X  
X  #
X  # Weird order, isn't it?  It puts the most often used utility routines
X  # and the main loop at the start of the file, and the routines that are
X--- 75,103 ----
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! VOBJS = o\allmain.obj o\main.obj o\tty.obj o\unix.obj o\hack.obj o\termcap.obj \
X! 	o\getline.obj o\pri.obj o\prisym.obj o\topl.obj o\cmd.obj o\msdos.obj \
X! 	o\decl.obj o\monst.obj o\objects.obj \
X! 	o\timeout.obj $(RANDOM) o\rnd.obj \
X! 	o\monmove.obj o\dogmove.obj o\mondata.obj o\exper.obj o\mon.obj \
X! 	o\mhitu.obj o\uhitm.obj o\mkobj.obj o\makemon.obj o\invent.obj \
X! 	o\pager.obj o\restore.obj
X! VOBJM = o\apply.obj o\artifact.obj o\attrib.obj o\dbridge.obj o\demon.obj \
X! 	o\do.obj o\do_name.obj o\do_wear.obj o\dog.obj o\dokick.obj \
X! 	o\dothrow.obj o\eat.obj o\lock.obj o\mcastu.obj o\mhitm.obj \
X! 	o\mthrowu.obj o\objnam.obj o\options.obj o\pickup.obj o\polyself.obj \
X! 	o\potion.obj o\pray.obj o\priest.obj o\read.obj o\search.obj \
X! 	o\shk.obj o\sit.obj o\sounds.obj o\steal.obj o\track.obj o\trap.obj \
X  	o\vault.obj o\weapon.obj o\were.obj o\wield.obj o\wizard.obj \
X  	o\worm.obj o\worn.obj o\write.obj o\zap.obj
X! VOBJ1 = o\engrave.obj o\fountain.obj o\spell.obj o\rumors.obj o\music.obj
X! VOBJ2 = o\save.obj o\mklev.obj o\mkmaze.obj o\extralev.obj \
X! 	o\sp_lev.obj o\mkroom.obj o\bones.obj o\shknam.obj
X! VOBJL = o\topten.obj o\end.obj o\o_init.obj o\u_init.obj o\rip.obj
X  
X+ VOBJ  = $(VOBJS) $(VOBJM) $(VOBJ1) $(VOBJ2) $(VOBJL)
X+ HOBJ  = $(VOBJS) $(VOBJM) $(VOBJ1) $(VOBJ2) o\version.obj $(VOBJL)
X+ 
X  #
X  # Weird order, isn't it?  It puts the most often used utility routines
X  # and the main loop at the start of the file, and the routines that are
X***************
X*** 134,140 ****
X  $(GAME): $(GAMEFILE)
X  
X  .c.obj:
X! 	$(CC) $(CFLAGS) -c -no $<
X  
X  all:	o $(GAME) auxil
X  	@echo Done.
X--- 136,142 ----
X  $(GAME): $(GAMEFILE)
X  
X  .c.obj:
X! 	$(CC) $(CFLAGS) $<
X  
X  all:	o $(GAME) auxil
X  	@echo Done.
X***************
X*** 188,200 ****
X  #	The following programs vary depending on what OS you are using.
X  #
X  o\main.obj:	$(HACK_H) $(TARG)main.c
X! 	$(CC) $(CFLAGS) -o$@ -c $(TARG)main.c
X  
X  o\tty.obj:	$(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X! 	$(CC) $(CFLAGS) -o$@ -c $(TARG)tty.c
X  
X  o\unix.obj:	$(HACK_H) $(TARG)unix.c
X! 	$(CC) $(CFLAGS) -o$@ -c $(TARG)unix.c
X  
X  #
X  # Secondary targets
X--- 190,202 ----
X  #	The following programs vary depending on what OS you are using.
X  #
X  o\main.obj:	$(HACK_H) $(TARG)main.c
X! 	$(CC) $(CFLAGS) -o$@ $(TARG)main.c
X  
X  o\tty.obj:	$(HACK_H) $(INCL)\func_tab.h $(TARG)tty.c
X! 	$(CC) $(CFLAGS) -o$@ $(TARG)tty.c
X  
X  o\unix.obj:	$(HACK_H) $(TARG)unix.c
X! 	$(CC) $(CFLAGS) -o$@ $(TARG)unix.c
X  
X  #
X  # Secondary targets
X***************
X*** 239,244 ****
X--- 241,247 ----
X  
X  # GO AHEAD, DELETE THIS LINE
X  
X+ o\allmain.obj:  $(HACK_H)
X  o\alloc.obj:  $(CONFIG_H)
X  o\apply.obj:  $(HACK_H) $(INCL)\edog.h
X  o\artifact.obj:  $(HACK_H) $(INCL)\artifact.h
X***************
X*** 280,287 ****
X  o\mondata.obj:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  o\monmove.obj:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X  o\monst.obj:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h
X! o\msdos.obj:  $(HACK_H)
X! 	$(CC) $(CFLAGS) -A- -oo\$*.obj -c $*.c
X  # set ANSI only off; many MS-DOS specific things.
X  o\mthrowu.obj:  $(HACK_H)
X  o\music.obj:  $(HACK_H)
X--- 283,290 ----
X  o\mondata.obj:  $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
X  o\monmove.obj:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
X  o\monst.obj:  $(CONFIG_H) $(PERMONST_H) $(INCL)\eshk.h $(INCL)\vault.h $(INCL)\epri.h
X! o\msdos.obj:  $(HACK_H) msdos.c
X! 	$(CC) $(CFLAGS) -A- $*.c
X  # set ANSI only off; many MS-DOS specific things.
X  o\mthrowu.obj:  $(HACK_H)
X  o\music.obj:  $(HACK_H)
X***************
X*** 301,308 ****
X  o\random.obj:
X  o\read.obj:  $(HACK_H)
X  o\restore.obj:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X! o\rip.obj:  $(HACK_H)
X! 	$(CC) $(CFLAGS) -d- -oo\$*.obj -c $*.c
X  # must not merge strings, or the tombstone lines will overlap.
X  o\rnd.obj:  $(HACK_H)
X  o\rumors.obj:  $(HACK_H)
X--- 304,311 ----
X  o\random.obj:
X  o\read.obj:  $(HACK_H)
X  o\restore.obj:  $(HACK_H) $(INCL)\lev.h $(INCL)\wseg.h
X! o\rip.obj:  $(HACK_H) rip.c
X! 	$(CC) $(CFLAGS) -d- $*.c
X  # must not merge strings, or the tombstone lines will overlap.
X  o\rnd.obj:  $(HACK_H)
X  o\rumors.obj:  $(HACK_H)
X*** others/Old/msdos.c	Wed Sep 27 10:22:01 1989
X--- others/msdos.c	Mon Sep 18 12:18:41 1989
X***************
X*** 3,8 ****
X--- 3,9 ----
X  /* An assortment of MSDOS functions.
X   */
X  
X+ #define NEED_VARARGS
X  #include "hack.h"
X  #ifdef MSDOS
X  # ifdef TOS
X***************
X*** 97,103 ****
X  	char *comspec;
X  
X  	if (comspec = getcomspec()) {
X! #ifdef DGK
X  		settty("To return to NetHack, enter \"exit\" at the DOS prompt.\n");
X  #else
X  		settty((char *)0);
X--- 98,104 ----
X  	char *comspec;
X  
X  	if (comspec = getcomspec()) {
X! #if defined(DGK) && !defined(TOS)	/* TOS has a variety of shells */
X  		settty("To return to NetHack, enter \"exit\" at the DOS prompt.\n");
X  #else
X  		settty((char *)0);
X***************
X*** 131,137 ****
X   * Shift characters are output when either shift key is pushed.
X   */
X  #ifdef TOS
X! #define KEYPADLO	0x67
X  #define KEYPADHI	0x71
X  #else
X  #define KEYPADLO	0x47
X--- 132,138 ----
X   * Shift characters are output when either shift key is pushed.
X   */
X  #ifdef TOS
X! #define KEYPADLO	0x61
X  #define KEYPADHI	0x71
X  #else
X  #define KEYPADLO	0x47
X***************
X*** 144,149 ****
X--- 145,158 ----
X  static const struct pad {
X  	char normal, shift;
X  	} keypad[PADKEYS] = {
X+ #ifdef TOS
X+ 			{C('['), 'Q'},		/* UNDO */
X+ 			{'?', '/'},		/* HELP */
X+ 			{'(', 'a'},		/* ( */
X+ 			{')', 'w'},		/* ) */
X+ 			{'/', '/'},		/* / */
X+ 			{C('p'), '$'},		/* * */
X+ #endif
X  			{'y', 'Y'},		/* 7 */
X  			{'k', 'K'},		/* 8 */
X  			{'u', 'U'},		/* 9 */
X***************
X*** 166,171 ****
X--- 175,188 ----
X  			{'i', 'I'},		/* Ins */
X  			{'.', ':'}		/* Del */
X  	}, numpad[PADKEYS] = {
X+ #ifdef TOS
X+ 			{C('['), 'Q'}	,	/* UNDO */
X+ 			{'?', '/'},		/* HELP */
X+ 			{'(', 'a'},		/* ( */
X+ 			{')', 'w'},		/* ) */
X+ 			{'/', '/'},		/* / */
X+ 			{C('p'), '$'},		/* * */
X+ #endif
X  			{'7', M('7')},		/* 7 */
X  			{'8', M('8')},		/* 8 */
X  			{'9', M('9')},		/* 9 */
X***************
X*** 196,201 ****
X--- 213,226 ----
X   * table to translate the scan codes into letters, then set the
X   * "meta" bit for them.  -3.
X   */
X+ /*
X+  * An addition to the above text: If a DOS or OS/2 keyboard conversion
X+  * table is in effect (almost always so outside of US), pressing ALT-letter
X+  * may indeed return a character which must be taken into account as a
X+  * character command instead of a metacommand. When an ALT-letter is pressed,
X+  * it is checked whether the character code is something else than a 0, and
X+  * if so, it is interpreted as a valid character command. (TH)
X+  */
X  #ifdef MSDOS
X  #define SCANLO		0x10
X  #define SCANHI		0x32
X***************
X*** 273,279 ****
X  			ch = (*kpad)[scan - KEYPADLO].normal;
X  	}
X  	if (shift & ALT) {
X! 		if (!ch && inmap(scan))
X  		    ch = scanmap[scan - SCANLO];
X  		return (isprint(ch) ? M(ch) : ch);
X  	}
X--- 298,305 ----
X  			ch = (*kpad)[scan - KEYPADLO].normal;
X  	}
X  	if (shift & ALT) {
X! 		if (ch) return ch; 	/* because of multilingual keyboards (TH) */
X! 		else if (inmap(scan))
X  		    ch = scanmap[scan - SCANLO];
X  		return (isprint(ch) ? M(ch) : ch);
X  	}
X***************
X*** 824,830 ****
X  			int lth;
X  
X  		     if ((lth = sscanf(bufp,
X! 		 "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X  				&translate[6], &translate[7], &translate[8],
X--- 850,856 ----
X  			int lth;
X  
X  		     if ((lth = sscanf(bufp,
X! 	 "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X  				&translate[6], &translate[7], &translate[8],
X***************
X*** 912,923 ****
X  }
X  
X  void
X! msmsg(fmt, a1, a2, a3)
X! char *fmt;
X! long a1, a2, a3;
X! {
X! 	Printf(fmt, a1, a2, a3);
X  	flushout();
X  	return;
X  }
X  
X--- 938,949 ----
X  }
X  
X  void
X! msmsg VA_DECL(char *, fmt)
X! 	VA_START(fmt);
X! 	VA_INIT(fmt, char *);
X! 	Vprintf(fmt, VA_ARGS);
X  	flushout();
X+ 	VA_END();
X  	return;
X  }
X  
X***************
X*** 1132,1137 ****
X--- 1158,1165 ----
X  #ifdef TOS
X  	if (run_from_desktop)
X  	    getreturn("to continue"); /* so the user can read the score list */
X+ 	if (flags.IBMBIOS && flags.use_color)
X+ 		restore_colors();
X  #endif
X  	exit(code);
X  	return;
X***************
X*** 1218,1222 ****
X--- 1246,1269 ----
X  int kbhit()
X  {
X  	return Cconis();
X+ }
X+ 
X+ static unsigned orig_color[4] = {-1, -1, -1, -1};
X+ static unsigned new_color[4] = { 0x0, 0x730, 0x047, 0x555 };
X+ 
X+ void set_colors()
X+ {
X+ 	int i;
X+ 
X+ 	for (i = 0; i < 4; i++)
X+ 		orig_color[i] = Setcolor(i, new_color[i]);
X+ }
X+ 
X+ void restore_colors()
X+ {
X+ 	int i;
X+ 
X+ 	for (i = 0; i < 4; i++)
X+ 		(void) Setcolor(i, orig_color[i]);
X  }
X  #endif /* TOS */
X*** others/Old/oldtos.c	Wed Sep 27 10:22:45 1989
X--- others/oldtos.c	Thu Sep 14 20:54:31 1989
X***************
X*** 442,448 ****
X  			int lth;
X  
X  		     if ((lth = sscanf(bufp,
X! 		     "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X  				&translate[6], &translate[7], &translate[8],
X--- 442,448 ----
X  			int lth;
X  
X  		     if ((lth = sscanf(bufp,
X! 	     "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
X  				&translate[0], &translate[1], &translate[2],
X  				&translate[3], &translate[4], &translate[5],
X  				&translate[6], &translate[7], &translate[8],
X*** others/Old/pcmain.c	Wed Sep 27 10:23:06 1989
X--- others/pcmain.c	Tue Sep 26 18:48:59 1989
X***************
X*** 4,21 ****
X  /* main.c - PC, ST, and Amiga NetHack */
X  
X  #include "hack.h"
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif
X  
X  char orgdir[PATHLEN];
X! 
X! extern struct permonst mons[NUMMONS];
X! extern char plname[PL_NSIZ], pl_character[PL_CSIZ];
X  
X! int (*afternmv)(), (*occupation)();
X! static void moveloop();	/* a helper function for MSC optimizer */
X! static void newgame();
X  
X  #if defined(DGK) && !defined(OLD_TOS)
X  struct finfo	zfinfo = ZFINFO;
X--- 4,22 ----
X  /* main.c - PC, ST, and Amiga NetHack */
X  
X  #include "hack.h"
X+ 
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif
X  
X  char orgdir[PATHLEN];
X! char SAVEF[FILENAME];
X  
X! char *hname = "NetHack";	/* used for syntax messages */
X! #ifndef AMIGA
X! char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X! #endif
X! int hackpid;		/* not used anymore, but kept in for save files */
X  
X  #if defined(DGK) && !defined(OLD_TOS)
X  struct finfo	zfinfo = ZFINFO;
X***************
X*** 22,34 ****
X  int i;
X  #endif /* DGK && !OLD_TOS */
X  
X- char SAVEF[FILENAME];
X- char *hname = "NetHack";	/* used for syntax messages */
X- char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X- int hackpid;		/* not used anymore, but kept in for save files */
X- 
X- extern char *nomovemsg;
X- extern long wailmsg;
X  #ifdef __TURBOC__	/* tell Turbo C to make a bigger stack */
X  extern unsigned _stklen = 0x2000;	/* 8K */
X  extern unsigned char _osmajor;
X--- 23,28 ----
X***************
X*** 77,84 ****
X  	 *  Initialize screen I/O before anything is displayed.
X  	 *
X  	 *  startup() must be called before initoptions()
X! 	 *  due to ordering of graphics settings, and before
X! 	 *  any calls to error() due to use of termcap strings.
X  	 */
X  	gettty();
X  #ifndef AMIGA
X--- 71,78 ----
X  	 *  Initialize screen I/O before anything is displayed.
X  	 *
X  	 *  startup() must be called before initoptions()
X! 	 *    due to ordering of graphics settings
X! 	 *  and before error(), due to use of termcap strings.
X  	 */
X  	gettty();
X  #ifndef AMIGA
X***************
X*** 114,128 ****
X  #endif /* DGK && !OLD_TOS */
X  
X  	initoptions();
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X  
X  	if(argc > 1) {
X! #ifdef TOS
X! 	    if(!strncmp(argv[1], "-D", 2)) {
X! #else
X! 	    if(!strncmp(argv[1], "-d", 2)) {
X! #endif
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X--- 108,122 ----
X  #endif /* DGK && !OLD_TOS */
X  
X  	initoptions();
X+ #ifdef TOS
X+ 	if (flags.IBMBIOS && flags.use_color)
X+ 		set_colors();
X+ #endif
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X  
X  	if(argc > 1) {
X! 	    if (!strncmp(argv[1], "-d", 2)) {
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X***************
X*** 135,151 ****
X  		if(!*dir)
X  		    error("Flag -d must be followed by a directory name.");
X  		Strcpy(hackdir, dir);
X! 	    }
X  
X  	/*
X  	 * Now we know the directory containing 'record' and
X  	 * may do a prscore().
X  	 */
X! #ifdef TOS
X! 	    else if (!strncmp(argv[1], "-S", 2)) {
X! #else
X! 	    else if (!strncmp(argv[1], "-s", 2)) {
X! #endif
X  #ifdef CHDIR
X  		chdirx(hackdir,0);
X  #endif
X--- 129,141 ----
X  		if(!*dir)
X  		    error("Flag -d must be followed by a directory name.");
X  		Strcpy(hackdir, dir);
X! 	    } else
X  
X  	/*
X  	 * Now we know the directory containing 'record' and
X  	 * may do a prscore().
X  	 */
X! 	    if (!strncmp(argv[1], "-s", 2)) {
X  #ifdef CHDIR
X  		chdirx(hackdir,0);
X  #endif
X***************
X*** 154,159 ****
X--- 144,152 ----
X  	    }
X  	}
X  
X+ 	/*
X+ 	 * It seems you really want to play.
X+ 	 */
X  	setrandom();
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X***************
X*** 182,218 ****
X  		argc--;
X  		switch(argv[0][1]){
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! # ifndef TOS
X! 		case 'D':
X! # endif
X  		case 'X':
X  # ifdef WIZARD
X  			/* Must have "name" set correctly by NETHACK.CNF,
X  			 * NETHACKOPTIONS, or -U
X  			 * before this flag to enter wizard mode. */
X! 			if(!strcmp(plname, WIZARD))
X  				wizard = TRUE;
X! # endif
X! # if defined(WIZARD) && defined(EXPLORE_MODE)
X! 			else
X  # endif
X  # ifdef EXPLORE_MODE
X! 				discover = TRUE;
X  # endif
X  			break;
X  #endif
X  #ifdef NEWS
X- 		case 'N':
X- # ifndef TOS
X  		case 'n':
X- # endif
X  			flags.nonews = TRUE;
X  			break;
X  #endif
X- 		case 'U':
X- #ifndef TOS
X  		case 'u':
X- #endif
X  			if(argv[0][2])
X  			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X  			else if(argc > 1) {
X--- 175,206 ----
X  		argc--;
X  		switch(argv[0][1]){
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! # ifndef EXPLORE_MODE
X  		case 'X':
X+ # endif
X+ 		case 'D':
X  # ifdef WIZARD
X  			/* Must have "name" set correctly by NETHACK.CNF,
X  			 * NETHACKOPTIONS, or -U
X  			 * before this flag to enter wizard mode. */
X! 			if(!strcmp(plname, WIZARD)) {
X  				wizard = TRUE;
X! 				break;
X! 			}
X! 			/* otherwise fall thru to discover */
X  # endif
X  # ifdef EXPLORE_MODE
X! 		case 'X':
X! 			discover = TRUE;
X  # endif
X  			break;
X  #endif
X  #ifdef NEWS
X  		case 'n':
X  			flags.nonews = TRUE;
X  			break;
X  #endif
X  		case 'u':
X  			if(argv[0][2])
X  			  (void) strncpy(plname, argv[0]+2, sizeof(plname)-1);
X  			else if(argc > 1) {
X***************
X*** 223,251 ****
X  				Printf("Player name expected after -U\n");
X  			break;
X  #ifdef DGK
X! 		/* Person does not want to use a ram disk
X  		 */
X- # ifdef TOS
X- 		case 'R':
X- # else
X  		case 'r':
X- # endif
X  			ramdisk = FALSE;
X  			break;
X  #endif
X- 		case 'C':   /* character role is next character */
X- 			/* allow -CT for Tourist, etc. */
X- 			(void) strncpy(pl_character, argv[0]+2,
X- 				sizeof(pl_character)-1);
X- 			break;
X  		default:
X- #ifndef TOS
X  			/* allow -T for Tourist, etc. */
X  			(void) strncpy(pl_character, argv[0]+1,
X  				sizeof(pl_character)-1);
X- #else
X- 			Printf("Unknown option: %s\n", *argv);
X- #endif
X  		}
X  	}
X  
X--- 211,226 ----
X  				Printf("Player name expected after -U\n");
X  			break;
X  #ifdef DGK
X! 		/* Player doesn't want to use a RAM disk
X  		 */
X  		case 'r':
X  			ramdisk = FALSE;
X  			break;
X  #endif
X  		default:
X  			/* allow -T for Tourist, etc. */
X  			(void) strncpy(pl_character, argv[0]+1,
X  				sizeof(pl_character)-1);
X  		}
X  	}
X  
X***************
X*** 297,302 ****
X--- 272,283 ----
X  #endif /* DGK */
X  	    ((fd = open(SAVEF, OMASK)) >= 0) &&
X  	    (uptodate(fd) || !unlink(SAVEF))) {
X+ #ifdef WIZARD
X+ 		/* Since wizard is actually flags.debug, restoring might
X+ 		 * overwrite it.
X+ 		 */
X+ 		boolean remember_wiz_mode = wizard;
X+ #endif
X  #ifndef NO_SIGNAL
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  #endif
X***************
X*** 304,309 ****
X--- 285,293 ----
X  		(void) fflush(stdout);
X  		if(!dorecover(fd))
X  			goto not_recovered;
X+ #ifdef WIZARD
X+ 		if(!wizard && remember_wiz_mode) wizard = TRUE;
X+ #endif
X  		pline("Hello %s, welcome to NetHack!", plname);
X  		/* get shopkeeper set properly if restore is in shop */
X  		(void) inshop();
X***************
X*** 349,535 ****
X  #ifdef OS2
X  	gettty(); /* somehow ctrl-P gets turned back on during startup ... */
X  #endif
X! 	/* Help for Microsoft optimizer.  Otherwise main is too large -dgk*/
X  	moveloop();
X  	return 0;
X  }
X  
X- static void
X- moveloop()
X- {
X- 	char ch;
X- 	int abort;
X- 
X- 	for(;;) {
X- 		if(flags.move) {	/* actual time passed */
X- 
X- #ifdef SOUNDS
X- 			dosounds();
X- #endif
X- 			settrack();
X- 
X- 			if(moves%2 == 0 ||
X- 			  (!(Fast & ~INTRINSIC) && (!Fast || rn2(3)))) {
X- 				movemon();
X- #ifdef HARD
X- 				if(!rn2(u.udemigod?25:(dlevel>30)?50:70))
X- #else
X- 				if(!rn2(70))
X- #endif
X- 				    (void) makemon((struct permonst *)0, 0, 0);
X- 			}
X- 			if(Glib) glibr();
X- 			timeout();
X- 			++moves;
X- #ifdef THEOLOGY
X- 			if (u.ublesscnt)  u.ublesscnt--;
X- #endif
X- #ifdef POLYSELF
X- 			if(u.mtimedone)
X- 			    if(u.mh < 1) rehumanize();
X- 			else
X- #endif
X- 			    if(u.uhp < 1) {
X- 				You("die...");
X- 				done(DIED);
X- 			    }
X- #ifdef POLYSELF
X- 			if (u.mtimedone) {
X- 			    if (u.mh < u.mhmax) {
X- 				if (Regeneration || !(moves%20)) {
X- 					flags.botl = 1;
X- 					u.mh++;
X- 				}
X- 			    }
X- 			}
X- #endif
X- 			if(u.uhp < u.uhpmax) {
X- 				if(u.ulevel > 9) {
X- 				    int heal;
X- 
X- 				    if(HRegeneration || !(moves%3)) {
X- 					flags.botl = 1;
X- 					if (ACURR(A_CON) <= 12) heal = 1;
X- 					else heal = rnd((int) ACURR(A_CON)-12);
X- 					if (heal > u.ulevel-9) heal = u.ulevel-9;
X- 					u.uhp += heal;
X- 					if(u.uhp > u.uhpmax)
X- 					    u.uhp = u.uhpmax;
X- 				    }
X- 				} else if(HRegeneration ||
X- 					(!(moves%((MAXULEV+12)/(u.ulevel+2)+1)))) {
X- 					flags.botl = 1;
X- 					u.uhp++;
X- 				}
X- 			}
X- #ifdef SPELLS
X- 			if ((u.uen<u.uenmax) && (!(moves%(19-ACURR(A_INT)/2)))) {
X- 				u.uen += rn2((int)ACURR(A_WIS)/5 + 1) + 1;
X- 				if (u.uen > u.uenmax)  u.uen = u.uenmax;
X- 				flags.botl = 1;
X- 			}
X- #endif
X- 			if(Teleportation && !rn2(85)) tele();
X- #ifdef POLYSELF
X- 			if(Polymorph && !rn2(100))
X- 				polyself();
X- 			if(u.ulycn >= 0 && !rn2(80 - (20 * night())))
X- 				you_were();
X- #endif
X- 			if(Searching && multi >= 0) (void) dosearch0(1);
X- 			gethungry();
X- 			hatch_eggs();
X- 			invault();
X- 			amulet();
X- #ifdef HARD
X- 			if (!rn2(40+(int)(ACURR(A_DEX)*3))) u_wipe_engr(rnd(3));
X- 			if (u.udemigod) {
X- 
X- 				u.udg_cnt--;
X- 				if(u.udg_cnt <= 0) {
X- 
X- 					intervene();
X- 					u.udg_cnt = rn1(200, 50);
X- 				}
X- 			}
X- #endif
X- 			restore_attrib();
X- 		}
X- 		if(multi < 0) {
X- 			if(!++multi){
X- 				pline(nomovemsg ? nomovemsg :
X- 					"You can move again.");
X- 				nomovemsg = 0;
X- 				if(afternmv) (*afternmv)();
X- 				afternmv = 0;
X- 			}
X- 		}
X- 
X- 		find_ac();
X- 		if(!flags.mv || Blind)
X- 		{
X- 			seeobjs();
X- 			seemons();
X- 			seeglds();
X- 			nscr();
X- 		}
X- 		if(flags.time) flags.botl = 1;
X- 
X- 		if(flags.botl || flags.botlx) bot();
X- 
X- 		flags.move = 1;
X- 
X- 		if(multi >= 0 && occupation) {
X- 			abort = 0;
X- 			if (kbhit()) {
X- 				if ((ch = Getchar()) == ABORT)
X- 					abort++;
X- #ifdef REDO
X- 				else
X- 					pushch(ch);
X- #endif /* REDO */
X- 			}
X- 			if(abort || monster_nearby())
X- 				stop_occupation();
X- 			else if ((*occupation)() == 0)
X- 				occupation = 0;
X- 			if (!(++occtime % 7))
X- 				(void) fflush(stdout);
X- 			continue;
X- 		}
X- 
X- 		if((u.uhave_amulet || Clairvoyant) && 
X- #ifdef ENDGAME
X- 			dlevel != ENDLEVEL &&
X- #endif
X- 			!(moves%15) && !rn2(2)) do_vicinity_map();
X- 
X- 		u.umoved = FALSE;
X- 		if(multi > 0) {
X- 			lookaround();
X- 			if(!multi) {	/* lookaround may clear multi */
X- 				flags.move = 0;
X- 				continue;
X- 			}
X- 			if(flags.mv) {
X- 				if(multi < COLNO && !--multi)
X- 					flags.mv = flags.run = 0;
X- 				domove();
X- 			} else {
X- 				--multi;
X- 				rhack(save_cm);
X- 			}
X- 		} else if(multi == 0) {
X- #ifdef MAIL
X- 			ckmailstatus();
X- #endif
X- 			rhack(NULL);
X- 		}
X- 		if(multi && multi%7 == 0)
X- 			(void) fflush(stdout);
X- 	}
X- }
X- 
X  /*
X   * plname is filled either by an option (-U Player  or  -UPlayer) or
X   * explicitly (by being the wizard) or by askname.
X--- 333,343 ----
X  #ifdef OS2
X  	gettty(); /* somehow ctrl-P gets turned back on during startup ... */
X  #endif
X! 
X  	moveloop();
X  	return 0;
X  }
X  
X  /*
X   * plname is filled either by an option (-U Player  or  -UPlayer) or
X   * explicitly (by being the wizard) or by askname.
X***************
X*** 561,581 ****
X  			msmsg("%c", c);
X  #endif
X  			plname[ct++] = c;
X! 	}
X  	}
X  	plname[ct] = 0;
X  	if(ct == 0) askname();
X  }
X  
X- /*VARARGS1*/
X- void
X- impossible(s,x1,x2)
X- 	register char *s, *x1, *x2;
X- {
X- 	pline(s,x1,x2);
X- 	pline("Program in disorder - perhaps you'd better Quit.");
X- }
X- 
X  #ifdef CHDIR
X  void
X  chdirx(dir, wr)
X--- 369,380 ----
X  			msmsg("%c", c);
X  #endif
X  			plname[ct++] = c;
X! 		}
X  	}
X  	plname[ct] = 0;
X  	if(ct == 0) askname();
X  }
X  
X  #ifdef CHDIR
X  void
X  chdirx(dir, wr)
X***************
X*** 593,599 ****
X  	chdrive(dir);
X  #endif
X  
X! 	/* warn the player if he cannot write the record file */
X  	/* perhaps we should also test whether . is writable */
X  	/* unfortunately the access systemcall is worthless */
X  	if(wr) {
X--- 392,398 ----
X  	chdrive(dir);
X  #endif
X  
X! 	/* warn the player if we can't write the record file */
X  	/* perhaps we should also test whether . is writable */
X  	/* unfortunately the access systemcall is worthless */
X  	if(wr) {
X***************
X*** 637,696 ****
X  	}
X  }
X  #endif /* CHDIR /**/
X- 
X- void
X- stop_occupation()
X- {
X- 	if(occupation) {
X- 		You("stop %s.", occtxt);
X- 		occupation = 0;
X- #ifdef REDO
X- 		multi = 0;
X- 		pushch(0);
X- #endif
X- 	}
X- }
X- 
X- static void
X- newgame() {
X- #ifdef DGK
X- 	gameDiskPrompt();
X- #endif
X- 
X- 	fobj = fcobj = invent = 0;
X- 	fmon = fallen_down = 0;
X- 	ftrap = 0;
X- 	fgold = 0;
X- 	flags.ident = 1;
X- 
X- 	init_objects();
X- 	u_init();
X- 
X- #ifndef NO_SIGNAL
X- 	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X- #endif
X- 
X- 	mklev();
X- 	u.ux = xupstair;
X- 	u.uy = yupstair;
X- 	(void) inshop();
X- 
X- 	setsee();
X- 	flags.botlx = 1;
X- 
X- 	/* Move the monster from under you or else
X- 	 * makedog() will fail when it calls makemon().
X- 	 * 			- ucsfcgl!kneller
X- 	 */
X- 	if(levl[u.ux][u.uy].mmask) mnexto(m_at(u.ux, u.uy));
X- 
X- 	(void) makedog();
X- 	seemons();
X- #ifdef NEWS
X- 	if(flags.nonews || !readnews())
X- 		/* after reading news we did docrt() already */
X- #endif
X- 		docrt();
X- 
X- 	return;
X- }
X--- 436,438 ----
X*** others/Old/pctty.c	Wed Sep 27 10:23:29 1989
X--- others/pctty.c	Sun Sep 17 14:27:07 1989
X***************
X*** 3,8 ****
X--- 3,9 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* tty.c - (PC) version */
X  
X+ #define NEED_VARARGS
X  #include "hack.h"
X  
X  char erase_char, kill_char;
X***************
X*** 35,47 ****
X  
X  /* fatal error */
X  /*VARARGS1*/
X  void
X! error(s,x,y)
X! char *s, *x, *y;
X! {
X  	end_screen();
X  	putchar('\n');
X! 	Printf(s,x,y);
X  	putchar('\n');
X  	exit(1);
X  }
X--- 36,50 ----
X  
X  /* fatal error */
X  /*VARARGS1*/
X+ 
X  void
X! error VA_DECL(char *,s)
X! 	VA_START(s);
X! 	VA_INIT(s, char *);
X  	end_screen();
X  	putchar('\n');
X! 	Vprintf(s,VA_ARGS);
X  	putchar('\n');
X+ 	VA_END();
X  	exit(1);
X  }
X
X*** auxil/Old/Guidebook.mn	Wed Sep 27 10:15:37 1989
X--- auxil/Guidebook.mn	Thu Sep 14 13:21:09 1989
X***************
X*** 4,10 ****
X  .ds vr "NetHack Version 3.0
X  .ds f0 "\*(vr
X  .ds f1
X! .ds f2 "August 13, 1989
X  .mt
X  A Guide to the Mazes of Menace
X  .au
X--- 4,10 ----
X  .ds vr "NetHack Version 3.0
X  .ds f0 "\*(vr
X  .ds f1
X! .ds f2 "September 6, 1989
X  .mt
X  A Guide to the Mazes of Menace
X  .au
X***************
X*** 497,523 ****
X  .lp #
X  perform an extended command.  As you can see, the authors of NetHack
X  used up all the letters, so this is a way to introduce the less useful
X! commands.  You may obtain a list of them by entering `?'.  What
X! extended commands are available depend on what features the game was
X! compiled with.  Most extended commands are used only under limited
X! circumstances. Note that if your keyboard has a meta key (that is, one which
X! when pressed in combination with another key modified it by turning on
X! the 'meta' or 0x80 bit) these extended commands can be invoked by meta-ing the
X! first letter of the command.
X  .pg
X  If the
X  .op number_pad
X  option is on, some additional letter commands are available:
X  .lp j
X! jump to another location.  Same as ``#jump'' or meta-j.
X  .lp k
X  kick something (usually a door).  Same as `^D'.
X  .lp l
X! loot a box on the floor.  Same as ``#loot'' or meta-l.
X  .lp N
X! name an object or type of object.  Same as ``#name'' or meta-n.
X  .lp u
X! untrap a trapped object or door.  Same as ``#untrap'' or meta-u.
X  
X  .hn 1
X  Rooms and corridors
X--- 497,553 ----
X  .lp #
X  perform an extended command.  As you can see, the authors of NetHack
X  used up all the letters, so this is a way to introduce the less useful
X! commands, or commands used under limited circumstances.  You may obtain a
X! list of them by entering `?'.  What extended commands are available
X! depend on what features the game was compiled with.
X  .pg
X+ If your keyboard has a meta key (which, when pressed in combination
X+ with another key, modifies it by setting the `meta' [8th, or `high']
X+ bit), you can invoke the extended commands by meta-ing the first
X+ letter of the command.  In PC NetHack and ST NetHack, the `Alt' key
X+ can be used in this fashion.
X+ .lp M-c
X+ talk to someone.
X+ .lp M-d
X+ dip an object into something.
X+ .lp M-f
X+ force a lock.
X+ .lp M-j
X+ jump to another location.
X+ .lp M-l
X+ loot a box on the floor.
X+ .lp M-m
X+ use a monster's special ability.
X+ .lp M-N
X+ Name an item or type of object.
X+ .lp M-o
X+ offer a sacrifice to the gods.
X+ .lp M-p
X+ pray to the gods for help.
X+ .lp M-r
X+ rub a lamp.
X+ .lp M-s
X+ sit down.
X+ .lp M-t
X+ turn undead.
X+ .lp M-u
X+ untrap something (usually a trapped object).
X+ .lp M-w
X+ wipe off your face.
X+ .pg
X  If the
X  .op number_pad
X  option is on, some additional letter commands are available:
X  .lp j
X! jump to another location.  Same as ``#jump'' or ``M-j''.
X  .lp k
X  kick something (usually a door).  Same as `^D'.
X  .lp l
X! loot a box on the floor.  Same as ``#loot'' or ``M-l''.
X  .lp N
X! name an item or type of object.  Same as ``#name'' or ``M-N''.
X  .lp u
X! untrap a trapped object or door.  Same as ``#untrap'' or ``M-u''.
X  
X  .hn 1
X  Rooms and corridors
X***************
X*** 537,543 ****
X  .pg
X  You can get through a locked door by using a tool to pick the lock
X  with the `a' (apply) command, or by kicking it open with the `^D'
X! command.
X  .pg
X  Secret doors [and corridors] are hidden.  You can find them with the
X  `s' (search) command.
X--- 567,573 ----
X  .pg
X  You can get through a locked door by using a tool to pick the lock
X  with the `a' (apply) command, or by kicking it open with the `^D'
X! (kick) command.
X  .pg
X  Secret doors [and corridors] are hidden.  You can find them with the
X  `s' (search) command.
X***************
X*** 824,830 ****
X  .pg
X  The command to read a spell book is the same as for scrolls, `r'
X  (read).  The `+' command lists your current spells and the number of
X! spell points they require.  The `Z' command casts a spell.
X  .hn 2
X  Tools (`(')
X  .pg
X--- 854,860 ----
X  .pg
X  The command to read a spell book is the same as for scrolls, `r'
X  (read).  The `+' command lists your current spells and the number of
X! spell points they require.  The `Z' (cast) command casts a spell.
X  .hn 2
X  Tools (`(')
X  .pg
X***************
X*** 1019,1025 ****
X  (default on) pick up things you move onto by default.
X  .lp rawio\ \ \ 
X  (default off) force raw (non-cbreak) mode for faster output and more
X! bulletproof input (MS-DOS sometimes treats ^P as a printer toggle
X  without it).  Note: DEC Rainbows hang if this is turned on.
X  Cannot be set with the `O' command.
X  .lp rest_on_space
X--- 1049,1055 ----
X  (default on) pick up things you move onto by default.
X  .lp rawio\ \ \ 
X  (default off) force raw (non-cbreak) mode for faster output and more
X! bulletproof input (MS-DOS sometimes treats `^P' as a printer toggle
X  without it).  Note: DEC Rainbows hang if this is turned on.
X  Cannot be set with the `O' command.
X  .lp rest_on_space
END_OF_FILE
if test 57252 -ne `wc -c <'patches04g'`; then
    echo shar: \"'patches04g'\" unpacked with wrong size!
fi
# end of 'patches04g'
fi
echo shar: End of archive 7 \(of 11\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
