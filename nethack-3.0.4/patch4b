Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i038:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch4b
Message-ID: <4628@tekred.CNA.TEK.COM>
Date: 29 Sep 89 21:08:19 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2131
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 38
Archive-name: NetHack3/Patch4b
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 11)."
# Contents:  patches04b
# Wrapped by billr@saab on Fri Sep 29 13:13:32 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches04b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches04b'\"
else
echo shar: Extracting \"'patches04b'\" \(53375 characters\)
sed "s/^X//" >'patches04b' <<'END_OF_FILE'
X*** src/Old/end.c	Wed Sep 27 11:25:17 1989
X--- src/end.c	Tue Sep 26 17:47:43 1989
X***************
X*** 4,9 ****
X--- 4,11 ----
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X+ #define NEED_VARARGS
X+ 
X  #include "hack.h"
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X***************
X*** 56,66 ****
X  		curs_on_u();
X  		(void) fflush(stdout);
X  		if(multi > 0) nomul(0);
X  		return 0;
X  	}
X! #if defined(WIZARD) && defined(UNIX)
X  	if(wizard) {
X  	    pline("Dump core? ");
X  	    if(yn() == 'y') {
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  		settty(NULL);
X--- 58,73 ----
X  		curs_on_u();
X  		(void) fflush(stdout);
X  		if(multi > 0) nomul(0);
X+ 		multi = 0;
X  		return 0;
X  	}
X! #if defined(WIZARD) && (defined(UNIX) || defined(VMS))
X  	if(wizard) {
X+ #ifdef VMS
X+ 	    pline("Enter debugger? ");
X+ #else
X  	    pline("Dump core? ");
X+ #endif
X  	    if(yn() == 'y') {
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  		settty(NULL);
X***************
X*** 83,89 ****
X  	done_stopprint++;
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X! #ifdef UNIX
X  	(void) signal(SIGQUIT, SIG_IGN);
X  #endif
X  #endif /* TOS /* */
X--- 90,96 ----
X  	done_stopprint++;
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, SIG_IGN);
X! #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, SIG_IGN);
X  #endif
X  #endif /* TOS /* */
X***************
X*** 90,96 ****
X  	return 0;
X  }
X  
X! #ifdef UNIX
X  static
X  int
X  done_hangup(){
X--- 97,103 ----
X  	return 0;
X  }
X  
X! #if defined(UNIX) || defined(VMS)
X  static
X  int
X  done_hangup(){
X***************
X*** 148,156 ****
X  extern boolean hu;	/* from save.c */
X  
X  void
X! panic(str,a1,a2,a3,a4,a5,a6)
X! char *str;
X! {
X  	if(panicking++)
X  #ifdef SYSV
X  	    (void)
X--- 155,163 ----
X  extern boolean hu;	/* from save.c */
X  
X  void
X! panic VA_DECL(char *, str)
X! 	VA_START(str);
X! 	VA_INIT(str, char *);
X  	if(panicking++)
X  #ifdef SYSV
X  	    (void)
X***************
X*** 159,187 ****
X  				    /* was exit(1) */
X  	home(); cls();
X  	(void) puts(" Suddenly, the dungeon collapses.");
X! #ifdef WIZARD
X! # ifndef MSDOS
X  	if(!wizard) {
X  	    pline("Report error to %s and it may be possible to rebuild.",WIZARD);
X  	    more();
X  	}
X! 	Sprintf (SAVEF, "%s.e", SAVEF);
X  	hu = FALSE;
X  	(void) dosave0();
X- # endif
X  #endif
X  	(void) fputs(" ERROR:  ", stdout);
X! 	Printf(str,a1,a2,a3,a4,a5,a6);
X  	more();				/* contains a fflush() */
X! #ifdef WIZARD
X! # ifdef UNIX
X  	if (wizard)	
X! #  ifdef SYSV
X  		(void)
X- #  endif
X- 		    abort();	/* generate core dump */
X  # endif
X  #endif
X  	done(PANICKED);
X  }
X  
X--- 166,201 ----
X  				    /* was exit(1) */
X  	home(); cls();
X  	(void) puts(" Suddenly, the dungeon collapses.");
X! #if defined(WIZARD) && !defined(MSDOS)
X  	if(!wizard) {
X  	    pline("Report error to %s and it may be possible to rebuild.",WIZARD);
X  	    more();
X  	}
X! #ifdef VMS
X! 	{
X! 		char *sem = rindex(SAVEF, ';');
X! 
X! 		if (sem)
X! 			*sem = '\0';
X! 	}
X! 	Strcat(SAVEF, ".e;1");
X! #else
X! 	Strcat(SAVEF, ".e");
X! #endif
X  	hu = FALSE;
X  	(void) dosave0();
X  #endif
X  	(void) fputs(" ERROR:  ", stdout);
X! 	Vprintf(str,VA_ARGS);
X  	more();				/* contains a fflush() */
X! #if defined(WIZARD) && (defined(UNIX) || defined(VMS))
X  	if (wizard)	
X! # ifdef SYSV
X  		(void)
X  # endif
X+ 		    abort();	/* generate core dump */
X  #endif
X+ 	VA_END();
X  	done(PANICKED);
X  }
X  
X***************
X*** 257,263 ****
X  die:
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
X! #ifdef UNIX
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X  #endif
X--- 271,277 ----
X  die:
X  #ifndef NO_SIGNAL
X  	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
X! #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
X  	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
X  #endif
X***************
X*** 406,412 ****
X  					continue;
X  				}
X  				u.urexp += i;
X! 				Printf("        %s (worth %ld Zorkmids),\n",
X  				    doname(otmp), i);
X  			} else if(otmp->olet == AMULET_SYM) {
X  				otmp->known = 1;
X--- 420,426 ----
X  					continue;
X  				}
X  				u.urexp += i;
X! 				Printf("        %s (worth %ld zorkmids),\n",
X  				    doname(otmp), i);
X  			} else if(otmp->olet == AMULET_SYM) {
X  				otmp->known = 1;
X***************
X*** 414,420 ****
X  					otmp->otyp == AMULET_OF_YENDOR ?
X  							5000 : 500;
X  				u.urexp += i;
X! 				Printf("        %s (worth %ld Zorkmids),\n",
X  				    doname(otmp), i);
X  			}
X  		}
X--- 428,434 ----
X  					otmp->otyp == AMULET_OF_YENDOR ?
X  							5000 : 500;
X  				u.urexp += i;
X! 				Printf("        %s (worth %ld zorkmids),\n",
X  				    doname(otmp), i);
X  			}
X  		}
X***************
X*** 467,475 ****
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! #if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS))
X  	register int x;
X! #ifdef UNIX
X  	(void) signal(SIGHUP,SIG_IGN);
X  #endif
X  	for(x = maxdlevel; x >= 0; x--) {
X--- 481,489 ----
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! #if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS)) || defined(VMS)
X  	register int x;
X! #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X  #endif
X  	for(x = maxdlevel; x >= 0; x--) {
X***************
X*** 486,492 ****
X--- 500,508 ----
X  {
X  	(void) signal(SIGINT, SIG_IGN);
X  	clearlocks();
X+ # ifndef VMS
X  	exit(1);
X+ # endif
X  }
X  #endif
X  
X***************
X*** 494,499 ****
X--- 510,516 ----
X  end_box_display()
X  {
X  	register struct obj *box, *obj;
X+ 	int boxcnt = 0;
X  	char buf[BUFSZ];
X  
X  	for(box=invent; box; box=box->nobj) {
X***************
X*** 504,510 ****
X  		    if (obj->cobj == box) {
X  			if (!cnt) {
X  			    Sprintf(buf, "Contents of the %s:",xname(box));
X! 			    cornline(0, buf);
X  			}
X  			makeknown(obj->otyp);
X  			obj->known = obj->bknown = obj->dknown = 1;
X--- 521,530 ----
X  		    if (obj->cobj == box) {
X  			if (!cnt) {
X  			    Sprintf(buf, "Contents of the %s:",xname(box));
X! 			    if (!boxcnt)
X! 				cornline(0, buf);
X! 			    else
X! 				cornline(1, buf);
X  			}
X  			makeknown(obj->otyp);
X  			obj->known = obj->bknown = obj->dknown = 1;
X***************
X*** 512,519 ****
X  			cnt++;
X  		    }
X  		}
X! 		if (!cnt) pline("The %s is empty.", xname(box));
X! 		else cornline(2,"");
X  	    }
X  	}
X  }
X--- 532,547 ----
X  			cnt++;
X  		    }
X  		}
X! 		if (!cnt) {
X! 		    Sprintf(buf, "The %s is empty.", xname(box));
X! 		    if (!boxcnt)
X! 			cornline(0, buf);
X! 		    else
X! 			cornline(1, buf);
X! 		} else
X! 		    cornline(1," ");
X! 		boxcnt++;
X  	    }
X  	}
X+ 	if (boxcnt) cornline(2,"");
X  }
X*** src/Old/engrave.c	Wed Sep 27 11:25:51 1989
X--- src/engrave.c	Sun Sep 24 19:41:27 1989
X***************
X*** 320,325 ****
X--- 320,334 ----
X  				type = DUST;
X  			}
X  		}
X+ 		if (otmp->spe < 0 && type != POLY) {
X+ dust:
X+ 		    /* If POLY, polymorph the writing and _then_ become dust. */
X+ 		    pline("The %s %sturns to dust.",
X+ 			   xname(otmp), Blind ? "" : "glows violently, then ");
X+     You("are not going to get anywhere writing in the dust with your dust...");
X+ 		    useup(otmp);
X+ 		    return(1);
X+ 		}
X  		if(type == DUST)
X  			You("write in the dust with %s.",
X  			   doname(otmp));
X***************
X*** 362,368 ****
X  		  del_engr(oep);
X  		  oep = 0;
X  	}
X! 	if(type == DUST && oep) {
X  	    You("cannot wipe out the message that is %s in the rock.",
X  		  (oep->engr_type == BURN) ? "burned" :
X  		  (oep->engr_type == ENGRAVE) ? "engraved" : "scribbled");
X--- 371,377 ----
X  		  del_engr(oep);
X  		  oep = 0;
X  	}
X! 	if(oep) {
X  	    You("cannot wipe out the message that is %s in the rock.",
X  		  (oep->engr_type == BURN) ? "burned" :
X  		  (oep->engr_type == ENGRAVE) ? "engraved" : "scribbled");
X***************
X*** 518,524 ****
X  	case WAN_STRIKING:
X  		pline("The %s unsuccessfully fights your attempt to write!",xname(otmp));
X  	}
X! 
X  	return(1);
X  }
X  
X--- 527,533 ----
X  	case WAN_STRIKING:
X  		pline("The %s unsuccessfully fights your attempt to write!",xname(otmp));
X  	}
X! 	if (otmp->otyp == WAN_POLYMORPH && otmp->spe < 0) goto dust;
X  	return(1);
X  }
X  
X*** src/Old/fountain.c	Wed Sep 27 11:27:12 1989
X--- src/fountain.c	Mon Sep 25 21:34:53 1989
X***************
X*** 11,19 ****
X  void
X  dowatersnakes() /* Fountain of snakes! */ {
X  	register int num = rnd(6);
X! 	if (!(mons[PM_WATER_MOCCASIN].geno & G_GENOD)) {	/* && chgd to &*/
X! 
X! 		pline("Good Lord!  An endless stream of snakes pours forth!");
X  		while(num-- > 0) (void) makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy);
X  	} else
X  		pline("The fountain bubbles furiously for a moment, then calms.");
X--- 11,18 ----
X  void
X  dowatersnakes() /* Fountain of snakes! */ {
X  	register int num = rnd(6);
X! 	if (!(mons[PM_WATER_MOCCASIN].geno & G_GENOD)) {
X! 		pline("An endless stream of snakes pours forth!");
X  		while(num-- > 0) (void) makemon(&mons[PM_WATER_MOCCASIN],u.ux,u.uy);
X  	} else
X  		pline("The fountain bubbles furiously for a moment, then calms.");
X***************
X*** 105,111 ****
X  
X  void
X  dryup(){
X! 	if (!rn2(3) && (levl[u.ux][u.uy].typ == FOUNTAIN)) {
X  		pline("The fountain dries up!");
X  		levl[u.ux][u.uy].typ = ROOM;
X  		levl[u.ux][u.uy].doormask = 0;
X--- 104,110 ----
X  
X  void
X  dryup(){
X! 	if (!rn2(3) && IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X  		pline("The fountain dries up!");
X  		levl[u.ux][u.uy].typ = ROOM;
X  		levl[u.ux][u.uy].doormask = 0;
X*** src/Old/getline.c	Wed Sep 27 11:27:39 1989
X--- src/getline.c	Sat Sep 23 00:47:46 1989
X***************
X*** 9,15 ****
X   * Some systems may have getchar() return EOF for various reasons, and
X   * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
X   */
X! #ifdef SYSV
X  #define	NR_OF_EOFS	20
X  #endif
X  
X--- 9,15 ----
X   * Some systems may have getchar() return EOF for various reasons, and
X   * we should not quit before seeing at least NR_OF_EOFS consecutive EOFs.
X   */
X! #if defined(SYSV) || defined(DGUX)
X  #define	NR_OF_EOFS	20
X  #endif
X  
X***************
X*** 123,129 ****
X  #else
X  	static char in_line[COLNO];
X  #endif
X! 	register int foo;
X  
X  	multi = 0;
X  	flags.move = 1;
X--- 123,130 ----
X  #else
X  	static char in_line[COLNO];
X  #endif
X! 	register int foo, cnt = 0;
X! 	boolean prezero = FALSE;
X  
X  	multi = 0;
X  	flags.move = 1;
X***************
X*** 141,147 ****
X--- 142,156 ----
X  			Printf("Count: %d", multi);
X  		}
X  		last_multi = multi;
X+ 		if(!cnt && foo == '0') prezero = TRUE;
X+ 		cnt++;
X  	    }
X+ 	    if (foo == '\033') {   /* esc cancels count (TH) */
X+ 		remember_topl();
X+ 		home();
X+ 		cl_end();
X+ 		multi = last_multi = 0;
X+ 	    }
X  # ifdef REDO
X  	if (foo == DOAGAIN || in_doagain)
X  		multi = last_multi;
X***************
X*** 171,176 ****
X--- 180,186 ----
X  		in_line[2] = 0;
X  	}
X  	clrlin();
X+ 	if(prezero) in_line[0] = '\033';
X  	return(in_line);
X  }
X  
X*** src/Old/hack.c	Wed Sep 27 11:28:02 1989
X--- src/hack.c	Mon Sep 25 21:29:34 1989
X***************
X*** 63,69 ****
X  		    for(y = u.uy-1; y < u.uy+2; y++) {
X  			if(!isok(x, y)) continue;
X  			lev = &levl[x][y];
X! 			if(lev->mmask) unpmon(m_at(x,y));
X  			if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			    lev->seen = 0;
X  			    atl(x, y, (char)STONE_SYM);
X--- 63,70 ----
X  		    for(y = u.uy-1; y < u.uy+2; y++) {
X  			if(!isok(x, y)) continue;
X  			lev = &levl[x][y];
X! 			if(MON_AT(x, y))
X! 			    unpmon(m_at(x,y));
X  			if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			    lev->seen = 0;
X  			    atl(x, y, (char)STONE_SYM);
X***************
X*** 95,101 ****
X  		if(isok(rx,ry) && !IS_ROCK(levl[rx][ry].typ) &&
X  		    (!IS_DOOR(levl[rx][ry].typ) || !(u.dx && u.dy)) &&
X  		    !sobj_at(BOULDER, rx, ry)) {
X! 			if(levl[rx][ry].mmask) {
X  			    mtmp = m_at(rx,ry);
X  			    if(canseemon(mtmp))
X  				pline("There's %s on the other side.",
X--- 96,102 ----
X  		if(isok(rx,ry) && !IS_ROCK(levl[rx][ry].typ) &&
X  		    (!IS_DOOR(levl[rx][ry].typ) || !(u.dx && u.dy)) &&
X  		    !sobj_at(BOULDER, rx, ry)) {
X! 			if(MON_AT(rx, ry)) {
X  			    mtmp = m_at(rx,ry);
X  			    if(canseemon(mtmp))
X  				pline("There's %s on the other side.",
X***************
X*** 119,124 ****
X--- 120,130 ----
X  				    pline("It completely fills the pit!");
X  				continue;
X  			    case TRAPDOOR:
X+ 				if(is_maze_lev
X+ #ifdef STRONGHOLD
X+ 					&& (dlevel > stronghold_level)
X+ #endif
X+ 					) break;
X  				pline("The boulder falls into and plugs a hole in the ground!");
X  				deltrap(ttmp);
X  				delobj(otmp);
X***************
X*** 361,367 ****
X  #endif
X  			}
X  		}
X! 		if (levl[x][y].mmask) {
X  			mtmp = m_at(x,y);
X  			/* Don't attack if you're running */
X  			if (flags.run && !mtmp->mimic &&
X--- 367,373 ----
X  #endif
X  			}
X  		}
X! 		if (MON_AT(x, y)) {
X  			mtmp = m_at(x,y);
X  			/* Don't attack if you're running */
X  			if (flags.run && !mtmp->mimic &&
X***************
X*** 490,496 ****
X  
X  		movobj(uball, uchain->ox, uchain->oy);
X  		unpobj(uball);		/* BAH %% */
X! 		place_object(uchain, u.ux, u.uy);
X  		nomul(-2);
X  		nomovemsg = "";
X  	nodrag:	;
X--- 496,502 ----
X  
X  		movobj(uball, uchain->ox, uchain->oy);
X  		unpobj(uball);		/* BAH %% */
X! 		move_object(uchain, u.ux, u.uy);
X  		nomul(-2);
X  		nomovemsg = "";
X  	nodrag:	;
X***************
X*** 568,574 ****
X  #ifdef POLYSELF
X  	if (hides_under(uasmon))
X  	    u.uundetected = (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask);
X! 	else if (u.dx || u.dy) { /* i.e. piercer */
X  	    if (u.usym == S_MIMIC_DEF)
X  		u.usym = S_MIMIC;
X  	    u.uundetected = 0;
X--- 574,580 ----
X  #ifdef POLYSELF
X  	if (hides_under(uasmon))
X  	    u.uundetected = (OBJ_AT(u.ux, u.uy) || levl[u.ux][u.uy].gmask);
X! 	else if (u.dx || u.dy) { /* piercer */
X  	    if (u.usym == S_MIMIC_DEF)
X  		u.usym = S_MIMIC;
X  	    u.uundetected = 0;
X***************
X*** 691,697 ****
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X! 		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X--- 697,703 ----
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X! 		if(MON_AT(x, y) && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X  			if((flags.run != 1 && !mtmp->mtame) || (x == u.ux+u.dx && y == u.uy+u.dy))
X  				goto stop;
X***************
X*** 792,798 ****
X  	for(x = u.ux-1; x <= u.ux+1; x++)
X  	    for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X! 		if(levl[x][y].mmask && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   !mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
X--- 798,804 ----
X  	for(x = u.ux-1; x <= u.ux+1; x++)
X  	    for(y = u.uy-1; y <= u.uy+1; y++) {
X  		if(x == u.ux && y == u.uy) continue;
X! 		if(MON_AT(x, y) && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		   !mtmp->mtame && !mtmp->mpeaceful &&
X  		   !noattacks(mtmp->data) &&
X  		   !mtmp->mfroz && !mtmp->msleep &&  /* aplvax!jcn */
X***************
X*** 809,815 ****
X  {
X  	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X! 				!levl[x][y].mmask && !levl[u.ux][u.uy].lit)
X  		return(0);
X  	if(dist(x,y) < 3) return(1);
X  	if(levl[x][y].lit &&
X--- 815,821 ----
X  {
X  	if(Blind || (u.uswallow && (x != u.ux || y != u.uy))) return(0);
X  	if(IS_ROCK(levl[x][y].typ) && levl[u.ux][u.uy].typ == CORR &&
X! 				!MON_AT(x, y) && !levl[u.ux][u.uy].lit)
X  		return(0);
X  	if(dist(x,y) < 3) return(1);
X  	if(levl[x][y].lit &&
X*** src/Old/invent.c	Wed Sep 27 11:28:57 1989
X--- src/invent.c	Sat Sep 23 01:23:44 1989
X***************
X*** 245,288 ****
X  #endif
X  }
X  
X- struct monst *
X- m_at(x,y)
X- register int x, y;
X- {
X- 	register struct monst *mtmp;
X- #ifdef WORM
X- 	register struct wseg *wtmp;
X- 	m_atseg = 0;
X- #endif
X- 
X- 	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X- 		if(mtmp->mx == x && mtmp->my == y)
X- 			return(mtmp);
X- #ifdef WORM
X- 		if(mtmp->wormno){
X- 		    for(wtmp = wsegs[mtmp->wormno]; wtmp; wtmp = wtmp->nseg)
X- 		    if(wtmp->wx == x && wtmp->wy == y){
X- 			m_atseg = wtmp;
X- 			return(mtmp);
X- 		    }
X- 		}
X- #endif
X- 	}
X- 	return((struct monst *)0);
X- }
X- 
X  struct obj *
X- o_at(x,y)
X- register int x, y;
X- {
X- 	register struct obj *otmp;
X- 
X- 	for(otmp = fobj; otmp; otmp = otmp->nobj)
X- 		if(otmp->ox == x && otmp->oy == y) return(otmp);
X- 	return((struct obj *)0);
X- }
X- 
X- struct obj *
X  sobj_at(n,x,y)
X  register int n, x, y;
X  {
X--- 245,251 ----
X***************
X*** 289,296 ****
X  	register struct obj *otmp;
X  
X  	if(OBJ_AT(x, y))
X! 	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X! 		if(otmp->ox == x && otmp->oy == y && otmp->otyp == n)
X  		    return(otmp);
X  	return((struct obj *)0);
X  }
X--- 252,259 ----
X  	register struct obj *otmp;
X  
X  	if(OBJ_AT(x, y))
X! 	    for(otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X! 		if(otmp->otyp == n)
X  		    return(otmp);
X  	return((struct obj *)0);
X  }
X***************
X*** 385,390 ****
X--- 348,354 ----
X  	boolean allownone = FALSE;
X  	xchar foox = 0;
X  	long cnt;
X+ 	boolean prezero = FALSE;
X  
X  	if(*let == '0') let++, allowcnt = 1;
X  	if(*let == GOLD_SYM) let++,
X***************
X*** 475,480 ****
X--- 439,445 ----
X  		}
X  		cnt = 0;
X  		ilet = readchar();
X+ 		if(ilet == '0') prezero = TRUE;
X  		while(digit(ilet) && allowcnt) {
X  #ifdef REDO
X  			if (ilet != '?' && ilet != '*')	savech(ilet);
X***************
X*** 503,508 ****
X--- 468,474 ----
X  				You("are not carrying any gold.");
X  				return(struct obj *)0;
X  			}
X+ 			if(cnt == 0 && prezero) return((struct obj *)0);
X  			if(!(allowcnt == 2 && cnt < u.ugold))
X  				cnt = u.ugold;
X  			return(mkgoldobj(cnt));
X***************
X*** 512,518 ****
X  			 * counts for other things since the throw code will
X  			 * split off a single item anyway */
X  			allowcnt = 1;
X! 			if(cnt != 1) {
X  			    pline("You can only throw one item at a time.");
X  			    continue;
X  			}
X--- 478,485 ----
X  			 * counts for other things since the throw code will
X  			 * split off a single item anyway */
X  			allowcnt = 1;
X! 			if(cnt == 0 && prezero) return((struct obj *)0);
X! 			if(cnt > 1) {
X  			    pline("You can only throw one item at a time.");
X  			    continue;
X  			}
X***************
X*** 973,979 ****
X  
X      	read_engr_at(u.ux, u.uy); /* Eric Backus */
X      	if(!u.uswallow) {
X! 		otmp0 = o_at(u.ux, u.uy);
X  		gold = g_at(u.ux, u.uy);
X      	}  else  {
X  		You("%s no objects here.", verb);
X--- 940,946 ----
X  
X      	read_engr_at(u.ux, u.uy); /* Eric Backus */
X      	if(!u.uswallow) {
X! 		otmp0 = level.objects[u.ux][u.uy];
X  		gold = g_at(u.ux, u.uy);
X      	}  else  {
X  		You("%s no objects here.", verb);
X***************
X*** 1064,1070 ****
X      	}
X  
X      	cornline(0, "Things that are here:");
X!     	for(otmp = otmp0; otmp; otmp = otmp->nobj) {
X  		if(otmp->ox == u.ux && otmp->oy == u.uy) {
X  	    		ct++;
X  	    		cornline(1, doname(otmp));
X--- 1031,1037 ----
X      	}
X  
X      	cornline(0, "Things that are here:");
X!     	for(otmp = otmp0; otmp; otmp = otmp->nexthere) {
X  		if(otmp->ox == u.ux && otmp->oy == u.uy) {
X  	    		ct++;
X  	    		cornline(1, doname(otmp));
X***************
X*** 1129,1139 ****
X  	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X  	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X  		return( (obj->corpsenm == otmp->corpsenm) &&
X  			(!ONAME(obj) || !strcmp(ONAME(obj), ONAME(otmp))) );
X  
X! 	else if(obj->known == otmp->known || !uses_known(otmp)) {
X  		return(objects[obj->otyp].oc_merge);
X  	} else return(FALSE);
X  }
X--- 1096,1110 ----
X  	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X+ 	else if(obj->olet == FOOD_SYM && OEATEN(obj) != OEATEN(otmp))
X+ 		return(FALSE);
X+ 
X  	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X  		return( (obj->corpsenm == otmp->corpsenm) &&
X  			(!ONAME(obj) || !strcmp(ONAME(obj), ONAME(otmp))) );
X  
X! 	else if(obj->known == otmp->known || 
X! 		!objects[otmp->otyp].oc_uses_known) {
X  		return(objects[obj->otyp].oc_merge);
X  	} else return(FALSE);
X  }
X*** src/Old/ioctl.c	Wed Sep 27 11:30:06 1989
X--- src/ioctl.c	Fri Sep 15 09:44:18 1989
X***************
X*** 8,13 ****
X--- 8,14 ----
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X+ #define MONFLAG_H
X  #include "hack.h"
X  
X  #if defined(BSD) || defined(ULTRIX)
X*** src/Old/lev_comp.y	Wed Sep 27 11:32:26 1989
X--- src/lev_comp.y	Tue Sep 26 16:18:27 1989
X***************
X*** 12,18 ****
X  #define MONDATA_H
X  #include "hack.h"
X  #include "sp_lev.h"
X! #include <fcntl.h>
X  
X  #ifdef AMIGA
X  char *fgets();
X--- 12,23 ----
X  #define MONDATA_H
X  #include "hack.h"
X  #include "sp_lev.h"
X! #ifndef O_WRONLY
X! # include <fcntl.h>
X! #endif
X! #ifndef O_CREAT	/* some older BSD systems do not define O_CREAT in <fcntl.h> */
X! # include <sys/file.h>
X! #endif
X  
X  #ifdef AMIGA
X  char *fgets();
X*** src/Old/lev_main.c	Wed Sep 27 11:34:00 1989
X--- src/lev_main.c	Sat Sep 16 17:53:54 1989
X***************
X*** 26,32 ****
X--- 26,37 ----
X  	    yyparse();
X  	else 			/* Otherwise every argument is a filename */
X  	    for(i=1; i<argc; i++) {
X+ #ifdef VMS
X+ 		    extern FILE *yyin;
X+ 		    yyin = fin = fopen(argv[i], "r");
X+ #else
X  		    fin = freopen(argv[i], "r", stdin);
X+ #endif
X  		    fname = argv[i];
X  		    if (!fin) 
X  			fprintf(stderr,"Can't open %s\n", argv[i]);
X*** src/Old/lock.c	Wed Sep 27 11:34:30 1989
X--- src/lock.c	Thu Sep 14 14:11:20 1989
X***************
X*** 228,234 ****
X  	    struct monst *mtmp;
X  
X  	    door = &levl[x][y];
X! 	    if (door->mmask && canseemon(mtmp = m_at(x,y)) && !mtmp->mimic) {
X  		if (picktyp == CREDIT_CARD &&
X  #ifdef ORACLE
X  		    (mtmp->isshk || mtmp->data == &mons[PM_ORACLE]))
X--- 228,234 ----
X  	    struct monst *mtmp;
X  
X  	    door = &levl[x][y];
X! 	    if (MON_AT(x, y) && canseemon(mtmp = m_at(x,y)) && !mtmp->mimic) {
X  		if (picktyp == CREDIT_CARD &&
X  #ifdef ORACLE
X  		    (mtmp->isshk || mtmp->data == &mons[PM_ORACLE]))
X***************
X*** 373,379 ****
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X! 	if(levl[x][y].mmask && (mtmp = m_at(x,y))->mimic && 
X  				mtmp->mappearance == DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X--- 373,379 ----
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X  				mtmp->mappearance == DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X***************
X*** 430,436 ****
X  obstructed(x,y)
X  register int x, y;
X  {
X! 	if(levl[x][y].mmask) {
X  		if (m_at(x,y)->mimic) goto obj;	  
X  		pline("%s stands in the way!", Blind ?
X  			"Some creature" : Monnam(m_at(x,y)));
X--- 430,436 ----
X  obstructed(x,y)
X  register int x, y;
X  {
X! 	if(MON_AT(x, y)) {
X  		if (m_at(x,y)->mimic) goto obj;	  
X  		pline("%s stands in the way!", Blind ?
X  			"Some creature" : Monnam(m_at(x,y)));
X***************
X*** 459,465 ****
X  		return(1);
X  	}
X  
X! 	if(levl[x][y].mmask && (mtmp = m_at(x,y))->mimic && 
X  				mtmp->mappearance == DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X--- 459,465 ----
X  		return(1);
X  	}
X  
X! 	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X  				mtmp->mappearance == DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X***************
X*** 624,630 ****
X  #endif
X  		if(door->doormask & (D_LOCKED | D_CLOSED)) {
X  		    if(door->doormask & D_TRAPPED) {
X! 			if (levl[x][y].mmask)
X  			    (void) mb_trapped(m_at(x,y));
X  			else if (flags.verbose)
X  			    if (cansee(x,y))
X--- 624,630 ----
X  #endif
X  		if(door->doormask & (D_LOCKED | D_CLOSED)) {
X  		    if(door->doormask & D_TRAPPED) {
X! 			if (MON_AT(x, y))
X  			    (void) mb_trapped(m_at(x,y));
X  			else if (flags.verbose)
X  			    if (cansee(x,y))
X*** src/Old/mail.c	Wed Sep 27 11:49:09 1989
X--- src/mail.c	Tue Sep 26 17:24:55 1989
X***************
X*** 9,16 ****
X  #ifdef MAIL
X  
X  # ifdef UNIX
X! #include <sys/stat.h>
X  # endif
X  
X  /*
X   * Notify user when new mail has arrived. [Idea from Merlyn Leroy, but
X--- 9,21 ----
X  #ifdef MAIL
X  
X  # ifdef UNIX
X! #  include <sys/stat.h>
X! #  include <pwd.h>
X  # endif
X+ # ifdef VMS
X+ #  include <descrip.h>
X+ #  include <ssdef.h>
X+ # endif
X  
X  /*
X   * Notify user when new mail has arrived. [Idea from Merlyn Leroy, but
X***************
X*** 19,27 ****
X   *   hack should do the paging itself. But when I get mail, I want to put it
X   *   in some folder, reply, etc. - it would be unreasonable to put all these
X   *   functions in hack. }
X!  * The motion of the mail daemon is less restrained than usual:
X!  * diagonal moves from a DOOR are possible. He might also use SDOOR's. Also,
X!  * the mail daemon is visible in a ROOM, even when you are Blind.
X   * Its path should be longer when you are Telepat-hic and Blind.
X   *
X   * Possible extensions:
X--- 24,35 ----
X   *   hack should do the paging itself. But when I get mail, I want to put it
X   *   in some folder, reply, etc. - it would be unreasonable to put all these
X   *   functions in hack. }
X!  *
X!  * The mail daemon can move with less than usual restraint.  It can:
X!  *	- move diagonally from a door
X!  *	- use secret doors
X!  *	- run thru a monster
X!  *
X   * Its path should be longer when you are Telepat-hic and Blind.
X   *
X   * Possible extensions:
X***************
X*** 42,57 ****
X   * Here are some minor problems i didn't fix:  -3.
X   *
X   *	- The code sometimes pops up the mail daemon next to you on
X!  *	  the corridor side of doorways when there are open spaces in
X!  *	  the room.
X   *	- It may also do this with adjoining castle rooms.
X   */
X  
X! # ifndef UNIX
X  int mustgetmail = -1;
X  # endif
X  
X  # ifdef UNIX
X  static struct stat omstat,nmstat;
X  static char *mailbox = NULL;
X  static long laststattime;
X--- 50,66 ----
X   * Here are some minor problems i didn't fix:  -3.
X   *
X   *	- The code sometimes pops up the mail daemon next to you on
X!  *	  the corridor side of doorways when there are open spaces
X!  *	  within the room.
X   *	- It may also do this with adjoining castle rooms.
X   */
X  
X! # if !defined(UNIX) && !defined(VMS)
X  int mustgetmail = -1;
X  # endif
X  
X  # ifdef UNIX
X+ extern struct passwd *getpwuid();
X  static struct stat omstat,nmstat;
X  static char *mailbox = NULL;
X  static long laststattime;
X***************
X*** 69,75 ****
X  #  ifdef MAILPATH
X  		mailbox = (char *) alloc(sizeof(MAILPATH)+8);
X  		Strcpy(mailbox, MAILPATH);
X! 		Strcat(mailbox, getlogin());
X  #  else
X  		return;
X  #  endif
X--- 78,84 ----
X  #  ifdef MAILPATH
X  		mailbox = (char *) alloc(sizeof(MAILPATH)+8);
X  		Strcpy(mailbox, MAILPATH);
X! 		Strcat(mailbox, getpwuid(getuid())->pw_name);
X  #  else
X  		return;
X  #  endif
X***************
X*** 76,82 ****
X  	}
X  	if(stat(mailbox, &omstat)){
X  #  ifdef PERMANENT_MAILBOX
X! 		pline("Cannot get status of MAIL=%s .", mailbox);
X  		mailbox = 0;
X  #  else
X  		omstat.st_mtime = 0;
X--- 85,91 ----
X  	}
X  	if(stat(mailbox, &omstat)){
X  #  ifdef PERMANENT_MAILBOX
X! 		pline("Cannot get status of MAIL=\"%s\".", mailbox);
X  		mailbox = 0;
X  #  else
X  		omstat.st_mtime = 0;
X***************
X*** 85,159 ****
X  }
X  # endif /* UNIX */
X  
X! /* make md run through the cave */
X  static void
X! mdrush(md,away)
X! register struct monst *md;
X! boolean away;
X  {
X! 	register int uroom = inroom(u.ux, u.uy);
X! 	if(uroom >= 0 && inroom(md->mx,md->my) == uroom) {
X! 		register int tmp = rooms[uroom].fdoor;
X! 		register int cnt = rooms[uroom].doorct;
X! 		register int fx = u.ux, fy = u.uy;
X! 		while(cnt--) {
X! 			if(dist(fx,fy) < dist(doors[tmp].x, doors[tmp].y)){
X! 				fx = doors[tmp].x;
X! 				fy = doors[tmp].y;
X! 			}
X! 			tmp++;
X! 		}
X! 		if (has_dnstairs(&rooms[uroom]))
X! 			if(dist(fx,fy) < dist(xdnstair, ydnstair)){
X! 				fx = xdnstair;
X! 				fy = ydnstair;
X! 			}
X! 		if (has_upstairs(&rooms[uroom]))
X! 			if(dist(fx,fy) < dist(xupstair, yupstair)){
X! 				fx = xupstair;
X! 				fy = yupstair;
X  			}
X! 		tmp_at(-1, md->data->mlet);	/* open call */
X! 		tmp_at(-3, (int)AT_MON);
X! 		if(away) {	/* interchange origin and destination */
X  			unpmon(md);
X! 			levl[md->mx][md->my].mmask = 0;
X! 			levl[fx][fy].mmask = 1;
X! 			tmp = fx; fx = md->mx; md->mx = tmp;
X! 			tmp = fy; fy = md->my; md->my = tmp;
X! 		}
X! 		while(fx != md->mx || fy != md->my) {
X! 			register int dx,dy,nfx = fx,nfy = fy,d1,d2;
X  
X! 			tmp_at(fx,fy);
X! 			d1 = dist2(fx,fy,md->mx,md->my);
X! 			for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X! 			    if((dx || dy) && 
X! 			       !IS_STWALL(levl[fx+dx][fy+dy].typ)) {
X! 				d2 = dist2(fx+dx,fy+dy,md->mx,md->my);
X! 				if(d2 < d1) {
X! 				    d1 = d2;
X! 				    nfx = fx+dx;
X! 				    nfy = fy+dy;
X  				}
X! 			    }
X! 			if(nfx != fx || nfy != fy) {
X! 			    fx = nfx;
X! 			    fy = nfy;
X! 			} else {
X! 			    if(!away) {
X! 				levl[md->mx][md->my].mmask = 0;
X! 				levl[fx][fy].mmask = 1;
X! 				md->mx = fx;
X! 				md->my = fy;
X! 			    }
X! 			    break;
X! 			} 
X  		}
X! 		tmp_at(-1,-1);			/* close call */
X! 	}
X! 	if(!away)
X! 		pmon(md);
X  }
X  
X  static void
X--- 94,204 ----
X  }
X  # endif /* UNIX */
X  
X! # ifdef VMS
X! extern unsigned long pasteboard_id;
X! int broadcasts = 0;
X! #  define getmailstatus()
X! # endif /* VMS */
X! 
X! 
X! /* make mail daemon run through the dungeon */
X  static void
X! mdrush(md,fx,fy)
X! struct monst *md;
X! register int fx, fy;	/* origin, where the '&' is displayed */
X  {
X! 	register int tx = md->mx, ty = md->my;
X! 			/* real location, where the '&' is going */
X! 
X! 	tmp_at(-1, md->data->mlet);	/* open call */
X! #ifdef TEXTCOLOR
X! 	tmp_at(-3, (int)md->data->mcolor);
X! #endif
X! 
X! 	while(fx != tx || fy != ty) {
X! 		register int dx, dy,		/* direction counters */
X! 			     nfx = fx, nfy = fy,/* next location */ 
X! 			     d1, d2;		/* shortest dist, eval */
X! 
X! 		/* display the '&' at (fx,fy) */
X! 		tmp_at(fx,fy);
X! 
X! 		/* find location next to (fx,fy) closest to (tx,ty) */
X! 		d1 = dist2(fx,fy,tx,ty);
X! 		for(dx = -1; dx <= 1; dx++) for(dy = -1; dy <= 1; dy++)
X! 		    if((dx || dy) && 
X! 		       !IS_STWALL(levl[fx+dx][fy+dy].typ)) {
X! 			d2 = dist2(fx+dx,fy+dy,tx,ty);
X! 			if(d2 < d1) {
X! 			    d1 = d2;
X! 			    nfx = fx+dx;
X! 			    nfy = fy+dy;
X  			}
X! 		    }
X! 
X! 		/* set (fx,fy) to next location, unless it stopped */
X! 		if(nfx != fx || nfy != fy) {
X! 		    fx = nfx;
X! 		    fy = nfy;
X! 		} else break;
X! 	}
X! 
X! 	tmp_at(-1,-1);			/* close call */
X! }
X! 
X! static void
X! mdappear(md,away)
X! struct monst *md;
X! boolean away;
X! {
X! 	static int fx, fy;			/* origin */
X! 	int tx = md->mx, ty = md->my;		/* destination */
X! 	register int uroom = inroom(u.ux, u.uy);/* room you're in */
X! 
X! 	/* if mail daemon is in same room as you */
X! 	if(uroom >= 0 && inroom(md->mx,md->my) == uroom && (!Blind || Telepat))
X! 		if(away) {
X  			unpmon(md);
X! 			remove_monster(tx, ty);
X  
X! 			/* fake "real" location to origin */
X! 			md->mx = fx; md->my = fy;
X! 
X! 			/* rush from destination */
X! 			mdrush(md,tx,ty);
X! 			return;
X! 		} else {
X! 			/* choose origin */
X! 			register int cnt = rooms[uroom].doorct;
X! 			register int tmp = rooms[uroom].fdoor;
X! 			register int dd = 0;
X! 
X! 			/* which door (or staircase) is farthest? */
X! 			while (cnt--) {
X! 				if(dd < dist(doors[tmp].x, doors[tmp].y)) {
X! 					fx = doors[tmp].x;
X! 					fy = doors[tmp].y;
X! 					dd = dist(tx,ty);
X! 				}
X! 				tmp++;
X! 			}
X! 			if (has_dnstairs(&rooms[uroom]))
X! 				if(dd < dist(xdnstair, ydnstair)) {
X! 					fx = xdnstair;
X! 					fy = ydnstair;
X! 					dd = dist(xdnstair, ydnstair);
X! 				}
X! 			if (has_upstairs(&rooms[uroom]))
X! 				if(dd < dist(xupstair, yupstair)) {
X! 					fx = xupstair;
X! 					fy = yupstair;
X  				}
X! 
X! 			/* rush from origin */
X! 			mdrush(md,fx,fy);
X  		}
X! 
X! 	pmon(md);
X  }
X  
X  static void
X***************
X*** 167,175 ****
X  
X  	if(!md)	return;
X  
X! 	mdrush(md,0);
X  
X  	pline("\"Hello, %s!  I have some mail for you.\"", plname);
X  
X  	if(dist(md->mx,md->my) > 2)
X  		verbalize("Catch!");
X--- 212,224 ----
X  
X  	if(!md)	return;
X  
X! 	mdappear(md,FALSE);
X  
X+ # ifdef VMS
X+ 	pline("\"Hello, %s!  I have a message for you.\"", plname);
X+ # else
X  	pline("\"Hello, %s!  I have some mail for you.\"", plname);
X+ # endif
X  
X  	if(dist(md->mx,md->my) > 2)
X  		verbalize("Catch!");
X***************
X*** 186,199 ****
X  	}
X  
X  	/* disappear again */
X! 	mdrush(md,1);
X  	mongone(md);
X  
X  	/* force the graphics character set off */
X  	nscr();
X  }
X  
X! # ifndef UNIX
X  void
X  ckmailstatus() {
X  	if (mustgetmail < 0)
X--- 235,251 ----
X  	}
X  
X  	/* disappear again */
X! 	mdappear(md,TRUE);
X  	mongone(md);
X  
X  	/* force the graphics character set off */
X  	nscr();
X+ # ifdef VMS
X+ 	broadcasts--;
X+ # endif
X  }
X  
X! # if !defined(UNIX) && !defined(VMS)
X  void
X  ckmailstatus() {
X  	if (mustgetmail < 0)
X***************
X*** 209,217 ****
X  {
X  	pline("It says:  \"Please disregard previous letter.\"");
X  }
X! 
X! # else /* UNIX */
X  
X  void
X  ckmailstatus() {
X  	if(!mailbox
X--- 261,269 ----
X  {
X  	pline("It says:  \"Please disregard previous letter.\"");
X  }
X! # endif /* !UNIX && !VMS */
X  
X+ # ifdef UNIX
X  void
X  ckmailstatus() {
X  	if(!mailbox
X***************
X*** 224,230 ****
X  	laststattime = moves;
X  	if(stat(mailbox, &nmstat)){
X  #  ifdef PERMANENT_MAILBOX
X! 		pline("Cannot get status of MAIL=%s anymore.", mailbox);
X  		mailbox = 0;
X  #  else
X  		nmstat.st_mtime = 0;
X--- 276,282 ----
X  	laststattime = moves;
X  	if(stat(mailbox, &nmstat)){
X  #  ifdef PERMANENT_MAILBOX
X! 		pline("Cannot get status of MAIL=\"%s\" anymore.", mailbox);
X  		mailbox = 0;
X  #  else
X  		nmstat.st_mtime = 0;
X***************
X*** 255,259 ****
X--- 307,334 ----
X  	getmailstatus();
X  }
X  # endif /* UNIX */
X+ 
X+ # ifdef VMS
X+ void
X+ ckmailstatus()
X+ {
X+ 	if (broadcasts)
X+ 		newmail();
X+ }
X+ 
X+ void
X+ readmail()
X+ {
X+ 	char buf[16384];	/* $BRKTHRU limits messages to 16350 bytes */
X+ 	$DESCRIPTOR(message, buf);
X+ 	short length;
X+ 
X+ 	if (SMG$GET_BROADCAST_MESSAGE(&pasteboard_id, &message, &length)
X+ 	    == SS$_NORMAL && length != 0) {
X+ 		buf[length] = '\0';
X+ 		pline("%s", buf);
X+ 	}
X+ }
X+ # endif /* VMS */
X  
X  #endif /* MAIL */
X*** src/Old/makemon.c	Wed Sep 27 11:49:42 1989
X--- src/makemon.c	Mon Sep 25 21:34:56 1989
X***************
X*** 382,388 ****
X  		    for(cnt = rn2((int)(mtmp->m_lev / 2)); cnt; cnt--) {
X  			    do
X  				otmp = mkobj(GEM_SYM,FALSE);
X! 			    while (otmp->otyp >= LAST_GEM+5);
X  			    otmp->quan = 2 + rnd(2);
X  			    otmp->owt = weight(otmp);
X  			    mpickobj(mtmp, otmp);
X--- 382,388 ----
X  		    for(cnt = rn2((int)(mtmp->m_lev / 2)); cnt; cnt--) {
X  			    do
X  				otmp = mkobj(GEM_SYM,FALSE);
X! 			    while (otmp->otyp >= LAST_GEM+6);
X  			    otmp->quan = 2 + rnd(2);
X  			    otmp->owt = weight(otmp);
X  			    mpickobj(mtmp, otmp);
X***************
X*** 421,434 ****
X  
X  	/* if caller wants random location, do it here */
X  	if(x == 0 && y == 0) {
X  		do {
X  			x = rn1(COLNO-3,2);
X  			y = rn2(ROWNO);
X! 		} while(!goodpos(x, y, ptr));
X  	}
X  
X  	/* if a monster already exists at the position, return */
X! 	if(levl[x][y].mmask) return((struct monst *) 0);
X  
X  	if(ptr){
X  		/* if you are to make a specific monster and it has 
X--- 421,441 ----
X  
X  	/* if caller wants random location, do it here */
X  	if(x == 0 && y == 0) {
X+ 		int uroom;
X+ 		int tryct = 0;	/* careful with bigrooms */
X+ 
X+ 		if(!in_mklev) uroom = inroom(u.ux, u.uy);
X+ 
X  		do {
X  			x = rn1(COLNO-3,2);
X  			y = rn2(ROWNO);
X! 		} while(!goodpos(x, y, ptr) ||
X! 			(!in_mklev && tryct++ < 50 && inroom(x, y) == uroom));
X  	}
X  
X  	/* if a monster already exists at the position, return */
X! 	if(MON_AT(x, y))
X! 		return((struct monst *) 0);
X  
X  	if(ptr){
X  		/* if you are to make a specific monster and it has 
X***************
X*** 476,488 ****
X  	     * above the 1..49 that indicate "normal" monster levels */
X   	    mtmp->mhpmax = mtmp->mhp = 2*(ptr->mlevel - 6);
X   	    mtmp->m_lev = mtmp->mhp / 4;	/* approximation */
X!  	} else if((ptr->mlet == S_DRAGON) && (ptr >= &mons[PM_GREY_DRAGON]))
X  	    mtmp->mhpmax = mtmp->mhp = 80;
X  	else if(!mtmp->m_lev) mtmp->mhpmax = mtmp->mhp = rnd(4);
X  	else mtmp->mhpmax = mtmp->mhp = d((int)mtmp->m_lev, 8);
X! 	mtmp->mx = x;
X! 	mtmp->my = y;
X! 	levl[x][y].mmask = 1;
X  	mtmp->mcansee = 1;
X  	mtmp->mpeaceful = peace_minded(ptr);
X  
X--- 483,493 ----
X  	     * above the 1..49 that indicate "normal" monster levels */
X   	    mtmp->mhpmax = mtmp->mhp = 2*(ptr->mlevel - 6);
X   	    mtmp->m_lev = mtmp->mhp / 4;	/* approximation */
X!  	} else if((ptr->mlet == S_DRAGON) && (ptr >= &mons[PM_GRAY_DRAGON]))
X  	    mtmp->mhpmax = mtmp->mhp = 80;
X  	else if(!mtmp->m_lev) mtmp->mhpmax = mtmp->mhp = rnd(4);
X  	else mtmp->mhpmax = mtmp->mhp = d((int)mtmp->m_lev, 8);
X! 	place_monster(mtmp, x, y);
X  	mtmp->mcansee = 1;
X  	mtmp->mpeaceful = peace_minded(ptr);
X  
X***************
X*** 492,501 ****
X  			break;
X  		case S_SPIDER:
X  		case S_SNAKE:
X! 			mtmp->mhide = mtmp->mundetected = 1;
X  			if(in_mklev)
X! 			    if(mtmp->mx && mtmp->my)
X! 				(void) mkobj_at(0, mtmp->mx, mtmp->my);
X  			break;
X  		case S_CHAMELEON:
X  			/* If you're protected with a ring, don't create
X--- 497,508 ----
X  			break;
X  		case S_SPIDER:
X  		case S_SNAKE:
X! 			mtmp->mhide = 1;
X  			if(in_mklev)
X! 			    if(x && y)
X! 				(void) mkobj_at(0, x, y);
X! 			if(OBJ_AT(x, y) || levl[x][y].gmask)
X! 			    mtmp->mundetected = 1;
X  			break;
X  		case S_CHAMELEON:
X  			/* If you're protected with a ring, don't create
X***************
X*** 521,527 ****
X  		case S_UNICORN:
X  			if ((ptr==&mons[PM_WHITE_UNICORN] && 
X  				u.ualigntyp == U_LAWFUL) ||
X! 			(ptr==&mons[PM_GREY_UNICORN] && 
X  				u.ualigntyp == U_NEUTRAL) ||
X  			(ptr==&mons[PM_BLACK_UNICORN] && 
X  				u.ualigntyp == U_CHAOTIC))
X--- 528,534 ----
X  		case S_UNICORN:
X  			if ((ptr==&mons[PM_WHITE_UNICORN] && 
X  				u.ualigntyp == U_LAWFUL) ||
X! 			(ptr==&mons[PM_GRAY_UNICORN] && 
X  				u.ualigntyp == U_NEUTRAL) ||
X  			(ptr==&mons[PM_BLACK_UNICORN] && 
X  				u.ualigntyp == U_CHAOTIC))
X***************
X*** 632,638 ****
X  int x,y;
X  struct permonst *mdat;
X  {
X! 	if (x < 1 || x > COLNO-2 || y < 1 || y > ROWNO-2 || levl[x][y].mmask)
X  		return 0;
X  	if (x == u.ux && y == u.uy) return 0;
X  	if (mdat) {
X--- 639,645 ----
X  int x,y;
X  struct permonst *mdat;
X  {
X! 	if (x < 1 || x > COLNO-2 || y < 1 || y > ROWNO-2 || MON_AT(x, y))
X  		return 0;
X  	if (x == u.ux && y == u.uy) return 0;
X  	if (mdat) {
X***************
X*** 668,677 ****
X  		ty = rn2(ROWNO);
X  	   } while(!goodpos(tx,ty,mtmp->data));
X  	if(mtmp->mx != 0 && mtmp->my != 0)
X! 		levl[mtmp->mx][mtmp->my].mmask = 0;
X! 	mtmp->mx = tx;
X! 	mtmp->my = ty;
X! 	levl[tx][ty].mmask = 1;
X  	if(u.ustuck == mtmp){
X  		if(u.uswallow) {
X  			u.ux = tx;
X--- 675,682 ----
X  		ty = rn2(ROWNO);
X  	   } while(!goodpos(tx,ty,mtmp->data));
X  	if(mtmp->mx != 0 && mtmp->my != 0)
X! 		remove_monster(mtmp->mx, mtmp->my);
X! 	place_monster(mtmp, tx, ty);
X  	if(u.ustuck == mtmp){
X  		if(u.uswallow) {
X  			u.ux = tx;
X***************
X*** 683,704 ****
X  	set_apparxy(mtmp);
X  }
X  
X- struct monst *
X- mkmon_at(name, x, y)
X- char *name;
X- register int x,y;
X- {
X- 	register int ct;
X- 	register struct permonst *ptr;
X- 
X- 	for(ct = PM_CHAMELEON; ct >= 0; ct--) { /* Chameleon is last monster */
X- 		ptr = &mons[ct];
X- 		if(!strcmp(ptr->mname, name))
X- 			return(makemon(ptr, x, y));
X- 	}
X- 	return((struct monst *)0);
X- }
X- 
X  static int
X  cmnum()	{	/* return the number of "common" monsters */
X  
X--- 688,693 ----
X***************
X*** 735,740 ****
X--- 724,732 ----
X  	n = (!!(ptr->geno & G_SGROUP));
X  	n += (!!(ptr->geno & G_LGROUP)) << 1;
X  
X+ /*	For ranged attacks */
X+ 	if (ranged_attk(ptr)) n++;
X+ 
X  /*	For higher ac values */
X  	n += (ptr->ac < 0);
X  
X***************
X*** 747,752 ****
X--- 739,745 ----
X  	    tmp2 = ptr->mattk[i].aatyp;
X  	    n += (tmp2 > 0);
X  	    n += (tmp2 == AT_MAGC);
X+ 	    n += (tmp2 == AT_WEAP && strongmonst(ptr));
X  	}
X  
X  /*	For each "special" damage type */
X***************
X*** 753,763 ****
X  	for(i = 0; i < NATTK; i++) {
X  
X  	    tmp2 = ptr->mattk[i].adtyp;
X! 	    if((tmp2 == AD_DRLI) || (tmp2 == AD_STON)) n += 2;
X  	    else n += (tmp2 != AD_PHYS);
X  	    n += ((ptr->mattk[i].damd * ptr->mattk[i].damn) > 23);
X  	}
X  
X  /*	Finally, adjust the monster level  0 <= n <= 24 (approx.) */
X  	if(n == 0) tmp--;
X  	else if(n >= 6) tmp += ( n / 2 );
X--- 746,764 ----
X  	for(i = 0; i < NATTK; i++) {
X  
X  	    tmp2 = ptr->mattk[i].adtyp;
X! 	    if((tmp2 == AD_DRLI) || (tmp2 == AD_STON)
X! #ifdef POLYSELF
X! 					|| (tmp2 == AD_WERE)
X! #endif
X! 								) n += 2;
X  	    else n += (tmp2 != AD_PHYS);
X  	    n += ((ptr->mattk[i].damd * ptr->mattk[i].damn) > 23);
X  	}
X  
X+ /*	Leprechauns are special cases.  They have many hit dice so they
X+ 	can hit and are hard to kill, but they don't really do much damage. */
X+ 	if (ptr == &mons[PM_LEPRECHAUN]) n -= 2;
X+ 
X  /*	Finally, adjust the monster level  0 <= n <= 24 (approx.) */
X  	if(n == 0) tmp--;
X  	else if(n >= 6) tmp += ( n / 2 );
X***************
X*** 1080,1086 ****
X  	if (levl[mtmp->mx][mtmp->my].gmask)
X  		sym = GOLD_SYM;
X  	else if (OBJ_AT(mtmp->mx, mtmp->my))
X! 		sym = o_at(mtmp->mx,mtmp->my)->olet;
X  	else if (IS_DOOR(levl[mtmp->mx][mtmp->my].typ) ||
X  		 IS_WALL(levl[mtmp->mx][mtmp->my].typ))
X  		sym = DOOR_SYM;
X--- 1081,1087 ----
X  	if (levl[mtmp->mx][mtmp->my].gmask)
X  		sym = GOLD_SYM;
X  	else if (OBJ_AT(mtmp->mx, mtmp->my))
X! 		sym = level.objects[mtmp->mx][mtmp->my]->olet;
X  	else if (IS_DOOR(levl[mtmp->mx][mtmp->my].typ) ||
X  		 IS_WALL(levl[mtmp->mx][mtmp->my].typ))
X  		sym = DOOR_SYM;
X*** src/Old/mhitm.c	Wed Sep 27 11:50:37 1989
X--- src/mhitm.c	Fri Sep 15 11:43:01 1989
X***************
X*** 263,270 ****
X  	magr->my = mdef->my;
X  	if(cansee(magr->mx, magr->my))	pmon(magr);
X  	if((tmp = mdamagem(magr, mdef, mattk)) == 2) {
X! 		levl[mx][my].mmask = 0;
X! 		levl[magr->mx][magr->my].mmask = 1;
X  		/* if mdamagem left a corpse it erased magr's symbol */
X  		unpmon(magr);
X  		pmon(magr);
X--- 263,270 ----
X  	magr->my = mdef->my;
X  	if(cansee(magr->mx, magr->my))	pmon(magr);
X  	if((tmp = mdamagem(magr, mdef, mattk)) == 2) {
X! 		remove_monster(mx, my);
X! 		place_monster(magr, magr->mx, magr->my);
X  		/* if mdamagem left a corpse it erased magr's symbol */
X  		unpmon(magr);
X  		pmon(magr);
X*** src/Old/mhitu.c	Wed Sep 27 11:51:06 1989
X--- src/mhitu.c	Mon Sep 25 21:29:39 1989
X***************
X*** 217,225 ****
X  		    coord cc; /* maybe we need a unexto() function? */
X  
X  		    unpmon(mtmp);
X! 		    levl[mtmp->mx][mtmp->my].mmask = 0;
X! 		    mtmp->mx = u.ux; mtmp->my = u.uy;
X! 		    levl[mtmp->mx][mtmp->my].mmask = 1;
X  		    pmon(mtmp);
X  		    enexto(&cc, u.ux, u.uy, &playermon);
X  		    teleds(cc.x, cc.y);
X--- 217,224 ----
X  		    coord cc; /* maybe we need a unexto() function? */
X  
X  		    unpmon(mtmp);
X! 		    remove_monster(mtmp->mx, mtmp->my);
X! 		    place_monster(mtmp, u.ux, u.uy);
X  		    pmon(mtmp);
X  		    enexto(&cc, u.ux, u.uy, &playermon);
X  		    teleds(cc.x, cc.y);
X***************
X*** 243,250 ****
X  		     pline("Wait, %s!  There's a %s named %s hiding under %s!",
X  			mtmp->mnamelth ? NAME(mtmp) : mtmp->data->mname,
X  			uasmon->mname, plname,
X! 			OBJ_AT(u.ux, u.uy) ? doname(o_at(u.ux,u.uy)) :
X! 			"some gold");
X  		    prme();
X  		}
X  		return(0);
X--- 242,250 ----
X  		     pline("Wait, %s!  There's a %s named %s hiding under %s!",
X  			mtmp->mnamelth ? NAME(mtmp) : mtmp->data->mname,
X  			uasmon->mname, plname,
X! 			OBJ_AT(u.ux,u.uy)
X! 			   ? doname(level.objects[u.ux][u.uy]) :
X! 			   "some gold");
X  		    prme();
X  		}
X  		return(0);
X***************
X*** 465,471 ****
X  		register struct obj *obj;
X  
X  		if(OBJ_AT(mtmp->mx, mtmp->my)) {
X! 		    if(obj = o_at(mtmp->mx,mtmp->my))
X  			pline("%s was hidden under %s!",
X  				  Xmonnam(mtmp), doname(obj));
X  		} else if (levl[mtmp->mx][mtmp->my].gmask == 1)
X--- 465,471 ----
X  		register struct obj *obj;
X  
X  		if(OBJ_AT(mtmp->mx, mtmp->my)) {
X! 		    if(obj = level.objects[mtmp->mx][mtmp->my])
X  			pline("%s was hidden under %s!",
X  				  Xmonnam(mtmp), doname(obj));
X  		} else if (levl[mtmp->mx][mtmp->my].gmask == 1)
X***************
X*** 719,724 ****
X--- 719,725 ----
X  		hitmsg(mtmp, mattk);
X  #ifdef POLYSELF
X  		if (ctmp && !rn2(4) && u.ulycn == -1
X+ 		    && !Protection_from_shape_changers
X  # ifdef NAMED_ITEMS
X  		    && !defends(AD_WERE,uwep)
X  # endif
X***************
X*** 1020,1029 ****
X  #endif
X  
X  	if(!u.uswallow) {	/* swallow him */
X! 		levl[mtmp->mx][mtmp->my].mmask = 0;
X! 		mtmp->mx = u.ux;
X! 		mtmp->my = u.uy;
X! 		levl[mtmp->mx][mtmp->my].mmask = 1;
X  		u.ustuck = mtmp;
X  		pmon(mtmp);
X  		kludge("%s engulfs you!", Monnam(mtmp));
X--- 1021,1028 ----
X  #endif
X  
X  	if(!u.uswallow) {	/* swallow him */
X! 		remove_monster(mtmp->mx, mtmp->my);
X! 		place_monster(mtmp, u.ux, u.uy);
X  		u.ustuck = mtmp;
X  		pmon(mtmp);
X  		kludge("%s engulfs you!", Monnam(mtmp));
X***************
X*** 1461,1466 ****
X--- 1460,1466 ----
X  	mayberem(uarmf, "boots");
X  	mayberem(uarmg, "gloves");
X  	mayberem(uarms, "shield");
X+ 	mayberem(uarmh, "helmet");
X  #ifdef SHIRT
X  	if(!uarmc && !uarm)
X  		mayberem(uarmu, "shirt");
X***************
X*** 1571,1580 ****
X  			if (!cost) cost=1;
X  		}
X  		if (cost > u.ugold) cost = u.ugold;
X! 		if (!cost) pline("%s says: \"It's on the house!\"", Monnam(mon));
X  		else {
X! 		    pline("%s takes %ld Zorkmid%s for services rendered!",
X! 			    Monnam(mon), cost, (cost==1) ? "" : "s");
X  		    u.ugold -= cost;
X  		    mon->mgold += cost;
X  		    flags.botl = 1;
X--- 1571,1580 ----
X  			if (!cost) cost=1;
X  		}
X  		if (cost > u.ugold) cost = u.ugold;
X! 		if (!cost) verbalize("It's on the house!");
X  		else {
X! 		    pline("%s takes %ld zorkmid%s for services rendered!",
X! 			    Monnam(mon), cost, plur(cost));
X  		    u.ugold -= cost;
X  		    mon->mgold += cost;
X  		    flags.botl = 1;
X***************
X*** 1599,1605 ****
X  		if (yn() == 'n') return;
X  	} else pline("\"Take off your %s; %s.\"", str,
X  			(obj == uarm)  ? "let's get a little closer" :
X! 			(obj == uarmc) ? "it's in the way" :
X  			(obj == uarmf) ? "let me rub your feet" :
X  			(obj == uarmg) ? "they're too clumsy" :
X  #ifdef SHIRT
X--- 1599,1605 ----
X  		if (yn() == 'n') return;
X  	} else pline("\"Take off your %s; %s.\"", str,
X  			(obj == uarm)  ? "let's get a little closer" :
X! 			(obj == uarmc || obj == uarms) ? "it's in the way" :
X  			(obj == uarmf) ? "let me rub your feet" :
X  			(obj == uarmg) ? "they're too clumsy" :
X  #ifdef SHIRT
X*** src/Old/mklev.c	Wed Sep 27 11:52:05 1989
X--- src/mklev.c	Thu Sep 14 14:27:57 1989
X***************
X*** 739,746 ****
X  	doorindex = 0;
X  	rooms[0].hx = -1;	/* in case we are in a maze */
X  
X! 	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++)
X  		levl[x][y] = zerorm;
X  
X  	oinit();	/* assign level dependent obj probabilities */
X  	fountsound = 0;
X--- 739,749 ----
X  	doorindex = 0;
X  	rooms[0].hx = -1;	/* in case we are in a maze */
X  
X! 	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++) {
X  		levl[x][y] = zerorm;
X+ 		level.objects[x][y] = (struct obj *)0;
X+ 		level.monsters[x][y] = (struct monst *)0;
X+ 	}
X  
X  	oinit();	/* assign level dependent obj probabilities */
X  	fountsound = 0;
X***************
X*** 1109,1115 ****
X  			    else	my = croom->ly-1;
X  			    mx = somex(croom);
X  			}
X! 		} while(levl[mx][my].mmask);
X  
X  		if((mtmp = makemon(mkclass(S_MIMIC), mx, my))) {
X  		    mtmp->mimic = 1;
X--- 1112,1119 ----
X  			    else	my = croom->ly-1;
X  			    mx = somex(croom);
X  			}
X! 		} while
X! 			(MON_AT(mx, my));
X  
X  		if((mtmp = makemon(mkclass(S_MIMIC), mx, my))) {
X  		    mtmp->mimic = 1;
X*** src/Old/mkmaze.c	Wed Sep 27 11:52:45 1989
X--- src/mkmaze.c	Mon Sep 25 21:29:42 1989
X***************
X*** 473,480 ****
X  }
X  
X  void
X! mazexy(cc)	/* find random point in generated corridors
X! 		   i.e., don't create items in moats, bunkers, or walls */
X  	coord	*cc;
X  {
X  	int cpt=0;
X--- 473,480 ----
X  }
X  
X  void
X! mazexy(cc)	/* find random point in generated corridors,
X! 		   so we don't create items in moats, bunkers, or walls */
X  	coord	*cc;
X  {
X  	int cpt=0;
X*** src/Old/mkobj.c	Wed Sep 27 11:53:09 1989
X--- src/mkobj.c	Tue Sep 26 12:59:37 1989
X***************
X*** 76,83 ****
X  	register struct obj *otmp;
X  
X  	mksx = x; mksy = y;
X! 	/* We might need to know the X, Y coordinates while creating the
X! 	 * object, i.e. to insure shop boxes are empty.
X  	 * Yes, this is a horrible kludge...
X  	 */
X  	otmp = mkobj(let,TRUE);
X--- 76,83 ----
X  	register struct obj *otmp;
X  
X  	mksx = x; mksy = y;
X! 	/* We need to know the X, Y coordinates while creating the object,
X! 	 * to insure shop boxes are empty.
X  	 * Yes, this is a horrible kludge...
X  	 */
X  	otmp = mkobj(let,TRUE);
X***************
X*** 215,227 ****
X  
X  	otmp = newobj(0);
X  	*otmp = zeroobj;
X! 	otmp->age = moves;
X  	otmp->o_id = flags.ident++;
X  	otmp->quan = 1;
X  	otmp->olet = let;
X  	otmp->otyp = otyp;
X  	otmp->dknown = index(dknowns, let) ? 0 : 1;
X! 	if (!uses_known(otmp))
X  		otmp->known = 1;
X  	switch(let) {
X  	case WEAPON_SYM:
X--- 215,227 ----
X  
X  	otmp = newobj(0);
X  	*otmp = zeroobj;
X! 	otmp->age = monstermoves;
X  	otmp->o_id = flags.ident++;
X  	otmp->quan = 1;
X  	otmp->olet = let;
X  	otmp->otyp = otyp;
X  	otmp->dknown = index(dknowns, let) ? 0 : 1;
X! 	if (!objects[otmp->otyp].oc_uses_known)
X  		otmp->known = 1;
X  	switch(let) {
X  	case WEAPON_SYM:
X***************
X*** 239,244 ****
X--- 239,245 ----
X  #endif
X  		break;
X  	case FOOD_SYM:
X+ 		OEATEN(otmp) = 0L;
X  		if(otmp->otyp == CORPSE) {
X  		    /* overridden by mkcorpstat() */
X  		    do otmp->corpsenm = rndmonnum();
X***************
X*** 302,312 ****
X  					break;
X  		case BAG_OF_TRICKS:	otmp->spe = rnd(20);
X  					break;
X! 		case FIGURINE:	{	int tryct = 0;
X  					do
X  					    otmp->corpsenm = rndmonnum();
X  					while(is_human(&mons[otmp->corpsenm])
X! 						&& tryct++ < 30);
X  					blessorcurse(otmp, 4);
X  					break;
X  				}
X--- 303,313 ----
X  					break;
X  		case BAG_OF_TRICKS:	otmp->spe = rnd(20);
X  					break;
X! 		case FIGURINE:	{	int tryct2 = 0;
X  					do
X  					    otmp->corpsenm = rndmonnum();
X  					while(is_human(&mons[otmp->corpsenm])
X! 						&& tryct2++ < 30);
X  					blessorcurse(otmp, 4);
X  					break;
X  				}
X***************
X*** 356,363 ****
X  			otmp->blessed = rn2(2);
X  		} else	blessorcurse(otmp, 10);
X  		if(otmp->otyp == DRAGON_SCALE_MAIL)
X! 			otmp->corpsenm = PM_GREY_DRAGON +
X! 			    rn2(PM_YELLOW_DRAGON-PM_GREY_DRAGON+1);
X  		break;
X  	case WAND_SYM:
X  #ifdef HARD
X--- 357,364 ----
X  			otmp->blessed = rn2(2);
X  		} else	blessorcurse(otmp, 10);
X  		if(otmp->otyp == DRAGON_SCALE_MAIL)
X! 			otmp->corpsenm = PM_GRAY_DRAGON +
X! 			    rn2(PM_YELLOW_DRAGON-PM_GRAY_DRAGON+1);
X  		break;
X  	case WAND_SYM:
X  #ifdef HARD
X***************
X*** 543,551 ****
X  
X  	otmp = mkcorpstat(objtype,ptr,x,y);
X  	if (lth > 0) {
X! 		/* Note: oname() is safe since otmp is first in chain */
X  		otmp = oname(otmp, nm, FALSE);
X  		fobj = otmp;
X  	}
X  	return(otmp);
X  }
X--- 544,553 ----
X  
X  	otmp = mkcorpstat(objtype,ptr,x,y);
X  	if (lth > 0) {
X! 		/* Note: oname() is safe since otmp is first in both chains */
X  		otmp = oname(otmp, nm, FALSE);
X  		fobj = otmp;
X+ 		level.objects[x][y] = otmp;
X  	}
X  	return(otmp);
X  }
X***************
X*** 575,626 ****
X  }
X  #endif
X  
X  /*
X!  * These functions encapsulate operations on the omask bit.  Someday soon they
X!  * will turn into list-manipulation functions.
X   */
X- boolean
X- OBJ_AT(x, y)
X- int x, y;
X- {
X- 	return levl[x][y].omask;
X- }
X  
X  void
X! place_object(obj, x, y)
X! struct obj *obj;
X! register int x, y;
X  {
X! 	obj->ox = x;
X! 	obj->oy = y;
X! 	levl[x][y].omask = 1;
X  }
X  
X! void
X! move_object(obj, x, y)
X! struct obj *obj;
X! register int x, y;
X  {
X! 	register int oldx = obj->ox, oldy = obj->oy;
X  
X- 	obj->ox = x;
X- 	obj->oy = y;
X- 	levl[x][y].omask = 1;
X- 	levl[oldx][oldy].omask = (o_at(oldx, oldy) != (struct obj *)0);
X- }
X- 
X- void
X- remove_object(obj)
X- struct obj *obj;
X- {
X- 	register int oldx = obj->ox, oldy = obj->oy;
X  
X- /*
X-  * This cannot be used since it screws up unpobj().  It's only necessary so
X-  * that o_at() doesn't mistakenly find the object, but this is called only
X-  * in situations with the object already removed from the chain anyway.
X- 	obj->ox = 0;
X- 	obj->oy = 0;
X-  */
X- 	levl[oldx][oldy].omask = (o_at(oldx, oldy) != (struct obj *)0);
X- }
X--- 577,623 ----
X  }
X  #endif
X  
X+ 
X  /*
X!  * These routines maintain the single-linked lists headed in level.objects[][]
X!  * and threaded through the nexthere fields in the object-instance structure.
X   */
X  
X  void
X! place_object(otmp, x, y)
X! /* put an object on top of the pile at the given location */
X! register struct obj *otmp;
X! int x, y;
X  {
X!     otmp->nexthere = level.objects[x][y];
X!     level.objects[x][y] = otmp;
X! 
X!     /* set the new object's location */
X!     otmp->ox = x;
X!     otmp->oy = y;
X! }
X! 
X! void
X! remove_object(otmp)
X! register struct obj *otmp;
X! {
X!     register struct obj *odel;
X! 
X!     if (otmp == level.objects[otmp->ox][otmp->oy])
X! 	level.objects[otmp->ox][otmp->oy] = otmp->nexthere;
X!     else
X! 	for (odel = level.objects[otmp->ox][otmp->oy];
X! 						    odel; odel = odel->nexthere)
X! 	    if (odel->nexthere == otmp)
X! 		odel->nexthere = otmp->nexthere;
X  }
X  
X! void move_object(otmp, x, y)
X! register struct obj *otmp;
X! int x, y;
X  {
X!     remove_object(otmp);
X!     place_object(otmp, x, y);
X! }
X  
X  
X
END_OF_FILE
if test 53375 -ne `wc -c <'patches04b'`; then
    echo shar: \"'patches04b'\" unpacked with wrong size!
fi
# end of 'patches04b'
fi
echo shar: End of archive 2 \(of 11\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
