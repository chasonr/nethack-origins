Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i044:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch4h
Message-ID: <4634@tekred.CNA.TEK.COM>
Date: 29 Sep 89 21:13:14 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2067
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 44
Archive-name: NetHack3/Patch4h
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 11)."
# Contents:  patches04h
# Wrapped by billr@saab on Fri Sep 29 13:25:08 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches04h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches04h'\"
else
echo shar: Extracting \"'patches04h'\" \(56752 characters\)
sed "s/^X//" >'patches04h' <<'END_OF_FILE'
X*** auxil/Old/help	Wed Sep 27 10:17:39 1989
X--- auxil/help	Thu Sep 14 13:20:36 1989
X***************
X*** 139,149 ****
X  		the commands you can use with "#" type "#?".  The extended
X  		commands you can use depends upon what options the game was
X  		compiled with, along with your class and what type of monster
X! 		you most closely resemble at a given moment. If your keyboard
X! 		has a meta key (that is, one which when pressed in combination
X! 		with another key modified it by turning on the 'meta' or 0x80
X! 		bit) these extended commands can be invoked by meta-ing the
X! 		first letter of the command.
X  
X  	If the "number_pad" option is on, some additional letter commands
X  	are available:
X--- 139,149 ----
X  		the commands you can use with "#" type "#?".  The extended
X  		commands you can use depends upon what options the game was
X  		compiled with, along with your class and what type of monster
X! 		you most closely resemble at a given moment.  If your keyboard
X! 		has a meta key (which, when pressed in combination with another
X! 		key, modifies it by setting the 'meta' (8th, or 'high') bit),
X! 		these extended commands can be invoked by meta-ing the first
X! 		letter of the command.
X  
X  	If the "number_pad" option is on, some additional letter commands
X  	are available:
X*** auxil/Old/hh	Wed Sep 27 10:17:53 1989
X--- auxil/hh	Thu Sep 14 13:20:41 1989
X***************
X*** 7,59 ****
X  			G<dir>,   same, except a branching corridor isn't
X  			^<dir>:     considered interesting
X  			m<dir>:   move without picking up objects
X! 		If the numberpad option is set, the number keys move instead.
X  
X! Meta commands:
X! ?	help	print one of several informative texts
X  Q	quit	end the game
X  S	save	save the game (to be continued later)
X  !	sh	escape to some SHELL (if allowed)
X  ^Z	suspend suspend the game (independent of your current suspend char)
X  O	options set options
X! /	whatis	give name (and sometimes more info) of specified monster
X! \	known	print list of what's been discovered
X! v	version	print version number
X! V	history	print game history
X! ^A	again	redo the previous command
X! ^R	redraw	redraw the screen (^R denotes the symbol CTRL/R)
X! ^P	print	repeat last message  (subsequent ^P's repeat earlier messages)
X! #		introduces a long command (# ? for list of long commands)
X  
X  Game commands:
X- ^T	'port	teleport (if you can)
X  ^D	kick	kick (a door, or something else)
X  a	apply	apply or use a tool (pick-axe, key, camera, etc.)
X! A	remove	take off all armor
X  c	close	close a door
X! C	name	name an individual monster (e.g., baptize your dog)
X  d	drop	drop an object.  d7a:  drop seven items of object 'a'
X! D	drop	drop several things
X  e	eat	eat something
X  E	engrave write a message in the dust on the floor  (E-  use fingers)
X! i	invent	list the inventory (all objects you are carrying)
X! I	invent	list selected parts of the inventory
X  		Iu: list unpaid objects
X  		Ix: list unpaid but used up items
X  		I$: count your money
X  o	open	open a door
X! p	pay	pay your bill
X! P	wear	put on a ring
X  q	quaff	drink a potion
X  r	read	read a scroll or spell book
X  R	remove	remove a ring
X  s	search	search for secret doors, hidden traps and monsters
X  t	throw	throw or shoot a weapon
X! T	remove	take off some armor
X  w	wield	wield a weapon	(w-  wield nothing)
X  W	wear	put on some armor
X  z	zap	zap a wand
X! Z	cast	cast a spell
X  <	up	go up the stairs
X  >	down	go down the stairs
X  ^	trap_id identify a previously found trap
X--- 7,59 ----
X  			G<dir>,   same, except a branching corridor isn't
X  			^<dir>:     considered interesting
X  			m<dir>:   move without picking up objects
X! 		If the number_pad option is set, the number keys move instead.
X  
X! General commands:
X! ?	help	display one of several informative texts
X  Q	quit	end the game
X  S	save	save the game (to be continued later)
X  !	sh	escape to some SHELL (if allowed)
X  ^Z	suspend suspend the game (independent of your current suspend char)
X  O	options set options
X! /	whatis	tell what a map symbol represents
X! \	known	display list of what's been discovered
X! v	version	display version number
X! V	history	display game history
X! ^A	again	redo the previous command (^A denotes the keystroke CTRL-A)
X! ^R	redraw	redraw the screen
X! ^P	prevmsg	repeat previous message (subsequent ^P's repeat earlier ones)
X! #		introduces an extended command (#? for a list of them)
X  
X  Game commands:
X  ^D	kick	kick (a door, or something else)
X+ ^T	'port	teleport (if you can)
X  a	apply	apply or use a tool (pick-axe, key, camera, etc.)
X! A	armor	take off all armor
X  c	close	close a door
X! C	call	name an individual monster (ex. baptize your dog)
X  d	drop	drop an object.  d7a:  drop seven items of object 'a'
X! D	Drop	drop selected types of objects
X  e	eat	eat something
X  E	engrave write a message in the dust on the floor  (E-  use fingers)
X! i	invent	list your inventory (all objects you are carrying)
X! I	Invent	list selected parts of your inventory
X  		Iu: list unpaid objects
X  		Ix: list unpaid but used up items
X  		I$: count your money
X  o	open	open a door
X! p	pay	pay your bill (in a shop)
X! P	puton	put on a ring
X  q	quaff	drink a potion
X  r	read	read a scroll or spell book
X  R	remove	remove a ring
X  s	search	search for secret doors, hidden traps and monsters
X  t	throw	throw or shoot a weapon
X! T	takeoff	take off some armor
X  w	wield	wield a weapon	(w-  wield nothing)
X  W	wear	put on some armor
X  z	zap	zap a wand
X! Z	Zap	cast a spell
X  <	up	go up the stairs
X  >	down	go down the stairs
X  ^	trap_id identify a previously found trap
X***************
X*** 62,78 ****
X  +	spells	list the spells you know
X  .	rest	wait a moment
X  ,	pickup	pick up all you can carry
X! @		turn "autopickup" on and off
X  :	look	look at what is here
X  
X! And if the "number_pad" option is on, these additional commands:
X  
X  n		followed by number of times to repeat the next command
X! j	jump	jump to a location
X! k	kick	kick a door
X  l	loot	loot a box on the floor
X! N	name	name an object or type of object
X! u	untrap	untrap a trapped object
X! 
X! If your keyboard has a meta key, 'jump' 'loot', 'name' and 'untrap' are
X! available as M-j, M-l, M-N or M-u respectively.
X--- 62,92 ----
X  +	spells	list the spells you know
X  .	rest	wait a moment
X  ,	pickup	pick up all you can carry
X! @		toggle "pickup" (auto pickup) option on and off
X  :	look	look at what is here
X  
X! Keyboards that have a meta key can also use these extended commands:
X! 
X! M-c	chat	talk to someone
X! M-d	dip	dip an object into something
X! M-f	force	force a lock
X! M-j	jump	jump to another location
X! M-l	loot	loot a box on the floor
X! M-m	monster	use a monster's special ability (only if defined)
X! M-N	name	name an item or type of object
X! M-o	offer	offer a sacrifice to the gods (only if defined)
X! M-p	pray	pray to the gods for help (only if defined)
X! M-r	rub	rub a lamp
X! M-s	sit	sit down
X! M-t	turn	turn undead
X! M-u	untrap	untrap something (usually a trapped object)
X! M-w	wipe	wipe off your face
X  
X+ If the "number_pad" option is on, these additional commands are available:
X+ 
X  n		followed by number of times to repeat the next command
X! j	jump	jump to another location
X! k	kick	kick something (usually a door)
X  l	loot	loot a box on the floor
X! N	name	name an item or type of object
X! u	untrap	untrap something (usually a trapped object)
X*** auxil/Old/history	Wed Sep 27 10:18:08 1989
X--- auxil/history	Sat Sep 16 17:54:33 1989
X***************
X*** 29,34 ****
X--- 29,35 ----
X  
X  Timo Hakulinen ported NetHack 3.0 to OS/2.
X  
X+ David Gentzel ported NetHack 3.0 to VMS.
X   
X  From time to time, some depraved individual out there in netland sends a
X  particularly intriguing modification to help out with the game.  The Gods of
X*** auxil/Old/nethack.6	Wed Sep 27 10:18:41 1989
X--- auxil/nethack.6	Sun Sep 17 12:29:03 1989
X***************
X*** 99,106 ****
X  .B \-D
X  or
X  .B \-X
X! option will start the game in a special non-scoring discovery mode
X! (or in debugging (wizard) mode if the player is the game administrator).
X  .PP
X  The
X  .B \-d
X--- 99,108 ----
X  .B \-D
X  or
X  .B \-X
X! option will start the game in a special non-scoring discovery mode.
X! .B \-D
X! will, if the player is the game administrator, start in debugging (wizard)
X! mode instead.
X  .PP
X  The
X  .B \-d
X*** auxil/Old/opthelp	Wed Sep 27 10:19:01 1989
X--- auxil/opthelp	Thu Sep 14 14:46:43 1989
X***************
X*** 34,43 ****
X  null		allow nulls to be sent to your terminal  [TRUE]
X  standout	use standout mode for --More-- on messages  [FALSE]
X  
X! Any Boolean option can be negated by prefixing it with a '!' or 'no'.
X! 
X  
X! 
X  
X  
X  
X--- 34,43 ----
X  null		allow nulls to be sent to your terminal  [TRUE]
X  standout	use standout mode for --More-- on messages  [FALSE]
X  
X! Boolean option if TEXTCOLOR was set at compile time:
X! color		use different colors for objects on screen  [TRUE]
X  
X! Any Boolean option can be negated by prefixing it with a '!' or 'no'.
X  
X  
X  
X*** include/Old/amiconf.h	Wed Sep 27 13:08:56 1989
X--- include/amiconf.h	Thu Sep 14 23:31:24 1989
X***************
X*** 1,4 ****
X! /*      SCCS Id: @(#)amiconf.h  3.0     89/04/28
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #ifndef AMICONF_H
X--- 1,4 ----
X! /*	SCCS Id: @(#)amiconf.h  3.0     89/09/04
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #ifndef AMICONF_H
X***************
X*** 22,27 ****
X--- 22,30 ----
X  
X  #undef  index
X  #undef  rindex
X+ extern char  *index P((const char *,int));
X+ extern char  *rindex P((const char *,int));
X+ #define memcpy(dest, source, size)  movmem(source, dest, size)
X  
X  /*
X   *  Configurable Amiga options:
X*** include/Old/artifact.h	Wed Sep 27 13:09:09 1989
X--- include/artifact.h	Mon Sep 25 20:58:06 1989
X***************
X*** 6,32 ****
X  #ifndef ARTIFACT_H
X  #define ARTIFACT_H
X  
X! #define SPFX_NONE   0x00	/* no special effects, just a bonus */
X! #define SPFX_NOGEN  0x01	/* item is special, bequeathed by gods */
X! #define SPFX_RESTR  0x02	/* item is restricted - can't be named */
X! #define	SPFX_INTEL  0x04	/* item is self-willed - intelligent */
X! #define SPFX_SPEEK  0x08	/* item can speak */
X! #define SPFX_SEEK   0x10	/* item helps you search for things */
X! #define SPFX_WARN   0x20	/* item warns you of danger */
X! #define SPFX_ATTK   0x40	/* item has a special attack (attk) */
X! #define SPFX_DEFN   0x80	/* item has a special defence (defn) */
X! #define SPFX_DMONS  0x100	/* attack bonus on one type of monster */
X! #define	SPFX_DCLAS  0x200	/* attack bonus on one class of monster */
X! #define SPFX_DRLI   0x400	/* drains a level from monsters */
X! #define SPFX_SEARCH 0x800	/* helps searching */
X  
X  struct artifact {
X  	unsigned    otyp;
X  	char	    *name;
X  	unsigned    spfx;
X! 	unsigned    mtype;
X  	struct attack attk, defn;
X! 	unsigned    align;
X  };
X  
X  #endif /* ARTIFACT_H /* */
X--- 6,37 ----
X  #ifndef ARTIFACT_H
X  #define ARTIFACT_H
X  
X! #define SPFX_NONE   0x0000	/* no special effects, just a bonus */
X! #define SPFX_NOGEN  0x0001	/* item is special, bequeathed by gods */
X! #define SPFX_RESTR  0x0002	/* item is restricted - can't be named */
X! #define	SPFX_INTEL  0x0004	/* item is self-willed - intelligent */
X! #define SPFX_SPEEK  0x0008	/* item can speak */
X! #define SPFX_SEEK   0x0010	/* item helps you search for things */
X! #define SPFX_WARN   0x0020	/* item warns you of danger */
X! #define SPFX_ATTK   0x0040	/* item has a special attack (attk) */
X! #define SPFX_DEFN   0x0080	/* item has a special defence (defn) */
X! #define SPFX_DRLI   0x0100	/* drains a level from monsters */
X! #define SPFX_SEARCH 0x0200	/* helps searching */
X! #define SPFX_DMONS  0x1000	/* attack bonus on one monster type */
X! #define	SPFX_DCLAS  0x2000	/* attack bonus on monsters w/ symbol mtype */
X! #define	SPFX_DFLAG1 0x4000	/* attack bonus on monsters w/ mflags1 flag */
X! #define	SPFX_DFLAG2 0x8000	/* attack bonus on monsters w/ mflags2 flag */
X  
X+ #define SPFX_DBONUS 0xF000	/* attack bonus mask */
X+ 
X  struct artifact {
X  	unsigned    otyp;
X  	char	    *name;
X  	unsigned    spfx;
X! 	unsigned long mtype;	/* monster type, symbol, or flag */
X  	struct attack attk, defn;
X! 	uchar	    align;	/* alignment of bequeathing gods */
X! 	char	    class;	/* character class associated with */
X  };
X  
X  #endif /* ARTIFACT_H /* */
X*** include/Old/config.h	Wed Sep 27 13:09:29 1989
X--- include/config.h	Mon Sep 25 20:55:44 1989
X***************
X*** 9,15 ****
X  /*
X   * Section 1:	OS selection.
X   *		Select the version of the OS you are using.
X!  *		For "UNIX" select either SYSV or BSD in unixconf.h
X   */
X  
X  #define	UNIX		/* delete if no fork(), exec() available */
X--- 9,17 ----
X  /*
X   * Section 1:	OS selection.
X   *		Select the version of the OS you are using.
X!  *		For "UNIX" select either SYSV or BSD in unixconf.h.
X!  *		A "VMS" option is not needed since the VMS C-compiler
X!  *		provides it (comment out the default OS option here).
X   */
X  
X  #define	UNIX		/* delete if no fork(), exec() available */
X*** include/Old/decl.h	Wed Sep 27 13:09:52 1989
X--- include/decl.h	Tue Sep 26 12:59:11 1989
X***************
X*** 13,24 ****
X  E int nroom;
X  E int multi;
X  E int hackpid;
X! #ifdef UNIX
X  E int locknum;
X  #ifdef DEF_PAGER
X  E char *catmore;
X  #endif	/* DEF_PAGER */
X- #endif	/* UNIX */
X  E char SAVEF[];
X  E char *hname;
X  E const char *hu_stat[];	/* defined in eat.c */
X--- 13,24 ----
X  E int nroom;
X  E int multi;
X  E int hackpid;
X! #if defined(UNIX) || defined(VMS)
X  E int locknum;
X+ #endif
X  #ifdef DEF_PAGER
X  E char *catmore;
X  #endif	/* DEF_PAGER */
X  E char SAVEF[];
X  E char *hname;
X  E const char *hu_stat[];	/* defined in eat.c */
X***************
X*** 97,103 ****
X  E coord dig_pos;
X  E boolean dig_down;
X  
X! E long moves;
X  E long wailmsg;
X  
X  E boolean in_mklev;
X--- 97,103 ----
X  E coord dig_pos;
X  E boolean dig_down;
X  
X! E long moves, monstermoves;
X  E long wailmsg;
X  
X  E boolean in_mklev;
X***************
X*** 121,134 ****
X  #endif
X  
X  #ifdef TEXTCOLOR
X  #define RED		1
X  #define GREEN		2
X! #define YELLOW		3
X  #define BLUE		4
X  #define MAGENTA 	5
X  #define CYAN		6
X  #define WHITE		7
X! E char *HI_COLOR[8];	/* termcap.c */
X  #endif
X  
X  #ifndef OBJ_H
X--- 121,158 ----
X  #endif
X  
X  #ifdef TEXTCOLOR
X+ 
X+ #define BLACK		0
X  #define RED		1
X  #define GREEN		2
X! #define BROWN		3	/* on IBM, lo-intensity yellow is brown */
X  #define BLUE		4
X  #define MAGENTA 	5
X  #define CYAN		6
X  #define WHITE		7
X! #define GRAY		7	/* lo-intensity white */
X! #define BRIGHT		8
X! #define ORANGE_COLORED	9
X! #define YELLOW		11
X! #define MAXCOLORS	16	/* 8 basic + 8 bright */
X! 
X! /* these can be configured */
X! #  define HI_MON	RED + BRIGHT		/* red slaps! */
X! #  define HI_OBJ	MAGENTA
X! #  define HI_METAL	CYAN
X! #  define HI_COPPER	YELLOW
X! #  define HI_SILVER	GRAY
X! #  define HI_GOLD	YELLOW
X! #  define HI_LEATHER	BROWN
X! #  define HI_CLOTH	BROWN
X! #  define HI_ORGANIC	GREEN
X! #  define HI_WOOD	BROWN
X! #  define HI_PAPER	BROWN
X! #  define HI_GLASS	CYAN + BRIGHT
X! #  define HI_MINERAL	GRAY
X! #  define HI_ZAP	BLUE + BRIGHT		/* blue zaps! */
X! 
X! E char *hilites[MAXCOLORS];
X  #endif
X  
X  #ifndef OBJ_H
X*** include/Old/extern.h	Wed Sep 27 13:10:43 1989
X--- include/extern.h	Tue Sep 26 19:11:23 1989
X***************
X*** 5,11 ****
X  #ifndef EXTERN_H
X  #define EXTERN_H
X  
X! #if defined(MSDOS) && !defined(__TURBOC__)
X  /* MSC include files do not contain "extern" keyword */
X  #define E
X  #else
X--- 5,11 ----
X  #ifndef EXTERN_H
X  #define EXTERN_H
X  
X! #if defined(MSDOS) && defined(MSC)
X  /* MSC include files do not contain "extern" keyword */
X  #define E
X  #else
X***************
X*** 12,17 ****
X--- 12,25 ----
X  #define E extern
X  #endif
X  
X+ /* ### allmain.c ### */
X+ 
X+ E int (*occupation)();
X+ E int (*afternmv)();
X+ E void moveloop();
X+ E void stop_occupation();
X+ E void newgame();
X+ 
X  /* ### alloc.c ### */
X  
X  #ifndef __TURBOC__
X***************
X*** 341,348 ****
X  E void delobj P((struct obj *));
X  E void freeobj P((struct obj *));
X  E void freegold P((struct gold *));
X- E struct monst *m_at P((int,int));
X- E struct obj *o_at P((int,int));
X  E struct obj *sobj_at P((int,int,int));
X  E int carried P((struct obj *));
X  E struct obj *carrying P((int));
X--- 349,354 ----
X***************
X*** 404,410 ****
X  E void enexto P((coord *,XCHAR_P,XCHAR_P,struct permonst *));
X  E int goodpos P((int,int, struct permonst *));
X  E void rloc P((struct monst *));
X- E struct monst *mkmon_at P((char *,int,int));
X  E void init_monstr();
X  E struct permonst *rndmonst();
X  E struct permonst *mkclass P((CHAR_P));
X--- 410,415 ----
X***************
X*** 490,496 ****
X  E boolean is_rustprone P((struct obj *));
X  E boolean is_corrodeable P((struct obj *));
X  #endif
X- E boolean OBJ_AT P((int,int));
X  E void place_object P((struct obj *,int,int));
X  E void move_object P((struct obj *,int,int));
X  E void remove_object P((struct obj *));
X--- 495,500 ----
X***************
X*** 528,534 ****
X  E void unstuck P((struct monst *));
X  E void killed P((struct monst *));
X  E void xkilled P((struct monst *,int));
X- E void kludge V((char *,char *,...));
X  E void rescham();
X  E void restartcham();
X  E int newcham P((struct monst *,struct permonst *));
X--- 532,537 ----
X***************
X*** 578,583 ****
X--- 581,592 ----
X  E int m_move P((struct monst *,int));
X  E void set_apparxy P((struct monst *));
X  E boolean mdig_tunnel P((struct monst *));
X+ #ifdef STUPID_CPP
X+ E void place_monster P((struct monst *, int, int));
X+ E void place_worm_seg P((struct monst *, int, int));
X+ E void remove_monster P((int, int));
X+ E struct monst *m_at P((int, int));
X+ #endif
X  
X  /* ### monst.c ### */
X  
X***************
X*** 617,627 ****
X  #ifdef TOS
X  E int _copyfile P((char *, char *));
X  E int kbhit();
X  #endif /* TOS */
X  
X  /* ### mthrowu.c ### */
X  
X! E int thitu P((int,int,char *));
X  E int thrwmu P((struct monst *));
X  E int spitmu P((struct monst *));
X  E int breamu P((struct monst *,struct attack *));
X--- 626,638 ----
X  #ifdef TOS
X  E int _copyfile P((char *, char *));
X  E int kbhit();
X+ E void restore_colors();
X+ E void set_colors();
X  #endif /* TOS */
X  
X  /* ### mthrowu.c ### */
X  
X! E int thitu P((int,int,struct obj *,char *));
X  E int thrwmu P((struct monst *));
X  E int spitmu P((struct monst *));
X  E int breamu P((struct monst *,struct attack *));
X***************
X*** 657,663 ****
X  E void lcase P((char *));
X  E char *makeplural P((char *));
X  E struct obj *readobjnam P((char *));
X- E boolean uses_known P((struct obj *));
X  
X  /* ### options.c ### */
X  
X--- 668,673 ----
X***************
X*** 689,708 ****
X  #ifdef SHELL
X  E int dosh();
X  #endif /* SHELL */
X  E int child P((int));
X  #endif /* UNIX */
X  
X  /* ### pcmain.c ### */
X  
X  #ifdef MSDOS
X- E int (*occupation)();
X- E int (*afternmv)();
X  E void askname();
X- E void impossible V((char *,...));
X  #ifdef CHDIR
X  E void chdirx P((char *,BOOLEAN_P));
X  #endif /* CHDIR */
X- E void stop_occupation();
X  #endif /* MSDOS */
X  
X  /* ### pctty.c ### */
X--- 699,716 ----
X  #ifdef SHELL
X  E int dosh();
X  #endif /* SHELL */
X+ #if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
X  E int child P((int));
X+ #endif
X  #endif /* UNIX */
X  
X  /* ### pcmain.c ### */
X  
X  #ifdef MSDOS
X  E void askname();
X  #ifdef CHDIR
X  E void chdirx P((char *,BOOLEAN_P));
X  #endif /* CHDIR */
X  #endif /* MSDOS */
X  
X  /* ### pctty.c ### */
X***************
X*** 957,963 ****
X  E void pay_for_door P((int,int,char *));
X  E void addtobill P((struct obj *,BOOLEAN_P));
X  E void splitbill P((struct obj *,struct obj *));
X! E void subfrombill P((struct obj *));
X  E int doinvbill P((int));
X  E int shkcatch P((struct obj *));
X  E int shk_move P((struct monst *));
X--- 965,971 ----
X  E void pay_for_door P((int,int,char *));
X  E void addtobill P((struct obj *,BOOLEAN_P));
X  E void splitbill P((struct obj *,struct obj *));
X! E void sellobj P((struct obj *));
X  E int doinvbill P((int));
X  E int shkcatch P((struct obj *));
X  E int shk_move P((struct monst *));
X***************
X*** 1060,1072 ****
X--- 1068,1087 ----
X  E void more();
X  E void cmore P((char *));
X  E void clrlin();
X+ #ifdef NEED_VARARGS
X+ #if defined(USE_STDARG) || defined(USE_VARARGS)
X+ E void vpline P((const char *, va_list));
X+ #endif
X+ #endif
X  E void pline V((const char *,...));
X  E void Norep V((const char *,...));
X  E void You V((const char *,...));
X  E void Your V((const char *,...));
X+ E void kludge V((char *,char *,...));
X  E void putsym P((CHAR_P));
X  E void putstr P((char *));
X  E char yn_function P((char *,CHAR_P));
X+ E void impossible V((char *,...));
X  
X  /* ### topten.c ### */
X  
X***************
X*** 1129,1140 ****
X  /* ### unixmain.c ### */
X  
X  #ifdef UNIX
X- E int (*occupation)();
X- E int (*afternmv)();
X  E void glo P((int));
X  E void askname();
X- E void impossible V((char *,...));
X- E void stop_occupation();
X  #endif /* UNIX */
X  
X  /* ### unixtty.c ### */
X--- 1144,1151 ----
X***************
X*** 1175,1180 ****
X--- 1186,1241 ----
X  /* ### version.c ### */
X  
X  E int doversion();
X+ 
X+ /* ### vmsmain.c ### */
X+ 
X+ #ifdef VMS
X+ #ifdef CHDIR
X+ E void chdirx P((char *,char));
X+ #endif /* CHDIR */
X+ E void glo P((int));
X+ E void askname();
X+ #endif /* VMS */
X+ 
X+ /* ### vmsmisc.c ### */
X+ 
X+ #ifdef VMS
X+ E void vms_abort();
X+ E void vms_exit();
X+ #endif /* VMS */
X+ 
X+ /* ### vmstty.c ### */
X+ 
X+ #ifdef VMS
X+ E void gettty();
X+ E void settty P((char *));
X+ E void setftty();
X+ E void intron();
X+ E void introff();
X+ E void error V((char *,...));
X+ #endif /* VMS */
X+ 
X+ /* ### vmsunix.c ### */
X+ 
X+ #ifdef VMS
X+ E void setrandom();
X+ E int getyear();
X+ E char *getdate();
X+ E int phase_of_the_moon();
X+ E int night();
X+ E int midnight();
X+ E void gethdate P((char *));
X+ E int uptodate P((int));
X+ E void getlock();
X+ E void regularize P((char *));
X+ E int vms_creat P((char *,unsigned int));
X+ E int vms_getuid();
X+ E void privoff();
X+ E void privon();
X+ # ifdef SHELL
X+ E int dosh();
X+ # endif
X+ #endif /* VMS */
X  
X  /* ### weapon.c ### */
X  
X*** include/Old/flag.h	Wed Sep 27 13:11:28 1989
X--- include/flag.h	Thu Sep 14 14:46:21 1989
X***************
X*** 51,56 ****
X--- 51,59 ----
X  	boolean  silent;	/* whether the bell rings or not */
X  	boolean  pickup;	/* whether you pickup or move and look */
X  	boolean  num_pad;	/* use numbers for movement commands */
X+ #ifdef TEXTCOLOR
X+ 	boolean  use_color;	/* use color grapics */
X+ #endif
X  #ifdef DGK
X  	boolean  IBMBIOS;	/* whether we can use a BIOS call for
X  				 * redrawing the screen and character input */
X*** include/Old/global.h	Wed Sep 27 13:11:49 1989
X--- include/global.h	Mon Sep 25 20:55:26 1989
X***************
X*** 9,15 ****
X  
X  
X  /* #define BETA		/* if a beta-test copy  [MRS] */
X! #define VERSION	"3.0f"	/* version number. */
X  
X  /*
X   * Files expected to exist in the playground directory.
X--- 9,15 ----
X  
X  
X  /* #define BETA		/* if a beta-test copy  [MRS] */
X! #define VERSION	"3.0g"	/* version number. */
X  
X  /*
X   * Files expected to exist in the playground directory.
X***************
X*** 117,122 ****
X--- 117,127 ----
X  #ifndef COORD_H
X  #include "coord.h"
X  #endif
X+ 
X+ #if defined(VMS) && !defined(VMSCONF_H)
X+ # include "vmsconf.h"
X+ #endif
X+ 
X  #if defined(UNIX) && !defined(UNIXCONF_H)
X  # include "unixconf.h"
X  #endif
X*** include/Old/monst.h	Wed Sep 27 13:13:23 1989
X--- include/monst.h	Thu Sep 14 14:24:49 1989
X***************
X*** 68,74 ****
X  
X  #define newmonst(xl)	(struct monst *) alloc((unsigned)(xl) + sizeof(struct monst))
X  
X- extern struct monst *fmon;
X  extern struct monst *mydogs, *fallen_down;
X  
X  /* these are in mspeed */
X--- 68,73 ----
X*** include/Old/obj.h	Wed Sep 27 13:13:52 1989
X--- include/obj.h	Sat Sep 23 01:27:18 1989
X***************
X*** 7,12 ****
X--- 7,13 ----
X  
X  struct obj {
X  	struct obj *nobj;
X+ 	struct obj *nexthere;		/* for location lists */
X  	struct obj *cobj;		/* id of container object is in */
X  /*	unsigned o_cwt;			/* container weight capacity */
X  	unsigned o_id;
X***************
X*** 45,54 ****
X  	Bitfield(onamelth,6);
X  	long age;		/* creation date */
X  	long owornmask;
X  
X  /* note that TIMEOUT in you.h is defined as 07777L; no bits for items that
X!  * confer properties may overlap that mask, or timeout.c will happily rearrange
X!  * the bits behind the back of the property code
X   * shirts, balls, and chains are currently safe
X   */
X  #define	W_BALL	02000L
X--- 46,56 ----
X  	Bitfield(onamelth,6);
X  	long age;		/* creation date */
X  	long owornmask;
X+ #define oeaten		rustfree
X  
X  /* note that TIMEOUT in you.h is defined as 07777L; no bits for items that
X!  * confer properties may overlap that mask, or timeout.c will happily 
X!  * rearrange the bits behind the back of the property code
X   * shirts, balls, and chains are currently safe
X   */
X  #define	W_BALL	02000L
X***************
X*** 75,88 ****
X  				   is flexible; amount for tmp gold objects */
X  };
X  
X- extern struct obj *fobj;
X- 
X  #define newobj(xl)	(struct obj *) alloc((unsigned)(xl) + sizeof(struct obj))
X  #define	ONAME(otmp)	((char *) otmp->oextra)
X  #define	OGOLD(otmp)	(otmp->oextra[0])
X  
X  # ifndef STUPID_CPP	/* otherwise these macros are functions */
X- /* #define OBJ_AT(x,y)	(levl[x][y].omask) */
X  
X  #define Is_container(otmp)	(otmp->otyp >= ICE_BOX && otmp->otyp <= BAG_OF_TRICKS)
X  #define Is_box(otmp)	(otmp->otyp == LARGE_BOX || otmp->otyp == CHEST)
X--- 77,88 ----
X  				   is flexible; amount for tmp gold objects */
X  };
X  
X  #define newobj(xl)	(struct obj *) alloc((unsigned)(xl) + sizeof(struct obj))
X  #define	ONAME(otmp)	((char *) otmp->oextra)
X  #define	OGOLD(otmp)	(otmp->oextra[0])
X+ #define	OEATEN(otmp)	(otmp->oeaten)
X  
X  # ifndef STUPID_CPP	/* otherwise these macros are functions */
X  
X  #define Is_container(otmp)	(otmp->otyp >= ICE_BOX && otmp->otyp <= BAG_OF_TRICKS)
X  #define Is_box(otmp)	(otmp->otyp == LARGE_BOX || otmp->otyp == CHEST)
X*** include/Old/objclass.h	Wed Sep 27 13:14:06 1989
X--- include/objclass.h	Thu Sep 14 14:53:21 1989
X***************
X*** 13,18 ****
X--- 13,22 ----
X  	char *oc_uname;		/* called by user */
X  	Bitfield(oc_name_known,1);
X  	Bitfield(oc_merge,1);	/* merge otherwise equal objects */
X+ 	Bitfield(oc_uses_known,1); /* obj->known affects full decription */
X+ 				/* otherwise, obj->dknown and obj->bknown */
X+ 				/* tell all, and obj->known should always */
X+ 				/* be set for proper merging behavior */
X  	Bitfield(oc_bool,1);
X  #define oc_bimanual	oc_bool	/* for weapons */
X  #define oc_bulky	oc_bool	/* for armor */
X***************
X*** 35,40 ****
X--- 39,47 ----
X  	int oc_cost;		/* base cost in shops */
X  	schar oc_oc1, oc_oc2;
X  	int oc_oi;
X+ #ifdef TEXTCOLOR
X+ 	uchar oc_color;		/* color of the object */
X+ #endif /* TEXTCOLOR */
X  #define	nutrition	oc_oi	/* for foods */
X  #define w_propellor	oc_oi	/* for weapons */
X  #define WP_BOW		1
X*** include/Old/patchlevel.h	Wed Sep 27 13:14:18 1989
X--- include/patchlevel.h	Wed Sep 27 13:08:27 1989
X***************
X*** 17,27 ****
X--- 17,29 ----
X   *  add better screen-size sensing
X   *  expand color use for PCs and introduce it for SVR3 UNIX machines
X   *  extend '/' to multiple identifications
X+  *  allow meta key to be used to invoke extended commands
X   *  fix various minor bugs, and do further code cleaning
X   */
X  
X  /*
X   *  Patch 3, September 6, 1989
X+  *  add war hammers and revise object prices
X   *  extend prototypes to ANSI compilers in addition to the previous MSDOS ones
X   *  move object-on-floor references into functions in preparation for planned
X   *	data structures to allow faster access and better colors
X***************
X*** 29,32 ****
X   *	patches
X   */
X  
X! #define PATCHLEVEL	3
X--- 31,46 ----
X   *	patches
X   */
X  
X! /*
X!  *  Patch 4, September 27, 1989
X!  *  add support for VMS (courtesy David Gentzel)
X!  *  move monster-on-floor references into functions and implement the new
X!  *	lookup structure for both objects and monsters
X!  *  extend the definitions of objects and monsters to provide "living color"
X!  *	in the dungeon, instead of a single monster color
X!  *  ifdef varargs usage to satisfy ANSI compilers
X!  *  standardize on the color 'gray'
X!  *  assorted bug fixes
X!  */
X! 
X! #define PATCHLEVEL	4
X*** include/Old/pcconf.h	Wed Sep  6 23:46:25 1989
X--- include/pcconf.h	Tue Sep 19 01:14:13 1989
X***************
X*** 93,107
X  #  define TEXTCOLOR /* */
X  #endif
X  
X! #ifdef TEXTCOLOR
X! /* configurable colors */
X! #  define HI_MON	RED	/* red slaps! */
X! #  define HI_OBJ	MAGENTA
X! #  define HI_METAL	CYAN
X! #  define HI_ORGANIC	GREEN
X! #  define HI_GOLD	YELLOW
X! #  define HI_ZAP	BLUE	/* blue zaps! */
X! #endif
X! 
X! #endif
X  #endif /* MSDOS /* */
X
X--- 93,97 -----
X  #  define TEXTCOLOR /* */
X  #endif
X  
X! #endif /* PCCONF_H /* */
X  #endif /* MSDOS /* */
X*** include/Old/permonst.h	Wed Sep 27 13:14:41 1989
X--- include/permonst.h	Thu Sep 14 14:49:22 1989
X***************
X*** 46,51 ****
X--- 46,54 ----
X  	uchar		msound;			/* noise it makes */
X  	long		mflags1,		/* boolean bitflags */
X  			mflags2;		/* more boolean bitflags */
X+ # ifdef TEXTCOLOR
X+ 	uchar		mcolor;			/* color to use */
X+ # endif
X  };
X  
X  extern struct permonst mons[];		/* the master list of monster types */
X*** include/Old/rm.h	Wed Sep 27 13:15:00 1989
X--- include/rm.h	Fri Sep 15 11:45:15 1989
X***************
X*** 206,213 ****
X  	Bitfield(seen,1);
X  	Bitfield(lit,1);
X  	Bitfield(doormask,5);
X- 	Bitfield(mmask,1);
X- 	Bitfield(omask,1);
X  	Bitfield(gmask,1);
X  };
X  
X--- 206,211 ----
X***************
X*** 216,222 ****
X  #define ladder		doormask
X  #define drawbridgemask	doormask
X  
X! extern struct rm levl[COLNO][ROWNO];
X  
X  #if defined(DGK) && !defined(OLD_TOS)
X  #define ACTIVE	1
X--- 214,249 ----
X  #define ladder		doormask
X  #define drawbridgemask	doormask
X  
X! typedef struct
X! {
X!     struct rm		locations[COLNO][ROWNO];
X!     struct obj		*objects[COLNO][ROWNO];
X!     struct monst	*monsters[COLNO][ROWNO];
X!     struct obj		*objlist;
X!     struct monst	*monlist;
X! }
X! level_t;
X! 
X! extern level_t	level;	/* structure describing the current level */
X! 
X! /*
X!  * Macros for compatibility with old code. Someday these will go away.
X!  */
X! #define OBJ_AT(x, y)	(level.objects[x][y] != (struct obj *)0)
X! #define MON_AT(x, y)	(level.monsters[x][y] != (struct monst *)0)
X! #define levl		level.locations
X! #define fobj		level.objlist
X! #define fmon		level.monlist
X! 
X! #ifndef STUPID_CPP	/* otherwise these macros are functions in monmove.c */
X! /*
X!  * Macros for encapsulation of level.monsters references.
X!  */
X! #define place_monster(m, x, y)	level.monsters[m->mx=x][m->my=y] = m
X! #define place_worm_seg(m, x, y) level.monsters[x][y] = m
X! #define remove_monster(x, y)	level.monsters[x][y] = (struct monst *)0
X! #define m_at(x, y)		level.monsters[x][y]
X! #endif	/* STUPID_CPP */
X  
X  #if defined(DGK) && !defined(OLD_TOS)
X  #define ACTIVE	1
X*** include/Old/system.h	Wed Sep 27 13:15:31 1989
X--- include/system.h	Sun Sep 17 14:26:28 1989
X***************
X*** 37,42 ****
X--- 37,46 ----
X  # endif
X  #endif
X  
X+ #ifdef VMS
X+ # define off_t long
X+ #endif
X+ 
X  /* You may want to change this to fit your system, as this is almost
X   * impossible to get right automatically.
X   * This is the type of signal handling functions.
X***************
X*** 170,179 ****
X--- 174,199 ----
X  #endif
X  #endif
X  
X+ #ifdef NEED_VARARGS
X+ #if defined(USE_STDARG) || defined(USE_VARARGS)
X+ E int vsprintf P((char *, const char *, va_list));
X+ E int vprintf P((const char *, va_list));
X+ #else
X+ #   define vprintf		printf
X+ #   define vsprintf		sprintf
X+ #   define vpline		pline
X+ #endif
X+ #endif /* NEED_VARARGS */
X+ 
X  #define Sprintf	(void) sprintf
X  #define Strcat	(void) strcat
X  #define Strcpy	(void) strcpy
X  #define Printf  (void) printf
X+ 
X+ #ifdef NEED_VARARGS
X+ #define Vprintf (void) vprintf
X+ #define Vsprintf (void) vsprintf
X+ #endif
X  
X  E int tgetent P((char *,char *));
X  E int tgetnum P((char *));
X*** include/Old/tosconf.h	Wed Sep 27 13:15:45 1989
X--- include/tosconf.h	Thu Sep 14 14:46:25 1989
X***************
X*** 33,41 ****
X--- 33,43 ----
X  #define Srand() srand()
X  #endif
X  
X+ /* configurable options */
X  #define DGK
X  #define RANDOM
X  #define SHELL
X+ #define TEXTCOLOR
X  
X  #ifndef MSDOS_H
X  #include "msdos.h"
X*** include/Old/tradstdc.h	Wed Sep 27 13:15:56 1989
X--- include/tradstdc.h	Sun Sep 17 14:26:33 1989
X***************
X*** 15,20 ****
X--- 15,76 ----
X   * Makes substitutes for compatibility with the old C standard.
X   */
X  
X+ /* Decide how to handle variable parameter lists:
X+  * USE_STDARG means use the ANSI <stdarg.h> facilities (only ANSI compilers
X+  * should do this, and only if the library supports it).
X+  * USE_VARARGS means use the <varargs.h> facilities. Again, this should only
X+  * be done if the library supports it. ANSI is *not* required for this.
X+  * Otherwise, the kludgy old methods are used.
X+  * The defaults are USE_STDARG for ANSI compilers, and USE_OLDARGS for
X+  * others.
X+  */
X+ 
X+ /* #define USE_VARARGS		/* use <varargs.h> instead of <stdarg.h> */
X+ /* #define USE_OLDARGS		/* don't use any variable argument facilites */
X+ 
X+ #ifdef __STDC__
X+ # if !(defined(AMIGA) || defined(USE_VARARGS) || defined(USE_OLDARGS))
X+ #   define USE_STDARG
X+ # endif
X+ #endif
X+ 
X+ #ifdef NEED_VARARGS		/* only define these if necessary */
X+ #ifdef USE_STDARG
X+ # include <stdarg.h>
X+ # define VA_DECL(typ1,var1)	(typ1 var1, ...) { va_list the_args;
X+ # define VA_DECL2(typ1,var1,typ2,var2)	\
X+ 	(typ1 var1, typ2 var2, ...) { va_list the_args;
X+ # define VA_INIT(var1,typ1)
X+ # define VA_NEXT(var1,typ1)	var1 = va_arg(the_args, typ1)
X+ # define VA_ARGS		the_args
X+ # define VA_START(x)		va_start(the_args, x)
X+ # define VA_END()		va_end(the_args)
X+ #else
X+ # ifdef USE_VARARGS
X+ #  include <varargs.h>
X+ #  define VA_DECL(typ1,var1)	(va_alist) va_dcl {\
X+ 		va_list the_args; typ1 var1;
X+ #  define VA_DECL2(typ1,var1,typ2,var2)	(va_alist) va_dcl {\
X+ 		va_list the_args; typ1 var1; typ2 var2;
X+ #  define VA_ARGS		the_args
X+ #  define VA_START(x)		va_start(the_args)
X+ #  define VA_INIT(var1,typ1) 	va_arg(var1, typ1)
X+ #  define VA_NEXT(var1,typ1)	var1 = va_arg(the_args,typ1)
X+ #  define VA_END()		va_end(the_args)
X+ # else
X+ #   define VA_ARGS	arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9
X+ #   define VA_DECL(typ1,var1)  (var1,VA_ARGS) typ1 var1; \
X+ 	char *arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9; {
X+ #   define VA_DECL2(typ1,var1,typ2,var2)  (var1,var2,VA_ARGS) \
X+ 	typ1 var1; typ2 var2;\
X+ 	char *arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9; {
X+ #   define VA_START(x)
X+ #   define VA_INIT(var1,typ1)
X+ #   define VA_END()
X+ # endif
X+ #endif
X+ #endif /* NEED_VARARGS */
X+ 
X  #if (defined(__STDC__) || defined(MSDOS)) && !defined(AMIGA)
X  
X  /* Used for robust ANSI parameter forward declarations:
X***************
X*** 27,33 ****
X   */
X  
X  # define P(s)		s
X! # ifdef MSDOS
X  #  define V(s)		s
X  # else
X  #  define V(s)		()
X--- 83,89 ----
X   */
X  
X  # define P(s)		s
X! # if defined(MSDOS) || defined(USE_STDARG)
X  #  define V(s)		s
X  # else
X  #  define V(s)		()
X*** include/Old/unixconf.h	Wed Sep  6 23:47:19 1989
X--- include/unixconf.h	Sat Sep 16 23:12:56 1989
X***************
X*** 73,80
X   * A stat system call is done on the mailbox every MAILCKFREQ moves.
X   */
X  
X! #define	MAIL
X! #if defined(BSD) || defined(ULTRIX)
X  #define	DEF_MAILREADER	"/usr/ucb/Mail"
X  #else
X  # ifdef SYSV
X
X--- 73,82 -----
X   * A stat system call is done on the mailbox every MAILCKFREQ moves.
X   */
X  
X! #define	MAIL		/* Deliver mail during the game */
X! #ifdef MAIL
X! 
X! # if defined(BSD) || defined(ULTRIX)
X  #define	DEF_MAILREADER	"/usr/ucb/Mail"
X  # else
X  #  if defined(SYSV) || defined(DGUX)
X***************
X*** 76,84
X  #define	MAIL
X  #if defined(BSD) || defined(ULTRIX)
X  #define	DEF_MAILREADER	"/usr/ucb/Mail"
X- #else
X- # ifdef SYSV
X- #define	DEF_MAILREADER	"/usr/bin/mailx"
X  # else
X  #define	DEF_MAILREADER	"/bin/mail"
X  # endif
X
X--- 78,83 -----
X  
X  # if defined(BSD) || defined(ULTRIX)
X  #define	DEF_MAILREADER	"/usr/ucb/Mail"
X  # else
X  #  if defined(SYSV) || defined(DGUX)
X  #   ifdef M_XENIX
X***************
X*** 80,85
X  # ifdef SYSV
X  #define	DEF_MAILREADER	"/usr/bin/mailx"
X  # else
X  #define	DEF_MAILREADER	"/bin/mail"
X  # endif
X  #endif
X
X--- 79,91 -----
X  # if defined(BSD) || defined(ULTRIX)
X  #define	DEF_MAILREADER	"/usr/ucb/Mail"
X  # else
X+ #  if defined(SYSV) || defined(DGUX)
X+ #   ifdef M_XENIX
X+ #define	DEF_MAILREADER	"/usr/bin/mail"
X+ #   else
X+ #define	DEF_MAILREADER	"/usr/bin/mailx"
X+ #   endif
X+ #  else
X  #define	DEF_MAILREADER	"/bin/mail"
X  #  endif
X  # endif
X***************
X*** 81,86
X  #define	DEF_MAILREADER	"/usr/bin/mailx"
X  # else
X  #define	DEF_MAILREADER	"/bin/mail"
X  # endif
X  #endif
X  #define	MAILCKFREQ	50
X
X--- 87,93 -----
X  #   endif
X  #  else
X  #define	DEF_MAILREADER	"/bin/mail"
X+ #  endif
X  # endif
X  
X  #define	MAILCKFREQ	50
X***************
X*** 82,88
X  # else
X  #define	DEF_MAILREADER	"/bin/mail"
X  # endif
X! #endif
X  #define	MAILCKFREQ	50
X  
X  #ifdef COMPRESS
X
X--- 89,95 -----
X  #define	DEF_MAILREADER	"/bin/mail"
X  #  endif
X  # endif
X! 
X  #define	MAILCKFREQ	50
X  #endif	/* MAIL */
X  
X***************
X*** 84,89
X  # endif
X  #endif
X  #define	MAILCKFREQ	50
X  
X  #ifdef COMPRESS
X  /* Some implementations of compress need a 'quiet' option.
X
X--- 91,97 -----
X  # endif
X  
X  #define	MAILCKFREQ	50
X+ #endif	/* MAIL */
X  
X  #ifdef COMPRESS
X  /* Some implementations of compress need a 'quiet' option.
X***************
X*** 146,160
X  # undef hc
X  #endif
X  
X! #ifdef TEXTCOLOR
X! /* configurable colors */
X! #  define HI_MON	RED	/* red slaps! */
X! #  define HI_OBJ	MAGENTA
X! #  define HI_METAL	CYAN
X! #  define HI_ORGANIC	GREEN
X! #  define HI_GOLD	YELLOW
X! #  define HI_ZAP	BLUE	/* blue zaps! */
X! #endif
X! 
X! #endif
X  #endif /* UNIX /* */
X
X--- 154,158 -----
X  # undef hc
X  #endif
X  
X! #endif /* UNIXCONF_H /* */
X  #endif /* UNIX /* */
X*** ./Old/Install.unix	Wed Sep 27 10:11:25 1989
X--- ./Install.unix	Sat Sep 23 00:47:12 1989
X***************
X*** 49,64 ****
X  
X  Notes:
X  
X! 1.  No, your old save files and bones files will not work with NetHack 3.0.
X      Don't bother trying to keep them.  The old score list will work fine; the
X      only problem is that you may have trouble beating your old scores in this
X      version.
X  
X! 2.  If you insisted on doing the final installation by hand, you probably
X      forgot to make a save directory.  If you don't go back and do this, you
X      won't be able to save games.
X  
X! 3.  To install an update of this version of NetHack after changing something,
X      type 'make update' from the main directory.  If you created the new
X      version yourself, it should be safe to use 'make update' as long as you
X      did not add, delete, or reorder monsters or objects and you did not change
X--- 49,70 ----
X  
X  Notes:
X  
X! 1.  A number of systems, such as Xenix, support both the termcap and terminfo
X!     terminal capability libraries.  Make sure that the TERMINFO definition in
X!     unixconf.h and TERMLIB in the source Makefile correspond.
X!     If spurious characters appear on the screen while kicking, zapping, etc.
X!     it is likely that you have linked the source to the wrong library.
X! 
X! 2.  No, your old save files and bones files will not work with NetHack 3.0.
X      Don't bother trying to keep them.  The old score list will work fine; the
X      only problem is that you may have trouble beating your old scores in this
X      version.
X  
X! 3.  If you insisted on doing the final installation by hand, you probably
X      forgot to make a save directory.  If you don't go back and do this, you
X      won't be able to save games.
X  
X! 4.  To install an update of this version of NetHack after changing something,
X      type 'make update' from the main directory.  If you created the new
X      version yourself, it should be safe to use 'make update' as long as you
X      did not add, delete, or reorder monsters or objects and you did not change
X***************
X*** 65,67 ****
X--- 71,81 ----
X      the format of saved level files.  If you did any of these things, you
X      should also remove any saved games and bones levels.  (Trying to use such
X      files often produces amusing but useless confusions on the game's part.)
X+ 
X+ 5.  Xenix/286's lex generates a faulty lexical analyser from lev_comp.l.
X+     The beta-release of flex 2.1 (avaliable from uunet, osu-cis,
X+     prep.ai.mit.edu, etc.) can be used to generate the lexer.
X+     The only change to flex is to change "#define yyleng (yy_cp - yy_bp)"
X+     to "#define yyleng (int)(yy_cp - yy_bp)" in flex.skel.
X+     Flex is not needed with Xenix/386, as its lex generates a proper lexical
X+     analyser.  [Xenix instructions by J.T. Conklin]
X*** ./Old/Makefile.top	Wed Sep 27 10:11:38 1989
X--- ./Makefile.top	Tue Sep 19 18:52:15 1989
X***************
X*** 1,6 ****
X--- 1,18 ----
X  #	Hack Makefile.
X  #	SCCS Id: @(#)Makefile.top	3.0	89/03/23
X  
X+ # newer makes predefine $(MAKE) to 'make' and do smarter processing of
X+ # recursive make calls if $(MAKE) is used
X+ # these makes allow $(MAKE) to be overridden by the environment if someone
X+ # wants to (or has to) use something other than the standard make, so we do
X+ # not want to unconditionally set $(MAKE) here
X+ #
X+ # unfortunately, some older makes do not predefine $(MAKE); if you have one of
X+ # these, uncomment the following line
X+ # (you will know that you have one if you get complaints about unable to
X+ # execute things like 'data' and 'rumors')
X+ # MAKE = make
X+ 
X  # make NetHack
X  GAME     = nethack
X  GAMEUID  = games
X***************
X*** 55,60 ****
X--- 67,73 ----
X  #	(don't yank the old version out from under people who're playing it)
X  	mv $(GAMEDIR)/$(GAME) $(GAMEDIR)/$(GAME).old
X  	cp src/$(GAME) $(GAMEDIR)
X+ 	-rm -f $(SHELLDIR)/$(GAME)
X  	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X  		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X  		< auxil/nethack.sh \
X***************
X*** 82,87 ****
X--- 95,101 ----
X  # copy over the game files
X  	( cd auxil ; cp $(AUX) $(GAMEDIR) )
X  	cp src/$(GAME) $(GAMEDIR)
X+ 	-rm -f $(SHELLDIR)/$(GAME)
X  	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
X  		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
X  		< auxil/nethack.sh \
X*** ./Old/Files	Wed Sep 27 10:11:03 1989
X--- ./Files	Tue Sep 26 23:04:12 1989
X***************
X*** 1,7 ****
X! This is a listing of all files in a full NetHack 3.0 distribution, organized in
X! their standard manner on a UNIX system.  It indicates which files are necessary
X! for which versions, so that you can tell which files may be deleted from or not
X! transferred to your system if you wish.
X  
X  
X  (files in top directory)
X--- 1,7 ----
X! This is a listing of all files in a full NetHack 3.0 distribution, organized
X! in their standard manner on a UNIX system.  It indicates which files are 
X! necessary for which versions, so that you can tell which files may be deleted
X! from or not transferred to your system if you wish.
X  
X  
X  (files in top directory)
X***************
X*** 27,34 ****
X  
X  others:
X  (files for MSDOS version)
X! Make.ini        Makefile.msc    Makefile.os2    Makefile.tcc    Maketcc.ini
X! NetHack.cnf     termcap         termcap.uu
X  (files for MSDOS, Amiga, and Atari versions)
X  pcmain.c        pctty.c         pcunix.c
X  (file for MSDOS and new Atari versions)
X--- 27,34 ----
X  
X  others:
X  (files for MSDOS version)
X! Make.ini        Makefile.msc    Makefile.pc     Makefile.os2    Makefile.tcc
X! Maketcc.ini     NetHack.cnf     termcap         termcap.uu
X  (files for MSDOS, Amiga, and Atari versions)
X  pcmain.c        pctty.c         pcunix.c
X  (file for MSDOS and new Atari versions)
X***************
X*** 37,43 ****
X  Makefile.st
X  (file for old Atari version)
X  oldtos.c
X! (file with random number routines, which may be included in any version)
X  random.c
X  
X  
X--- 37,43 ----
X  Makefile.st
X  (file for old Atari version)
X  oldtos.c
X! (Berkeley random number file, which may be included in any version)
X  random.c
X  
X  
X***************
X*** 51,57 ****
X  obj.h           objclass.h      patchlevel.h    pcconf.h        permonst.h
X  prop.h          rm.h            sp_lev.h        spell.h         system.h
X  tosconf.h       tradstdc.h      trap.h          trapname.h      unixconf.h
X! vault.h         wseg.h          you.h           youprop.h
X  (file for special level compiler (STRONGHOLD option))
X  lev_comp.h
X  
X--- 51,57 ----
X  obj.h           objclass.h      patchlevel.h    pcconf.h        permonst.h
X  prop.h          rm.h            sp_lev.h        spell.h         system.h
X  tosconf.h       tradstdc.h      trap.h          trapname.h      unixconf.h
X! vault.h         vmsconf.h       wseg.h          you.h           youprop.h
X  (file for special level compiler (STRONGHOLD option))
X  lev_comp.h
X  
X***************
X*** 79,81 ****
X--- 79,88 ----
X  lev_comp.c      lev_comp.l      lev_comp.y      lev_lex.c       lev_main.c
X  (files for UNIX versions)
X  Makefile.src    unixmain.c      unixtty.c       unixunix.c
X+ 
X+ vms:
X+ (files for VMS version)
X+ Install.vms     spec_lev.com    vmsbuild.com    vmsmain.c       vmsmisc.c
X+ vmstty.c        vmsunix.c
X+ (GNU termcap files that support VMS version)
X+ vmstermcap.c    vmstparam.c
X*** ./Old/README	Wed Sep 27 10:11:59 1989
X--- ./README	Sun Sep 17 13:12:06 1989
X***************
X*** 37,43 ****
X      directory as the 'Top' directory.  It makes no difference what you
X      call it.
X  
X! 2.  If there is no flaw in the packaging, FIVE sub-directories will be
X      automatically created, and files will be deposited in them: 
X  
X      a.  A 'src' directory, which will contain general *.c files.
X--- 37,43 ----
X      directory as the 'Top' directory.  It makes no difference what you
X      call it.
X  
X! 2.  If there is no flaw in the packaging, SIX sub-directories will be
X      automatically created, and files will be deposited in them: 
X  
X      a.  A 'src' directory, which will contain general *.c files.
X***************
X*** 45,50 ****
X--- 45,51 ----
X      c.  An 'auxil' directory, which will contain a variety of data files.
X      d.  An 'amiga' directory, which will contain the Amiga-specific files.
X      e.  An 'others' directory, which will contain MSDOS and TOS files.
X+     f.  A 'vms' directory, which will contain VMS files.
X  
X      The names of these directories should not be changed, unless you are
X      ready to go through the makefiles and the makedefs program and change
X***************
X*** 86,91 ****
X--- 87,94 ----
X  	Commodore Amiga (probably -- there have been some changes since
X  		the Amiga port was done, but we believe it should still work)
X  	Atari 1040ST under TOS
X+ 	DEC vaxen running VMS (probably still requires tweaking) 
X+ 	Data General AViiON systems under DG/UX
X  
X  			- - - - - - - - - - -
X  
X*** /dev/null	Thu Sep 28 00:44:19 1989
X--- include/vmsconf.h	Thu Sep 28 00:44:04 1989
X***************
X*** 0
X
X--- 1,69 -----
X+ /*	SCCS Id: @(#)vmsconf.h	3.0	88/07/21
X+ /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ #ifdef VMS
X+ #ifndef VMSCONF_H
X+ #define VMSCONF_H
X+ 
X+ #undef UNIX
X+ #undef HACKDIR
X+ #define HACKDIR	"USR$ROOT0:[GENTZEL.NHDIR]"
X+ #undef RECORD
X+ #define RECORD "record;1"
X+ 
X+ #undef COMPRESS
X+ #undef ZEROCOMP
X+ 
X+ /*
X+  * If you define MAIL, then the player will be notified of new broadcasts
X+  * when they arrive.
X+  */
X+ #define	MAIL
X+ 
X+ #define RANDOM		/* if neither random/srandom nor lrand48/srand48
X+ 			   is available from your system */
X+ 
X+ #define	FCMASK	0660	/* file creation mask */
X+ 
X+ 
X+ /*
X+  * The remainder of the file should not need to be changed.
X+  */
X+ 
X+ #include <time.h>
X+ #include <file.h>
X+ 
X+ #define	HLOCK	"perm;1"	/* an empty file used for locking purposes */
X+ #define LLOCK	"safelock;1"	/* link to previous */
X+ 
X+ #ifndef REDO
X+ # define Getchar vms_getchar
X+ #else
X+ # define tgetch vms_getchar
X+ #endif
X+ 
X+ #define SHELL		/* do not delete the '!' command */
X+ 
X+ #include "system.h"
X+ 
X+ #define index	strchr
X+ #define rindex	strrchr
X+ 
X+ /* Use the high quality random number routines. */
X+ #if defined(RANDOM)
X+ #define Rand()	random()
X+ #define Srand(seed) srandom(seed)
X+ #else
X+ #define Rand()	rand()
X+ #define Srand(seed) srand(seed)
X+ #endif
X+ 
X+ #define unlink(x) delete(x)
X+ #define exit(x) vms_exit(x)
X+ #define getuid() vms_getuid()
X+ #define abort() vms_abort()
X+ #define creat(f,m) vms_creat(f,m)
X+ 
X+ #endif
X+ #endif /* VMS /* */
X*** /dev/null	Wed Sep 27 12:48:12 1989
X--- vms/vmsunix.c	Tue Sep 26 18:51:29 1989
X***************
X*** 0 ****
X--- 1,397 ----
X+ /*	SCCS Id: @(#)vmsunix.c	3.0	88/04/13
X+ /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ /* This file collects some Unix dependencies; pager.c contains some more */
X+ 
X+ /*
X+  * The time is used for:
X+  *	- seed for rand()
X+  *	- year on tombstone and yymmdd in record file
X+  *	- phase of the moon (various monsters react to NEW_MOON or FULL_MOON)
X+  *	- night and midnight (the undead are dangerous at midnight)
X+  *	- determination of what files are "very old"
X+  */
X+ 
X+ #include "hack.h"
X+ 
X+ #include <rms.h>
X+ #include <jpidef.h>
X+ #include <ssdef.h>
X+ #include <errno.h>
X+ #include <signal.h>
X+ #undef off_t
X+ #include <sys/stat.h>
X+ 
X+ void
X+ setrandom()
X+ {
X+ 	(void) Srand((long) time ((time_t *) 0));
X+ }
X+ 
X+ static struct tm *
X+ getlt()
X+ {
X+ 	time_t date;
X+ 
X+ 	(void) time(&date);
X+ 	return(localtime(&date));
X+ }
X+ 
X+ int
X+ getyear()
X+ {
X+ 	return(1900 + getlt()->tm_year);
X+ }
X+ 
X+ char *
X+ getdate()
X+ {
X+ 	static char datestr[7];
X+ 	register struct tm *lt = getlt();
X+ 
X+ 	Sprintf(datestr, "%2d%2d%2d",
X+ 		lt->tm_year, lt->tm_mon + 1, lt->tm_mday);
X+ 	if(datestr[2] == ' ') datestr[2] = '0';
X+ 	if(datestr[4] == ' ') datestr[4] = '0';
X+ 	return(datestr);
X+ }
X+ 
X+ int
X+ phase_of_the_moon()			/* 0-7, with 0: new, 4: full */
X+ {					/* moon period: 29.5306 days */
X+ 					/* year: 365.2422 days */
X+ 	register struct tm *lt = getlt();
X+ 	register int epact, diy, goldn;
X+ 
X+ 	diy = lt->tm_yday;
X+ 	goldn = (lt->tm_year % 19) + 1;
X+ 	epact = (11 * goldn + 18) % 30;
X+ 	if ((epact == 25 && goldn > 11) || epact == 24)
X+ 		epact++;
X+ 
X+ 	return( (((((diy + epact) * 6) + 11) % 177) / 22) & 7 );
X+ }
X+ 
X+ int
X+ night()
X+ {
X+ 	register int hour = getlt()->tm_hour;
X+ 
X+ 	return(hour < 6 || hour > 21);
X+ }
X+ 
X+ int
X+ midnight()
X+ {
X+ 	return(getlt()->tm_hour == 0);
X+ }
X+ 
X+ static struct stat buf, hbuf;
X+ 
X+ void
X+ gethdate(name) char *name; {
X+ 	register char *np;
X+ 
X+ 	if(stat(name, &hbuf))
X+ 		error("Cannot get status of %s.",
X+ 			(np = rindex(name, ']')) ? np+1 : name);
X+ }
X+ 
X+ int
X+ uptodate(fd)
X+ int fd;
X+ {
X+ 	if(fstat(fd, &buf)) {
X+ 		pline("Cannot get status of saved level? ");
X+ 		return(0);
X+ 	}
X+ 	if(buf.st_mtime < hbuf.st_mtime) {
X+ 		pline("Saved level is out of date. ");
X+ 		return(0);
X+ 	}
X+ 	return(1);
X+ }
X+ 
X+ static int
X+ veryold(fd)
X+ int fd;
X+ {
X+ 	register int i;
X+ 	time_t date;
X+ 
X+ 	if(fstat(fd, &buf)) return(0);			/* cannot get status */
X+ 	if(buf.st_size != sizeof(int)) return(0);	/* not an xlock file */
X+ 	(void) time(&date);
X+ 	if(date - buf.st_mtime < 3L*24L*60L*60L) {	/* recent */
X+ 		int lockedpid;	/* should be the same size as hackpid */
X+ 		int status, dummy, code = JPI$_PID;
X+ 
X+ 		if(read(fd, (char *)&lockedpid, sizeof(lockedpid)) !=
X+ 			sizeof(lockedpid))
X+ 			/* strange ... */
X+ 			return(0);
X+   		if(!(!((status = LIB$GETJPI(&code, &lockedpid, 0, &dummy)) & 1)
X+ 		     && status == SS$_NONEXPR))
X+ 			return(0);
X+ 	}
X+ 	(void) close(fd);
X+ 	for(i = 1; i <= MAXLEVEL+1; i++) {		/* try to remove all */
X+ 		glo(i);
X+ 		(void) delete(lock);
X+ 	}
X+ 	glo(0);
X+ 	if(delete(lock)) return(0);			/* cannot remove it */
X+ 	return(1);					/* success! */
X+ }
X+ 
X+ void
X+ getlock()
X+ {
X+ 	register int i = 0, fd;
X+ 
X+ #ifdef HARD
X+ 	/* idea from rpick%ucqais@uccba.uc.edu
X+ 	 * prevent automated rerolling of characters
X+ 	 * test input (fd0) so that tee'ing output to get a screen dump still
X+ 	 * works
X+ 	 * also incidentally prevents development of any hack-o-matic programs
X+ 	 */
X+ 	if (!isatty(0))
X+ 		error("You must play from a terminal.");
X+ #endif
X+ 
X+ 	(void) fflush(stdout);
X+ 
X+ 	/* we ignore QUIT and INT at this point */
X+ 	if (link(HLOCK, LLOCK) == -1) {
X+ 		register int errnosv = errno;
X+ 
X+ 		perror(HLOCK);
X+ 		Printf("Cannot link %s to %s\n", LLOCK, HLOCK);
X+ 		switch(errnosv) {
X+ 		case ENOENT:
X+ 		    Printf("Perhaps there is no (empty) file %s ?\n", HLOCK);
X+ 		    break;
X+ 		case EACCES:
X+ 		    Printf("It seems you don't have write permission here.\n");
X+ 		    break;
X+ 		case EEXIST:
X+ 		    Printf("(Try again or rm %s.)\n", LLOCK);
X+ 		    break;
X+ 		default:
X+ 		    Printf("I don't know what is wrong.");
X+ 		}
X+ 		getret();
X+ 		error("");
X+ 		/*NOTREACHED*/
X+ 	}
X+ 
X+ 	regularize(lock);
X+ 	glo(0);
X+ 	if(locknum > 25) locknum = 25;
X+ 
X+ 	do {
X+ 		if(locknum) lock[0] = 'a' + i++;
X+ 
X+ 		if((fd = open(lock, 0)) == -1) {
X+ 			if(errno == ENOENT) goto gotlock;    /* no such file */
X+ 			perror(lock);
X+ 			(void) delete(LLOCK);
X+ 			error("Cannot open %s", lock);
X+ 		}
X+ 
X+ 		if(veryold(fd))	/* if true, this closes fd and unlinks lock */
X+ 			goto gotlock;
X+ 		(void) close(fd);
X+ 	} while(i < locknum);
X+ 
X+ 	(void) delete(LLOCK);
X+ 	error(locknum ? "Too many hacks running now."
X+ 		      : "There is a game in progress under your name.");
X+ gotlock:
X+ 	fd = creat(lock, FCMASK);
X+ 	if(delete(LLOCK) == -1)
X+ 		error("Cannot delete %s.", LLOCK);
X+ 	if(fd == -1) {
X+ 		error("cannot creat lock file.");
X+ 	} else {
X+ 		if(write(fd, (char *) &hackpid, sizeof(hackpid))
X+ 		    != sizeof(hackpid)){
X+ 			error("cannot write lock");
X+ 		}
X+ 		if(close(fd) == -1) {
X+ 			error("cannot close lock");
X+ 		}
X+ 	}
X+ }	
X+ 
X+ void
X+ regularize(s)	/* normalize file name */
X+ register char *s;
X+ {
X+ 	register char *lp;
X+ 
X+ 	for (lp = s; *lp; lp++)
X+ 		if (!((*lp >= 'A' && *lp <= 'Z')
X+ 		      || (*lp >= 'a' && *lp <= 'z')
X+ 		      || (*lp >= '0' && *lp <= '9')
X+ 		      || *lp == '$' || *lp == '_'
X+ 		      || (lp > s && *lp == '-')))
X+ 			*lp = '_';
X+ }
X+ 
X+ int link(file, new)
X+ char *file, *new;
X+ {
X+     int status;
X+     struct FAB fab;
X+     struct NAM nam;
X+     unsigned short fid[3];
X+     char esa[NAM$C_MAXRSS];
X+ 
X+     fab = cc$rms_fab;
X+     fab.fab$l_fop = FAB$M_OFP;
X+     fab.fab$l_fna = file;
X+     fab.fab$b_fns = strlen(file);
X+     fab.fab$l_nam = &nam;
X+ 
X+     nam = cc$rms_nam;
X+     nam.nam$l_esa = esa;
X+     nam.nam$b_ess = NAM$C_MAXRSS;
X+ 
X+     if (!((status = SYS$PARSE(&fab)) & 1)
X+ 	|| !((status = SYS$SEARCH(&fab)) & 1))
X+     {
X+ 	C$$TRANSLATE(status);
X+ 	return -1;
X+     }
X+ 
X+     fid[0] = nam.nam$w_fid[0];
X+     fid[1] = nam.nam$w_fid[1];
X+     fid[2] = nam.nam$w_fid[2];
X+ 
X+     fab.fab$l_fna = new;
X+     fab.fab$b_fns = strlen(new);
X+ 
X+     if (!((status = SYS$PARSE(&fab)) & 1))
X+     {
X+ 	C$$TRANSLATE(status);
X+ 	return -1;
X+     }
X+ 
X+     nam.nam$w_fid[0] = fid[0];
X+     nam.nam$w_fid[1] = fid[1];
X+     nam.nam$w_fid[2] = fid[2];
X+ 
X+     nam.nam$l_esa = nam.nam$l_name;
X+     nam.nam$b_esl = nam.nam$b_name + nam.nam$b_type + nam.nam$b_ver;
X+ 
X+     if (!((status = SYS$ENTER(&fab)) & 1))
X+     {
X+ 	C$$TRANSLATE(status);
X+ 	return -1;
X+     }
X+ 
X+     return 0;
X+ }
X+ 
X+ #undef unlink
X+ int unlink(file)
X+ char *file;
X+ {
X+     int status;
X+     struct FAB fab = cc$rms_fab;
X+     struct NAM nam = cc$rms_nam;
X+     char esa[NAM$C_MAXRSS];
X+ 
X+     fab.fab$l_fop = FAB$M_DLT;
X+     fab.fab$l_fna = file;
X+     fab.fab$b_fns = strlen(file);
X+     fab.fab$l_nam = &nam;
X+     nam.nam$l_esa = esa;
X+     nam.nam$b_ess = NAM$C_MAXRSS;
X+ 
X+     if (!((status = SYS$PARSE(&fab)) & 1)
X+ 	|| !((status = SYS$REMOVE(&fab)) & 1))
X+     {
X+ 	C$$TRANSLATE(status);
X+ 	return -1;
X+     }
X+ 
X+     return 0;
X+ }
X+ 
X+ #undef creat
X+ int vms_creat(file, mode)
X+ char *file;
X+ unsigned int mode;
X+ {
X+     if (index(file, ';'))
X+ 	(void) delete(file);
X+     return creat(file, mode);
X+ }
X+ 
X+ #undef getuid
X+ int
X+ vms_getuid()
X+ {
X+     return (getgid() << 16) | getuid();
X+ }
X+ 
X+ #ifdef CHDIR
X+ unsigned int oprv[2];
X+ 
X+ void
X+ privoff()
X+ {
X+     unsigned int prv[2] = { -1, -1 }, code = JPI$_PROCPRIV;
X+ 
X+     (void) SYS$SETPRV(0, prv, 0, oprv);
X+     (void) LIB$GETJPI(&code, 0, 0, prv);
X+     (void) SYS$SETPRV(1, prv, 0, 0);
X+ }
X+ 
X+ void
X+ privon()
X+ {
X+     (void) SYS$SETPRV(1, oprv, 0, 0);
X+ }
X+ #endif
X+ 
X+ #ifdef SHELL
X+ unsigned int dosh_pid = 0;
X+ 
X+ int
X+ dosh()
X+ {
X+ 	int status;
X+ 
X+ 	settty((char *) NULL);	/* also calls end_screen() */
X+ 	(void) signal(SIGINT,SIG_IGN);
X+ 	(void) signal(SIGQUIT,SIG_IGN);
X+ 	if (!dosh_pid || !((status = LIB$ATTACH(&dosh_pid)) & 1))
X+ 	{
X+ #ifdef CHDIR
X+ 		(void) chdir(getenv("PATH"));
X+ 		privoff();
X+ #endif
X+ 		dosh_pid = 0;
X+ 		status = LIB$SPAWN(0, 0, 0, 0, 0, &dosh_pid);
X+ #ifdef CHDIR
X+ 		privon();
X+ 		chdirx((char *) 0, 0);
X+ #endif
X+ 	}
X+ 	gettty();
X+ 	setftty();
X+ 	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X+ #ifdef WIZARD
X+ 	if(wizard) (void) signal(SIGQUIT,SIG_DFL);
X+ #endif
X+ 	docrt();
X+ 	if (!(status & 1))
X+ 	    pline("Spawn failed.  Try again.");
X+ 	return 0;
X+ }
X+ #endif
X
END_OF_FILE
if test 56752 -ne `wc -c <'patches04h'`; then
    echo shar: \"'patches04h'\" unpacked with wrong size!
fi
# end of 'patches04h'
fi
echo shar: End of archive 8 \(of 11\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
