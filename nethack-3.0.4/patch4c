Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i039:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch4c
Message-ID: <4629@tekred.CNA.TEK.COM>
Date: 29 Sep 89 21:09:22 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1917
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 39
Archive-name: NetHack3/Patch4c
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 11)."
# Contents:  patches04c
# Wrapped by billr@saab on Fri Sep 29 13:13:48 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches04c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches04c'\"
else
echo shar: Extracting \"'patches04c'\" \(47374 characters\)
sed "s/^X//" >'patches04c' <<'END_OF_FILE'
X*** src/Old/mkroom.c	Wed Sep 27 11:53:40 1989
X--- src/mkroom.c	Thu Sep 14 14:36:01 1989
X***************
X*** 296,303 ****
X  		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X  		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X  		if(!OBJ_AT(sx, sy) && levl[sx][sy].gmask == 0 &&
X! 		   levl[sx][sy].mmask == 0 &&
X! 		   !t_at(sx,sy) && !nexttodoor(sx,sy)) {
X  		    if((sx+sy)%2) {
X  			levl[sx][sy].typ = POOL;
X  			levl[sx][sy].scrsym = POOL_SYM;
X--- 296,302 ----
X  		for(sx = sroom->lx; sx <= sroom->hx; sx++)
X  		for(sy = sroom->ly; sy <= sroom->hy; sy++)
X  		if(!OBJ_AT(sx, sy) && levl[sx][sy].gmask == 0 &&
X! 		   !MON_AT(sx, sy) && !t_at(sx,sy) && !nexttodoor(sx,sy)) {
X  		    if((sx+sy)%2) {
X  			levl[sx][sy].typ = POOL;
X  			levl[sx][sy].scrsym = POOL_SYM;
X***************
X*** 324,330 ****
X  
X  	if(!place_oracle(sroom,&dy,&xx,&yy)) return;
X  
X! 	if(levl[xx][yy].mmask) rloc(m_at(xx, yy)); /* insurance */
X  
X  	/* set up Oracle and environment */
X  	if(!(oracl = makemon(&mons[PM_ORACLE],xx,yy))) return;
X--- 323,330 ----
X  
X  	if(!place_oracle(sroom,&dy,&xx,&yy)) return;
X  
X! 	if(MON_AT(xx, yy))
X! 	    rloc(m_at(xx, yy)); /* insurance */
X  
X  	/* set up Oracle and environment */
X  	if(!(oracl = makemon(&mons[PM_ORACLE],xx,yy))) return;
X*** src/Old/mon.c	Wed Sep 27 11:54:07 1989
X--- src/mon.c	Mon Sep 25 21:35:03 1989
X***************
X*** 8,13 ****
X--- 8,17 ----
X  #  include "artifact.h"
X  #endif
X  
X+ #ifdef WORM
X+ #  include "wseg.h"
X+ #endif
X+ 
X  #ifdef HARD
X  static boolean restrap();
X  #  include <ctype.h>
X***************
X*** 17,23 ****
X  int lastwarnlev;
X  static const char *warnings[] = {
X  	"white", "pink", "red", "ruby", "purple", "black" };
X! struct monst *fdmon;	/* chain of dead monsters, need not to be saved */
X  
X  /* Creates a monster corpse, a "special" corpse, or nothing if it doesn't
X   * leave corpses.  Monsters which leave "special" corpses should have
X--- 21,27 ----
X  int lastwarnlev;
X  static const char *warnings[] = {
X  	"white", "pink", "red", "ruby", "purple", "black" };
X! struct monst *fdmon;	/* chain of dead monsters, need not be saved */
X  
X  /* Creates a monster corpse, a "special" corpse, or nothing if it doesn't
X   * leave corpses.  Monsters which leave "special" corpses should have
X***************
X*** 112,123 ****
X  	/* All special cases should precede the G_NOCORPSE check */
X  
X  	/* Note: oname() cannot be used generically for non-inventory objects
X! 	 * unless you fix the link from the previous object in the chain.
X  	 * (Here we know it's the first one, so there was no link.)
X  	 */
X  	if (mtmp->mnamelth) {
X  		obj = oname(obj, NAME(mtmp), 0);
X  		fobj = obj;
X  	}
X  	stackobj(fobj);
X  	newsym(x, y);
X--- 116,128 ----
X  	/* All special cases should precede the G_NOCORPSE check */
X  
X  	/* Note: oname() cannot be used generically for non-inventory objects
X! 	 * unless you fix the link from the previous object in the chains.
X  	 * (Here we know it's the first one, so there was no link.)
X  	 */
X  	if (mtmp->mnamelth) {
X  		obj = oname(obj, NAME(mtmp), 0);
X  		fobj = obj;
X+ 		level.objects[x][y] = obj;
X  	}
X  	stackobj(fobj);
X  	newsym(x, y);
X***************
X*** 376,382 ****
X  
X  	for(otmp = fobj; otmp; otmp = otmp->nobj)
X  	  if(throws_rocks(mtmp->data) ? otmp->otyp == BOULDER :
X! 			(otmp->olet == GEM_SYM && otmp->otyp < LAST_GEM+5))
X  	    if(otmp->ox == mtmp->mx && otmp->oy == mtmp->my)
X  	      if(mtmp->data->mlet != S_UNICORN
X  		 || objects[otmp->otyp].g_val != 0){
X--- 381,387 ----
X  
X  	for(otmp = fobj; otmp; otmp = otmp->nobj)
X  	  if(throws_rocks(mtmp->data) ? otmp->otyp == BOULDER :
X! 			(otmp->olet == GEM_SYM && otmp->otyp < LAST_GEM+6))
X  	    if(otmp->ox == mtmp->mx && otmp->oy == mtmp->my)
X  	      if(mtmp->data->mlet != S_UNICORN
X  		 || objects[otmp->otyp].g_val != 0){
X***************
X*** 542,548 ****
X  			if(!(flag & ALLOW_U)) continue;
X  			info[cnt] |= ALLOW_U;
X  		} else {
X! 			if(levl[nx][ny].mmask) {
X  				if(!(flag & ALLOW_M)) continue;
X  				info[cnt] |= ALLOW_M;
X  				if((m_at(nx,ny))->mtame) {
X--- 547,553 ----
X  			if(!(flag & ALLOW_U)) continue;
X  			info[cnt] |= ALLOW_U;
X  		} else {
X! 			if(MON_AT(nx, ny)) {
X  				if(!(flag & ALLOW_M)) continue;
X  				info[cnt] |= ALLOW_M;
X  				if((m_at(nx,ny))->mtame) {
X***************
X*** 697,706 ****
X  	    /* Dead Kops may come back. */
X  	    switch(rnd(5)) {
X  		case 1:	     /* returns near the stairs */
X! 			(void) mkmon_at(mtmp->data->mname,xdnstair,ydnstair);
X  			break;
X  		case 2:	     /* randomly */
X! 			(void) mkmon_at(mtmp->data->mname,0,0);
X  			break;
X  		default:
X  			break;
X--- 702,711 ----
X  	    /* Dead Kops may come back. */
X  	    switch(rnd(5)) {
X  		case 1:	     /* returns near the stairs */
X! 			(void) makemon(mtmp->data,xdnstair,ydnstair);
X  			break;
X  		case 2:	     /* randomly */
X! 			(void) makemon(mtmp->data,0,0);
X  			break;
X  		default:
X  			break;
X***************
X*** 728,739 ****
X  {
X  	relmon(mtmp);
X  	monfree(mtmp);
X! 	levl[mtmp2->mx][mtmp2->my].mmask = 1;
X  	mtmp2->nmon = fmon;
X  	fmon = mtmp2;
X  	if(u.ustuck == mtmp) u.ustuck = mtmp2;
X  	if(mtmp2->isshk) replshk(mtmp,mtmp2);
X  	if(mtmp2->isgd) replgd(mtmp,mtmp2);
X  }
X  
X  void
X--- 733,753 ----
X  {
X  	relmon(mtmp);
X  	monfree(mtmp);
X! 	place_monster(mtmp2, mtmp2->mx, mtmp2->my);
X  	mtmp2->nmon = fmon;
X  	fmon = mtmp2;
X  	if(u.ustuck == mtmp) u.ustuck = mtmp2;
X  	if(mtmp2->isshk) replshk(mtmp,mtmp2);
X  	if(mtmp2->isgd) replgd(mtmp,mtmp2);
X+ #ifdef WORM
X+ 	if(mtmp2->wormno) {
X+ 		/* Each square the worm is on has a pointer; fix them all */
X+ 		register struct wseg *wtmp;
X+ 
X+ 		for(wtmp=wsegs[mtmp2->wormno]; wtmp; wtmp=wtmp->nseg)
X+ 			place_worm_seg(mtmp2, wtmp->wx, wtmp->wy);
X+ 	}
X+ #endif
X  }
X  
X  void
X***************
X*** 744,750 ****
X  
X  	if (fmon == 0)  panic ("relmon: no fmon available.");
X  
X! 	levl[mon->mx][mon->my].mmask = 0;
X  
X  	if(mon == fmon) fmon = fmon->nmon;
X  	else {
X--- 758,764 ----
X  
X  	if (fmon == 0)  panic ("relmon: no fmon available.");
X  
X! 	remove_monster(mon->mx, mon->my);
X  
X  	if(mon == fmon) fmon = fmon->nmon;
X  	else {
X***************
X*** 760,766 ****
X  monfree(mtmp) register struct monst *mtmp; {
X  	mtmp->nmon = fdmon;
X  	fdmon = mtmp;
X! 	levl[mtmp->mx][mtmp->my].mmask = 0;
X  }
X  
X  void
X--- 774,780 ----
X  monfree(mtmp) register struct monst *mtmp; {
X  	mtmp->nmon = fdmon;
X  	fdmon = mtmp;
X! 	remove_monster(mtmp->mx, mtmp->my);
X  }
X  
X  void
X***************
X*** 862,868 ****
X  	}
X  	if((mtmp->mpeaceful && !rn2(2)) || mtmp->mtame)	change_luck(-1);
X  	if ((mdat==&mons[PM_BLACK_UNICORN] && u.ualigntyp == U_CHAOTIC) ||
X! 	    (mdat==&mons[PM_GREY_UNICORN] && u.ualigntyp == U_NEUTRAL) ||
X  	    (mdat==&mons[PM_WHITE_UNICORN] && u.ualigntyp == U_LAWFUL))
X  		change_luck(-5);
X  
X--- 876,882 ----
X  	}
X  	if((mtmp->mpeaceful && !rn2(2)) || mtmp->mtame)	change_luck(-1);
X  	if ((mdat==&mons[PM_BLACK_UNICORN] && u.ualigntyp == U_CHAOTIC) ||
X! 	    (mdat==&mons[PM_GRAY_UNICORN] && u.ualigntyp == U_NEUTRAL) ||
X  	    (mdat==&mons[PM_WHITE_UNICORN] && u.ualigntyp == U_LAWFUL))
X  		change_luck(-5);
X  
X***************
X*** 961,977 ****
X  	}
X  }
X  
X- /*VARARGS2*/
X- void
X- kludge(str, arg, arg2, arg3)
X- 	register char *str,*arg,*arg2,*arg3;
X- {
X- 	if(Blind || !flags.verbose) {
X- 		if(*str == '%') pline(str,"It",arg2,arg3);
X- 		else pline(str,"it",arg2,arg3);
X- 	} else pline(str,arg,arg2,arg3);
X- }
X- 
X  void
X  rescham() {	/* force all chameleons to become normal */
X  
X--- 975,980 ----
X***************
X*** 1094,1103 ****
X  {
X  	coord mm;
X  	enexto(&mm, u.ux, u.uy, mtmp->data);
X! 	levl[mtmp->mx][mtmp->my].mmask = 0;
X! 	levl[mm.x][mm.y].mmask = 1;
X! 	mtmp->mx = mm.x;
X! 	mtmp->my = mm.y;
X  	pmon(mtmp);
X  	set_apparxy(mtmp);
X  }
X--- 1097,1104 ----
X  {
X  	coord mm;
X  	enexto(&mm, u.ux, u.uy, mtmp->data);
X! 	remove_monster(mtmp->mx, mtmp->my);
X! 	place_monster(mtmp, mm.x, mm.y);
X  	pmon(mtmp);
X  	set_apparxy(mtmp);
X  }
X***************
X*** 1115,1124 ****
X  	}
X  	if(x == mtmp->mx && y == mtmp->my) /* that was easy */
X  		return;
X! 	levl[mtmp->mx][mtmp->my].mmask = 0;
X! 	levl[x][y].mmask = 1;
X! 	mtmp->mx = x;
X! 	mtmp->my = y;
X  	pmon(mtmp);
X  	set_apparxy(mtmp);
X  }
X--- 1116,1123 ----
X  	}
X  	if(x == mtmp->mx && y == mtmp->my) /* that was easy */
X  		return;
X! 	remove_monster(mtmp->mx, mtmp->my);
X! 	place_monster(mtmp, x, y);
X  	pmon(mtmp);
X  	set_apparxy(mtmp);
X  }
X*** src/Old/mondata.c	Wed Sep 27 11:55:12 1989
X--- src/mondata.c	Mon Sep 25 21:35:06 1989
X***************
X*** 278,284 ****
X  
X  const int grownups[][2] = { {PM_LITTLE_DOG, PM_DOG}, {PM_DOG, PM_LARGE_DOG},
X  	{PM_HELL_HOUND_PUP, PM_HELL_HOUND}, {PM_KITTEN, PM_HOUSECAT},
X! 	{PM_HOUSECAT, PM_LARGE_CAT}, {PM_BABY_GREY_DRAGON, PM_GREY_DRAGON},
X  	{PM_BABY_RED_DRAGON, PM_RED_DRAGON},
X  	{PM_BABY_WHITE_DRAGON, PM_WHITE_DRAGON},
X  	{PM_BABY_BLUE_DRAGON, PM_BLUE_DRAGON},
X--- 278,284 ----
X  
X  const int grownups[][2] = { {PM_LITTLE_DOG, PM_DOG}, {PM_DOG, PM_LARGE_DOG},
X  	{PM_HELL_HOUND_PUP, PM_HELL_HOUND}, {PM_KITTEN, PM_HOUSECAT},
X! 	{PM_HOUSECAT, PM_LARGE_CAT}, {PM_BABY_GRAY_DRAGON, PM_GRAY_DRAGON},
X  	{PM_BABY_RED_DRAGON, PM_RED_DRAGON},
X  	{PM_BABY_WHITE_DRAGON, PM_WHITE_DRAGON},
X  	{PM_BABY_BLUE_DRAGON, PM_BLUE_DRAGON},
X*** src/Old/monmove.c	Wed Sep 27 11:55:42 1989
X--- src/monmove.c	Wed Sep 27 09:29:38 1989
X***************
X*** 59,65 ****
X  		    here->doormask = D_BROKEN;
X  		}
X  	    }
X! 	else pile = 12; /* it doesn't leave rocks if it didn't dig */
X  
X  	/* Left behind a pile? */
X  	if(pile < 5) {
X--- 59,65 ----
X  		    here->doormask = D_BROKEN;
X  		}
X  	    }
X! 	else return TRUE; /* it doesn't leave rocks if it didn't dig */
X  
X  	/* Left behind a pile? */
X  	if(pile < 5) {
X***************
X*** 68,77 ****
X  	    else
X  		(void) mksobj_at(ROCK, mtmp->mx, mtmp->my);
X  	}
X! 	if(canseeit) {
X! 	    here->seen = TRUE;
X  	    newsym(mtmp->mx,mtmp->my);
X! 	} else
X  	    mnewsym(mtmp->mx,mtmp->my);
X  	return(TRUE);
X  }
X--- 68,77 ----
X  	    else
X  		(void) mksobj_at(ROCK, mtmp->mx, mtmp->my);
X  	}
X! 	here->seen = TRUE; /* required for newsym and mnewsym to work */
X! 	if(canseeit && mtmp->minvis && !See_invisible)
X  	    newsym(mtmp->mx,mtmp->my);
X! 	else
X  	    mnewsym(mtmp->mx,mtmp->my);
X  	return(TRUE);
X  }
X***************
X*** 271,276 ****
X--- 271,278 ----
X   			if(Hallucination) pmon(mtmp);
X   			break;
X   		    case 1:	/* monster moved */
X+ 			/* Maybe it stepped on a trap and fell asleep... */
X+ 			if(mtmp->msleep || mtmp->mfroz) return(0);
X   			if(!nearby && ranged_attk(mdat)) break;
X   			else if(mdat->mmove <= 12) return(0);
X   			break;
X***************
X*** 349,356 ****
X  
X  	set_apparxy(mtmp);
X  	/* where does mtmp think you are? */
X! 	/* Not necessary if m_move called from here, but necessary in
X! 	 * other calls of m_move (i.e. leprechauns dodging)
X  	 */
X  	can_tunnel = tunnels(ptr) &&
X  #ifdef REINCARNATION
X--- 351,358 ----
X  
X  	set_apparxy(mtmp);
X  	/* where does mtmp think you are? */
X! 	/* Not necessary if m_move called from this file, but necessary in
X! 	 * other calls of m_move (ex. leprechauns dodging)
X  	 */
X  	can_tunnel = tunnels(ptr) &&
X  #ifdef REINCARNATION
X***************
X*** 360,367 ****
X  #ifdef WORM
X  	if(mtmp->wormno) goto not_special;
X  #endif
X! 	/* my dog gets a special treatment */
X! 	if(mtmp->mtame) return( dog_move(mtmp, after) );
X  
X  	/* likewise for shopkeeper */
X  	if(mtmp->isshk) {
X--- 362,372 ----
X  #ifdef WORM
X  	if(mtmp->wormno) goto not_special;
X  #endif
X! 	/* my dog gets special treatment */
X! 	if(mtmp->mtame) {
X! 	    mmoved = dog_move(mtmp, after);
X! 	    goto postmov;
X! 	}
X  
X  	/* likewise for shopkeeper */
X  	if(mtmp->isshk) {
X***************
X*** 485,491 ****
X  		   (likemagic && index(magical, otmp->olet)) ||
X  		   (likerock && otmp->otyp == BOULDER) ||
X  		   (likegems && otmp->olet == GEM_SYM &&
X! 			otmp->otyp < LAST_GEM + 5) ||
X  		   (conceals && !cansee(otmp->ox,otmp->oy)) ||
X  		   (ptr == &mons[PM_GELATINOUS_CUBE] &&
X  					!index(indigestion, otmp->olet))
X--- 490,496 ----
X  		   (likemagic && index(magical, otmp->olet)) ||
X  		   (likerock && otmp->otyp == BOULDER) ||
X  		   (likegems && otmp->olet == GEM_SYM &&
X! 			otmp->otyp < LAST_GEM + 6) ||
X  		   (conceals && !cansee(otmp->ox,otmp->oy)) ||
X  		   (ptr == &mons[PM_GELATINOUS_CUBE] &&
X  					!index(indigestion, otmp->olet))
X***************
X*** 527,533 ****
X  	    nx = poss[i].x;
X  	    ny = poss[i].y;
X  
X! 	    for(j=0; j < MTSZ && j < cnt-1; j++)
X  		if(nx == mtmp->mtrack[j].x && ny == mtmp->mtrack[j].y)
X  		    if(rn2(4*(cnt-j))) goto nxti;
X  
X--- 532,538 ----
X  	    nx = poss[i].x;
X  	    ny = poss[i].y;
X  
X! 	    if (appr != 0) for(j=0; j < MTSZ && j < cnt-1; j++)
X  		if(nx == mtmp->mtrack[j].x && ny == mtmp->mtrack[j].y)
X  		    if(rn2(4*(cnt-j))) goto nxti;
X  
X***************
X*** 534,540 ****
X  	    nearer = (dist2(nx,ny,gx,gy) < dist2(nix,niy,gx,gy));
X  
X  	    if((appr == 1 && nearer) || (appr == -1 && !nearer) ||
X! 		   	!mmoved || (!appr && !rn2(++chcnt))) {
X  		nix = nx;
X  		niy = ny;
X  		chi = i;
X--- 539,545 ----
X  	    nearer = (dist2(nx,ny,gx,gy) < dist2(nix,niy,gx,gy));
X  
X  	    if((appr == 1 && nearer) || (appr == -1 && !nearer) ||
X! 		   	(!appr && !rn2(++chcnt)) || !mmoved) {
X  		nix = nx;
X  		niy = ny;
X  		chi = i;
X***************
X*** 561,567 ****
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X  		mtmp2 = 
X! 		    (levl[nix][niy].mmask ? m_at(nix,niy) : (struct monst *)0);
X  		if(mattackm(mtmp, mtmp2) == 1 && rn2(4) &&
X  			mtmp2->mlstmv != moves && mattackm(mtmp2, mtmp) == 2)
X  		    return(2);
X--- 566,572 ----
X  	    if((info[chi] & ALLOW_M) ||
X  		   (nix == mtmp->mux && niy == mtmp->muy)) {
X  		mtmp2 = 
X! 		    (MON_AT(nix, niy) ? m_at(nix,niy) : (struct monst *)0);
X  		if(mattackm(mtmp, mtmp2) == 1 && rn2(4) &&
X  			mtmp2->mlstmv != moves && mattackm(mtmp2, mtmp) == 2)
X  		    return(2);
X***************
X*** 568,580 ****
X  		return(3);
X  	    }
X  #ifdef WORM
X! 	    /* The square now has a worm segment and must keep its mmask */
X  	    if (!mtmp->wormno)
X  #endif
X! 		    levl[omx][omy].mmask = 0;
X! 	    levl[nix][niy].mmask = 1;
X! 	    mtmp->mx = nix;
X! 	    mtmp->my = niy;
X  	    for(j = MTSZ-1; j > 0; j--)
X  		mtmp->mtrack[j] = mtmp->mtrack[j-1];
X  	    mtmp->mtrack[0].x = omx;
X--- 573,583 ----
X  		return(3);
X  	    }
X  #ifdef WORM
X! 	    /* The square now has a worm segment and must keep its MON_AT() state */
X  	    if (!mtmp->wormno)
X  #endif
X! 		    remove_monster(omx, omy);
X! 	    place_monster(mtmp, nix, niy);
X  	    for(j = MTSZ-1; j > 0; j--)
X  		mtmp->mtrack[j] = mtmp->mtrack[j-1];
X  	    mtmp->mtrack[0].x = omx;
X***************
X*** 688,695 ****
X  		    mtmp->mdy = mtmp->my;
X  		}
X  	    }
X  	}
X- 	pmon(mtmp);
X  	return(mmoved);
X  }
X  
X--- 691,698 ----
X  		    mtmp->mdy = mtmp->my;
X  		}
X  	    }
X+ 	    pmon(mtmp);
X  	}
X  	return(mmoved);
X  }
X  
X***************
X*** 732,734 ****
X--- 735,770 ----
X  	       )
X  	);
X  }
X+ 
X+ #ifdef STUPID_CPP	/* otherwise these functions are macros in rm.h */
X+ /*
X+  * Functions for encapsulation of level.monsters references.
X+  */
X+ void place_monster(mtmp, x, y)
X+ register struct monst *mtmp;
X+ int x, y;
X+ {
X+     level.monsters[x][y] = mtmp;
X+     mtmp->mx = x;
X+     mtmp->my = y;
X+ }
X+ 
X+ void place_worm_seg(mtmp, x, y)
X+ register struct monst *mtmp;
X+ int x, y;
X+ {
X+     level.monsters[x][y] = mtmp;
X+ }
X+ 
X+ void remove_monster(x, y)
X+ int x, y;
X+ {
X+     level.monsters[x][y] = (struct monst *)0;
X+ }
X+ 
X+ struct monst *m_at(x, y)
X+ int x, y;
X+ {
X+     return(level.monsters[x][y]);
X+ }
X+ #endif	/* STUPID_CPP */
X*** src/Old/mthrowu.c	Wed Sep 27 11:58:14 1989
X--- src/mthrowu.c	Tue Sep 26 16:08:05 1989
X***************
X*** 23,38 ****
X  };
X  
X  int
X! thitu(tlev, dam, name)	/* u is hit by sth, but not a monster */
X  	register int tlev, dam;
X  	register char *name;
X  {
X  	char buf[BUFSZ];
X! 	boolean acidic = (!strcmp(name, "splash of venom") && dam);
X! 	/* A horrible kludge... the problem is that we want to do something
X! 	 * special--and we can't do it after returning since we might die and
X! 	 * not return, but the special stuff should be done anyway...
X! 	 */
X  
X  	setan(name, buf);
X  	if(u.uac + tlev <= rnd(20)) {
X--- 23,35 ----
X  };
X  
X  int
X! thitu(tlev, dam, obj, name)	/* u is hit by sth, but not a monster */
X  	register int tlev, dam;
X+ 	struct obj *obj;
X  	register char *name;
X  {
X  	char buf[BUFSZ];
X! 	boolean acidic = (obj && obj->otyp == ACID_VENOM);
X  
X  	setan(name, buf);
X  	if(u.uac + tlev <= rnd(20)) {
X***************
X*** 43,48 ****
X--- 40,52 ----
X  		if(Blind || !flags.verbose) You("are hit!");
X  		else You("are hit by %s!", buf);
X  #ifdef POLYSELF
X+ 		if (obj && obj->otyp == SILVER_ARROW && (u.ulycn != -1 ||
X+ 				is_demon(uasmon) || u.usym == S_VAMPIRE ||
X+ 				(u.usym == S_IMP && u.umonnum != PM_TENGU))) {
X+ 			dam += rnd(20);
X+ 			pline("You feel the %sarrow sear your flesh!",
X+ 				Blind ? "" : "silver ");
X+ 		}
X  		if (acidic && resists_acid(uasmon))
X  			pline("It doesn't seem to hurt you.");
X  		else {
X***************
X*** 106,112 ****
X--- 110,120 ----
X  
X  	if(sym) {
X  		tmp_at(-1, sym);	/* open call */
X+ #ifdef TEXTCOLOR
X+ 		tmp_at(-3, (int)objects[obj->otyp].oc_color);
X+ #else
X  		tmp_at(-3, (int)AT_OBJ);
X+ #endif
X  	}
X  	while(range-- > 0) { /* Actually the loop is always exited by break */
X  		boolean vis;
X***************
X*** 114,120 ****
X  		bhitpos.x += dx;
X  		bhitpos.y += dy;
X  		vis = cansee(bhitpos.x, bhitpos.y);
X! 		if(levl[bhitpos.x][bhitpos.y].mmask) {
X  		    mtmp = m_at(bhitpos.x,bhitpos.y);
X  
X  		    if(mtmp->data->ac + 8 + obj->spe <= rnd(20)) {
X--- 122,128 ----
X  		bhitpos.x += dx;
X  		bhitpos.y += dy;
X  		vis = cansee(bhitpos.x, bhitpos.y);
X! 		if(MON_AT(bhitpos.x, bhitpos.y)) {
X  		    mtmp = m_at(bhitpos.x,bhitpos.y);
X  
X  		    if(mtmp->data->ac + 8 + obj->spe <= rnd(20)) {
X***************
X*** 146,151 ****
X--- 154,169 ----
X  				}
X  			    }
X  			}
X+ 			if (obj->otyp==SILVER_ARROW && (is_were(mtmp->data)
X+ 				|| is_demon(mtmp->data)
X+ 				|| mtmp->data->mlet == S_VAMPIRE
X+ 				|| (mtmp->data->mlet==S_IMP
X+ 					&& mtmp->data != &mons[PM_TENGU]))) {
X+ 			    if (vis) pline("The silver arrow sears %s's flesh!",
X+ 				mon_nam(mtmp));
X+ 			    else pline("Its flesh is seared!");
X+ 			    damage += rnd(20);
X+ 			}
X  			if (obj->otyp==ACID_VENOM && cansee(mtmp->mx,mtmp->my)){
X  			    if (resists_acid(mtmp->data)) {
X  				pline("%s is unaffected.", vis ? Monnam(mtmp)
X***************
X*** 186,197 ****
X  			    int dam;
X  			    case CREAM_PIE:
X  			    case BLINDING_VENOM:
X! 				hitu = thitu(8, 0, xname(singleobj));
X  				break;
X  			    default:
X  				dam = dmgval(obj, uasmon);
X  				if (dam < 1) dam = 1;
X! 				hitu = thitu(8+obj->spe, dam, xname(singleobj));
X  			}
X  			if (hitu && obj->opoisoned)
X  			    /* it's safe to call xname twice because it's the
X--- 204,216 ----
X  			    int dam;
X  			    case CREAM_PIE:
X  			    case BLINDING_VENOM:
X! 				hitu = thitu(8, 0, singleobj, xname(singleobj));
X  				break;
X  			    default:
X  				dam = dmgval(obj, uasmon);
X  				if (dam < 1) dam = 1;
X! 				hitu = thitu(8+obj->spe, dam, singleobj,
X! 					xname(singleobj));
X  			}
X  			if (hitu && obj->opoisoned)
X  			    /* it's safe to call xname twice because it's the
X*** src/Old/music.c	Wed Sep 27 11:58:33 1989
X--- src/music.c	Mon Sep 25 22:58:27 1989
X***************
X*** 206,212 ****
X  			    /* We have to check whether monsters or player
X  			       fall in a chasm... */
X  
X! 			    if (levl[x][y].mmask) {
X  				mtmp = m_at(x,y);
X  				if(!is_flyer(mtmp->data)) {
X  				    mtmp->mtrapped = 1;
X--- 206,212 ----
X  			    /* We have to check whether monsters or player
X  			       fall in a chasm... */
X  
X! 			    if (MON_AT(x, y)) {
X  				mtmp = m_at(x,y);
X  				if(!is_flyer(mtmp->data)) {
X  				    mtmp->mtrapped = 1;
X***************
X*** 253,259 ****
X  			    if (cansee(x,y))
X  				pline("The door collapses.");
X  			    levl[x][y].doormask = D_NODOOR;
X! 			    if (!levl[x][y].mmask && !(x == u.ux && y == u.uy))
X  				newsym(x,y);
X  			    break;
X  		    }
X--- 253,259 ----
X  			    if (cansee(x,y))
X  				pline("The door collapses.");
X  			    levl[x][y].doormask = D_NODOOR;
X! 			    if (!MON_AT(x, y) && !(x == u.ux && y == u.uy))
X  				newsym(x,y);
X  			    break;
X  		    }
X***************
X*** 415,429 ****
X  			}
X  		    if(tumblers)
X  			if(gears)
X! 			You("hear %d tumbler%s click and %d gear%s turn.",
X! 			    tumblers, (tumblers > 1 ? "s" : ""),
X! 			    gears, (gears > 1 ? "s" : ""));
X  			else
X  			    You("hear %d tumbler%s click.",
X! 			    tumblers, (tumblers > 1 ? "s" : ""));
X  		    else if(gears)
X  			You("hear %d gear%s turn.",
X! 			gears, (gears > 1 ? "s" : ""));
X  		}
X  	    }
X  	return 1;
X--- 415,429 ----
X  			}
X  		    if(tumblers)
X  			if(gears)
X! 			    You("hear %d tumbler%s click and %d gear%s turn.",
X! 				tumblers, plur((long)tumblers),
X! 				gears, plur((long)gears));
X  			else
X  			    You("hear %d tumbler%s click.",
X! 				tumblers, plur((long)tumblers));
X  		    else if(gears)
X  			You("hear %d gear%s turn.",
X! 			    gears, plur((long)gears));
X  		}
X  	    }
X  	return 1;
X*** src/Old/o_init.c	Wed Sep 27 12:06:05 1989
X--- src/o_init.c	Fri Sep 15 00:50:41 1989
X***************
X*** 36,48 ****
X  {
X  	register int j,first;
X  #ifdef STRONGHOLD
X! 	int level = (dlevel > MAXLEVEL) ? MAXLEVEL : dlevel;
X  #endif
X  
X  	first = bases[letindex(GEM_SYM)];
X  
X  #ifdef STRONGHOLD
X! 	for(j = 0; j < 9-level/3; j++)
X  #else
X  	for(j = 0; j < 9-dlevel/3; j++)
X  #endif
X--- 36,48 ----
X  {
X  	register int j,first;
X  #ifdef STRONGHOLD
X! 	int lev = (dlevel > MAXLEVEL) ? MAXLEVEL : dlevel;
X  #endif
X  
X  	first = bases[letindex(GEM_SYM)];
X  
X  #ifdef STRONGHOLD
X! 	for(j = 0; j < 9-lev/3; j++)
X  #else
X  	for(j = 0; j < 9-dlevel/3; j++)
X  #endif
X***************
X*** 54,60 ****
X  		Printf("Not enough gems? - first=%d j=%d LAST_GEM=%d\n",
X  			first, j, LAST_GEM);
X  	for(j = first; j < LAST_GEM; j++)
X! 		objects[j].oc_prob = (180+j-first)/(LAST_GEM-first);
X  }
X  
X  /* shuffle descriptions on objects o_low to o_high */
X--- 54,60 ----
X  		Printf("Not enough gems? - first=%d j=%d LAST_GEM=%d\n",
X  			first, j, LAST_GEM);
X  	for(j = first; j < LAST_GEM; j++)
X! 		objects[j].oc_prob = (184+j-first)/(LAST_GEM-first);
X  }
X  
X  /* shuffle descriptions on objects o_low to o_high */
X***************
X*** 66,71 ****
X--- 66,74 ----
X  {
X  	register int i, j;
X  	char *desc;
X+ #ifdef TEXTCOLOR
X+ 	int color;
X+ #endif /* TEXTCOLOR */
X  	int tmp;
X  
X  	for(j=o_low; j <= o_high; j++) {
X***************
X*** 73,78 ****
X--- 76,86 ----
X  		desc = objects[j].oc_descr;
X  		objects[j].oc_descr = objects[i].oc_descr;
X  		objects[i].oc_descr = desc;
X+ #ifdef TEXTCOLOR
X+ 		color = objects[j].oc_color;
X+ 		objects[j].oc_color = objects[i].oc_color;
X+ 		objects[i].oc_color = color;
X+ #endif /* TEXTCOLOR */
X  		/* shuffle discovery list */
X  		tmp = disco[j];
X  		disco[j] = disco[i];
X*** src/Old/objnam.c	Wed Sep 27 12:07:22 1989
X--- src/objnam.c	Tue Sep 26 18:19:25 1989
X***************
X*** 203,209 ****
X  	    case TOOL_SYM:
X  		if(nn)	Strcat(buf, an);
X  		else	Strcat(buf, dn);
X! 		if(obj->otyp == FIGURINE && obj->known) {
X  			Sprintf(eos(buf), " of a%s %s",
X  				index(vowels, *mons[obj->corpsenm].mname)
X  								? "n" : "",
X--- 203,209 ----
X  	    case TOOL_SYM:
X  		if(nn)	Strcat(buf, an);
X  		else	Strcat(buf, dn);
X! 		if(obj->otyp == FIGURINE) {
X  			Sprintf(eos(buf), " of a%s %s",
X  				index(vowels, *mons[obj->corpsenm].mname)
X  								? "n" : "",
X***************
X*** 503,508 ****
X--- 503,510 ----
X  		}
X  		break;
X  	case FOOD_SYM:
X+ 		if(OEATEN(obj))
X+ 		    Strcat(prefix, "partly eaten ");
X  		if(obj->otyp == CORPSE) {
X  		    Strcat(prefix, mons[obj->corpsenm].mname);
X  		    Strcat(prefix, " ");
X***************
X*** 524,532 ****
X  	}
X  
X  	if((obj->owornmask & W_WEP) && !mrg_to_wielded) {
X! 		Strcat(bp, " (weapon in ");
X! 		Strcat(bp, body_part(HAND));
X! 		Strcat(bp, ")");
X  	}
X  	if(obj->unpaid)
X  		Strcat(bp, " (unpaid)");
X--- 526,538 ----
X  	}
X  
X  	if((obj->owornmask & W_WEP) && !mrg_to_wielded) {
X! 		if (obj->quan != 1)
X! 			Strcat(bp, " (wielded)");
X! 		else {
X! 			Strcat(bp, " (weapon in ");
X! 			Strcat(bp, body_part(HAND));
X! 			Strcat(bp, ")");
X! 		}
X  	}
X  	if(obj->unpaid)
X  		Strcat(bp, " (unpaid)");
X***************
X*** 541,547 ****
X  	return(bp);
X  }
X  
X! /* used only in fight.c (thitu) */
X  void
X  setan(str,buf)
X  register char *str,*buf;
X--- 547,553 ----
X  	return(bp);
X  }
X  
X! /* used only in mthrowu.c (thitu) */
X  void
X  setan(str,buf)
X  register char *str,*buf;
X***************
X*** 562,568 ****
X  	}
X  
X  	if(verb) {
X! 		/* verb is given in plural (i.e., without trailing s) */
X  		Strcat(bp, " ");
X  		if(otmp->quan != 1)
X  			Strcat(bp, verb);
X--- 568,574 ----
X  	}
X  
X  	if(verb) {
X! 		/* verb is given in plural (without trailing s) */
X  		Strcat(bp, " ");
X  		if(otmp->quan != 1)
X  			Strcat(bp, verb);
X***************
X*** 633,639 ****
X  	}
X  	Strcpy(str, oldstr);
X  
X! 	/* Search for common compounds, i.e. lump of royal jelly */
X  	for(excess=(char *)0, spot=str; *spot; spot++) {
X  		if (!strncmp(spot, " of ", 4)
X  				|| !strncmp(spot, " labeled ", 9)
X--- 639,645 ----
X  	}
X  	Strcpy(str, oldstr);
X  
X! 	/* Search for common compounds, ex. lump of royal jelly */
X  	for(excess=(char *)0, spot=str; *spot; spot++) {
X  		if (!strncmp(spot, " of ", 4)
X  				|| !strncmp(spot, " labeled ", 9)
X***************
X*** 825,833 ****
X  	register char *p;
X  	register int i;
X  	register struct obj *otmp;
X! 	int cnt, spe, spesgn, typ, heavy, blessed, uncursed;
X! 	int iscursed, ispoisoned, mntmp, contents, iskey=0;
X! 	int  isnamedbox=0;
X  #ifdef TUTTI_FRUTTI
X  	struct fruit *f;
X  	int ftype = current_fruit;
X--- 831,839 ----
X  	register char *p;
X  	register int i;
X  	register struct obj *otmp;
X! 	int cnt, spe, spesgn, typ, heavy, blessed, uncursed, halfeaten;
X! 	int iscursed, ispoisoned, mntmp, contents;
X! 	int iskey, isnamedbox;
X  #ifdef TUTTI_FRUTTI
X  	struct fruit *f;
X  	int ftype = current_fruit;
X***************
X*** 845,852 ****
X  	int fake=0;
X  #endif
X  
X! 	cnt = spe = spesgn = typ = heavy = 
X! 		blessed = uncursed = iscursed = ispoisoned = 0;
X  	mntmp = -1;
X  #define UNDEFINED 0
X  #define EMPTY 1
X--- 851,858 ----
X  	int fake=0;
X  #endif
X  
X! 	cnt = spe = spesgn = typ = heavy = blessed = uncursed = iscursed =
X! 		ispoisoned = halfeaten = iskey = isnamedbox = 0;
X  	mntmp = -1;
X  #define UNDEFINED 0
X  #define EMPTY 1
X***************
X*** 875,883 ****
X  			cnt = atoi(bp);
X  			while(digit(*bp)) bp++;
X  			while(*bp == ' ') bp++;
X! 		} else if(!strncmp(bp,"blessed ",8) || !strncmp(bp,"holy ",5)) {
X  			blessed=1;
X  			bp += 8;
X  		} else if(!strncmp(bp,"cursed ",7) || !strncmp(bp,"unholy ",7)){
X  			iscursed=1;
X  			bp += 7;
X--- 881,895 ----
X  			cnt = atoi(bp);
X  			while(digit(*bp)) bp++;
X  			while(*bp == ' ') bp++;
X! 		} else if(!strncmp(bp, "partly eaten ", 13)) {
X! 			halfeaten = 1;
X! 			bp += 13;
X! 		} else if(!strncmp(bp,"blessed ",8)) {
X  			blessed=1;
X  			bp += 8;
X+ 		} else if(!strncmp(bp,"holy ",5)) {
X+ 			blessed=1;
X+ 			bp += 5;
X  		} else if(!strncmp(bp,"cursed ",7) || !strncmp(bp,"unholy ",7)){
X  			iscursed=1;
X  			bp += 7;
X***************
X*** 996,1001 ****
X--- 1008,1014 ----
X  	}
X  	/* Find corpse type w/o "of" (red dragon scale mail, yeti corpse) */
X  	if (strncmp(bp, "samurai sword", 13)) /* not the "samurai" monster! */
X+ 	if (strncmp(bp, "wizard lock", 11)) /* not the "wizard" monster! */
X  	if (strncmp(bp, "orcish", 6)) /* not the "orc" monster! */
X  	if (mntmp < 0) if ((mntmp = name_to_mon(bp)) >= 0) {
X  		bp += strlen(mons[mntmp].mname);
X***************
X*** 1161,1167 ****
X  #endif
X  						) cnt=5000;
X  		if (cnt < 1) cnt=1;
X! 		pline("%d gold piece%s.", cnt, cnt==1 ? "" : "s");
X  		u.ugold += cnt;
X  		flags.botl=1;
X  		return (&zeroobj);
X--- 1174,1180 ----
X  #endif
X  						) cnt=5000;
X  		if (cnt < 1) cnt=1;
X! 		pline("%d gold piece%s.", cnt, plur((long)cnt));
X  		u.ugold += cnt;
X  		flags.botl=1;
X  		return (&zeroobj);
X***************
X*** 1213,1219 ****
X  	/* helmet is not generic */
X  
X  	an = bp;
X! 	if (!dn) dn = an; /* i.e., "black cap" */
X  srch:
X  	i = 1;
X  	if(let) i = bases[letindex(let)];
X--- 1226,1232 ----
X  	/* helmet is not generic */
X  
X  	an = bp;
X! 	if (!dn) dn = an; /* ex. "black cap" */
X  srch:
X  	i = 1;
X  	if(let) i = bases[letindex(let)];
X***************
X*** 1262,1274 ****
X  	 * wizards to wish for it since it's faster than polymorphing and
X  	 * spitting.
X  	 */
X! 	if(otmp->olet==VENOM_SYM
X  #ifdef WIZARD
X! 				&& !wizard
X  #endif
X- 						) {
X- 		free((genericptr_t) otmp);
X- 		return((struct obj *)0);
X  	}
X  	if(iskey) otmp->spe = (iskey-1);
X  	if(isnamedbox && (otmp->otyp==LARGE_BOX || otmp->otyp==CHEST))
X--- 1275,1289 ----
X  	 * wizards to wish for it since it's faster than polymorphing and
X  	 * spitting.
X  	 */
X! 	if(otmp->olet==VENOM_SYM) {
X! #ifdef WIZARD
X! 		if (!wizard) {
X! #endif
X! 			free((genericptr_t) otmp);
X! 			return((struct obj *)0);
X  #ifdef WIZARD
X! 		} else otmp->spe = 1;
X  #endif
X  	}
X  	if(iskey) otmp->spe = (iskey-1);
X  	if(isnamedbox && (otmp->otyp==LARGE_BOX || otmp->otyp==CHEST))
X***************
X*** 1303,1309 ****
X  		if (spe > otmp->spe) spe = otmp->spe;
X  	}
X  
X! 	if (spesgn == -1 && spe > 0) spe = -spe;
X  
X  	/* set otmp->spe.  This may, or may not, use spe... */
X  	switch (typ) {
X--- 1318,1324 ----
X  		if (spe > otmp->spe) spe = otmp->spe;
X  	}
X  
X! 	if (spesgn == -1) spe = -spe;
X  
X  	/* set otmp->spe.  This may, or may not, use spe... */
X  	switch (typ) {
X***************
X*** 1379,1385 ****
X  		case DRAGON_SCALE_MAIL: /* Not actually possible unless they
X  				   typed "red dragon dragon scale mail" */
X  		case SCALE_MAIL:
X! 			if (mntmp >= PM_GREY_DRAGON &&
X  			    mntmp <= PM_YELLOW_DRAGON)
X  				otmp->corpsenm = mntmp;
X  			if (otmp->corpsenm >= 0)
X--- 1394,1400 ----
X  		case DRAGON_SCALE_MAIL: /* Not actually possible unless they
X  				   typed "red dragon dragon scale mail" */
X  		case SCALE_MAIL:
X! 			if (mntmp >= PM_GRAY_DRAGON &&
X  			    mntmp <= PM_YELLOW_DRAGON)
X  				otmp->corpsenm = mntmp;
X  			if (otmp->corpsenm >= 0)
X***************
X*** 1420,1447 ****
X  	if (name) otmp = oname(otmp, name, 0);
X  	otmp->owt = weight(otmp);
X  	if (heavy) otmp->owt += 15;
X  	return(otmp);
X- }
X- 
X- boolean
X- uses_known(otmp)
X- register struct obj *otmp;
X- /* returns TRUE if otmp->known would be used to affect the full description
X-  * of the item
X-  * if not, otmp->dknown and otmp->bknown give all the information of otmp->known
X-  * and otmp->known should always be set to avoid problems with items not
X-  * merging due to different values of otmp->known
X-  */
X- {
X- 	return (otmp->olet == ARMOR_SYM ||
X- 		otmp->olet == WAND_SYM ||
X- 		otmp->olet == WEAPON_SYM ||
X- 		((otmp->olet == TOOL_SYM || otmp->olet == RING_SYM) &&
X- 		    objects[otmp->otyp].oc_charged) ||
X- 		otmp->otyp == FIGURINE ||
X- 		otmp->otyp == EGG ||
X- 		otmp->otyp == TIN ||
X- 		otmp->otyp == AMULET_OF_YENDOR);
X  }
X  
X  static int
X--- 1435,1442 ----
X  	if (name) otmp = oname(otmp, name, 0);
X  	otmp->owt = weight(otmp);
X  	if (heavy) otmp->owt += 15;
X+ 	if (halfeaten && otmp->olet == FOOD_SYM) OEATEN(otmp) = 1;
X  	return(otmp);
X  }
X  
X  static int
X*** src/Old/options.c	Wed Sep 27 12:08:11 1989
X--- src/options.c	Mon Sep 25 23:23:08 1989
X***************
X*** 5,11 ****
X  #include "hack.h"
X  static boolean set_order;
X  
X! static void nmcpy();
X  
X  void
X  initoptions()
X--- 5,12 ----
X  #include "hack.h"
X  static boolean set_order;
X  
X! static void nmcpy P((char *, char *, int));
X! static int next_opt P((char *));
X  
X  void
X  initoptions()
X***************
X*** 28,33 ****
X--- 29,37 ----
X  	nmcpy(pl_fruit, objects[SLIME_MOLD].oc_name, PL_FSIZ);
X  #endif
X  	flags.num_pad = FALSE;
X+ #ifdef TEXTCOLOR
X+ 	flags.use_color = TRUE;
X+ #endif
X  #ifdef MSDOS
X  #ifdef DECRAINBOW
X  	flags.DECRainbow = FALSE;
X***************
X*** 260,265 ****
X--- 264,276 ----
X  		return;
X  	}
X  
X+ #ifdef TEXTCOLOR
X+ 	if (!strncmp(opts, "col", 3)) {
X+ 		flags.use_color = !negated;
X+ 		return;
X+ 	}
X+ #endif
X+ 
X  #ifdef DGK
X  	if (!strncmp(opts, "IBM", 3)) {
X  		flags.IBMBIOS = !negated;
X***************
X*** 546,551 ****
X--- 557,565 ----
X  		Strcat(buf, inv_order);
X  		Strcat(buf, ",");
X  	    }
X+ #ifdef TEXTCOLOR
X+ 	    if (flags.use_color) Strcat(buf, "color,");
X+ #endif
X  	    if (flags.confirm) Strcat(buf,"confirm,");
X  	    if (flags.safe_dog) Strcat(buf,"safe_pet,");
X  	    if (flags.pickup) Strcat(buf,"pickup,");
X***************
X*** 580,585 ****
X--- 594,600 ----
X  }
X  
X  #define Page_line(x)	if(page_line(x)) goto quit
X+ #define Next_opt(x)	if (next_opt(x)) goto quit
X  
X  void
X  option_help() {
X***************
X*** 601,624 ****
X  	Page_line("");
X  
X  	Page_line("Boolean options (which can be negated by prefixing them with '!' or \"no\"):");
X- 	Page_line("confirm, (fe)male, fixinv, pickup, rest_on_space, safe_pet, silent, sortpack,");
X  #ifdef MSDOS
X! #ifdef NEWS
X! 	Page_line("time, tombstone, verbose, news, number_pad, rawio, and IBM_BIOS");
X! #else
X! 	Page_line("time, tombstone, verbose, number_pad, rawio, and IBM_BIOS");
X  #endif
X! #ifdef DECRAINBOW
X! 	Page_line("and DEC_Rainbow.");
X! #endif /* DECRAINBOW */
X! #else /* MSDOS */
X  #ifdef NEWS
X! 	Page_line("time, tombstone, verbose, news, null, ignintr, and standout.");
X! #else
X! 	Page_line("time, tombstone, verbose, null, ignintr, and standout.");
X  #endif
X! #endif /* MSDOS */
X! 	Page_line("");
X  
X  	Page_line("Compound options:");
X  	Page_line("`name'      - your character's name (e.g., name:Merlin-W),");
X--- 616,654 ----
X  	Page_line("");
X  
X  	Page_line("Boolean options (which can be negated by prefixing them with '!' or \"no\"):");
X  #ifdef MSDOS
X! # ifdef DECRAINBOW
X! 	Next_opt("DEC_Rainbow, ");
X! # endif
X! 	Next_opt("IBM_BIOS, ");
X  #endif
X! #ifdef TEXTCOLOR
X! 	Next_opt("color, ");
X! #endif
X! 	Next_opt("confirm, ");
X! 	Next_opt("(fe)male, "); Next_opt("fixinv, ");
X! #ifdef UNIX
X! 	Next_opt("ignintr, ");
X! #endif
X  #ifdef NEWS
X! 	Next_opt("news, ");
X  #endif
X! #ifdef UNIX
X! 	Next_opt("null, ");
X! #endif
X! 	Next_opt("number_pad, ");
X! 	Next_opt("pickup, ");
X! #ifdef MSDOS
X! 	Next_opt("rawio, ");
X! #endif
X! 	Next_opt("rest_on_space, "); Next_opt("safe_pet, ");
X! 	Next_opt("silent, "); Next_opt("sortpack, ");
X! #ifdef UNIX
X! 	Next_opt("standout, ");
X! #endif
X! 	Next_opt("time, "); Next_opt("tombstone, ");
X! 	Next_opt("and verbose.");
X! 	Next_opt("");
X  
X  	Page_line("Compound options:");
X  	Page_line("`name'      - your character's name (e.g., name:Merlin-W),");
X***************
X*** 642,647 ****
X--- 672,702 ----
X  quit:
X  	set_pager(2);
X  	return;
X+ }
X+ 
X+ /*
X+  * prints the next boolean option, on the same line if possible, on a new
X+  * line if not
X+  */
X+ static int
X+ next_opt(str)
X+ 	char *str;
X+ {
X+ 	static char buf[80];
X+ 	static int i = 0;
X+ 	int r = 0;
X+ 
X+ 	i += strlen(str);
X+ 	if (i > (CO - 2) || !*str) {
X+ 		r = page_line(buf);
X+ 		buf[0] = 0;
X+ 		i = strlen(str);
X+ 	}
X+ 	if (*str)
X+ 		strcat(buf, str);
X+ 	else
X+ 		(void) page_line(str);	/* always returns 0 on "" */
X+ 	return r;
X  }
X  
X  #ifdef TUTTI_FRUTTI
X*** src/Old/pager.c	Wed Sep 27 12:08:41 1989
X--- src/pager.c	Wed Sep 27 09:29:44 1989
X***************
X*** 29,35 ****
X  	FILE *fp;
X  	char bufr[BUFSZ+6];
X  	register char *buf = &bufr[6], *ep, q;
X- 	register struct monst *mtmp;
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X  
X--- 29,34 ----
X***************
X*** 44,50 ****
X  	else {
X  		coord	cc;
X  		uchar	r;
X- 		boolean bycurs = FALSE;
X  
X  		pline ("Specify unknown object by cursor? ");
X  		q = ynq();
X--- 43,48 ----
X***************
X*** 56,62 ****
X  			pline("Specify what? ");
X  			r = readchar();
X  		} else {
X- 		    bycurs = TRUE;
X  		    cc.x = u.ux;
X  		    cc.y = u.uy;
X  	selobj:
X--- 54,59 ----
X***************
X*** 68,73 ****
X--- 65,71 ----
X  			    return 0;
X  		    }
X  		    r = levl[cc.x][cc.y].scrsym;
X+ 		    if (!r || !levl[cc.x][cc.y].seen) r = ' ';
X  		}
X  
X  #define conv_sym(x)	if(r == showsyms.x) q = defsyms.x
X***************
X*** 109,131 ****
X  		else conv_sym(dbvwall);
X  		else conv_sym(dbhwall);
X  #endif
X- 		else q = r;
X  #undef conv_sym
X! 
X! 		if (index(quitchars, q)) {
X! 			(void) fclose(fp); /* sweet@scubed */
X! 			return 0;
X! 		}
X! 		if(q == '%') {
X! 			pline("%%       a piece of food");
X! 			if(bycurs) {
X! 				buf = &bufr[6];
X! 				more();
X! 				rewind(fp);
X! 				goto selobj;
X  			}
X- 			(void) fclose(fp);
X- 			return 0;
X  		}
X  
X  		if(q != '\t')
X--- 107,119 ----
X  		else conv_sym(dbvwall);
X  		else conv_sym(dbhwall);
X  #endif
X  #undef conv_sym
X! 		else {
X! 			q = r;
X! 			if (index(quitchars, q)) {
X! 				(void) fclose(fp); /* sweet@scubed */
X! 				return 0;
X  			}
X  		}
X  
X  		if(q != '\t')
X***************
X*** 140,152 ****
X  				buf[0] = r;
X  				(void) strncpy(buf+1, "       ", 7);
X  			}
X! 			pline(buf);
X  			if(cc.x != -1) {
X  #ifdef ALTARS
X  			    if (r == showsyms.altar && q == defsyms.altar &&
X  				(IS_ALTAR(levl[cc.x][cc.y].typ) ||
X! 				 (levl[cc.x][cc.y].mmask &&
X! 				    m_at(cc.x,cc.y)->mimic))
X  			       ) {
X  				    int type = levl[cc.x][cc.y].altarmask &
X  						~A_SHRINE;
X--- 128,146 ----
X  				buf[0] = r;
X  				(void) strncpy(buf+1, "       ", 7);
X  			}
X! 			/* use %s so '%' won't be interpreted as a format */
X! 			pline("%s", buf);
X  			if(cc.x != -1) {
X+ 			    register struct monst *mtmp;
X+ 
X+ 			    if(MON_AT(cc.x,cc.y))
X+ 				mtmp = m_at(cc.x,cc.y);
X+ 			    else
X+ 				mtmp = (struct monst *) 0;
X  #ifdef ALTARS
X  			    if (r == showsyms.altar && q == defsyms.altar &&
X  				(IS_ALTAR(levl[cc.x][cc.y].typ) ||
X! 				 (mtmp && mtmp->mimic))
X  			       ) {
X  				    int type = levl[cc.x][cc.y].altarmask &
X  						~A_SHRINE;
X***************
X*** 154,167 ****
X  					  (type == A_NEUTRAL) ? "(neutral)" :
X  					  "(lawful)");
X  			    } else
X  			    if (q == CHAIN_SYM && OBJ_AT(cc.x, cc.y))
X  				    pline("(chain)");
X! 			    else
X! #endif
X! 			    if (r == showsyms.door && q == defsyms.door &&
X  				(IS_DOOR(levl[cc.x][cc.y].typ) ||
X!                                  (levl[cc.x][cc.y].mmask &&
X! 				    m_at(cc.x,cc.y)->mimic))) {
X  				/* Note: this will say mimics in walls are
X  				 *	 closed doors, which we want.
X  				 */
X--- 148,159 ----
X  					  (type == A_NEUTRAL) ? "(neutral)" :
X  					  "(lawful)");
X  			    } else
X+ #endif
X  			    if (q == CHAIN_SYM && OBJ_AT(cc.x, cc.y))
X  				    pline("(chain)");
X! 			    else if (r == showsyms.door && q == defsyms.door &&
X  				(IS_DOOR(levl[cc.x][cc.y].typ) ||
X! 				 (mtmp && mtmp->mimic))) {
X  				/* Note: this will say mimics in walls are
X  				 *	 closed doors, which we want.
X  				 */
X***************
X*** 191,215 ****
X  				IS_SINK(levl[cc.x][cc.y].typ))
X  				    pline("(sink)");
X  #endif
X! 			}
X! 			if (!Invisible 
X  #ifdef POLYSELF
X  				&& !u.uundetected
X  #endif
X  					&& u.ux==cc.x && u.uy==cc.y) {
X! 			    pline("(%s named %s)",
X  #ifdef POLYSELF
X! 				u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X! 				pl_character, plname);
X! 			} else if(levl[cc.x][cc.y].mmask) {
X! 			    mtmp = m_at(cc.x,cc.y);
X! 			    if (q == mtmp->data->mlet)
X! 				pline("(%s%s)",
X! 				    mtmp->mtame ? "tame " :
X! 				      mtmp->mpeaceful ? "peaceful " : "",
X! 				    strncmp(lmonnam(mtmp), "the ", 4)
X! 				      ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X  			}
X  			if(ep[-1] == ';') {
X  				pline("More info? ");
X--- 183,211 ----
X  				IS_SINK(levl[cc.x][cc.y].typ))
X  				    pline("(sink)");
X  #endif
X! 			    if (!Invisible 
X  #ifdef POLYSELF
X  				&& !u.uundetected
X  #endif
X  					&& u.ux==cc.x && u.uy==cc.y) {
X! 				pline("(%s named %s)",
X  #ifdef POLYSELF
X! 				    u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X! 				    pl_character, plname);
X! 			    /* Note: the blind/telepathy check is necessary.
X! 			     * Otherwise a ghost sitting on a blank square
X! 			     * gets identified even while blind because the
X! 			     * symbol is "correct".
X! 			     */
X! 			    } else if (mtmp && (!Blind || Telepat)) {
X! 				if (q == mtmp->data->mlet)
X! 				    pline("(%s%s)",
X! 					mtmp->mtame ? "tame " :
X! 					  mtmp->mpeaceful ? "peaceful " : "",
X! 					strncmp(lmonnam(mtmp), "the ", 4)
X! 					  ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X! 			    }
X  			}
X  			if(ep[-1] == ';') {
X  				pline("More info? ");
X***************
X*** 218,224 ****
X  					return 0;
X  				}
X  			}
X! 			if(bycurs) {
X  				buf = &bufr[6];
X  				more();
X  				rewind(fp);
X--- 214,220 ----
X  					return 0;
X  				}
X  			}
X! 			if(cc.x != -1) {
X  				buf = &bufr[6];
X  				more();
X  				rewind(fp);
X***************
X*** 254,264 ****
X  	}
X  
X  	pline("What command? ");
X! #ifdef UNIX
X  	introff();
X  #endif
X  	q = readchar();
X! #ifdef UNIX
X  	intron();
X  #endif
X  	ctrl = ((q <= '\033') ? (q - 1 + 'A') : 0);
X--- 250,260 ----
X  	}
X  
X  	pline("What command? ");
X! #if defined(UNIX) || defined(VMS)
X  	introff();
X  #endif
X  	q = readchar();
X! #if defined(UNIX) || defined(VMS)
X  	intron();
X  #endif
X  	ctrl = ((q <= '\033') ? (q - 1 + 'A') : 0);
X***************
X*** 282,288 ****
X  			buf[0] = q;
X  			(void) strncpy(buf+1, "       ", 7);
X  		}
X! 		pline(buf);
X  		(void) fclose(fp);
X  		return 0;
X  	    }
X--- 278,284 ----
X  			buf[0] = q;
X  			(void) strncpy(buf+1, "       ", 7);
X  		}
X! 		pline("%s", buf);
X  		(void) fclose(fp);
X  		return 0;
X  	    }
X***************
X*** 514,520 ****
X  
X  	/* --- now we really do it --- */
X  	if(mode == 2 && linect == 1)			    /* topline only */
X! 		pline(texthead->line_text);
X  	else
X  	if(mode == 2) {
X  	    register int curline, lth;
X--- 510,516 ----
X  
X  	/* --- now we really do it --- */
X  	if(mode == 2 && linect == 1)			    /* topline only */
X! 		pline("%s", texthead->line_text);
X  	else
X  	if(mode == 2) {
X  	    register int curline, lth;
X***************
X*** 760,765 ****
X--- 756,762 ----
X  }
X  #endif /* SHELL /**/
X  
X+ #if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
X  int
X  child(wt)
X  int wt;
X***************
X*** 806,809 ****
X--- 803,807 ----
X  	docrt();
X  	return(0);
X  }
X+ #endif
X  #endif /* UNIX /**/
X*** src/Old/panic.c	Wed Sep 27 12:09:11 1989
X--- src/panic.c	Sun Sep 17 14:26:41 1989
X***************
X*** 6,11 ****
X--- 6,12 ----
X   */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define NEED_VARARGS
X  #include	"config.h"
X  
X  #ifdef MSDOS
X***************
X*** 17,25 ****
X  boolean panicking;
X  
X  void
X! panic(str,a1,a2,a3,a4,a5,a6)
X! char *str;
X! {
X  	if(panicking++)
X  #ifdef SYSV
X  	    (void)
X--- 18,26 ----
X  boolean panicking;
X  
X  void
X! panic VA_DECL(char *,str)
X! 	VA_START(str);
X! 	VA_INIT(str, char *);
X  	if(panicking++)
X  #ifdef SYSV
X  	    (void)
X***************
X*** 27,40 ****
X  		abort();    /* avoid loops - this should never happen*/
X  
X  	(void) fputs(" ERROR:  ", stderr);
X! 	Printf(str,a1,a2,a3,a4,a5,a6);
X  	(void) fflush(stderr);
X! #ifdef UNIX
X  # ifdef SYSV
X  		(void)
X  # endif
X  		    abort();	/* generate core dump */
X  #endif
X  	exit(1);		/* redundant */
X  	return;
X  }
X--- 28,42 ----
X  		abort();    /* avoid loops - this should never happen*/
X  
X  	(void) fputs(" ERROR:  ", stderr);
X! 	Vprintf(str,VA_ARGS);
X  	(void) fflush(stderr);
X! #if defined(UNIX) || defined(VMS)
X  # ifdef SYSV
X  		(void)
X  # endif
X  		    abort();	/* generate core dump */
X  #endif
X+ 	VA_END();
X  	exit(1);		/* redundant */
X  	return;
X  }
X*** src/Old/pickup.c	Wed Sep 27 12:09:25 1989
X--- src/pickup.c	Tue Sep 26 12:59:19 1989
X***************
X*** 29,37 ****
X  	dummygold.oy = u.uy;
X  	dummygold.olet = GOLD_SYM;
X  	dummygold.nobj = fobj;
X  	dummygold.cobj = 0;
X  
X! 	if(Levitation) return;
X  	if (all && !flags.pickup) {
X  		int ct = 0;
X  
X--- 29,41 ----
X  	dummygold.oy = u.uy;
X  	dummygold.olet = GOLD_SYM;
X  	dummygold.nobj = fobj;
X+ 	dummygold.nexthere = level.objects[u.ux][u.uy];
X  	dummygold.cobj = 0;
X  
X! 	if(Levitation) {
X! 		if (all && !flags.pickup) read_engr_at(u.ux,u.uy);
X! 		return;
X! 	}
X  	if (all && !flags.pickup) {
X  		int ct = 0;
X  
X***************
X*** 65,72 ****
X  		register int ct = 0;
X  
X  		if (gold) ct++;
X! 		for(obj = fobj; obj; obj = obj->nobj)
X! 		    if(obj->ox == u.ux && obj->oy == u.uy)
X  			if(!obj->cobj) ct++;
X  		if(ct < 2)
X  			all++;
X--- 69,75 ----
X  		register int ct = 0;
X  
X  		if (gold) ct++;
X! 		for(obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X  			if(!obj->cobj) ct++;
X  		if(ct < 2)
X  			all++;
X***************
X*** 76,82 ****
X  
X  	/* added by GAN 10/24/86 to allow selective picking up */
X  	if(!all)  {
X! 		register struct obj *otmp = fobj;
X  
X  		ilets[iletct] = 0;
X  		if(gold) {
X--- 79,85 ----
X  
X  	/* added by GAN 10/24/86 to allow selective picking up */
X  	if(!all)  {
X! 		register struct obj *otmp = level.objects[u.ux][u.uy];
X  
X  		ilets[iletct] = 0;
X  		if(gold) {
X***************
X*** 84,95 ****
X  			ilets[iletct] = 0;
X  		}
X  		while(otmp) {
X! 			if(!index(ilets, otmp->olet) && !otmp->cobj &&
X! 			   otmp->ox == u.ux && otmp->oy == u.uy)  {
X  				ilets[iletct++] = otmp->olet;
X  				ilets[iletct] = 0;
X  			}
X! 			otmp = otmp->nobj;
X  		}
X  		if(iletct == 1)
X  			Strcpy(buf,ilets);
X--- 87,97 ----
X  			ilets[iletct] = 0;
X  		}
X  		while(otmp) {
X! 			if(!index(ilets, otmp->olet) && !otmp->cobj) {
X  				ilets[iletct++] = otmp->olet;
X  				ilets[iletct] = 0;
X  			}
X! 			otmp = otmp->nexthere;
X  		}
X  		if(iletct == 1)
X  			Strcpy(buf,ilets);
X***************
X*** 127,135 ****
X  	}
X  	if(all_of_a_type && !olets[0]) all = TRUE;
X  
X! 	for(obj = (gold ? &dummygold : fobj); obj; obj = obj2) {
X! 	    obj2 = obj->nobj;   /* perhaps obj will be picked up */
X! 	    if(!obj->cobj && obj->ox == u.ux && obj->oy == u.uy) {
X  		if(flags.run) nomul(0);
X  
X  		if(!all)  {
X--- 129,138 ----
X  	}
X  	if(all_of_a_type && !olets[0]) all = TRUE;
X  
X! 	for(obj = (gold ? &dummygold : level.objects[u.ux][u.uy]); obj;
X! 			obj = obj2) {
X! 	    obj2 = obj->nexthere;   /* perhaps obj will be picked up */
X! 	    if(!obj->cobj) {
X  		if(flags.run) nomul(0);
X  
X  		if(!all)  {
X***************
X*** 282,288 ****
X  		  obj->quan = pickquan; /* to fool prinv() */
X  		  if(uwep && uwep == obj) mrg_to_wielded = TRUE;
X  		  prinv(obj);
X! 		  if(mrg_to_wielded) mrg_to_wielded = FALSE;
X  		  obj->quan = mergquan;
X  		}
X  	    }
X--- 285,291 ----
X  		  obj->quan = pickquan; /* to fool prinv() */
X  		  if(uwep && uwep == obj) mrg_to_wielded = TRUE;
X  		  prinv(obj);
X! 		  mrg_to_wielded = FALSE;
X  		  obj->quan = mergquan;
X  		}
X  	    }
X***************
X*** 368,374 ****
X  	if((obj->otyp == LOADSTONE) && obj->cursed) {
X  		obj->bknown = 1;
X  		pline("The stone%s won't leave your person.",
X! 			obj->quan==1 ? "" : "s");
X  		return(0);
X  	}
X  	/* Prohibit Amulets in containers; if you allow it, monsters can't
X--- 371,377 ----
X  	if((obj->otyp == LOADSTONE) && obj->cursed) {
X  		obj->bknown = 1;
X  		pline("The stone%s won't leave your person.",
X! 			plur((long)obj->quan));
X  		return(0);
X  	}
X  	/* Prohibit Amulets in containers; if you allow it, monsters can't
X***************
X*** 407,413 ****
X  	obj->nobj = fcobj;
X  	fcobj = obj;
X  
X! 	if(Icebox)	obj->age = moves - obj->age;	/* actual age */
X  
X  	else if(Is_mbag(obj->cobj) &&
X  		(Is_mbag(obj) ||
X--- 410,416 ----
X  	obj->nobj = fcobj;
X  	fcobj = obj;
X  
X! 	if(Icebox) obj->age = monstermoves - obj->age; /* actual age */
X  
X  	else if(Is_mbag(obj->cobj) &&
X  		(Is_mbag(obj) ||
X***************
X*** 452,459 ****
X  	dec_cwt(current_container, obj);
X  	obj->cobj = (struct obj *) 0;
X  
X! 	if (Icebox)
X! 		obj->age = moves - obj->age;	/* simulated point of time */
X  
X  	(void) addinv(obj);
X  	return 0;
X--- 455,462 ----
X  	dec_cwt(current_container, obj);
X  	obj->cobj = (struct obj *) 0;
X  
X! 	if (Icebox) obj->age = monstermoves - obj->age;
X! 	/* simulated point of time */
X  
X  	(void) addinv(obj);
X  	return 0;
X
END_OF_FILE
if test 47374 -ne `wc -c <'patches04c'`; then
    echo shar: \"'patches04c'\" unpacked with wrong size!
fi
# end of 'patches04c'
fi
echo shar: End of archive 3 \(of 11\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
