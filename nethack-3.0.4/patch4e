Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i041:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch4e
Message-ID: <4631@tekred.CNA.TEK.COM>
Date: 29 Sep 89 21:11:06 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2288
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 41
Archive-name: NetHack3/Patch4e
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 11)."
# Contents:  patches04e
# Wrapped by billr@saab on Fri Sep 29 13:14:17 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches04e' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches04e'\"
else
echo shar: Extracting \"'patches04e'\" \(56197 characters\)
sed "s/^X//" >'patches04e' <<'END_OF_FILE'
X*** src/Old/topl.c	Wed Sep 27 12:21:06 1989
X--- src/topl.c	Mon Sep 25 23:07:03 1989
X***************
X*** 2,7 ****
X--- 2,8 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #define NEED_VARARGS
X  #include "hack.h"
X  
X  char toplines[BUFSIZ];
X***************
X*** 134,154 ****
X  }
X  
X  /*VARARGS1*/
X! /* Because the modified mstatusline has 9 arguments KAA */
X  void
X! pline(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
X! #ifndef TOS
X! register
X  #endif
X! const char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X! {
X  	char pbuf[BUFSZ];
X  	register char *bp = pbuf, *tl;
X  	register int n,n0;
X  
X  	if(!line || !*line) return;
X  	if(!index(line, '%')) Strcpy(pbuf,line); else
X! 	Sprintf(pbuf,line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
X  	if(no_repeat && flags.toplin == 1 && !strcmp(pbuf, toplines)) return;
X  	nscr();		/* %% */
X  
X--- 135,177 ----
X  }
X  
X  /*VARARGS1*/
X! /* Note the modified mstatusline has 9 arguments KAA */
X! 
X! /* Also note that these declarations rely on knowledge of the internals
X!  * of the variable argument handling stuff in "tradstdc.h"
X!  */
X! 
X! #if defined(USE_STDARG) || defined(USE_VARARGS)
X! void
X! pline VA_DECL(const char *, line)
X! 	VA_START(line);
X! 	VA_INIT(line, char *);
X! 	vpline(line, VA_ARGS);
X! 	VA_END();
X! }
X! 
X! # ifdef USE_STDARG
X! void
X! vpline(const char *line, va_list the_args) {
X! # else
X! void
X! vpline(line, the_args) const char *line; va_list the_args; {
X! # endif
X! 
X! #else  /* USE_STDARG | USE_VARARG */
X! 
X  void
X! pline VA_DECL(const char *, line)
X  #endif
X! 
X  	char pbuf[BUFSZ];
X  	register char *bp = pbuf, *tl;
X  	register int n,n0;
X+ /* Do NOT use VA_START and VA_END in here... see above */
X  
X  	if(!line || !*line) return;
X  	if(!index(line, '%')) Strcpy(pbuf,line); else
X! 	Vsprintf(pbuf,line,VA_ARGS);
X  	if(no_repeat && flags.toplin == 1 && !strcmp(pbuf, toplines)) return;
X  	nscr();		/* %% */
X  
X***************
X*** 206,257 ****
X  
X  /*VARARGS1*/
X  void
X! Norep(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
X! #ifndef TOS
X! register
X! #endif
X! const char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X! {
X  	no_repeat = TRUE;
X! 	pline(line, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
X  	no_repeat = FALSE;
X  	return;
X  }
X  
X  /*VARARGS1*/
X  void
X! You(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
X! #ifndef TOS
X! register
X! #endif
X! const char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X! {
X  	char *tmp;
X  	tmp = (char *)alloc((unsigned int)(strlen(line) + 5));
X  	Strcpy(tmp, "You ");
X  	Strcat(tmp, line);
X! 	pline(tmp, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
X  	free(tmp);
X  	return;
X  }
X  
X  /*VARARGS1*/
X  void
X! Your(line,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
X! #ifndef TOS
X! register
X! #endif
X! const char *line,*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,*arg7,*arg8,*arg9;
X! {
X  	char *tmp;
X  	tmp = (char *)alloc((unsigned int)(strlen(line) + 6));
X  	Strcpy(tmp, "Your ");
X  	Strcat(tmp, line);
X! 	pline(tmp, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
X  	free(tmp);
X  	return;
X  }
X  
X  void
X  putsym(c)
X  char c;
X--- 229,299 ----
X  
X  /*VARARGS1*/
X  void
X! Norep VA_DECL(const char *, line)
X! 	VA_START(line);
X! 	VA_INIT(line, const char *);
X  	no_repeat = TRUE;
X! 	vpline(line, VA_ARGS);
X  	no_repeat = FALSE;
X+ 	VA_END();
X  	return;
X  }
X  
X  /*VARARGS1*/
X  void
X! You VA_DECL(const char *, line)
X  	char *tmp;
X+ 	VA_START(line);
X+ 	VA_INIT(line, const char *);
X  	tmp = (char *)alloc((unsigned int)(strlen(line) + 5));
X  	Strcpy(tmp, "You ");
X  	Strcat(tmp, line);
X! 	vpline(tmp, VA_ARGS);
X  	free(tmp);
X+ 	VA_END();
X  	return;
X  }
X  
X  /*VARARGS1*/
X  void
X! Your VA_DECL(const char *,line)
X  	char *tmp;
X+ 	VA_START(line);
X+ 	VA_INIT(line, const char *);
X  	tmp = (char *)alloc((unsigned int)(strlen(line) + 6));
X  	Strcpy(tmp, "Your ");
X  	Strcat(tmp, line);
X! 	vpline(tmp, VA_ARGS);
X  	free(tmp);
X+ 	VA_END();
X  	return;
X  }
X  
X+ /*ARGSUSED*/
X+ /*VARARGS2*/
X+ void
X+ kludge  VA_DECL2(char *, str, char *, arg)
X+ #ifdef VA_NEXT
X+ 	char *other1, *other2, *other3;
X+ #endif
X+ 	VA_START(arg);
X+ 	VA_INIT(str, char *);
X+ 	VA_INIT(arg, char *);
X+ #ifdef VA_NEXT
X+ 	VA_NEXT(other1, char *);
X+ 	VA_NEXT(other2, char *);
X+ 	VA_NEXT(other3, char *);
X+ # define OTHER_ARGS other1,other2,other3
X+ #else
X+ # define OTHER_ARGS arg1,arg2,arg3
X+ #endif
X+ 	if(Blind || !flags.verbose) {
X+ 		if(*str == '%') pline(str,"It",OTHER_ARGS);
X+ 		else pline(str,"it",OTHER_ARGS);
X+ 	} else pline(str,arg,OTHER_ARGS);
X+ 	VA_END();
X+ }
X+ 
X  void
X  putsym(c)
X  char c;
X***************
X*** 311,314 ****
X--- 353,366 ----
X  	flags.toplin = 2;
X  
X  	return q;
X+ }
X+ 
X+ /*VARARGS1*/
X+ void
X+ impossible VA_DECL(char *, s)
X+ 	VA_START(s);
X+ 	VA_INIT(s, char *);
X+ 	vpline(s,VA_ARGS);
X+ 	pline("Program in disorder - perhaps you'd better Quit.");
X+ 	VA_END();
X  }
X*** src/Old/topten.c	Wed Sep 27 12:21:23 1989
X--- src/topten.c	Sun Sep 17 12:27:57 1989
X***************
X*** 42,55 ****
X  	int rank, rank0 = -1, rank1 = 0;
X  	int occ_cnt = PERSMAX;
X  	register struct toptenentry *t0, *t1, *tprev;
X- 	char *recfile = RECORD;
X  #ifdef UNIX
X  	char *reclock = "record_lock";
X  # ifdef NO_FILE_LINKS
X  	int lockfd ;
X  # endif
X- 	int sleepct = 100;
X  #endif /* UNIX */
X  	FILE *rfile;
X  	register int flg = 0;
X  #ifdef LOGFILE
X--- 42,62 ----
X  	int rank, rank0 = -1, rank1 = 0;
X  	int occ_cnt = PERSMAX;
X  	register struct toptenentry *t0, *t1, *tprev;
X  #ifdef UNIX
X  	char *reclock = "record_lock";
X  # ifdef NO_FILE_LINKS
X  	int lockfd ;
X  # endif
X  #endif /* UNIX */
X+ #ifdef VMS
X+ 	char *reclock = "record_lock;1";
X+ 	char recfile[] = RECORD;
X+ #else
X+ 	char *recfile = RECORD;
X+ #endif
X+ #if defined(UNIX) || defined(VMS)
X+ 	int sleepct = 100;
X+ #endif
X  	FILE *rfile;
X  	register int flg = 0;
X  #ifdef LOGFILE
X***************
X*** 57,64 ****
X  	FILE *lfile;
X  # ifdef UNIX
X  	char *loglock = "logfile_lock";
X- 	int sleeplgct = 30;
X  # endif /* UNIX */
X  #endif /* LOGFILE */
X  
X  #ifdef MSDOS
X--- 64,76 ----
X  	FILE *lfile;
X  # ifdef UNIX
X  	char *loglock = "logfile_lock";
X  # endif /* UNIX */
X+ # ifdef VMS
X+ 	char *loglock = "logfile_lock;1";
X+ # endif /* VMS */
X+ # if defined(UNIX) || defined(VMS)
X+ 	int sleeplgct = 30;
X+ # endif /* UNIX or VMS */
X  #endif /* LOGFILE */
X  
X  #ifdef MSDOS
X***************
X*** 84,90 ****
X  	Strcpy(t0->date, getdate());
X  
X  #ifdef LOGFILE		/* used for debugging (who dies of what, where) */
X! # ifdef UNIX
X  #  ifdef NO_FILE_LINKS
X  	loglock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(lgfile)+6);
X  	Strcpy(loglock,LOCKDIR) ;
X--- 96,102 ----
X  	Strcpy(t0->date, getdate());
X  
X  #ifdef LOGFILE		/* used for debugging (who dies of what, where) */
X! # if defined(UNIX) || defined(VMS)
X  #  ifdef NO_FILE_LINKS
X  	loglock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(lgfile)+6);
X  	Strcpy(loglock,LOCKDIR) ;
X***************
X*** 108,119 ****
X  		HUP Printf("Waiting for access to log file. (%d)\n",
X   			sleeplgct);
X  		HUP (void) fflush(stdout);
X! #  if defined(SYSV) || defined(ULTRIX)
X  		(void)
X  #  endif
X  		    sleep(1);
X  	}
X! # endif /* UNIX */
X  	if(!(lfile = fopen(lgfile,"a"))){
X  		HUP (void) puts("Cannot open log file!");
X  		goto lgend;
X--- 120,131 ----
X  		HUP Printf("Waiting for access to log file. (%d)\n",
X   			sleeplgct);
X  		HUP (void) fflush(stdout);
X! #  if defined(SYSV) || defined(ULTRIX) || defined(VMS)
X  		(void)
X  #  endif
X  		    sleep(1);
X  	}
X! # endif /* UNIX or VMS */
X  	if(!(lfile = fopen(lgfile,"a"))){
X  		HUP (void) puts("Cannot open log file!");
X  		goto lgend;
X***************
X*** 124,132 ****
X  	    t0->hp, t0->maxhp, t0->points,
X  	    t0->plchar, t0->sex, t0->name, t0->death);
X  	(void) fclose(lfile);
X! # ifdef UNIX
X  	(void) unlink(loglock);
X! # endif /* UNIX */
X        lgend:;
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X--- 136,144 ----
X  	    t0->hp, t0->maxhp, t0->points,
X  	    t0->plchar, t0->sex, t0->name, t0->death);
X  	(void) fclose(lfile);
X! # if defined(UNIX) || defined(VMS)
X  	(void) unlink(loglock);
X! # endif /* UNIX or VMS */
X        lgend:;
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X***************
X*** 140,146 ****
X  # endif
X  #endif /* LOGFILE */
X  
X! #ifdef UNIX
X  # ifdef NO_FILE_LINKS
X  	reclock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(recfile)+7);
X  	Strcpy(reclock,LOCKDIR) ;
X--- 152,158 ----
X  # endif
X  #endif /* LOGFILE */
X  
X! #if defined(UNIX) || defined(VMS)
X  # ifdef NO_FILE_LINKS
X  	reclock = (char *)alloc(sizeof(LOCKDIR)+1+strlen(recfile)+7);
X  	Strcpy(reclock,LOCKDIR) ;
X***************
X*** 160,171 ****
X  		HUP Printf("Waiting for access to record file. (%d)\n",
X  			sleepct);
X  		HUP (void) fflush(stdout);
X! # if defined(SYSV) || defined(ULTRIX)
X  		(void)
X  # endif
X  		    sleep(1);
X  	}
X! #endif /* UNIX */
X  	if(!(rfile = fopen(recfile,"r"))){
X  		HUP (void) puts("Cannot open record file!");
X  		goto unlock;
X--- 172,183 ----
X  		HUP Printf("Waiting for access to record file. (%d)\n",
X  			sleepct);
X  		HUP (void) fflush(stdout);
X! # if defined(SYSV) || defined(ULTRIX) || defined(VMS)
X  		(void)
X  # endif
X  		    sleep(1);
X  	}
X! #endif /* UNIX or VMS */
X  	if(!(rfile = fopen(recfile,"r"))){
X  		HUP (void) puts("Cannot open record file!");
X  		goto unlock;
X***************
X*** 244,249 ****
X--- 256,269 ----
X  	}
X  	if(flg) {	/* rewrite record file */
X  		(void) fclose(rfile);
X+ #ifdef VMS
X+ 		{
X+ 			char *sem = rindex(recfile, ';');
X+ 
X+ 			if (sem)
X+ 				*sem = '\0';
X+ 		}
X+ #endif
X  		if(!(rfile = fopen(recfile,"w"))){
X  			HUP (void) puts("Cannot write record file\n");
X  			goto unlock;
X***************
X*** 295,302 ****
X  	if(rank0 >= rank) if(!done_stopprint)
X  		(void) outentry(0, t0, 1);
X  	(void) fclose(rfile);
X  unlock:	;
X! #ifdef UNIX
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X  # endif
X--- 315,329 ----
X  	if(rank0 >= rank) if(!done_stopprint)
X  		(void) outentry(0, t0, 1);
X  	(void) fclose(rfile);
X+ #ifdef VMS
X+ 	if (flg) {
X+ 		delete(RECORD);
X+ 		rename(recfile, RECORD);
X+ 	}
X+ # undef unlink
X+ #endif
X  unlock:	;
X! #if defined(UNIX) || defined(VMS)
X  # ifdef NO_FILE_LINKS
X  	(void) close(lockfd) ;
X  # endif
X***************
X*** 693,701 ****
X  	} else {
X  		otmp->corpsenm = classmon(tt->plchar, (tt->sex == 'F'));
X  		otmp->owt = weight(otmp);
X! 		/* Note: oname() is safe since otmp is first in chain */
X  		otmp = oname(otmp, tt->name, 0);
X  		fobj = otmp;
X  		free((genericptr_t) tt);
X  		return otmp;
X  	}
X--- 720,729 ----
X  	} else {
X  		otmp->corpsenm = classmon(tt->plchar, (tt->sex == 'F'));
X  		otmp->owt = weight(otmp);
X! 		/* Note: oname() is safe since otmp is first in chains */
X  		otmp = oname(otmp, tt->name, 0);
X  		fobj = otmp;
X+ 		level.objects[otmp->ox][otmp->oy] = otmp;
X  		free((genericptr_t) tt);
X  		return otmp;
X  	}
X*** src/Old/trap.c	Wed Sep 27 12:22:04 1989
X--- src/trap.c	Mon Sep 25 21:30:24 1989
X***************
X*** 101,109 ****
X  	boolean	tmp1, tmp2, tmp3;
X  #  ifdef POLYSELF
X  	tmp1 = isok(x,y) && (!IS_ROCK(levl[x][y].typ) ||
X! 		passes_walls(uasmon)) && !levl[x][y].mmask;
X  #  else
X! 	tmp1 = isok(x,y) && !IS_ROCK(levl[x][y].typ) && !levl[x][y].mmask;
X  #  endif
X  	tmp2 = !sobj_at(BOULDER,x,y) && !t_at(x,y);
X  	tmp3 = !(is_pool(x,y) &&
X--- 101,109 ----
X  	boolean	tmp1, tmp2, tmp3;
X  #  ifdef POLYSELF
X  	tmp1 = isok(x,y) && (!IS_ROCK(levl[x][y].typ) ||
X! 		passes_walls(uasmon)) && !MON_AT(x, y);
X  #  else
X! 	tmp1 = isok(x,y) && !IS_ROCK(levl[x][y].typ) && !MON_AT(x, y);
X  #  endif
X  	tmp2 = !sobj_at(BOULDER,x,y) && !t_at(x,y);
X  	tmp3 = !(is_pool(x,y) &&
X***************
X*** 122,128 ****
X  #  else
X  		!IS_ROCK(levl[x][y].typ) &&
X  #  endif
X! 		!levl[x][y].mmask &&
X  		!sobj_at(BOULDER,x,y) && !t_at(x,y) &&
X  		!(is_pool(x,y) &&
X  		!(Levitation || Wwalking
X--- 122,128 ----
X  #  else
X  		!IS_ROCK(levl[x][y].typ) &&
X  #  endif
X! 		!MON_AT(x, y) &&
X  		!sobj_at(BOULDER,x,y) && !t_at(x,y) &&
X  		!(is_pool(x,y) &&
X  		!(Levitation || Wwalking
X***************
X*** 206,211 ****
X--- 206,212 ----
X  #endif
X  		    break;
X  		case STATUE_TRAP:
X+ 		    deltrap(trap);
X  		    for(otmp=fobj; otmp; otmp=otmp->nobj) {
X  			if(otmp->otyp == STATUE && otmp->ox == u.ux &&
X  				otmp->oy == u.uy && otmp->corpsenm == trap->pm)
X***************
X*** 215,221 ****
X  				break;
X  			    }
X  		    }
X- 		    deltrap(trap);
X  		    break;
X  		case MONST_TRAP:
X  		    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X--- 216,221 ----
X***************
X*** 226,232 ****
X  			    if(uarmh)
X  				pline("Its blow glances off your helmet.");
X  			    else
X! 				(void) thitu(3,d(4,6),"falling piercer");
X  			    break;
X  			default:	/* monster surprises you. */
X  			    pline("%s attacks you by surprise!",
X--- 226,233 ----
X  			    if(uarmh)
X  				pline("Its blow glances off your helmet.");
X  			    else
X! 				(void) thitu(3,d(4,6),(struct obj *)0,
X! 					"falling piercer");
X  			    break;
X  			default:	/* monster surprises you. */
X  			    pline("%s attacks you by surprise!",
X***************
X*** 238,244 ****
X  		    break;
X  		case ARROW_TRAP:
X  		    pline("An arrow shoots out at you!");
X! 		    if(!thitu(8,rnd(6),"arrow")){
X  			(void) mksobj_at(ARROW, u.ux, u.uy);
X  			fobj->quan = 1;
X  			fobj->owt = weight(fobj);
X--- 239,245 ----
X  		    break;
X  		case ARROW_TRAP:
X  		    pline("An arrow shoots out at you!");
X! 		    if(!thitu(8,rnd(6),(struct obj *)0,"arrow")){
X  			(void) mksobj_at(ARROW, u.ux, u.uy);
X  			fobj->quan = 1;
X  			fobj->owt = weight(fobj);
X***************
X*** 294,300 ****
X  		    break;
X  		case DART_TRAP:
X  		    pline("A little dart shoots out at you!");
X! 		    if(thitu(7,rnd(3),"little dart")) {
X  			if(!rn2(6)) poisoned("dart",A_CON,"poison dart");
X  		    } else {
X  			(void) mksobj_at(DART, u.ux, u.uy);
X--- 295,301 ----
X  		    break;
X  		case DART_TRAP:
X  		    pline("A little dart shoots out at you!");
X! 		    if(thitu(7,rnd(3),(struct obj *)0,"little dart")) {
X  			if(!rn2(6)) poisoned("dart",A_CON,"poison dart");
X  		    } else {
X  			(void) mksobj_at(DART, u.ux, u.uy);
X***************
X*** 1122,1132 ****
X  	    } while(!digit(buf[0]) && (buf[0] != '-' || !digit(buf[1])));
X  	    newlevel = atoi(buf);
X  	} else {
X- 	    newlevel = rn2(5) | !Fire_resistance ? rnd(dlevel + 3) :
X  #ifdef STRONGHOLD
X! 		stronghold_level + 1;
X  #else
X! 		HELLLEVEL;
X  #endif
X  	    if(dlevel == newlevel)
X  		if(is_maze_lev) newlevel--; else newlevel++;
X--- 1123,1136 ----
X  	    } while(!digit(buf[0]) && (buf[0] != '-' || !digit(buf[1])));
X  	    newlevel = atoi(buf);
X  	} else {
X  #ifdef STRONGHOLD
X! 	    /* We cannot send them to Hell if STRONGHOLD is defined, since
X! 	     * they may find themselves trapped on the other side of the
X! 	     * stronghold...
X! 	     */
X! 	    newlevel = rn2(5) ? rnd(dlevel + 3) : rnd(stronghold_level);
X  #else
X! 	    newlevel = rn2(5) || !Fire_resistance ? rnd(dlevel + 3) : HELLLEVEL;
X  #endif
X  	    if(dlevel == newlevel)
X  		if(is_maze_lev) newlevel--; else newlevel++;
X***************
X*** 1259,1265 ****
X  		       /* below pline added by GAN 10/30/86 */
X  		       adjattrib(A_CHA,1,FALSE);
X  		       for(i = -1; i <= 1; i++) for(j = -1; j <= 1; j++)
X! 		       if(levl[u.ux+i][u.uy+j].mmask)
X  			   (void) tamedog(m_at(u.ux+i, u.uy+j), (struct obj *)0);
X  		       break;
X  		   }
X--- 1263,1269 ----
X  		       /* below pline added by GAN 10/30/86 */
X  		       adjattrib(A_CHA,1,FALSE);
X  		       for(i = -1; i <= 1; i++) for(j = -1; j <= 1; j++)
X! 		       if(MON_AT(u.ux+i, u.uy+j))
X  			   (void) tamedog(m_at(u.ux+i, u.uy+j), (struct obj *)0);
X  		       break;
X  		   }
X***************
X*** 1289,1295 ****
X  
X  	/* Scrolls and potions get affected by the water */
X  	for(obj = invent; obj; obj = obj->nobj) {
X! 		if(obj->olet == SCROLL_SYM && rn2(12) > u.uluck)
X  			obj->otyp = SCR_BLANK_PAPER;
X  		if(obj->olet == POTION_SYM && rn2(12) > u.uluck) {
X  			if (obj->spe == -1) {
X--- 1293,1303 ----
X  
X  	/* Scrolls and potions get affected by the water */
X  	for(obj = invent; obj; obj = obj->nobj) {
X! 		if(obj->olet == SCROLL_SYM && rn2(12) > u.uluck
X! #ifdef MAIL
X! 			&& obj->otyp != SCR_MAIL
X! #endif
X! 								)
X  			obj->otyp = SCR_BLANK_PAPER;
X  		if(obj->olet == POTION_SYM && rn2(12) > u.uluck) {
X  			if (obj->spe == -1) {
X***************
X*** 1458,1465 ****
X  	}
X  }
X  
X! /* this is only called when the player is doing something to the chest
X!  * -- i.e., the player and the chest are in the same position */
X  void
X  chest_trap(obj, bodypart)
X  register struct obj *obj;
X--- 1466,1472 ----
X  	}
X  }
X  
X! /* only called when the player is doing something to the chest directly */
X  void
X  chest_trap(obj, bodypart)
X  register struct obj *obj;
X*** src/Old/u_init.c	Wed Sep 27 12:22:58 1989
X--- src/u_init.c	Mon Sep 25 22:54:56 1989
X***************
X*** 93,98 ****
X--- 93,103 ----
X  	{ POT_HEALING, 0, POTION_SYM, 4, 1, UNDEF_BLESS },
X  	{ POT_EXTRA_HEALING, 0, POTION_SYM, 4, 1, UNDEF_BLESS },
X  	{ WAN_SLEEP, UNDEF_SPE, WAND_SYM, 1, 1, UNDEF_BLESS },
X+ #ifdef SPELLS
X+ 	/* always blessed, so it's guaranteed readable */
X+ 	{ SPE_HEALING, 0, SPBOOK_SYM, 1, 1, 1 },
X+ 	{ SPE_EXTRA_HEALING, 0, SPBOOK_SYM, 1, 1, 1 },
X+ #endif
X  	{ APPLE, 0, FOOD_SYM, 5, 1, 0 },
X  	{ 0, 0, 0, 0, 0, 0 }
X  };
X***************
X*** 542,553 ****
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			int nocreate = STRANGE_OBJECT;
X  #  ifdef SPELLS
X! 			int nocreate2 = STRANGE_OBJECT;
X  #  endif
X  #endif
X! 			int nocreate3 = STRANGE_OBJECT;
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X--- 547,558 ----
X  		 */
X  		if (undefined) {
X  #ifdef POLYSELF
X! 			static unsigned nocreate = STRANGE_OBJECT;
X  #  ifdef SPELLS
X! 			static unsigned nocreate2 = STRANGE_OBJECT;
X  #  endif
X  #endif
X! 			static unsigned nocreate3 = STRANGE_OBJECT;
X  
X  			while(obj->otyp == WAN_WISHING
X  #ifdef POLYSELF
X***************
X*** 601,607 ****
X  		}
X  
X  		obj->bknown = trop->trknown;
X! 		if(uses_known(obj)) obj->known = trop->trknown;
X  		/* not obj->dknown = 1; - let him look at it at least once */
X  		obj->cursed = 0;
X  		if(obj->olet == TOOL_SYM){ /* problem with multiple tools */
X--- 606,612 ----
X  		}
X  
X  		obj->bknown = trop->trknown;
X! 		if(objects[obj->otyp].oc_uses_known) obj->known = trop->trknown;
X  		/* not obj->dknown = 1; - let him look at it at least once */
X  		obj->cursed = 0;
X  		if(obj->olet == TOOL_SYM){ /* problem with multiple tools */
X*** src/Old/uhitm.c	Wed Sep 27 12:23:32 1989
X--- src/uhitm.c	Mon Sep 25 23:01:15 1989
X***************
X*** 26,32 ****
X  	mm.x = mon->mx;
X  	mm.y = mon->my;
X  	enexto(&mm, mm.x, mm.y, mon->data);
X! 	if (levl[mm.x][mm.y].mmask || mon->mhp <= 1) return (struct monst *)0;
X  	m2 = newmonst(0);
X  	*m2 = *mon;			/* copy condition of old monster */
X  	m2->nmon = fmon;
X--- 26,32 ----
X  	mm.x = mon->mx;
X  	mm.y = mon->my;
X  	enexto(&mm, mm.x, mm.y, mon->data);
X! 	if (MON_AT(mm.x, mm.y) || mon->mhp <= 1) return (struct monst *)0;
X  	m2 = newmonst(0);
X  	*m2 = *mon;			/* copy condition of old monster */
X  	m2->nmon = fmon;
X***************
X*** 62,68 ****
X  	m2->mnamelth = 0;
X  	m2->mdispl = 0;
X  	pmon(m2);	/* display the new monster */
X! 	levl[m2->mx][m2->my].mmask = 1;
X  	if (mon->mtame) (void) tamedog(m2, (struct obj *)0);
X  	return m2;
X  }
X--- 62,68 ----
X  	m2->mnamelth = 0;
X  	m2->mdispl = 0;
X  	pmon(m2);	/* display the new monster */
X! 	place_monster(m2, m2->mx, m2->my);
X  	if (mon->mtame) (void) tamedog(m2, (struct obj *)0);
X  	return m2;
X  }
X***************
X*** 98,104 ****
X  
X  		    if(Blind) pline("Wait!  There's a hidden monster there!");
X  		    else if(OBJ_AT(mtmp->mx, mtmp->my)) {
X! 			if(obj = o_at(mtmp->mx,mtmp->my))
X  				pline("Wait!  There's %s hiding under %s!",
X  					defmonnam(mtmp), doname(obj));
X  		    } else if (levl[mtmp->mx][mtmp->my].gmask == 1)
X--- 98,104 ----
X  
X  		    if(Blind) pline("Wait!  There's a hidden monster there!");
X  		    else if(OBJ_AT(mtmp->mx, mtmp->my)) {
X! 			if(obj = level.objects[mtmp->mx][mtmp->my])
X  				pline("Wait!  There's %s hiding under %s!",
X  					defmonnam(mtmp), doname(obj));
X  		    } else if (levl[mtmp->mx][mtmp->my].gmask == 1)
X***************
X*** 317,326 ****
X--- 317,331 ----
X  	 * 7) Possibly kill monster (must be done after 6a, 6b)
X  	 * 8) Instant-kill from poison (can happen anywhere between 5 and 9)
X  	 * 9) Hands not glowing (must be done after 7 and 8)
X+ 	 * The major problem is that since we don't want a "hit" message
X+ 	 * when the monster dies, we have to know how much damage it did
X+ 	 * _before_ outputting a hit message, but any messages associated with
X+ 	 * the damage don't come out until _after_ outputting a hit message.
X  	 */
X  	boolean hittxt = FALSE, destroyed = FALSE;
X  	boolean get_dmg_bonus = TRUE;
X  	boolean ispoisoned = FALSE, needpoismsg = FALSE, poiskilled = FALSE;
X+ 	boolean silvermsg = FALSE;
X  
X  	wakeup(mon);
X  	if(!obj) {
X***************
X*** 379,384 ****
X--- 384,397 ----
X  				obj->opoisoned)
X  			    ispoisoned = TRUE;
X  		    }
X+ 		    if(thrown && obj->otyp == SILVER_ARROW) {
X+ 			if (is_were(mon->data) || mon->data->mlet==S_VAMPIRE
X+ 			    || (mon->data->mlet==S_IMP && mon->data != &mons[PM_TENGU])
X+ 			    || is_demon(mon->data)) {
X+ 				silvermsg = TRUE;
X+ 				tmp += rnd(20);
X+ 			}
X+ 		    }
X  		}
X  	    } else if(obj->olet == POTION_SYM) {
X  			if (obj->quan > 1) setuwep(splitobj(obj, 1));
X***************
X*** 426,432 ****
X  				kludge("You hit %s with the %s egg%s.",
X  					mon_nam(mon),
X  					mons[obj->corpsenm].mname,
X! 					(obj->quan==1) ? "" : "s");
X  				hittxt = TRUE;
X  				pline("The egg%sn't live any more...",
X  					(obj->quan==1) ? " is" : "s are");
X--- 439,445 ----
X  				kludge("You hit %s with the %s egg%s.",
X  					mon_nam(mon),
X  					mons[obj->corpsenm].mname,
X! 					plur((long)obj->quan));
X  				hittxt = TRUE;
X  				pline("The egg%sn't live any more...",
X  					(obj->quan==1) ? " is" : "s are");
X***************
X*** 557,565 ****
X  		else	You("hit %s%s", mon_nam(mon), exclam(tmp));
X  	}
X  
X  	if (needpoismsg)
X  		kludge("The poison doesn't seem to affect %s.", mon_nam(mon));
X- 
X  	if (poiskilled) {
X  		pline("The poison was deadly...");
X  		xkilled(mon, 0);
X--- 570,585 ----
X  		else	You("hit %s%s", mon_nam(mon), exclam(tmp));
X  	}
X  
X+ 	if (silvermsg) {
X+ 		if (cansee(mon->mx, mon->my))
X+ 			pline("The silver arrow sears %s's flesh!",
X+ 				mon_nam(mon));
X+ 		else
X+ 			pline("Its flesh is seared!");
X+ 	}
X+ 
X  	if (needpoismsg)
X  		kludge("The poison doesn't seem to affect %s.", mon_nam(mon));
X  	if (poiskilled) {
X  		pline("The poison was deadly...");
X  		xkilled(mon, 0);
X***************
X*** 616,622 ****
X  	    ) {
X  	    struct monst *dtmp;
X  	    pline("Some hell-p has arrived!");
X- /*	    if((dtmp = mkmon_at(uasmon, u.ux, u.uy)))*/
X  /*	    if((dtmp = makemon(uasmon, u.ux, u.uy)))*/
X  	    if((dtmp = makemon(&mons[ndemon()], u.ux, u.uy)))
X  		(void)tamedog(dtmp, (struct obj *)0);
X--- 636,641 ----
X***************
X*** 1088,1094 ****
X  				sum[i] = damageum(mon,mattk);
X  			break;
X  		case AT_CLAW:
X! 			if (i==0 && uwep && humanoid(uasmon)) goto use_weapon;
X  # ifdef SEDUCE
X  			/* succubi/incubi are humanoid, but their _second_
X  			 * attack is AT_CLAW, not their first...
X--- 1107,1113 ----
X  				sum[i] = damageum(mon,mattk);
X  			break;
X  		case AT_CLAW:
X! 			if (i==0 && uwep && !cantwield(uasmon)) goto use_weapon;
X  # ifdef SEDUCE
X  			/* succubi/incubi are humanoid, but their _second_
X  			 * attack is AT_CLAW, not their first...
X*** src/Old/unixmain.c	Wed Sep 27 12:24:30 1989
X--- src/unixmain.c	Tue Sep 26 18:46:28 1989
X***************
X*** 1,7 ****
X  /*	SCCS Id: @(#)unixmain.c	3.0	89/01/13
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X! /* main.c - (Unix) version */
X  
X  #include <signal.h>
X  #include <pwd.h>
X--- 1,7 ----
X  /*	SCCS Id: @(#)unixmain.c	3.0	89/01/13
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X! /* main.c - Unix NetHack */
X  
X  #include <signal.h>
X  #include <pwd.h>
X***************
X*** 8,35 ****
X  
X  #include "hack.h"
X  
X  int hackpid = 0;				/* current pid */
X  int locknum = 0;				/* max num of players */
X  #ifdef DEF_PAGER
X  char *catmore = 0;				/* default pager */
X  #endif
X- char SAVEF[PL_NSIZ + 11] = "save/";	/* save/99999player */
X- char *hname = 0;		/* name of the game (argv[0] of call) */
X- char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X  
X! int (*occupation)() = DUMMY;
X! int (*afternmv)() = DUMMY;
X  #ifdef CHDIR
X  static void chdirx();
X  #endif /* CHDIR */
X! static void whoami(), newgame();
X  
X  main(argc,argv)
X  int argc;
X  char *argv[];
X  {
X  	struct passwd *pw;
X- 	extern struct passwd *getpwuid();
X  	extern int x_maze_max, y_maze_max;
X  	register int fd;
X  #ifdef CHDIR
X--- 8,35 ----
X  
X  #include "hack.h"
X  
X+ char SAVEF[PL_NSIZ + 11] = "save/";	/* save/99999player */
X+ 
X+ char *hname = 0;		/* name of the game (argv[0] of call) */
X+ char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
X  int hackpid = 0;				/* current pid */
X  int locknum = 0;				/* max num of players */
X  #ifdef DEF_PAGER
X  char *catmore = 0;				/* default pager */
X  #endif
X  
X! extern struct passwd *getpwuid();
X  #ifdef CHDIR
X  static void chdirx();
X  #endif /* CHDIR */
X! static void whoami();
X  
X+ int
X  main(argc,argv)
X  int argc;
X  char *argv[];
X  {
X  	struct passwd *pw;
X  	extern int x_maze_max, y_maze_max;
X  	register int fd;
X  #ifdef CHDIR
X***************
X*** 38,47 ****
X--- 38,62 ----
X  #ifdef COMPRESS
X  	char	cmd[80], old[80];
X  #endif
X+ 
X  	hname = argv[0];
X  	hackpid = getpid();
X  	(void) umask(0);
X  
X+ 	/*
X+ 	 *  Remember tty modes, to be restored on exit.
X+ 	 *
X+ 	 *  gettty() must be called before startup()
X+ 	 *    due to ordering of LI/CO settings
X+ 	 *  startup() must be called before initoptions()
X+ 	 *    due to ordering of graphics settings
X+ 	 */
X+ 	gettty();
X+ 	setbuf(stdout,obuf);
X+ 	startup();
X+ 	initoptions();
X+ 	whoami();
X+ 
X  #ifdef CHDIR			/* otherwise no chdir() */
X  	/*
X  	 * See if we must change directory to the playground.
X***************
X*** 50,58 ****
X  	 * The environment variable HACKDIR is overridden by a
X  	 *  -d command line option (must be the first option given)
X  	 */
X- 
X  	dir = getenv("HACKDIR");
X! 	if(argc > 1 && !strncmp(argv[1], "-d", 2)) {
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X--- 65,75 ----
X  	 * The environment variable HACKDIR is overridden by a
X  	 *  -d command line option (must be the first option given)
X  	 */
X  	dir = getenv("HACKDIR");
X! #endif
X! 	if(argc > 1) {
X! #ifdef CHDIR
X! 	    if (!strncmp(argv[1], "-d", 2)) {
X  		argc--;
X  		argv++;
X  		dir = argv[0]+2;
X***************
X*** 64,101 ****
X  		}
X  		if(!*dir)
X  		    error("Flag -d must be followed by a directory name.");
X! 	}
X  #endif /* CHDIR /**/
X  
X  	/*
X- 	 *  Remember tty modes, to be restored on exit.
X- 	 *
X- 	 *  Note that getty() must be called before startup() due to ordering
X- 	 *  of LI/CO settings, and startup() must be called before initoptions()
X- 	 *  due to ordering of graphics settings.
X- 	 */
X- 	gettty();
X- 	startup();
X- 	initoptions();
X- 	whoami();
X- 	/*
X  	 * Now we know the directory containing 'record' and
X  	 * may do a prscore().
X  	 */
X! 	if(argc > 1 && !strncmp(argv[1], "-s", 2)) {
X  #ifdef CHDIR
X  		chdirx(dir,0);
X  #endif
X  		prscore(argc, argv);
X! 		getret();
X  		settty(NULL);
X  		exit(0);
X  	}
X  
X  	/*
X! 	 * It seems he really wants to play.
X  	 */
X- 	setbuf(stdout,obuf);
X  	setrandom();
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X--- 81,107 ----
X  		}
X  		if(!*dir)
X  		    error("Flag -d must be followed by a directory name.");
X! 	    } else
X  #endif /* CHDIR /**/
X  
X  	/*
X  	 * Now we know the directory containing 'record' and
X  	 * may do a prscore().
X  	 */
X! 	    if (!strncmp(argv[1], "-s", 2)) {
X  #ifdef CHDIR
X  		chdirx(dir,0);
X  #endif
X  		prscore(argc, argv);
X! 		if(isatty(1)) getret();
X  		settty(NULL);
X  		exit(0);
X+ 	    }
X  	}
X  
X  	/*
X! 	 * It seems you really want to play.
X  	 */
X  	setrandom();
X  	cls();
X  	u.uhp = 1;	/* prevent RIP on early quits */
X***************
X*** 123,140 ****
X  		argc--;
X  		switch(argv[0][1]){
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 		case 'D':
X  		case 'X':
X! 			pw = getpwuid(getuid());
X  # ifdef WIZARD
X! 			if(!strcmp(pw->pw_name, WIZARD))
X  				wizard = TRUE;
X! # endif
X! # if defined(WIZARD) && defined(EXPLORE_MODE)
X! 			else
X  # endif
X  # ifdef EXPLORE_MODE
X! 				discover = TRUE;
X  # endif
X  			break;
X  #endif
X--- 129,149 ----
X  		argc--;
X  		switch(argv[0][1]){
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! # ifndef EXPLORE_MODE
X  		case 'X':
X! # endif
X! 		case 'D':
X  # ifdef WIZARD
X! 			pw = getpwuid(getuid());
X! 			if(!strcmp(pw->pw_name, WIZARD)) {
X  				wizard = TRUE;
X! 				break;
X! 			}
X! 			/* otherwise fall thru to discover */
X  # endif
X  # ifdef EXPLORE_MODE
X! 		case 'X':
X! 			discover = TRUE;
X  # endif
X  			break;
X  #endif
X***************
X*** 176,182 ****
X  	getmailstatus();
X  #endif
X  #ifdef WIZARD
X! 	if(wizard) Strcpy(plname, "wizard"); else
X  #endif
X  	if(!*plname || !strncmp(plname, "player", 4)
X  		    || !strncmp(plname, "games", 4))
X--- 185,193 ----
X  	getmailstatus();
X  #endif
X  #ifdef WIZARD
X! 	if (wizard)
X! 		Strcpy(plname, "wizard");
X! 	else
X  #endif
X  	if(!*plname || !strncmp(plname, "player", 4)
X  		    || !strncmp(plname, "games", 4))
X***************
X*** 202,217 ****
X  #endif /* WIZARD /**/
X  	setftty();
X  
X! 	/* 
X  	 * Initialisation of the boundaries of the mazes
X  	 * Both boundaries have to be even.
X  	 */
X! 	 
X  	x_maze_max = COLNO-1;
X! 	if (x_maze_max % 2) 
X  		x_maze_max--;
X  	y_maze_max = ROWNO-1;
X! 	if (y_maze_max % 2) 
X  		y_maze_max--;
X  
X  	/* initialize static monster strength array */
X--- 213,228 ----
X  #endif /* WIZARD /**/
X  	setftty();
X  
X! 	/*
X  	 * Initialisation of the boundaries of the mazes
X  	 * Both boundaries have to be even.
X  	 */
X! 
X  	x_maze_max = COLNO-1;
X! 	if (x_maze_max % 2)
X  		x_maze_max--;
X  	y_maze_max = ROWNO-1;
X! 	if (y_maze_max % 2)
X  		y_maze_max--;
X  
X  	/* initialize static monster strength array */
X***************
X*** 237,247 ****
X--- 248,267 ----
X  #endif
X  	if((fd = open(SAVEF,0)) >= 0 &&
X  	   (uptodate(fd) || unlink(SAVEF) == 666)) {
X+ #ifdef WIZARD
X+ 		/* Since wizard is actually flags.debug, restoring might
X+ 		 * overwrite it.
X+ 		 */
X+ 		boolean remember_wiz_mode = wizard;
X+ #endif
X  		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X  		pline("Restoring old save file...");
X  		(void) fflush(stdout);
X  		if(!dorecover(fd))
X  			goto not_recovered;
X+ #ifdef WIZARD
X+ 		if(!wizard && remember_wiz_mode) wizard = TRUE;
X+ #endif
X  		pline("Hello %s, welcome to NetHack!", plname);
X  		/* get shopkeeper set properly if restore is in shop */
X  		(void) inshop();
X***************
X*** 282,443 ****
X  
X  	initrack();
X  
X! 	for(;;) {
X! 		if(flags.move) {	/* actual time passed */
X! 
X! #ifdef SOUNDS
X! 			dosounds();
X! #endif
X! 			settrack();
X! 
X! 			if(moves%2 == 0 ||
X! 			  (!(Fast & ~INTRINSIC) && (!Fast || rn2(3)))) {
X! 				movemon();
X! #ifdef HARD
X! 				if(!rn2(u.udemigod?25:(dlevel>30)?50:70))
X! #else
X! 				if(!rn2(70))
X! #endif
X! 				    (void) makemon((struct permonst *)0, 0, 0);
X! 			}
X! 			if(Glib) glibr();
X! 			timeout();
X! 			++moves;
X! #ifdef THEOLOGY
X! 			if (u.ublesscnt)  u.ublesscnt--;
X! #endif
X! 			if(flags.time) flags.botl = 1;
X! #ifdef POLYSELF
X! 			if(u.mtimedone)
X! 			    if(u.mh < 1) rehumanize();
X! 			else
X! #endif
X! 			    if(u.uhp < 1) {
X! 				You("die...");
X! 				done(DIED);
X! 			    }
X! #ifdef POLYSELF
X! 			if (u.mtimedone) {
X! 			    if (u.mh < u.mhmax) {
X! 				if (Regeneration || !(moves%20)) {
X! 					flags.botl = 1;
X! 					u.mh++;
X! 				}
X! 			    }
X! 			}
X! #endif
X! 			if(u.uhp < u.uhpmax) {
X! 				if(u.ulevel > 9) {
X! 				    int heal;
X! 
X! 				    if(HRegeneration || !(moves%3)) {
X! 					flags.botl = 1;
X! 					if (ACURR(A_CON) <= 12) heal = 1;
X! 					else heal = rnd((int) ACURR(A_CON)-12);
X! 					if (heal > u.ulevel-9) heal = u.ulevel-9;
X! 					u.uhp += heal;
X! 					if(u.uhp > u.uhpmax)
X! 					    u.uhp = u.uhpmax;
X! 				    }
X! 				} else if(HRegeneration ||
X! 				      (!(moves%((MAXULEV+12)/(u.ulevel+2)+1)))) {
X! 					flags.botl = 1;
X! 					u.uhp++;
X! 				}
X! 			}
X! #ifdef SPELLS
X! 			if ((u.uen<u.uenmax) && (!(moves%(19-ACURR(A_INT)/2)))) {
X! 				u.uen += rn2((int)ACURR(A_WIS)/5 + 1) + 1;
X! 				if (u.uen > u.uenmax)  u.uen = u.uenmax;
X! 				flags.botl = 1;
X! 			}
X! #endif
X! 			if(Teleportation && !rn2(85)) tele();
X! #ifdef POLYSELF
X! 			if(Polymorph && !rn2(100)) polyself();
X! 			if(u.ulycn >= 0 && !rn2(80 - (20 * night())))
X! 				you_were();
X! #endif
X! 			if(Searching && multi >= 0) (void) dosearch0(1);
X! 			hatch_eggs();
X! 			gethungry();
X! 			invault();
X! 			amulet();
X! #ifdef HARD
X! 			if (!rn2(40+(int)(ACURR(A_DEX)*3))) u_wipe_engr(rnd(3));
X! 			if (u.udemigod) {
X! 
X! 				if(u.udg_cnt) u.udg_cnt--;
X! 				if(!u.udg_cnt) {
X! 
X! 					intervene();
X! 					u.udg_cnt = rn1(200, 50);
X! 				}
X! 			}
X! #endif
X! 			restore_attrib();
X! 		}
X! 		if(multi < 0) {
X! 			if(!++multi){
X! 				pline(nomovemsg ? nomovemsg :
X! 					"You can move again.");
X! 				nomovemsg = 0;
X! 				if(afternmv) (*afternmv)();
X! 				afternmv = 0;
X! 			}
X! 		}
X! 
X! 		find_ac();
X! 		if(!flags.mv || Blind)
X! 		{
X! 			seeobjs();
X! 			seemons();
X! 			seeglds();
X! 			nscr();
X! 		}
X! 		if(flags.botl || flags.botlx) bot();
X! 
X! 		flags.move = 1;
X! 
X! 		if(multi >= 0 && occupation) {
X! 
X! 			if(monster_nearby())
X! 				stop_occupation();
X! 			else if ((*occupation)() == 0)
X! 				occupation = 0;
X! 			continue;
X! 		}
X! 
X! 		if((u.uhave_amulet || Clairvoyant) && 
X! #ifdef ENDGAME
X! 			dlevel != ENDLEVEL &&
X! #endif
X! 			!(moves%15) && !rn2(2)) do_vicinity_map();
X! 
X! 		u.umoved = FALSE;
X! 		if(multi > 0) {
X! 			lookaround();
X! 			if(!multi) {	/* lookaround may clear multi */
X! 				flags.move = 0;
X! 				continue;
X! 			}
X! 			if(flags.mv) {
X! 				if(multi < COLNO && !--multi)
X! 					flags.mv = flags.run = 0;
X! 				domove();
X! 			} else {
X! 				--multi;
X! 				rhack(save_cm);
X! 			}
X! 		} else if(multi == 0) {
X! #ifdef MAIL
X! 			ckmailstatus();
X! #endif
X! 			rhack(NULL);
X! 		}
X! 		if(multi && multi%7 == 0)
X! 			(void) fflush(stdout);
X! 	}
X  }
X  
X  void
X--- 302,309 ----
X  
X  	initrack();
X  
X! 	moveloop();
X! 	return(0);
X  }
X  
X  void
X***************
X*** 458,469 ****
X   * It may still contain a suffix denoting pl_character.
X   */
X  void
X! askname(){
X! register int c,ct;
X  	Printf("\nWho are you? ");
X  	(void) fflush(stdout);
X  	ct = 0;
X! 	while((c = Getchar()) != '\n'){
X  		if(c == EOF) error("End of input\n");
X  		/* some people get confused when their erase char is not ^H */
X  		if(c == '\010') {
X--- 324,336 ----
X   * It may still contain a suffix denoting pl_character.
X   */
X  void
X! askname() {
X! 	register int c, ct;
X! 
X  	Printf("\nWho are you? ");
X  	(void) fflush(stdout);
X  	ct = 0;
X! 	while((c = Getchar()) != '\n') {
X  		if(c == EOF) error("End of input\n");
X  		/* some people get confused when their erase char is not ^H */
X  		if(c == '\010') {
X***************
X*** 472,492 ****
X  		}
X  		if(c != '-')
X  		if(c < 'A' || (c > 'Z' && c < 'a') || c > 'z') c = '_';
X! 		if(ct < sizeof(plname)-1) plname[ct++] = c;
X  	}
X  	plname[ct] = 0;
X  	if(ct == 0) askname();
X  }
X  
X- /*VARARGS1*/
X- void
X- impossible(s,x1,x2)
X- register char *s, *x1, *x2;
X- {
X- 	pline(s,x1,x2);
X- 	pline("Program in disorder - perhaps you'd better Quit.");
X- }
X- 
X  #ifdef CHDIR
X  static void
X  chdirx(dir, wr)
X--- 339,351 ----
X  		}
X  		if(c != '-')
X  		if(c < 'A' || (c > 'Z' && c < 'a') || c > 'z') c = '_';
X! 		if(ct < sizeof(plname)-1)
X! 			plname[ct++] = c;
X  	}
X  	plname[ct] = 0;
X  	if(ct == 0) askname();
X  }
X  
X  #ifdef CHDIR
X  static void
X  chdirx(dir, wr)
X***************
X*** 515,521 ****
X  		error("Cannot chdir to %s.", dir);
X  	}
X  
X! 	/* warn the player if he cannot write the record file */
X  	/* perhaps we should also test whether . is writable */
X  	/* unfortunately the access systemcall is worthless */
X  	if(wr) {
X--- 374,380 ----
X  		error("Cannot chdir to %s.", dir);
X  	}
X  
X! 	/* warn the player if we can't write the record file */
X  	/* perhaps we should also test whether . is writable */
X  	/* unfortunately the access systemcall is worthless */
X  	if(wr) {
X***************
X*** 532,550 ****
X  }
X  #endif /* CHDIR /**/
X  
X- void
X- stop_occupation()
X- {
X- 	if(occupation) {
X- 		You("stop %s.", occtxt);
X- 		occupation = 0;
X- #ifdef REDO
X- 		multi = 0;
X- 		pushch(0);		
X- #endif
X- 	}
X- }
X- 
X  static void
X  whoami() {
X  	/*
X--- 391,396 ----
X***************
X*** 555,561 ****
X  	 * If everything fails, or if the resulting name is some generic
X  	 * account like "games", "play", "player", "hack" then eventually
X  	 * we'll ask him.
X! 	 * Note that we trust him here; it is possible to play under
X  	 * somebody else's name.
X  	 */
X  	register char *s;
X--- 401,407 ----
X  	 * If everything fails, or if the resulting name is some generic
X  	 * account like "games", "play", "player", "hack" then eventually
X  	 * we'll ask him.
X! 	 * Note that we trust the user here; it is possible to play under
X  	 * somebody else's name.
X  	 */
X  	register char *s;
X***************
X*** 566,607 ****
X  		(void) strncpy(plname, s, sizeof(plname)-1);
X  	if(!*plname && (s = getlogin()))
X  		(void) strncpy(plname, s, sizeof(plname)-1);
X- }
X- 
X- static void
X- newgame() {
X- 	fobj = fcobj = invent = 0;
X- 	fmon = fallen_down = 0;
X- 	ftrap = 0;
X- 	fgold = 0;
X- 	flags.ident = 1;
X- 
X- 	init_objects();
X- 	u_init();
X- 
X- 	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X- 
X- 	mklev();
X- 	u.ux = xupstair;
X- 	u.uy = yupstair;
X- 	(void) inshop();
X- 
X- 	setsee();
X- 	flags.botlx = 1;
X- 
X- 	/* Move the monster from under you or else
X- 	 * makedog() will fail when it calls makemon().
X- 	 * 			- ucsfcgl!kneller
X- 	 */
X- 	if(levl[u.ux][u.uy].mmask) mnexto(m_at(u.ux, u.uy));
X- 
X- 	(void) makedog();
X- 	seemons();
X- #ifdef NEWS
X- 	if(flags.nonews || !readnews())
X- 		/* after reading news we did docrt() already */
X- #endif
X- 		docrt();
X- 
X- 	return;
X  }
X--- 412,415 ----
X*** src/Old/unixtty.c	Wed Sep 27 12:24:56 1989
X--- src/unixtty.c	Sun Sep 17 14:26:48 1989
X***************
X*** 10,15 ****
X--- 10,16 ----
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X  #define ONAMES_H
X+ #define NEED_VARARGS
X  #include "hack.h"
X  
X  /*
X***************
X*** 187,199 ****
X  
X  /* fatal error */
X  /*VARARGS1*/
X  void
X! error(s, x, y)
X! char *s, *x, *y;
X! {
X  	if(settty_needed)
X  		settty(NULL);
X! 	Printf(s,x,y);
X  	(void) putchar('\n');
X  	exit(1);
X  }
X--- 188,202 ----
X  
X  /* fatal error */
X  /*VARARGS1*/
X+ 
X  void
X! error VA_DECL(char *,s)
X! 	VA_START(s);
X! 	VA_INIT(s, char *);
X  	if(settty_needed)
X  		settty(NULL);
X! 	Vprintf(s,VA_ARGS);
X  	(void) putchar('\n');
X+ 	VA_END();
X  	exit(1);
X  }
X*** src/Old/unixunix.c	Wed Sep 27 12:25:13 1989
X--- src/unixunix.c	Tue Sep 26 18:51:38 1989
X***************
X*** 27,33 ****
X  void
X  setrandom()
X  {
X! #ifdef SYSV
X  	(void) Srand((long) time ((time_t *) 0));
X  #else
X  #ifdef ULTRIX
X--- 27,33 ----
X  void
X  setrandom()
X  {
X! #if defined(SYSV) || defined(DGUX)
X  	(void) Srand((long) time ((time_t *) 0));
X  #else
X  #ifdef ULTRIX
X*** src/Old/vault.c	Wed Sep 27 12:25:28 1989
X--- src/vault.c	Mon Sep 25 21:30:30 1989
X***************
X*** 237,246 ****
X  	fcp->ftyp = typ;
X  newpos:
X  	if(EGD->gddone) nx = ny = 0;
X! 	levl[guard->mx][guard->my].mmask = 0;
X! 	levl[nx][ny].mmask = 1;
X! 	guard->mx = nx;
X! 	guard->my = ny;
X  	pmon(guard);
X  	restfakecorr();
X  	return(1);
X--- 237,244 ----
X  	fcp->ftyp = typ;
X  newpos:
X  	if(EGD->gddone) nx = ny = 0;
X! 	remove_monster(guard->mx, guard->my);
X! 	place_monster(guard, nx, ny);
X  	pmon(guard);
X  	restfakecorr();
X  	return(1);
X***************
X*** 270,277 ****
X  	if (!u.ugold) return;
X  
X  	if (u.uinvault) {
X! 	    Your("%ld Zorkmids goes into the Magic Memory Vault.",
X! 		u.ugold);
X  	    mkgold(u.ugold, u.ux, u.uy);
X  	    u.ugold = 0L;
X  	} else if (guard) {
X--- 268,275 ----
X  	if (!u.ugold) return;
X  
X  	if (u.uinvault) {
X! 	    Your("%ld zorkmid%s goes into the Magic Memory Vault.",
X! 		u.ugold, plur(u.ugold));
X  	    mkgold(u.ugold, u.ux, u.uy);
X  	    u.ugold = 0L;
X  	} else if (guard) {
X*** src/Old/version.c	Wed Sep 27 12:25:42 1989
X--- src/version.c	Sat Sep 16 17:54:27 1989
X***************
X*** 38,43 ****
X--- 38,46 ----
X  #ifdef UNIX
X  		"Unix",
X  #endif
X+ #ifdef VMS
X+ 		"VMS",
X+ #endif
X  		VERSION,
X  #ifndef BETA
X  		PATCHLEVEL,
X*** src/Old/weapon.c	Wed Sep 27 12:25:56 1989
X--- src/weapon.c	Fri Sep 15 00:51:04 1989
X***************
X*** 171,185 ****
X  #ifdef TOLKIEN
X  static const int rwep[] =
X  	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X! 	  SHURIKEN, ELVEN_ARROW, ARROW, ORCISH_ARROW, CROSSBOW_BOLT,
X! 	  ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK, LOADSTONE,
X! 	  LUCKSTONE, DART, BOOMERANG, CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #else
X  static const int rwep[] =
X! 	{ SPEAR, JAVELIN, SHURIKEN, ARROW, CROSSBOW_BOLT, DAGGER, KNIFE,
X! 	  ROCK, LOADSTONE, LUCKSTONE, DART, BOOMERANG, CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #endif
X--- 171,185 ----
X  #ifdef TOLKIEN
X  static const int rwep[] =
X  	{ DWARVISH_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
X! 	  SHURIKEN, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
X! 	  CROSSBOW_BOLT, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE, ROCK,
X! 	  LOADSTONE, LUCKSTONE, DART, BOOMERANG, CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #else
X  static const int rwep[] =
X! 	{ SPEAR, JAVELIN, SHURIKEN, SILVER_ARROW, ARROW, CROSSBOW_BOLT,
X! 	  DAGGER, KNIFE, ROCK, LOADSTONE, LUCKSTONE, DART, BOOMERANG, CREAM_PIE
X  	  /* note: CREAM_PIE should NOT be #ifdef KOPS */
X  	  };
X  #endif
X*** src/Old/were.c	Wed Sep 27 12:26:12 1989
X--- src/were.c	Thu Sep 14 14:34:44 1989
X***************
X*** 10,25 ****
X  {
X  	register int pm = monsndx(mon->data);
X  
X- 	if(Protection_from_shape_changers) return;
X  	if(is_were(mon->data))
X  	    if(is_human(mon->data)) {
X  		if(!rn2(50-(night()*20)) || flags.moonphase == FULL_MOON) {
X  		    new_were(mon);
X! 		    if(pm != PM_WERERAT && flags.soundok)
X  			You("hear a %s howling at the moon.",
X  			      pm == PM_WEREJACKAL ? "jackal" : "wolf");
X  		}
X! 	    } else if(!rn2(30)) new_were(mon);
X  }
X  
X  static int
X--- 10,25 ----
X  {
X  	register int pm = monsndx(mon->data);
X  
X  	if(is_were(mon->data))
X  	    if(is_human(mon->data)) {
X+ 		if(Protection_from_shape_changers) return;
X  		if(!rn2(50-(night()*20)) || flags.moonphase == FULL_MOON) {
X  		    new_were(mon);
X! 		    if(mons[pm].msound == MS_BARK && flags.soundok)
X  			You("hear a %s howling at the moon.",
X  			      pm == PM_WEREJACKAL ? "jackal" : "wolf");
X  		}
X! 	    } else if(!rn2(30) || Protection_from_shape_changers) new_were(mon);
X  }
X  
X  static int
X***************
X*** 69,75 ****
X  	register struct monst *mtmp;
X  	boolean success = FALSE;
X  
X! 	if(Protection_from_shape_changers)
X  		return FALSE;
X  	for(i = rnd(5); i > 0; i--) {
X  	   switch(pm) {
X--- 69,75 ----
X  	register struct monst *mtmp;
X  	boolean success = FALSE;
X  
X! 	if(Protection_from_shape_changers && !yours)
X  		return FALSE;
X  	for(i = rnd(5); i > 0; i--) {
X  	   switch(pm) {
X*** src/Old/wield.c	Wed Sep 27 12:26:26 1989
X--- src/wield.c	Mon Sep 25 23:01:52 1989
X***************
X*** 209,215 ****
X  	} else
X  		Sprintf(buf, "Your %s%s",
X  			is_sword(obj) ? "sword" : "weapon",
X! 			((obj->quan > 1) ? "s" : ""));
X  	Strcat(buf, (obj->quan==1) ? " is" : " are");
X  #ifdef POLYSELF
X  	Sprintf(eos(buf), " welded to your %s!",
X--- 209,215 ----
X  	} else
X  		Sprintf(buf, "Your %s%s",
X  			is_sword(obj) ? "sword" : "weapon",
X! 			plur((long)obj->quan));
X  	Strcat(buf, (obj->quan==1) ? " is" : " are");
X  #ifdef POLYSELF
X  	Sprintf(eos(buf), " welded to your %s!",
X*** src/Old/wizard.c	Wed Sep 27 12:26:39 1989
X--- src/wizard.c	Thu Sep 14 20:44:26 1989
X***************
X*** 80,93 ****
X  			    mnexto(mtmp);
X  			    return(0);
X  			}
X! 			if(!levl[otmp->ox][otmp->oy].mmask ||
X  			    (mtmp->mx == otmp->ox && mtmp->my == otmp->oy)) {
X  
X  			    /* teleport to it and pick it up */
X! 			    levl[mtmp->mx][mtmp->my].mmask = 0;
X! 			    levl[otmp->ox][otmp->oy].mmask = 1;
X! 			    mtmp->mx = otmp->ox;
X! 			    mtmp->my = otmp->oy;
X  			    freeobj(otmp);
X  			    mpickobj(mtmp, otmp);
X  			    pmon(mtmp);
X--- 80,91 ----
X  			    mnexto(mtmp);
X  			    return(0);
X  			}
X! 			if(!MON_AT(otmp->ox, otmp->oy) ||
X  			    (mtmp->mx == otmp->ox && mtmp->my == otmp->oy)) {
X  
X  			    /* teleport to it and pick it up */
X! 			    remove_monster(mtmp->mx, mtmp->my);
X! 			    place_monster(mtmp, otmp->ox, otmp->oy);
X  			    freeobj(otmp);
X  			    mpickobj(mtmp, otmp);
X  			    pmon(mtmp);
X*** src/Old/worm.c	Wed Sep 27 12:26:55 1989
X--- src/worm.c	Sun Sep 17 12:28:48 1989
X***************
X*** 47,53 ****
X  register struct wseg *wtmp;
X  {
X  	if (mtmp->mx != wtmp->wx || mtmp->my != wtmp->wy)
X! 		levl[wtmp->wx][wtmp->wy].mmask = 0;
X  	if(wtmp->wdispl) newsym(wtmp->wx, wtmp->wy);
X  	free((genericptr_t) wtmp);
X  }
X--- 47,53 ----
X  register struct wseg *wtmp;
X  {
X  	if (mtmp->mx != wtmp->wx || mtmp->my != wtmp->wy)
X! 		remove_monster(wtmp->wx, wtmp->wy);
X  	if(wtmp->wdispl) newsym(wtmp->wx, wtmp->wy);
X  	free((genericptr_t) wtmp);
X  }
X***************
X*** 181,187 ****
X  	/* sometimes the tail end dies */
X  	if(rn2(3) || !getwn(mtmp2)){
X  		monfree(mtmp2);
X! 		levl[mtmp2->mx][mtmp2->my].mmask = 1;
X  			/* since mtmp is still on that spot */
X  		tmp2 = 0;
X  	} else {
X--- 181,187 ----
X  	/* sometimes the tail end dies */
X  	if(rn2(3) || !getwn(mtmp2)){
X  		monfree(mtmp2);
X! 		place_worm_seg(mtmp, mtmp2->mx, mtmp2->my);
X  			/* since mtmp is still on that spot */
X  		tmp2 = 0;
X  	} else {
X***************
X*** 196,216 ****
X  		remseg(mtmp, wtmp->nseg);
X  		wtmp->nseg = 0;
X  		if(tmp2) {
X! 		    You("cut the worm in half.");
X  		/* devalue the monster level of both halves of the worm */
X  		    mtmp->m_lev = (mtmp->m_lev <= 2) ? 2 : mtmp->m_lev - 2;
X  		    mtmp2->m_lev = mtmp->m_lev;
X  		/* calculate the mhp on the new (lower) monster level */
X  		    mtmp2->mhpmax = mtmp2->mhp = d((int)mtmp2->m_lev, 8);
X! 		    mtmp2->mx = wtmp->wx;
X! 		    mtmp2->my = wtmp->wy;
X! 		    levl[mtmp2->mx][mtmp2->my].mmask = 1;
X  		    mtmp2->nmon = fmon;
X  		    fmon = mtmp2;
X  		    mtmp2->mdispl = 0;
X  		    pmon(mtmp2);
X  		} else {
X! 			You("cut off part of the worm's tail.");
X  			remseg(mtmp, wtmp);
X  		}
X  		mtmp->mhp /= 2;
X--- 196,215 ----
X  		remseg(mtmp, wtmp->nseg);
X  		wtmp->nseg = 0;
X  		if(tmp2) {
X! 		    kludge("You cut %s in half.", mon_nam(mtmp));
X  		/* devalue the monster level of both halves of the worm */
X  		    mtmp->m_lev = (mtmp->m_lev <= 2) ? 2 : mtmp->m_lev - 2;
X  		    mtmp2->m_lev = mtmp->m_lev;
X  		/* calculate the mhp on the new (lower) monster level */
X  		    mtmp2->mhpmax = mtmp2->mhp = d((int)mtmp2->m_lev, 8);
X! 		    place_monster(mtmp2, wtmp->wx, wtmp->wy);
X  		    mtmp2->nmon = fmon;
X  		    fmon = mtmp2;
X  		    mtmp2->mdispl = 0;
X  		    pmon(mtmp2);
X  		} else {
X! 			if (Blind) You("cut off part of its tail.");
X! 			else You("cut off part of %s's tail.", mon_nam(mtmp));
X  			remseg(mtmp, wtmp);
X  		}
X  		mtmp->mhp /= 2;
X*** src/Old/worn.c	Wed Sep 27 12:27:10 1989
X--- src/worn.c	Mon Sep 25 21:35:28 1989
X***************
X*** 138,144 ****
X  
X  	if (obj->otyp != DRAGON_SCALE_MAIL) return;
X  	switch(obj->corpsenm) {
X! 		case PM_GREY_DRAGON:
X  			mask = &Antimagic;
X  			break;
X  		case PM_RED_DRAGON:
X--- 138,144 ----
X  
X  	if (obj->otyp != DRAGON_SCALE_MAIL) return;
X  	switch(obj->corpsenm) {
X! 		case PM_GRAY_DRAGON:
X  			mask = &Antimagic;
X  			break;
X  		case PM_RED_DRAGON:
X*** src/Old/write.c	Wed Sep 27 12:27:23 1989
X--- src/write.c	Mon Sep 25 21:30:53 1989
X***************
X*** 96,102 ****
X  	getlin(namebuf);
X  	if(namebuf[0] == '\033' || !namebuf[0])
X  		return;
X! 	Strcpy(scrbuf,"scroll of ");
X  	Strcat(scrbuf,namebuf);
X  	newscroll = readobjnam(scrbuf);
X  
X--- 96,104 ----
X  	getlin(namebuf);
X  	if(namebuf[0] == '\033' || !namebuf[0])
X  		return;
X! 	scrbuf[0] = '\0';
X! 	if(strncmp(namebuf,"scroll of ",10) != 0)
X! 		Strcpy(scrbuf,"scroll of ");
X  	Strcat(scrbuf,namebuf);
X  	newscroll = readobjnam(scrbuf);
X  
X*** src/Old/zap.c	Wed Sep 27 12:27:39 1989
X--- src/zap.c	Tue Sep 26 23:23:24 1989
X***************
X*** 145,150 ****
X--- 145,156 ----
X  		break;
X  #endif
X  	case WAN_OPENING:
X+ 		if(u.uswallow && mtmp == u.ustuck) {
X+ 			if (Blind) pline("Its mouth opens!");
X+ 			else pline("%s opens its mouth!", Monnam(mtmp));
X+ 			regurgitates(mtmp);
X+ 			break;
X+ 		}
X  	case WAN_LOCKING:
X  #ifdef SPELLS
X  	case SPE_KNOCK:
X***************
X*** 189,195 ****
X  				montype = PM_UNARMORED_SOLDIER;
X  #endif
X  			mons[montype].pxlth += nl;
X! 			mtmp = mkmon_at(mons[montype].mname, x, y);
X  			mons[montype].pxlth -= nl;
X  			if (mtmp) {
X  				/* Monster retains its name */
X--- 195,201 ----
X  				montype = PM_UNARMORED_SOLDIER;
X  #endif
X  			mons[montype].pxlth += nl;
X! 			mtmp = makemon(&mons[montype], x, y);
X  			mons[montype].pxlth -= nl;
X  			if (mtmp) {
X  				/* Monster retains its name */
X***************
X*** 220,225 ****
X--- 226,234 ----
X  #ifdef MAIL
X  	    obj->otyp == SCR_MAIL ||
X  #endif
X+ #ifdef TUTTI_FRUTTI
X+ 	    obj->otyp == SLIME_MOLD ||
X+ #endif
X  	    obj->otyp == KEY || obj->otyp == SKELETON_KEY ||
X  	    obj->otyp == LARGE_BOX || obj->otyp == CHEST))
X  		obj->spe = (obj->olet == WAND_SYM) ? -1 : 0;
X***************
X*** 286,292 ****
X  			otmp2->opoisoned = 1;
X  
X  		/* Turn dragon corpses into dragon armors */
X! 		if (obj->otyp == CORPSE && obj->corpsenm >= PM_GREY_DRAGON
X  				&& obj->corpsenm <= PM_YELLOW_DRAGON) {
X  			if (!rn2(10)) { /* Random failure */
X  				otmp2->otyp = TIN;
X--- 295,301 ----
X  			otmp2->opoisoned = 1;
X  
X  		/* Turn dragon corpses into dragon armors */
X! 		if (obj->otyp == CORPSE && obj->corpsenm >= PM_GRAY_DRAGON
X  				&& obj->corpsenm <= PM_YELLOW_DRAGON) {
X  			if (!rn2(10)) { /* Random failure */
X  				otmp2->otyp = TIN;
X***************
X*** 781,787 ****
X  			if(u.uswallow) {
X  				register struct monst *mtmp = u.ustuck;
X  
X! 				You("pierce %s's stomach wall!", mon_nam(mtmp));
X  				mtmp->mhp = 1;	/* almost dead */
X  				regurgitates(mtmp);
X  				break;
X--- 790,798 ----
X  			if(u.uswallow) {
X  				register struct monst *mtmp = u.ustuck;
X  
X! 				if (Blind) You("pierce its stomach wall!");
X! 				else You("pierce %s's stomach wall!",
X! 					mon_nam(mtmp));
X  				mtmp->mhp = 1;	/* almost dead */
X  				regurgitates(mtmp);
X  				break;
X***************
X*** 939,945 ****
X--- 950,960 ----
X  
X  	if(sym) {
X  		tmp_at(-1, sym);	/* open call */
X+ #ifdef TEXTCOLOR
X+ 		tmp_at(-3, (int)objects[obj->otyp].oc_color);
X+ #else
X  		tmp_at(-3, (int)AT_OBJ);
X+ #endif
X  	}
X  	while(range-- > 0) {
X  #ifdef STRONGHOLD
X***************
X*** 949,955 ****
X  		bhitpos.y += ddy;
X  #ifdef STRONGHOLD
X  		x = bhitpos.x; y = bhitpos.y;
X! 		if (find_drawbridge(&x,&y))
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  # ifdef SPELLS
X--- 964,970 ----
X  		bhitpos.y += ddy;
X  #ifdef STRONGHOLD
X  		x = bhitpos.x; y = bhitpos.y;
X! 		if (find_drawbridge(&x,&y) && !sym)
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  # ifdef SPELLS
X***************
X*** 970,976 ****
X  			    destroy_drawbridge(x,y);
X  		    }
X  #endif /* STRONGHOLD /**/
X! 		if(levl[bhitpos.x][bhitpos.y].mmask){
X  			mtmp = m_at(bhitpos.x,bhitpos.y);
X  			if(sym) {
X  				tmp_at(-1, -1);	/* close call */
X--- 985,991 ----
X  			    destroy_drawbridge(x,y);
X  		    }
X  #endif /* STRONGHOLD /**/
X! 		if(MON_AT(bhitpos.x, bhitpos.y)){
X  			mtmp = m_at(bhitpos.x,bhitpos.y);
X  			if(sym) {
X  				tmp_at(-1, -1);	/* close call */
X***************
X*** 995,1001 ****
X  		    if(hitanything)	range--;
X  		}
X  		typ = levl[bhitpos.x][bhitpos.y].typ;
X! 		if(IS_DOOR(typ) || typ == SDOOR) {
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  			case WAN_LOCKING:
X--- 1010,1016 ----
X  		    if(hitanything)	range--;
X  		}
X  		typ = levl[bhitpos.x][bhitpos.y].typ;
X! 		if((IS_DOOR(typ) || typ == SDOOR) && !sym) {
X  		    switch (obj->otyp) {
X  			case WAN_OPENING:
X  			case WAN_LOCKING:
X***************
X*** 1065,1071 ****
X  		dy = ydir[i];
X  		bhitpos.x += dx;
X  		bhitpos.y += dy;
X! 		if(levl[bhitpos.x][bhitpos.y].mmask){
X  			tmp_at(-1,-1);
X  			return(m_at(bhitpos.x,bhitpos.y));
X  		}
X--- 1080,1086 ----
X  		dy = ydir[i];
X  		bhitpos.x += dx;
X  		bhitpos.y += dy;
X! 		if(MON_AT(bhitpos.x, bhitpos.y)){
X  			tmp_at(-1,-1);
X  			return(m_at(bhitpos.x,bhitpos.y));
X  		}
X***************
X*** 1075,1082 ****
X  			break;
X  		}
X  		if(bhitpos.x == u.ux && bhitpos.y == u.uy) { /* ct == 9 */
X! 			if(rn2(20) >= ACURR(A_DEX)){ /* we hit ourselves */
X! 				(void) thitu(10, rnd(10), "boomerang");
X  				break;
X  			} else {	/* we catch it */
X  				tmp_at(-1,-1);
X--- 1090,1099 ----
X  			break;
X  		}
X  		if(bhitpos.x == u.ux && bhitpos.y == u.uy) { /* ct == 9 */
X! 			if(Fumbling || rn2(20) >= ACURR(A_DEX)){
X! 				/* we hit ourselves */
X! 				(void) thitu(10, rnd(10), (struct obj *)0,
X! 					"boomerang");
X  				break;
X  			} else {	/* we catch it */
X  				tmp_at(-1,-1);
X***************
X*** 1186,1196 ****
X  }
X  
X  /*
X!  * burn scrolls on floor at position x,y
X!  * return the number of scrolls burned
X   */
X  static int
X! burn_floor_scrolls(x, y)
X  int x, y;
X  {
X  	register struct obj *obj, *obj2;
X--- 1203,1213 ----
X  }
X  
X  /*
X!  * burn scrolls and spell books on floor at position x,y
X!  * return the number of scrolls and spell books burned
X   */
X  static int
X! burn_floor_paper(x, y)
X  int x, y;
X  {
X  	register struct obj *obj, *obj2;
X***************
X*** 1200,1206 ****
X  	for(obj = fobj; obj; obj = obj2) {
X  	    obj2 = obj->nobj;
X  	    /* Bug fix - KAA */
X! 	    if(obj->ox == x && obj->oy == y && obj->olet == SCROLL_SYM) {
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X  		    if(!rn2(3))  {
X--- 1217,1228 ----
X  	for(obj = fobj; obj; obj = obj2) {
X  	    obj2 = obj->nobj;
X  	    /* Bug fix - KAA */
X! 	    if(obj->ox == x && obj->oy == y &&
X! #ifdef SPELLS
X! 	       (obj->olet == SCROLL_SYM || obj->olet == SPBOOK_SYM)) {
X! #else
X! 	       obj->olet == SCROLL_SYM) {
X! #endif
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X  		    if(!rn2(3))  {
X***************
X*** 1391,1402 ****
X  			}
X  		}
X  		if(OBJ_AT(sx, sy) && abstype == 1)
X! 			if(burn_floor_scrolls(sx,sy) && cansee(sx,sy))  {
X  			    mnewsym(sx,sy);
X  			    if(!Blind)
X  				You("see a puff of smoke.");
X  			}
X! 		if(levl[sx][sy].mmask){
X  			mon = m_at(sx,sy);
X  			/* Cannot use wakeup() which also angers the monster */
X  			mon->msleep = 0;
X--- 1413,1424 ----
X  			}
X  		}
X  		if(OBJ_AT(sx, sy) && abstype == 1)
X! 			if(burn_floor_paper(sx,sy) && cansee(sx,sy))  {
X  			    mnewsym(sx,sy);
X  			    if(!Blind)
X  				You("see a puff of smoke.");
X  			}
X! 		if(MON_AT(sx, sy)){
X  			mon = m_at(sx,sy);
X  			/* Cannot use wakeup() which also angers the monster */
X  			mon->msleep = 0;
X***************
X*** 1863,1889 ****
X  {
X  	register int	resisted = 0;
X  #ifdef HARD
X! 	register int	level;
X  
X  	switch(olet)  {
X  
X  	    case WAND_SYM:
X! 			level = 8;
X  			break;
X  
X  	    case SCROLL_SYM:
X! 			level = 6;
X  			break;
X  
X  	    case POTION_SYM:
X! 			level = 5;
X  			break;
X  
X! 	    default:	level = u.ulevel;
X  			break;
X  	}
X  
X! 	resisted = (rn2(100) - mtmp->m_lev + level) < mtmp->data->mr;
X  	if(resisted) {
X  
X  		if(tell) {
X--- 1885,1911 ----
X  {
X  	register int	resisted = 0;
X  #ifdef HARD
X! 	register int	lev;
X  
X  	switch(olet)  {
X  
X  	    case WAND_SYM:
X! 			lev = 8;
X  			break;
X  
X  	    case SCROLL_SYM:
X! 			lev = 6;
X  			break;
X  
X  	    case POTION_SYM:
X! 			lev = 5;
X  			break;
X  
X! 	    default:	lev = u.ulevel;
X  			break;
X  	}
X  
X! 	resisted = (rn2(100) - mtmp->m_lev + lev) < mtmp->data->mr;
X  	if(resisted) {
X  
X  		if(tell) {
X***************
X*** 1925,1933 ****
X  	}
X  	if (otmp != &zeroobj) {
X  	    if(dropit) {
X! 		pline("Oops!  The %s drop%s to the floor!", xname(otmp),
X! 			otmp->quan > 1 ? "" : "s");
X! 		dropy(otmp);
X  	    } else {
X  	    	wishquan = otmp->quan;
X  	    	otmp = addinv(otmp);
X--- 1947,1954 ----
X  	}
X  	if (otmp != &zeroobj) {
X  	    if(dropit) {
X! 	        pline("Oops!  The %s to the floor!", aobjnam(otmp, "drop"));
X! 	        dropy(otmp);
X  	    } else {
X  	    	wishquan = otmp->quan;
X  	    	otmp = addinv(otmp);
X
END_OF_FILE
if test 56197 -ne `wc -c <'patches04e'`; then
    echo shar: \"'patches04e'\" unpacked with wrong size!
fi
# end of 'patches04e'
fi
echo shar: End of archive 5 \(of 11\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
