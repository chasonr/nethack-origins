Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i037:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch4a
Message-ID: <4627@tekred.CNA.TEK.COM>
Date: 29 Sep 89 21:07:24 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2032
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 37
Archive-name: NetHack3/Patch4a
Patch-To: NetHack3: Volume 7, Issue 56-93

	[Here is patch #4 for NetHack3 (in 11 parts).  Unpack all
	 11 parts in your top-level NetHack directory then execute
	 the do_patch4.sh shell script (or the equivalent if you're
	 not on a Unix machine, or don't have 'sh').  -br]

[[ From the development team...
-------------
UPDATE4
-------------
NOTICE:  The changes which were made in the code make all save and bones 
files absolete.  Once Patch 4 is applied, all the old save and bones files
must be thrown out.


Here is a list of the main changes:

Object and monster types got a new field specifying their color, so things 
can now appear in "living color" instead having one color for all monsters,
one for all weapons, and so on.

References to monsters and objects on the floor were moved to new structures,
which support the better color handling as well as provide yet faster access.

David Gentzel provided a port for VMS.  Although extensively tested by
David and others, and found to be sound, it probably needs further
refinements.  We are appealing to those of you who know VMS (none of us
does..) to join David in his efforts to refine the VMS code.

Much of the *main.c code was moved to a new file, to avoid having to update
that common code in three different *main.c files.

VARARG handling was ifdef'd to satisfy ANSI compilers.

Almost all grey creatures now join the other gray creatures.

Monsters will no longer be created in the same room as the player, and should
no longer want to end up in the SE corner of the dungeon.

Lycanthropy is now considered a "major problem" (allowing for appeal to the
gods through prayer), some artifacts are associated with particular character
classes, various oddities involving statues, digging, iron balls, and 
throwing have been removed, and many other bugs, both major and minor, were
fixed.]]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 11)."
# Contents:  patches04a
# Wrapped by billr@saab on Fri Sep 29 13:13:17 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches04a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches04a'\"
else
echo shar: Extracting \"'patches04a'\" \(55684 characters\)
sed "s/^X//" >'patches04a' <<'END_OF_FILE'
X*** src/Old/Makefile.src	Wed Sep 27 12:16:31 1989
X--- src/Makefile.src	Tue Sep 26 19:07:09 1989
X***************
X*** 5,11 ****
X  # Makefile.3B2, Makefile.att, and Makefile.tos.
X  # Set SYSTEM to one of:
X  #	'Sysunix'	-- generic UNIX
X- #	'Sysxenix'	-- 286 Xenix (386 Xenix should use Sysunix)
X  #	'Sys3B2'	-- AT&T 3B2, 3B5, etc.
X  #	'Sysatt'	-- AT&T UNIXPC, 7300, 3B1
X  #	'Systos'	-- Atari
X--- 5,10 ----
X***************
X*** 37,44 ****
X  
X  # flags may have to be changed as required
X  # flags for 286 Xenix:
X! # CFLAGS = -O -Gt24 -LARGE -Ml -I../include
X! # LFLAGS = -Ml
X  # flags for 286 Microport SysV-AT
X  # CFLAGS = -DDUMB -Ml -I../include
X  # LFLAGS = -Ml
X--- 36,43 ----
X  
X  # flags may have to be changed as required
X  # flags for 286 Xenix:
X! # CFLAGS = -Ml2t16 -O -LARGE -I../include
X! # LFLAGS = -Ml -F 4000 -SEG 512
X  # flags for 286 Microport SysV-AT
X  # CFLAGS = -DDUMB -Ml -I../include
X  # LFLAGS = -Ml
X***************
X*** 50,63 ****
X  
X  # object files for makedefs
X  MAKEOBJS = makedefs.o monst.o objects.o panic.o
X- # objects files for makedefs for 286 Xenix
X- # MAKEOBJS = Smakedefs.o Smonst.o Sobjects.o Spanic.o
X  
X  # object files for special levels compiler
X  SPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X- # object files for special levels compiler for 286 Xenix
X- # SPLEVOBJS = Slev_comp.o Slev_lex.o Slev_main.o Salloc.o Smonst.o Sobjects.o \
X- #	      Spanic.o
X  
X  # on some systems the termcap library is in -ltermcap or -lcurses
X  # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
X--- 49,57 ----
X***************
X*** 87,103 ****
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! HACKCSRC = alloc.c apply.c artifact.c attrib.c bones.c cmd.c dbridge.c decl.c\
X! 	   demon.c do.c do_name.c do_wear.c dog.c dogmove.c dokick.c dothrow.c\
X!  	   eat.c end.c engrave.c exper.c extralev.c fountain.c getline.c hack.c\
X! 	   invent.c ioctl.c lock.c mail.c makemon.c mcastu.c mhitm.c mhitu.c\
X! 	   mklev.c mkmaze.c mkobj.c mkroom.c mon.c mondata.c monmove.c monst.c\
X! 	   mthrowu.c music.c o_init.c objects.c objnam.c options.c pager.c\
X! 	   pickup.c polyself.c potion.c pray.c pri.c priest.c prisym.c read.c\
X!  	   restore.c rip.c rnd.c rumors.c save.c search.c shk.c shknam.c sit.c\
X! 	   sounds.c sp_lev.c spell.c steal.c termcap.c timeout.c topl.c\
X! 	   topten.c track.c trap.c u_init.c uhitm.c vault.c version.c weapon.c\
X! 	   were.c wield.c wizard.c worm.c worn.c write.c zap.c
X  
X  # all .c that are part of the main NetHack program and are not system specific
X  
X--- 81,98 ----
X  # other things that have to be reconfigured are in config.h,
X  # {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
X  
X! HACKCSRC = allmain.c alloc.c apply.c artifact.c attrib.c bones.c cmd.c\
X! 	   dbridge.c decl.c demon.c do.c do_name.c do_wear.c dog.c dogmove.c\
X! 	   dokick.c dothrow.c eat.c end.c engrave.c exper.c extralev.c\
X! 	   fountain.c getline.c hack.c invent.c ioctl.c lock.c mail.c makemon.c\
X! 	   mcastu.c mhitm.c mhitu.c mklev.c mkmaze.c mkobj.c mkroom.c mon.c\
X! 	   mondata.c monmove.c monst.c mthrowu.c music.c o_init.c objects.c\
X! 	   objnam.c options.c pager.c pickup.c polyself.c potion.c pray.c pri.c\
X! 	   priest.c prisym.c read.c restore.c rip.c rnd.c rumors.c save.c\
X! 	   search.c shk.c shknam.c sit.c sounds.c sp_lev.c spell.c steal.c\
X! 	   termcap.c timeout.c topl.c topten.c track.c trap.c u_init.c uhitm.c\
X! 	   vault.c version.c weapon.c were.c wield.c wizard.c worm.c worn.c\
X! 	   write.c zap.c
X  
X  # all .c that are part of the main NetHack program and are not system specific
X  
X***************
X*** 122,131 ****
X  
X  SOURCES = $(CSOURCES) $(HSOURCES)
X  
X! HOBJ = alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o decl.o\
X! 	demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o dothrow.o\
X!  	eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o hack.o\
X! 	invent.o ioctl.o lock.o mail.o main.o makemon.o mcastu.o mhitm.o\
X  	mhitu.o mklev.o mkmaze.o mkobj.o mkroom.o mon.o mondata.o monmove.o\
X  	monst.o mthrowu.o music.o o_init.o objects.o objnam.o options.o pager.o\
X  	pickup.o polyself.o potion.o pray.o pri.o priest.o prisym.o read.o\
X--- 117,126 ----
X  
X  SOURCES = $(CSOURCES) $(HSOURCES)
X  
X! HOBJ = allmain.o alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o\
X! 	decl.o demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o\
X! 	dothrow.o eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o\
X! 	hack.o invent.o ioctl.o lock.o mail.o main.o makemon.o mcastu.o mhitm.o\
X  	mhitu.o mklev.o mkmaze.o mkobj.o mkroom.o mon.o mondata.o monmove.o\
X  	monst.o mthrowu.o music.o o_init.o objects.o objnam.o options.o pager.o\
X  	pickup.o polyself.o potion.o pray.o pri.o priest.o prisym.o read.o\
X***************
X*** 144,154 ****
X  	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB)
X  	@touch Sysunix
X  
X- Sysxenix:	$(HOBJ) Makefile
X- 	@echo "Loading ..."
X- 	@$(CC) $(LFLAGS) -m hack.map -o $(GAME) /lib/Lsignal.o $(HOBJ) $(TERMLIB) -SEG#256
X- 	@touch Sysxenix
X- 
X  Sys3B2:	$(HOBJ) Makefile
X  	@echo "Loading ..."
X  	@$(CC) $(LFLAGS) -o $(GAME) $(HOBJ) $(TERMLIB) -lmalloc
X--- 139,144 ----
X***************
X*** 222,264 ****
X  	$(LEX) lev_comp.l
X  	mv lex.yy.c lev_lex.c
X  
X- # special stuff for 286 Xenix makedefs & lev_comp
X- 
X- Smakedefs.o:	makedefs.c ../include/config.h ../include/permonst.h
X- 	cp makedefs.c Smakedefs.c
X- 	$(CC) -O -c Smakedefs.c
X- 
X- Slev_comp.o:  lev_comp.c ../include/hack.h ../include/sp_lev.h
X- 	cp lev_comp.c Slev_comp.c
X- 	$(CC) -O -c Slev_comp.c
X- 
X- Slev_lex.o: lev_lex.c ../include/hack.h ../include/sp_lev.h ../include/lev_comp.h
X- 	cp lev_lex.c Slev_lex.c
X- 	$(CC) -O -c Slev_lex.c
X- 
X- Slev_main.o: lev_main.c ../include/hack.h ../include/sp_lev.h
X- 	cp lev_main.c Slev_main.c
X- 	$(CC) -O -c Slev_main.c
X- 
X- Salloc.o:	alloc.c
X- 	cp alloc.c Salloc.c
X- 	$(CC) -O -c Salloc.c
X- 
X- Smonst.o:	monst.c ../include/config.h ../include/permonst.h \
X- 		../include/monsym.h ../include/epri.h ../include/eshk.h \
X- 		../include/vault.h
X- 	cp monst.c Smonst.c
X- 	$(CC) -O -c Smonst.c
X- 
X- Sobjects.o:	objects.c ../include/config.h ../include/obj.h \
X- 		../include/objclass.h ../include/prop.h
X- 	cp objects.c Sobjects.c
X- 	$(CC) -O -c Sobjects.c
X- 
X- Spanic.o:	panic.c
X- 	cp panic.c Spanic.c
X- 	$(CC) -O -c Spanic.c
X- 
X  #
X  #	The following include files depend on makedefs to be created.
X  #	As a result, they are not defined in HACKINCL, instead, their
X--- 212,217 ----
X***************
X*** 370,375 ****
X--- 323,329 ----
X  
X  # DO NOT DELETE THIS LINE
X  
X+ allmain.o:  ../include/hack.h
X  alloc.o:  ../include/config.h
X  apply.o:  ../include/hack.h ../include/edog.h
X  artifact.o:  ../include/hack.h ../include/artifact.h
X***************
X*** 406,419 ****
X  mkmaze.o:  ../include/hack.h
X  mkobj.o:  ../include/hack.h
X  mkroom.o:  ../include/hack.h
X! mon.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
X  mondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
X  monmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
X! monst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h
X  mthrowu.o:  ../include/hack.h
X  music.o:  ../include/hack.h
X  o_init.o:  ../include/hack.h
X! objects.o:  ../include/config.h ../include/obj.h ../include/objclass.h ../include/prop.h
X  objnam.o:  ../include/hack.h
X  options.o:  ../include/hack.h
X  pager.o:  ../include/hack.h
X--- 360,373 ----
X  mkmaze.o:  ../include/hack.h
X  mkobj.o:  ../include/hack.h
X  mkroom.o:  ../include/hack.h
X! mon.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h ../include/wseg.h
X  mondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
X  monmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
X! monst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h ../include/decl.h
X  mthrowu.o:  ../include/hack.h
X  music.o:  ../include/hack.h
X  o_init.o:  ../include/hack.h
X! objects.o:  ../include/config.h ../include/obj.h ../include/objclass.h ../include/prop.h ../include/decl.h
X  objnam.o:  ../include/hack.h
X  options.o:  ../include/hack.h
X  pager.o:  ../include/hack.h
X***************
X*** 421,427 ****
X  polyself.o:  ../include/hack.h
X  potion.o:  ../include/hack.h
X  pray.o:  ../include/hack.h
X! pri.o:  ../include/hack.h
X  priest.o:  ../include/hack.h ../include/mfndpos.h ../include/eshk.h ../include/epri.h
X  prisym.o:  ../include/hack.h ../include/wseg.h ../include/lev.h
X  read.o:  ../include/hack.h
X--- 375,381 ----
X  polyself.o:  ../include/hack.h
X  potion.o:  ../include/hack.h
X  pray.o:  ../include/hack.h
X! pri.o:  ../include/hack.h ../include/epri.h
X  priest.o:  ../include/hack.h ../include/mfndpos.h ../include/eshk.h ../include/epri.h
X  prisym.o:  ../include/hack.h ../include/wseg.h ../include/lev.h
X  read.o:  ../include/hack.h
X***************
X*** 447,453 ****
X  u_init.o:  ../include/hack.h
X  uhitm.o:  ../include/hack.h ../include/artifact.h
X  vault.o:  ../include/hack.h ../include/vault.h
X! version.o:  ../include/hack.h ../include/date.h
X  weapon.o:  ../include/hack.h
X  were.o:  ../include/hack.h
X  wield.o:  ../include/hack.h
X--- 401,407 ----
X  u_init.o:  ../include/hack.h
X  uhitm.o:  ../include/hack.h ../include/artifact.h
X  vault.o:  ../include/hack.h ../include/vault.h
X! version.o:  ../include/hack.h ../include/date.h ../include/patchlevel.h
X  weapon.o:  ../include/hack.h
X  were.o:  ../include/hack.h
X  wield.o:  ../include/hack.h
X***************
X*** 460,468 ****
X  			touch ../include/config.h
X  ../include/decl.h:  ../include/spell.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X  			touch ../include/decl.h
X! ../include/global.h:  ../include/coord.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h
X  			touch ../include/global.h
X! ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h
X  			touch ../include/hack.h
X  ../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X  			touch ../include/permonst.h
X--- 414,422 ----
X  			touch ../include/config.h
X  ../include/decl.h:  ../include/spell.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X  			touch ../include/decl.h
X! ../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h
X  			touch ../include/global.h
X! ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h ../include/extern.h
X  			touch ../include/hack.h
X  ../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X  			touch ../include/permonst.h
X*** /dev/null	Wed Sep 27 11:17:44 1989
X--- src/allmain.c	Tue Sep 26 18:59:13 1989
X***************
X*** 0 ****
X--- 1,253 ----
X+ /*	SCCS Id: @(#)allmain.c	3.0	89/09/26
X+ /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ /* various code that was replicated in *main.c */
X+ 
X+ #include "hack.h"
X+ 
X+ #ifndef NO_SIGNAL
X+ #include <signal.h>
X+ #endif
X+ 
X+ int (*afternmv)();
X+ int (*occupation)();
X+ 
X+ void
X+ moveloop()
X+ {
X+ #ifdef MSDOS
X+ 	char ch;
X+ 	int abort;
X+ #endif
X+ 
X+ 	for(;;) {
X+ 		if(flags.move) {	/* actual time passed */
X+ 
X+ #ifdef SOUNDS
X+ 			dosounds();
X+ #endif
X+ 			settrack();
X+ 
X+ 			if(moves%2 == 0 ||
X+ 			  (!(Fast & ~INTRINSIC) && (!Fast || rn2(3)))) {
X+ 				movemon();
X+ #ifdef HARD
X+ 				if(!rn2(u.udemigod?25:(dlevel>30)?50:70))
X+ #else
X+ 				if(!rn2(70))
X+ #endif
X+ 				    (void) makemon((struct permonst *)0, 0, 0);
X+ 				++monstermoves;
X+ 			}
X+ 			if(Glib) glibr();
X+ 			timeout();
X+ 			++moves;
X+ #ifdef THEOLOGY
X+ 			if (u.ublesscnt)  u.ublesscnt--;
X+ #endif
X+ 			if(flags.time) flags.botl = 1;
X+ #ifdef POLYSELF
X+ 			if(u.mtimedone)
X+ 			    if(u.mh < 1) rehumanize();
X+ 			else
X+ #endif
X+ 			    if(u.uhp < 1) {
X+ 				You("die...");
X+ 				done(DIED);
X+ 			    }
X+ #ifdef POLYSELF
X+ 			if (u.mtimedone) {
X+ 			    if (u.mh < u.mhmax) {
X+ 				if (Regeneration || !(moves%20)) {
X+ 					flags.botl = 1;
X+ 					u.mh++;
X+ 				}
X+ 			    }
X+ 			}
X+ #endif
X+ 			if(u.uhp < u.uhpmax) {
X+ 				if(u.ulevel > 9) {
X+ 				    int heal;
X+ 
X+ 				    if(HRegeneration || !(moves%3)) {
X+ 					flags.botl = 1;
X+ 					if (ACURR(A_CON) <= 12) heal = 1;
X+ 					else heal = rnd((int) ACURR(A_CON)-12);
X+ 					if (heal > u.ulevel-9) heal = u.ulevel-9;
X+ 					u.uhp += heal;
X+ 					if(u.uhp > u.uhpmax)
X+ 					    u.uhp = u.uhpmax;
X+ 				    }
X+ 				} else if(HRegeneration ||
X+ 					(!(moves%((MAXULEV+12)/(u.ulevel+2)+1)))) {
X+ 					flags.botl = 1;
X+ 					u.uhp++;
X+ 				}
X+ 			}
X+ #ifdef SPELLS
X+ 			if ((u.uen<u.uenmax) && (!(moves%(19-ACURR(A_INT)/2)))) {
X+ 				u.uen += rn2((int)ACURR(A_WIS)/5 + 1) + 1;
X+ 				if (u.uen > u.uenmax)  u.uen = u.uenmax;
X+ 				flags.botl = 1;
X+ 			}
X+ #endif
X+ 			if(Teleportation && !rn2(85)) tele();
X+ #ifdef POLYSELF
X+ 			if(Polymorph && !rn2(100))
X+ 				polyself();
X+ 			if(u.ulycn >= 0 && !rn2(80 - (20 * night())))
X+ 				you_were();
X+ #endif
X+ 			if(Searching && multi >= 0) (void) dosearch0(1);
X+ 			hatch_eggs();
X+ 			gethungry();
X+ 			invault();
X+ 			amulet();
X+ #ifdef HARD
X+ 			if (!rn2(40+(int)(ACURR(A_DEX)*3))) u_wipe_engr(rnd(3));
X+ 			if (u.udemigod) {
X+ 				if (u.udg_cnt) u.udg_cnt--;
X+ 				if (!u.udg_cnt) {
X+ 					intervene();
X+ 					u.udg_cnt = rn1(200, 50);
X+ 				}
X+ 			}
X+ #endif
X+ 			restore_attrib();
X+ 		}
X+ 		if(multi < 0) {
X+ 			if(!++multi){
X+ 				pline(nomovemsg ? nomovemsg :
X+ 					"You can move again.");
X+ 				nomovemsg = 0;
X+ 				if(afternmv) (*afternmv)();
X+ 				afternmv = 0;
X+ 			}
X+ 		}
X+ 
X+ 		find_ac();
X+ 		if(!flags.mv || Blind)
X+ 		{
X+ 			seeobjs();
X+ 			seemons();
X+ 			seeglds();
X+ 			nscr();
X+ 		}
X+ 		if(flags.botl || flags.botlx) bot();
X+ 
X+ 		flags.move = 1;
X+ 
X+ 		if(multi >= 0 && occupation) {
X+ #ifdef MSDOS
X+ 			abort = 0;
X+ 			if (kbhit()) {
X+ 				if ((ch = Getchar()) == ABORT)
X+ 					abort++;
X+ # ifdef REDO
X+ 				else
X+ 					pushch(ch);
X+ # endif /* REDO */
X+ 			}
X+ 			if(abort || monster_nearby())
X+ #else
X+ 			if(monster_nearby())
X+ #endif
X+ 				stop_occupation();
X+ 			else if ((*occupation)() == 0)
X+ 				occupation = 0;
X+ #ifdef MSDOS
X+ 			if (!(++occtime % 7))
X+ 				(void) fflush(stdout);
X+ #endif
X+ 			continue;
X+ 		}
X+ 
X+ 		if((u.uhave_amulet || Clairvoyant) && 
X+ #ifdef ENDGAME
X+ 			dlevel != ENDLEVEL &&
X+ #endif
X+ 			!(moves%15) && !rn2(2)) do_vicinity_map();
X+ 
X+ 		u.umoved = FALSE;
X+ 		if(multi > 0) {
X+ 			lookaround();
X+ 			if(!multi) {	/* lookaround may clear multi */
X+ 				flags.move = 0;
X+ 				continue;
X+ 			}
X+ 			if(flags.mv) {
X+ 				if(multi < COLNO && !--multi)
X+ 					flags.mv = flags.run = 0;
X+ 				domove();
X+ 			} else {
X+ 				--multi;
X+ 				rhack(save_cm);
X+ 			}
X+ 		} else if(multi == 0) {
X+ #ifdef MAIL
X+ 			ckmailstatus();
X+ #endif
X+ 			rhack(NULL);
X+ 		}
X+ 		if(multi && multi%7 == 0)
X+ 			(void) fflush(stdout);
X+ 	}
X+ }
X+ 
X+ void
X+ stop_occupation()
X+ {
X+ 	if(occupation) {
X+ 		You("stop %s.", occtxt);
X+ 		occupation = 0;
X+ #ifdef REDO
X+ 		multi = 0;
X+ 		pushch(0);
X+ #endif
X+ 	}
X+ }
X+ 
X+ void
X+ newgame() {
X+ #ifdef DGK
X+ 	gameDiskPrompt();
X+ #endif
X+ 
X+ 	fobj = fcobj = invent = 0;
X+ 	fmon = fallen_down = 0;
X+ 	ftrap = 0;
X+ 	fgold = 0;
X+ 	flags.ident = 1;
X+ 
X+ 	init_objects();
X+ 	u_init();
X+ 
X+ #ifndef NO_SIGNAL
X+ 	(void) signal(SIGINT, (SIG_RET_TYPE) done1);
X+ #endif
X+ 
X+ 	mklev();
X+ 	u.ux = xupstair;
X+ 	u.uy = yupstair;
X+ 	(void) inshop();
X+ 
X+ 	setsee();
X+ 	flags.botlx = 1;
X+ 
X+ 	/* Move the monster from under you or else
X+ 	 * makedog() will fail when it calls makemon().
X+ 	 * 			- ucsfcgl!kneller
X+ 	 */
X+ 	if(MON_AT(u.ux, u.uy)) mnexto(m_at(u.ux, u.uy));
X+ 
X+ 	(void) makedog();
X+ 	seemons();
X+ #ifdef NEWS
X+ 	if(flags.nonews || !readnews())
X+ 		/* after reading news we did docrt() already */
X+ #endif
X+ 		docrt();
X+ 
X+ 	return;
X+ }
X*** src/Old/apply.c	Wed Sep 27 11:18:07 1989
X--- src/apply.c	Tue Sep 26 16:08:31 1989
X***************
X*** 31,37 ****
X  	while(range--) {
X  		bchx += ddx;
X  		bchy += ddy;
X! 		if(levl[bchx][bchy].mmask) {
X  			mtmp = m_at(bchx,bchy);
X  			break;
X  		}
X--- 31,37 ----
X  	while(range--) {
X  		bchx += ddx;
X  		bchy += ddy;
X! 		if(MON_AT(bchx, bchy)) {
X  			mtmp = m_at(bchx,bchy);
X  			break;
X  		}
X***************
X*** 155,161 ****
X  		return;
X  	}
X  	lev = &levl[rx][ry];
X! 	if(lev->mmask) {
X  		mtmp = m_at(rx,ry);
X  		mstatusline(mtmp);
X  		if (mtmp->mundetected) {
X--- 155,161 ----
X  		return;
X  	}
X  	lev = &levl[rx][ry];
X! 	if(MON_AT(rx, ry)) {
X  		mtmp = m_at(rx,ry);
X  		mstatusline(mtmp);
X  		if (mtmp->mundetected) {
X***************
X*** 288,294 ****
X  		return;
X  	}
X  
X! 	if(levl[x][y].mmask == 0) {
X  		pline("There is no creature here.");
X  		return;
X  	}
X--- 288,294 ----
X  		return;
X  	}
X  
X! 	if(!MON_AT(x, y)) {
X  		pline("There is no creature here.");
X  		return;
X  	}
X***************
X*** 441,448 ****
X  	if(Fumbling && !rn2(3)) {
X  		switch(rn2(3)) {
X  		case 0:  if(!welded(uwep)) {
X! 			     You("fumble and drop your %s", xname(uwep));
X  			     dropx(uwep);
X  			 } else {
X  			     pline("Ouch!  Your %s bounces and hits you!",
X  				xname(uwep));
X--- 441,449 ----
X  	if(Fumbling && !rn2(3)) {
X  		switch(rn2(3)) {
X  		case 0:  if(!welded(uwep)) {
X! 			     You("fumble and drop your %s.", xname(uwep));
X  			     dropx(uwep);
X+ 			     setuwep((struct obj *)0);
X  			 } else {
X  			     pline("Ouch!  Your %s bounces and hits you!",
X  				xname(uwep));
X***************
X*** 516,523 ****
X  			digtxt = "You just broke a hole through the door.";
X  			if(!(lev->doormask & D_TRAPPED))
X  				lev->doormask = D_BROKEN;
X! 		} else
X! 		  digtxt = "Now what exactly was it that you were digging in?";
X  		mnewsym(dpx, dpy);
X  		prl(dpx, dpy);
X  		if (digtxt) pline(digtxt);	/* after mnewsym & prl */
X--- 517,523 ----
X  			digtxt = "You just broke a hole through the door.";
X  			if(!(lev->doormask & D_TRAPPED))
X  				lev->doormask = D_BROKEN;
X! 		} else return(0); /* statue or boulder got taken */
X  		mnewsym(dpx, dpy);
X  		prl(dpx, dpy);
X  		if (digtxt) pline(digtxt);	/* after mnewsym & prl */
X***************
X*** 537,543 ****
X  			IS_DOOR(lev->typ) ? "door" : "wall");
X  			return(0);
X  		    }
X! 		}
X  		if(!did_dig_msg) {
X  		    You("hit the %s with all your might.",
X  			sobj_at(STATUE, dpx, dpy) ? "statue" :
X--- 537,545 ----
X  			IS_DOOR(lev->typ) ? "door" : "wall");
X  			return(0);
X  		    }
X! 		} else if (!IS_ROCK(lev->typ) && !sobj_at(STATUE, dpx, dpy)
X! 				&& !sobj_at(BOULDER, dpx, dpy))
X! 			return(0); /* statue or boulder got taken */
X  		if(!did_dig_msg) {
X  		    You("hit the %s with all your might.",
X  			sobj_at(STATUE, dpx, dpy) ? "statue" :
X***************
X*** 552,558 ****
X  /* When will hole be finished? Very rough indication used by shopkeeper. */
X  int
X  holetime() {
X! 	return( (occupation == dig) ? (250 - dig_effort)/20 : -1);
X  }
X  
X  void
X--- 554,561 ----
X  /* When will hole be finished? Very rough indication used by shopkeeper. */
X  int
X  holetime() {
X! 	if(occupation != dig || !in_shop(u.ux, u.uy)) return(-1);
X! 	return((250 - dig_effort)/20);
X  }
X  
X  void
X***************
X*** 679,685 ****
X  		rx = u.ux + u.dx;
X  		ry = u.uy + u.dy;
X  		lev = &levl[rx][ry];
X! 		if(lev->mmask && attack(m_at(rx, ry)))
X  			return(1);
X  		if(!isok(rx, ry)) {
X  			pline("Clash!");
X--- 682,688 ----
X  		rx = u.ux + u.dx;
X  		ry = u.uy + u.dy;
X  		lev = &levl[rx][ry];
X! 		if(MON_AT(rx, ry) && attack(m_at(rx, ry)))
X  			return(1);
X  		if(!isok(rx, ry)) {
X  			pline("Clash!");
X***************
X*** 1076,1082 ****
X  	} else if (!cansee(cc.x, cc.y)) {
X  		You("cannot see where to land!");
X  		return 0;
X! 	} else if (levl[cc.x][cc.y].mmask) {
X  		mtmp = m_at(cc.x, cc.y);
X  		You("cannot trample %s!", mon_nam(mtmp));
X  		return 0;
X--- 1079,1085 ----
X  	} else if (!cansee(cc.x, cc.y)) {
X  		You("cannot see where to land!");
X  		return 0;
X! 	} else if (MON_AT(cc.x, cc.y)) {
X  		mtmp = m_at(cc.x, cc.y);
X  		You("cannot trample %s!", mon_nam(mtmp));
X  		return 0;
X*** src/Old/artifact.c	Wed Sep 27 11:18:52 1989
X--- src/artifact.c	Mon Sep 25 21:28:23 1989
X***************
X*** 15,24 ****
X  
X  { LONG_SWORD,	 "Excalibur",	(SPFX_NOGEN | SPFX_SEEK | SPFX_DEFN |
X  								SPFX_SEARCH), 0,
X!   { 0, AD_PHYS, 5, 10 }, { 0, AD_DRLI, 0, 0}, A_LAW },
X  
X  { KATANA,	 "Snickersnee",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 0, 8 }, NO_ATTK, A_LAW },
X  
X  /*	Ah, never shall I forget the cry, 
X   *		or the shriek that shrieked he,
X--- 15,24 ----
X  
X  { LONG_SWORD,	 "Excalibur",	(SPFX_NOGEN | SPFX_SEEK | SPFX_DEFN |
X  								SPFX_SEARCH), 0,
X!   { 0, AD_PHYS, 5, 10 }, { 0, AD_DRLI, 0, 0}, A_LAW, 'K' },
X  
X  { KATANA,	 "Snickersnee",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 0, 8 }, NO_ATTK, A_LAW, 'S' },
X  
X  /*	Ah, never shall I forget the cry, 
X   *		or the shriek that shrieked he,
X***************
X*** 30,100 ****
X   */
X  
X  { AXE,		 "Cleaver",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 3, 12 }, NO_ATTK, A_CHAOS },
X  
X  #ifdef TOLKIEN
X  { ORCISH_DAGGER, "Grimtooth",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 2, 6 }, NO_ATTK, A_CHAOS },
X  #else
X  { DAGGER,	 "Grimtooth",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 2, 6 }, NO_ATTK, A_CHAOS },
X  #endif
X  
X  /*  Special purpose swords - various types */
X  
X! { TWO_HANDED_SWORD, "Orcrist",	SPFX_DCLAS, S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  #ifdef TOLKIEN
X! { ELVEN_DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DCLAS), S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  #else
X! { DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DCLAS), S_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  #endif
X  
X  { LONG_SWORD,	 "Frost Brand", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_COLD, 5, 0 }, { 0, AD_COLD, 0, 0 }, A_NEUTRAL },
X  
X  { LONG_SWORD,	 "Fire Brand",	(SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_FIRE, 5, 0 }, { 0, AD_FIRE, 0, 0 }, A_NEUTRAL },
X  
X  /* Stormbringer only has a 2 because it can drain a level, providing 8 more */
X  { BROADSWORD,	 "Stormbringer", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN |
X  								SPFX_DRLI), 0,
X!   { 0, AD_DRLI, 5, 2 }, { 0, AD_DRLI, 0, 0 }, A_CHAOS },
X  
X! { LONG_SWORD,	 "Sunsword",	(SPFX_RESTR | SPFX_DCLAS), 0, /* undead */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  { BROADSWORD,	 "Dragonbane",	(SPFX_RESTR | SPFX_DCLAS), S_DRAGON,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_NEUTRAL },
X  
X! { LONG_SWORD,	 "Demonbane",	(SPFX_RESTR | SPFX_DCLAS), 0, /* demons */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  /* A silver weapon would be appropriate, if we had one. */
X! { LONG_SWORD,	 "Werebane",	(SPFX_RESTR | SPFX_DCLAS), 0, /* weres */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X! { LONG_SWORD,	 "Giantslayer", (SPFX_RESTR | SPFX_DCLAS), 0, /* giants */
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_NEUTRAL },
X  
X  /* Another interesting weapon would be the dwarven hammer or axe with the
X   * boomerang-like power of returning to the wielder's hand, if the code
X   * were written to add such an ability.
X   */
X! { WAR_HAMMER, "Ogresmasher",	(SPFX_RESTR | SPFX_DCLAS),  S_OGRE,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  { WAR_HAMMER, "Mjollnir",	(SPFX_RESTR | SPFX_ATTK),  0,
X!   { 0, AD_ELEC, 5, 24 }, NO_ATTK, A_LAW }, /* Mjo:llnir */
X  
X  { MORNING_STAR,	 "Trollsbane", (SPFX_RESTR | SPFX_DCLAS), S_TROLL,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW },
X  
X  /*	ARRAY TERMINATOR	*/
X! { 0,  "", 0, 0, NO_ATTK, NO_ATTK, 0 }
X  };
X  
X  void
X--- 30,100 ----
X   */
X  
X  { AXE,		 "Cleaver",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 3, 12 }, NO_ATTK, A_CHAOS, 0 },
X  
X  #ifdef TOLKIEN
X  { ORCISH_DAGGER, "Grimtooth",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 2, 6 }, NO_ATTK, A_CHAOS, 0 },
X  #else
X  { DAGGER,	 "Grimtooth",	SPFX_RESTR, 0,
X!   { 0, AD_PHYS, 2, 6 }, NO_ATTK, A_CHAOS, 0 },
X  #endif
X  
X  /*  Special purpose swords - various types */
X  
X! { TWO_HANDED_SWORD, "Orcrist",	SPFX_DFLAG2, M2_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 'E' },
X  
X  #ifdef TOLKIEN
X! { ELVEN_DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DFLAG2), M2_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  #else
X! { DAGGER,	 "Sting",	(SPFX_WARN | SPFX_DFLAG2), M2_ORC,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  #endif
X  
X  { LONG_SWORD,	 "Frost Brand", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_COLD, 5, 0 }, { 0, AD_COLD, 0, 0 }, A_NEUTRAL, 0 },
X  
X  { LONG_SWORD,	 "Fire Brand",	(SPFX_RESTR | SPFX_ATTK | SPFX_DEFN), 0,
X!   { 0, AD_FIRE, 5, 0 }, { 0, AD_FIRE, 0, 0 }, A_NEUTRAL, 0 },
X  
X  /* Stormbringer only has a 2 because it can drain a level, providing 8 more */
X  { BROADSWORD,	 "Stormbringer", (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN |
X  								SPFX_DRLI), 0,
X!   { 0, AD_DRLI, 5, 2 }, { 0, AD_DRLI, 0, 0 }, A_CHAOS, 0 },
X  
X! { LONG_SWORD,	 "Sunsword",	(SPFX_RESTR | SPFX_DFLAG1), M1_UNDEAD,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  { BROADSWORD,	 "Dragonbane",	(SPFX_RESTR | SPFX_DCLAS), S_DRAGON,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_NEUTRAL, 0 },
X  
X! { LONG_SWORD,	 "Demonbane",	(SPFX_RESTR | SPFX_DFLAG2), M2_DEMON,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  /* A silver weapon would be appropriate, if we had one. */
X! { LONG_SWORD,	 "Werebane",	(SPFX_RESTR | SPFX_DFLAG1), M1_WERE,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X! { LONG_SWORD,	 "Giantslayer", (SPFX_RESTR | SPFX_DFLAG2), M2_GIANT,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_NEUTRAL, 0 },
X  
X  /* Another interesting weapon would be the dwarven hammer or axe with the
X   * boomerang-like power of returning to the wielder's hand, if the code
X   * were written to add such an ability.
X   */
X! { WAR_HAMMER, "Ogresmasher",	(SPFX_RESTR | SPFX_DCLAS), S_OGRE,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  { WAR_HAMMER, "Mjollnir",	(SPFX_RESTR | SPFX_ATTK),  0,
X!   { 0, AD_ELEC, 5, 24 }, NO_ATTK, A_LAW, 'V' }, /* Mjo:llnir */
X  
X  { MORNING_STAR,	 "Trollsbane", (SPFX_RESTR | SPFX_DCLAS), S_TROLL,
X!   { 0, AD_PHYS, 5, 0 }, NO_ATTK, A_LAW, 0 },
X  
X  /*	ARRAY TERMINATOR	*/
X! { 0,  "", 0, 0, NO_ATTK, NO_ATTK, 0, 0 }
X  };
X  
X  void
X***************
X*** 177,183 ****
X  	register int n = 0;
X  
X  	for(artif = artilist; artif->otyp; artif++)
X! 	    if(align == artif->align && !(artif->spfx & SPFX_NOGEN)) n++;
X  	if (n) {
X  		n = rnd(n);
X  		for(artif = artilist; artif->otyp && n > 0; ) {
X--- 177,186 ----
X  	register int n = 0;
X  
X  	for(artif = artilist; artif->otyp; artif++)
X! 	    if(align == artif->align && !(artif->spfx & SPFX_NOGEN))
X! 		if (pl_character[0] == artif->class) {
X! 		    n=0; break;
X! 		} else n++;
X  	if (n) {
X  		n = rnd(n);
X  		for(artif = artilist; artif->otyp && n > 0; ) {
X***************
X*** 185,195 ****
X  			n--;
X  		    if (n > 0) artif++;
X  		}
X! 		if(artif->otyp) {
X! 			otmp = mksobj((int)artif->otyp, FALSE);
X! 			otmp = oname(otmp, artif->name, 0);
X! 			return (otmp);
X! 		}
X  	}
X  	return ((struct obj *) 0);
X  }
X--- 188,198 ----
X  			n--;
X  		    if (n > 0) artif++;
X  		}
X! 	}
X! 	if(artif->otyp) {
X! 		otmp = mksobj((int)artif->otyp, FALSE);
X! 		otmp = oname(otmp, artif->name, 0);
X! 		return (otmp);
X  	}
X  	return ((struct obj *) 0);
X  }
X***************
X*** 212,239 ****
X  register struct artifact *weap;
X  struct permonst *ptr;
X  {
X! 	if(!(weap->spfx & (SPFX_DMONS | SPFX_DCLAS | SPFX_ATTK)))
X  	    return(1);
X  
X  	if(weap->spfx & SPFX_DMONS)
X! 	    return((ptr == &mons[weap->mtype]));
X! 	else if(weap->spfx & SPFX_DCLAS) {
X! 
X! 	    if(weap->mtype)
X! 		return((weap->mtype == ptr->mlet));
X! 	    else {
X! 		if(!strcmp(weap->name, "Sunsword"))
X! 		    return(is_undead(ptr));
X! 		else if(!strcmp(weap->name, "Demonbane"))
X! 		    return(is_demon(ptr));
X! 		else if(!strcmp(weap->name, "Werebane"))
X! 		    return(is_were(ptr));
X! 		else if(!strcmp(weap->name, "Giantslayer"))
X! 		    return(is_giant(ptr));
X! 		else impossible("Weird class specific weapon '%s'",
X! 				weap->name);
X! 	    }
X! 	} else if(weap->spfx & SPFX_ATTK) {
X  	    switch(weap->attk.adtyp) {
X  		case AD_FIRE:	return(!resists_fire(ptr));
X  		case AD_COLD:	return(!resists_cold(ptr));
X--- 215,232 ----
X  register struct artifact *weap;
X  struct permonst *ptr;
X  {
X! 	if(!(weap->spfx & (SPFX_DBONUS | SPFX_ATTK)))
X  	    return(1);
X  
X  	if(weap->spfx & SPFX_DMONS)
X! 	    return((ptr == &mons[(int)weap->mtype]));
X! 	else if(weap->spfx & SPFX_DCLAS)
X! 	    return((weap->mtype == ptr->mlet));
X! 	else if(weap->spfx & SPFX_DFLAG1)
X! 	    return((ptr->mflags1 & weap->mtype) != 0L);
X! 	else if(weap->spfx & SPFX_DFLAG2)
X! 	    return((ptr->mflags2 & weap->mtype) != 0L);
X! 	else if(weap->spfx & SPFX_ATTK) {
X  	    switch(weap->attk.adtyp) {
X  		case AD_FIRE:	return(!resists_fire(ptr));
X  		case AD_COLD:	return(!resists_cold(ptr));
X*** src/Old/attrib.c	Wed Sep 27 11:19:13 1989
X--- src/attrib.c	Mon Sep 25 21:29:23 1989
X***************
X*** 88,94 ****
X  	struct	attribs	base, dist;
X   	schar	align, aligntyp;
X  	schar	shp, hd, xlev, ndx;
X! /* According to AD&D, HD for some classes (i.e. Wizard) should be smaller
X   * (4-sided for wizards).  But this is not AD&D, and using the AD&D
X   * rule here produces an unplayable character.  This I have used a minimum
X   * of an 10-sided hit die for everything.  Another AD&D change: wizards get
X--- 88,94 ----
X  	struct	attribs	base, dist;
X   	schar	align, aligntyp;
X  	schar	shp, hd, xlev, ndx;
X! /* According to AD&D, HD for some classes (ex. Wizard) should be smaller
X   * (4-sided for wizards).  But this is not AD&D, and using the AD&D
X   * rule here produces an unplayable character.  This I have used a minimum
X   * of an 10-sided hit die for everything.  Another AD&D change: wizards get
X*** src/Old/bones.c	Wed Sep 27 11:19:32 1989
X--- src/bones.c	Tue Sep 26 16:08:32 1989
X***************
X*** 16,22 ****
X  extern long bytes_counted;
X  #endif
X  #else
X! char bones[] = "bones.xx";
X  #endif
X  
X  #ifdef COMPRESS
X--- 16,22 ----
X  extern long bytes_counted;
X  #endif
X  #else
X! char bones[] = "bones.xxxx";
X  #endif
X  
X  #ifdef COMPRESS
X***************
X*** 130,135 ****
X--- 130,138 ----
X  	for(f=ffruit; f; f=f->nextf) f->fid = -f->fid;
X  #endif
X  
X+ 	/* check iron balls separately--maybe they're not carrying it */
X+ 	if (uball) uball->owornmask = uchain->owornmask = 0;
X+ 
X  	/* drop everything; the corpse's possessions are usually cursed */
X  	otmp = invent;
X  	while(otmp) {
X***************
X*** 177,183 ****
X  #ifdef TUTTI_FRUTTI
X  		    if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X  #endif
X! 		    if(uses_known(otmp)) otmp->known = 0;
X  		    if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X  			otmp->spe = -1;  /* no longer the actual amulet */
X  			curse(otmp);
X--- 180,186 ----
X  #ifdef TUTTI_FRUTTI
X  		    if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X  #endif
X! 		    if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X  		    if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X  			otmp->spe = -1;  /* no longer the actual amulet */
X  			curse(otmp);
X***************
X*** 201,207 ****
X  #endif
X  		   )
X  			otmp->onamelth = 0;
X! 		if(uses_known(otmp)) otmp->known = 0;
X  #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X  #endif
X--- 204,210 ----
X  #endif
X  		   )
X  			otmp->onamelth = 0;
X! 		if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X  #ifdef TUTTI_FRUTTI
X  		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X  #endif
X***************
X*** 355,371 ****
X   * but be careful if you use it for other things -dgk
X   */
X  void
X! name_file(file, level)
X  char *file;
X! int level;
X  {
X  	char *tf;
X  
X  	if (tf = rindex(file, '.'))
X! 	    Sprintf(tf+1, "%d", level);
X  #ifdef MSDOS /* for glo() */
X  	else if (tf = eos(file))
X! 	    Sprintf(tf, ".%d", level);
X  #endif
X  	return;
X  }
X--- 358,378 ----
X   * but be careful if you use it for other things -dgk
X   */
X  void
X! name_file(file, lev)
X  char *file;
X! int lev;
X  {
X  	char *tf;
X  
X  	if (tf = rindex(file, '.'))
X! #ifdef VMS
X! 	    Sprintf(tf+1, "%d;1", lev);
X! #else
X!   	    Sprintf(tf+1, "%d", lev);
X! #endif
X  #ifdef MSDOS /* for glo() */
X  	else if (tf = eos(file))
X! 	    Sprintf(tf, ".%d", lev);
X  #endif
X  	return;
X  }
X*** src/Old/cmd.c	Wed Sep 27 11:19:52 1989
X--- src/cmd.c	Mon Sep 25 22:55:13 1989
X***************
X*** 348,353 ****
X--- 348,354 ----
X  
X  void
X  enlightenment() {
X+ 	char buf[BUFSZ];
X  
X  	cornline(0, "Current Attributes:");
X  
X***************
X*** 355,360 ****
X--- 356,367 ----
X  	else if (u.ualign > 3) cornline(1, "You are stridently aligned.");
X  	else if (u.ualign > 0) cornline(1, "You are haltingly aligned.");
X  	else cornline(1, "You have strayed.");
X+ #ifdef WIZARD
X+ 	if (wizard) {
X+ 		Sprintf(buf, "Your alignment is %d.", u.ualign);
X+ 		cornline(1, buf);
X+ 	}
X+ #endif
X  
X  	if (Adornment) cornline(1, "You are adorned.");
X  	if (Teleportation) cornline(1, "You can teleport.");
X***************
X*** 388,395 ****
X  	if (Invisible) cornline(1, "You are invisible.");
X  	else if (Invis) cornline(1, "You are invisible to others.");
X  	if (Wounded_legs) {
X- 		char buf[41];
X- 
X  		Sprintf(buf, "You have wounded %s.",
X  						makeplural(body_part(LEG)));
X  		cornline(1, buf);
X--- 395,400 ----
X***************
X*** 397,404 ****
X  	if (Stoned) cornline(1, "You are turning to stone.");
X  	/* if (Hallucination) cornline(1, "You are hallucinating."); */
X  	if (Glib) {
X- 		char buf[41];
X- 
X  		Sprintf(buf, "You have slippery %s.",
X  						makeplural(body_part(FINGER)));
X  		cornline(1, buf);
X--- 402,407 ----
X***************
X*** 420,425 ****
X--- 423,434 ----
X  		if (stone_luck(FALSE) >= 0)
X  			cornline(1, "Good luck does not time out for you.");
X  	}
X+ #ifdef WIZARD
X+ 	if (wizard) {
X+ 		Sprintf(buf, "Your luck is %d.", u.uluck);
X+ 		cornline(1, buf);
X+ 	}
X+ #endif
X  
X  	cornline(2, "");
X  	return;
X*** src/Old/dbridge.c	Wed Sep 27 11:20:19 1989
X--- src/dbridge.c	Thu Sep 14 14:12:30 1989
X***************
X*** 222,228 ****
X  	}
X  	lev2->diggable = (W_NONDIGGABLE | W_GATEWAY);
X  	if ((lev1->drawbridgemask & DB_UNDER) == DB_MOAT) {
X! 	    if (lev1->mmask && !is_flyer((mtmp = m_at(x,y))->data)) {
X  		if (is_swimmer(mtmp->data)) {
X  		    if (flags.soundok) You("hear a splash.");
X  		} else {
X--- 222,228 ----
X  	}
X  	lev2->diggable = (W_NONDIGGABLE | W_GATEWAY);
X  	if ((lev1->drawbridgemask & DB_UNDER) == DB_MOAT) {
X! 	    if (MON_AT(x, y) && !is_flyer((mtmp = m_at(x,y))->data)) {
X  		if (is_swimmer(mtmp->data)) {
X  		    if (flags.soundok) You("hear a splash.");
X  		} else {
X***************
X*** 244,250 ****
X  		    if (!Wwalking) drown();
X  	    }
X  	}
X! 	if (lev2->mmask && !noncorporeal((mtmp = m_at(x2, y2))->data)) {
X  		if (cansee(x2,y2))
X  		    pline("%s is crushed by the portcullis.",Monnam(mtmp));
X  		else if (flags.soundok)
X--- 244,250 ----
X  		    if (!Wwalking) drown();
X  	    }
X  	}
X! 	if (MON_AT(x2,y2) && !noncorporeal((mtmp = m_at(x2, y2))->data)) {
X  		if (cansee(x2,y2))
X  		    pline("%s is crushed by the portcullis.",Monnam(mtmp));
X  		else if (flags.soundok)
X*** src/Old/decl.c	Wed Sep 27 11:20:37 1989
X--- src/decl.c	Tue Sep 26 12:59:05 1989
X***************
X*** 72,78 ****
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X  #ifdef TEXTCOLOR
X! char *HI_COLOR[8];		/* terminal escapes for the various colors */
X  #endif
X  
X  #ifdef MSDOS
X--- 72,78 ----
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X  #ifdef TEXTCOLOR
X! char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X  #endif
X  
X  #ifdef MSDOS
X***************
X*** 89,95 ****
X  const char *alllevels = "levels.*";
X  const char *allbones = "bones.*";
X  #else
X! char lock[PL_NSIZ+4] = "1lock";	/* long enough for login name .99 */
X  #endif
X  
X  int dig_effort = 0;	/* effort expended on current pos */
X--- 89,99 ----
X  const char *alllevels = "levels.*";
X  const char *allbones = "bones.*";
X  #else
X! # ifdef VMS
X! char lock[PL_NSIZ+16] = "1lock";/* long enough for uic+login_name+.99;1 */
X! # else
X! char lock[PL_NSIZ+14] = "1lock";/* long enough for uic+login_name+.99 */
X! # endif
X  #endif
X  
X  int dig_effort = 0;	/* effort expended on current pos */
X***************
X*** 125,132 ****
X  coord doors[DOORMAX] = DUMMY;
X  
X  struct mkroom rooms[MAXNROFROOMS+1] = DUMMY;
X! struct rm levl[COLNO][ROWNO] = DUMMY;		/* level map */
X! struct monst *fmon = 0;
X  struct trap *ftrap = 0;
X  struct gold *fgold = 0;
X  struct monst youmonst = DUMMY;	/* dummy; used as return value for boomhit */
X--- 129,135 ----
X  coord doors[DOORMAX] = DUMMY;
X  
X  struct mkroom rooms[MAXNROFROOMS+1] = DUMMY;
X! level_t level;		/* level map */
X  struct trap *ftrap = 0;
X  struct gold *fgold = 0;
X  struct monst youmonst = DUMMY;	/* dummy; used as return value for boomhit */
X***************
X*** 133,139 ****
X  struct flag flags = DUMMY;
X  struct you u = DUMMY;
X  
X! struct obj *fobj = 0, *fcobj = 0, *invent = 0, *uwep = 0, *uarm = 0,
X  #ifdef SHIRT
X  	*uarmu = 0,		/* under-wear, so to speak */
X  #endif
X--- 136,142 ----
X  struct flag flags = DUMMY;
X  struct you u = DUMMY;
X  
X! struct obj *fcobj = 0, *invent = 0, *uwep = 0, *uarm = 0,
X  #ifdef SHIRT
X  	*uarmu = 0,		/* under-wear, so to speak */
X  #endif
X***************
X*** 186,192 ****
X  struct spell spl_book[MAXSPELL + 1] = DUMMY;
X  #endif
X  
X! long moves = 1;
X  long wailmsg = 0;
X  
X  struct obj zeroobj = DUMMY;	/* used to zero all elements of a struct obj */
X--- 189,195 ----
X  struct spell spl_book[MAXSPELL + 1] = DUMMY;
X  #endif
X  
X! long moves = 1, monstermoves = 1; /* These diverge when player is Fast */
X  long wailmsg = 0;
X  
X  struct obj zeroobj = DUMMY;	/* used to zero all elements of a struct obj */
X*** src/Old/demon.c	Wed Sep 27 11:20:53 1989
X--- src/demon.c	Mon Sep 25 21:29:25 1989
X***************
X*** 84,91 ****
X  	    return mtmp->mpeaceful = 0;
X  	else {
X  
X! 	    pline("%s demands %ld Zorkmids for safe passage.",
X! 		  Xmonnam(mtmp), demand);
X  
X  	    if((offer = bribe(mtmp)) >= demand) {
X  		pline("%s vanishes laughing about cowardly mortals.",
X--- 84,91 ----
X  	    return mtmp->mpeaceful = 0;
X  	else {
X  
X! 	    pline("%s demands %ld zorkmid%s for safe passage.",
X! 		  Xmonnam(mtmp), demand, plur(demand));
X  
X  	    if((offer = bribe(mtmp)) >= demand) {
X  		pline("%s vanishes laughing about cowardly mortals.",
X***************
X*** 127,134 ****
X   	} else if(offer >= u.ugold) {
X  		You("give %s all your gold.", x_monnam(mtmp, 0));
X  		offer = u.ugold;
X! 	} else You("give %s %ld Zorkmid%s.", x_monnam(mtmp, 0), offer,
X! 		   offer == 1 ? "" : "s");
X  
X  	u.ugold -= offer;
X  	return(offer);
X--- 127,134 ----
X   	} else if(offer >= u.ugold) {
X  		You("give %s all your gold.", x_monnam(mtmp, 0));
X  		offer = u.ugold;
X! 	} else You("give %s %ld zorkmid%s.", x_monnam(mtmp, 0), offer,
X! 		   plur(offer));
X  
X  	u.ugold -= offer;
X  	return(offer);
X*** src/Old/do.c	Wed Sep 27 11:21:10 1989
X--- src/do.c	Mon Sep 25 22:57:35 1989
X***************
X*** 30,47 ****
X  struct obj *obj;
X  int x,y;
X  {
X! 	if(obj->otyp == BOULDER && IS_POOL(levl[x][y].typ)) {
X  #ifdef STRONGHOLD
X! 	    if(levl[x][y].typ == DRAWBRIDGE_UP)
X! 		levl[x][y].drawbridgemask |= DB_FLOOR;
X! 	    else
X  #endif
X! 		levl[x][y].typ = ROOM;
X! 	    if (cansee(x,y))
X! 		pline("There is a large splash as the boulder fills the %s.",
X  			(levl[x][y].typ==POOL) ? "pool" : "moat");
X! 	    else if (flags.soundok)
X! 		You("hear a splash.");
X  	    obfree(obj, (struct obj *)0);
X  	    mnewsym(x,y);
X  	    if ((x != u.ux || y != u.uy || Invisible) && !Blind)
X--- 30,75 ----
X  struct obj *obj;
X  int x,y;
X  {
X! 	struct trap *t = t_at(x,y);
X! 	boolean pool = IS_POOL(levl[x][y].typ);
X! 
X! 	if(obj->otyp == BOULDER && (pool ||
X! 	  (t && (t->ttyp==PIT || t->ttyp==SPIKED_PIT || t->ttyp==TRAPDOOR)))) {
X! 	    if (pool) {
X  #ifdef STRONGHOLD
X! 		if(levl[x][y].typ == DRAWBRIDGE_UP)
X! 		    levl[x][y].drawbridgemask |= DB_FLOOR;
X! 		else
X  #endif
X! 		    levl[x][y].typ = ROOM;
X! 		if (cansee(x,y))
X! 		  pline("There is a large splash as the boulder fills the %s.",
X  			(levl[x][y].typ==POOL) ? "pool" : "moat");
X! 		else if (flags.soundok)
X! 		    You("hear a splash.");
X! 	    } else if (t) {
X! 		if(is_maze_lev
X! #ifdef STRONGHOLD
X! 		 	&& (dlevel > stronghold_level)
X! #endif
X! 			&& t->ttyp == TRAPDOOR) return FALSE;
X! 		if (Blind) You("hear the boulder roll.");
X! 		else pline("The boulder %sfills a %s.",
X! 			t->tseen ? "" : "triggers and ",
X! 			t->ttyp == TRAPDOOR ? "trapdoor" : "pit");
X! 		deltrap(t);
X! 		if (u.utrap && x==u.ux && y==u.uy) {
X! 		    u.utrap = 0;
X! #ifdef POLYSELF
X! 		    if (!passes_walls(uasmon)) {
X! #endif
X! 			pline("Unfortunately, you were still in it.");
X! 			losehp(rnd(15), "burial beneath a boulder");
X! #ifdef POLYSELF
X! 		    }
X! #endif
X! 		}
X! 	    }
X  	    obfree(obj, (struct obj *)0);
X  	    mnewsym(x,y);
X  	    if ((x != u.ux || y != u.uy || Invisible) && !Blind)
X***************
X*** 225,231 ****
X  		obj->bknown = 1;
X  		pline("For some reason, you cannot %s the stone%s!",
X  			word,
X! 			obj->quan==1 ? "" : "s");
X  		return(FALSE);
X  	}
X  #ifdef WALKIES
X--- 253,259 ----
X  		obj->bknown = 1;
X  		pline("For some reason, you cannot %s the stone%s!",
X  			word,
X! 			plur((long)obj->quan));
X  		return(FALSE);
X  	}
X  #ifdef WALKIES
X***************
X*** 322,328 ****
X  		fobj = obj;
X  		place_object(obj, u.ux, u.uy);
X  		if(Invisible) newsym(u.ux,u.uy);
X! 		if(obj != uball) subfrombill(obj);
X  		stackobj(obj);
X  	}
X  }
X--- 350,356 ----
X  		fobj = obj;
X  		place_object(obj, u.ux, u.uy);
X  		if(Invisible) newsym(u.ux,u.uy);
X! 		if(obj != uball) sellobj(obj);
X  		stackobj(obj);
X  	}
X  }
X***************
X*** 348,353 ****
X--- 376,386 ----
X  #endif
X  	  ) {
X  		if (!(trap = t_at(u.ux,u.uy)) || trap->ttyp != TRAPDOOR
X+ 			|| (is_maze_lev
X+ #ifdef STRONGHOLD
X+ 				&& (dlevel > stronghold_level)
X+ #endif
X+ 								)
X  							|| !trap->tseen) {
X  			You("can't go down here.");
X  			return(0);
X***************
X*** 404,410 ****
X--- 437,450 ----
X  		You("are being held, and cannot go up.");
X  		return(1);
X  	}
X+ #ifdef POLYSELF
X+ 	/* Some monsters have carrying capacities less than 5, and we don't
X+ 	 * want to totally keep them from going upstairs.
X+ 	 */
X+ 	if((invent || u.ugold) && inv_weight() + 5 > 0) {
X+ #else
X  	if(inv_weight() + 5 > 0) {
X+ #endif
X  		/* No levitation check; inv_weight() already allows for it */
X  #ifdef STRONGHOLD
X  		Your("load is too heavy to climb the %s.",
X***************
X*** 700,706 ****
X  		u.ux = rnd(COLNO-1);
X  		u.uy = rn2(ROWNO);
X  	    } while(tryct++ < 100 && (levl[u.ux][u.uy].typ != ROOM &&
X! 		     levl[u.ux][u.uy].typ != CORR) || levl[u.ux][u.uy].mmask);
X  	    if(tryct >= 100)
X  		panic("goto_level: could not relocate player!");
X  	    if(Punished){
X--- 740,746 ----
X  		u.ux = rnd(COLNO-1);
X  		u.uy = rn2(ROWNO);
X  	    } while(tryct++ < 100 && (levl[u.ux][u.uy].typ != ROOM &&
X! 		     levl[u.ux][u.uy].typ != CORR) || MON_AT(u.ux, u.uy));
X  	    if(tryct >= 100)
X  		panic("goto_level: could not relocate player!");
X  	    if(Punished){
X***************
X*** 719,725 ****
X  	initrack();
X  
X  	losedogs();
X! 	if(levl[u.ux][u.uy].mmask) mnexto(m_at(u.ux, u.uy));
X  	flags.nscrinh = 0;
X  	setsee();
X  	seeobjs();	/* make old cadavers disappear - riv05!a3 */
X--- 759,765 ----
X  	initrack();
X  
X  	losedogs();
X! 	if(MON_AT(u.ux, u.uy)) mnexto(m_at(u.ux, u.uy));
X  	flags.nscrinh = 0;
X  	setsee();
X  	seeobjs();	/* make old cadavers disappear - riv05!a3 */
X***************
X*** 732,738 ****
X  	if (dlevel == 1 && u.uhave_amulet && flags.no_of_wizards == 0)
X  	    resurrect();
X  #endif
X! 	is_maze_lev = !xdnstair;
X  }
X  
X  int
X--- 772,786 ----
X  	if (dlevel == 1 && u.uhave_amulet && flags.no_of_wizards == 0)
X  	    resurrect();
X  #endif
X! 	is_maze_lev = (rooms[0].hx < 0
X! #ifdef STRONGHOLD
X! 		|| dlevel == stronghold_level
X! 		|| (dlevel >= tower_level && dlevel <= tower_level + 2)
X! #endif
X! #ifdef ENDGAME
X! 		|| dlevel == ENDLEVEL
X! #endif
X! 		);
X  }
X  
X  int
X***************
X*** 789,795 ****
X  	obj->owt = weight(obj);
X  	otmp->quan -= num;
X  	otmp->owt = weight(otmp);	/* -= obj->owt ? */
X! 	obj->nobj = otmp;
X  	if(obj->unpaid) splitbill(obj,otmp);
X  	return(otmp);
X  }
X--- 837,843 ----
X  	obj->owt = weight(obj);
X  	otmp->quan -= num;
X  	otmp->owt = weight(otmp);	/* -= obj->owt ? */
X! 	obj->nobj = obj->nexthere = otmp;
X  	if(obj->unpaid) splitbill(obj,otmp);
X  	return(otmp);
X  }
X***************
X*** 799,805 ****
X  register long side;
X  register int timex;
X  {
X! 	if(!Wounded_legs) ATEMP(A_DEX)--;
X  
X  	if(!Wounded_legs || (Wounded_legs & TIMEOUT))
X  		Wounded_legs |= side + timex;
X--- 847,856 ----
X  register long side;
X  register int timex;
X  {
X! 	if(!Wounded_legs) {
X! 		ATEMP(A_DEX)--;
X! 		flags.botl = 1;
X! 	}
X  
X  	if(!Wounded_legs || (Wounded_legs & TIMEOUT))
X  		Wounded_legs |= side + timex;
X*** src/Old/do_name.c	Wed Sep 27 11:21:40 1989
X--- src/do_name.c	Sat Sep 23 00:46:41 1989
X***************
X*** 93,100 ****
X  		plname);
X  		return(0);
X  	}
X! 	if (!cansee(cx, cy) || !levl[cx][cy].mmask ||
X! 	    (mtmp = m_at(cx, cy))->mimic) {
X  		pline("I see no monster there.");
X  		return(0);
X  	}
X--- 93,100 ----
X  		plname);
X  		return(0);
X  	}
X! 	if (!cansee(cx,cy) || !MON_AT(cx,cy) || (mtmp = m_at(cx, cy))->mimic
X! 		    || (mtmp->minvis && !See_invisible) || mtmp->mundetected) {
X  		pline("I see no monster there.");
X  		return(0);
X  	}
X*** src/Old/do_wear.c	Wed Sep 27 11:22:02 1989
X--- src/do_wear.c	Sat Sep 16 17:53:44 1989
X***************
X*** 241,247 ****
X  		}
X  		break;
X  	case HELM_OF_OPPOSITE_ALIGNMENT:
X! 		if (u.ualigntyp == U_NEUTRAL) u.ualigntyp = rnd(2) ? -1 : 1;
X  		else u.ualigntyp = -(u.ualigntyp);
X  		makeknown(uarmh->otyp);
X  		flags.botl = 1;
X--- 241,247 ----
X  		}
X  		break;
X  	case HELM_OF_OPPOSITE_ALIGNMENT:
X! 		if (u.ualigntyp == U_NEUTRAL) u.ualigntyp = rn2(2) ? -1 : 1;
X  		else u.ualigntyp = -(u.ualigntyp);
X  		makeknown(uarmh->otyp);
X  		flags.botl = 1;
X***************
X*** 446,453 ****
X--- 446,459 ----
X  		}
X  		flags.botl = 1;
X  		(void)strncpy(plname, buf, sizeof(plname)-1);
X+ #ifdef VMS
X+ 		Sprintf(SAVEF, "[.save]%d%s", getuid(), plname);
X+ 		regularize(SAVEF+7);
X+ 		Strcat(SAVEF, ";1");
X+ #else
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X+ #endif
X  #ifdef WIZARD
X  		}
X  #endif
X*** src/Old/dog.c	Wed Sep 27 11:22:53 1989
X--- src/dog.c	Thu Sep 14 14:18:20 1989
X***************
X*** 185,191 ****
X  			continue;
X  		}
X  		relmon(mtmp);
X! 		mtmp->mx = mtmp->my = 0; /* to avoid mnexto()/mmask problem */
X  		mtmp->nmon = mydogs;
X  		mydogs = mtmp;
X  		unpmon(mtmp);
X--- 185,191 ----
X  			continue;
X  		}
X  		relmon(mtmp);
X! 		mtmp->mx = mtmp->my = 0; /* avoid mnexto()/MON_AT() problem */
X  		mtmp->nmon = mydogs;
X  		mydogs = mtmp;
X  		unpmon(mtmp);
X***************
X*** 213,219 ****
X  	mtmp->mx = tolev; 
X  	mtmp->my = 0;
X  		/* make sure to reset mtmp->mx to 0 when releasing, */
X! 		/* so rloc() on next level doesn't affect mmask */
X  }
X  
X  /* return quality of food; the lower the better */
X--- 213,219 ----
X  	mtmp->mx = tolev; 
X  	mtmp->my = 0;
X  		/* make sure to reset mtmp->mx to 0 when releasing, */
X! 		/* so rloc() on next level doesn't affect MON_AT() state */
X  }
X  
X  /* return quality of food; the lower the better */
X*** src/Old/dogmove.c	Wed Sep 27 11:23:12 1989
X--- src/dogmove.c	Fri Sep 15 11:34:42 1989
X***************
X*** 81,87 ****
X  			edog->droptime = moves;
X  		}
X  	} else {
X! 		if(obj = o_at(omx,omy)) if(!index(nofetch, obj->olet)){
X  		    if((otyp = dogfood(mtmp, obj)) <= CADAVER){
X  			nix = omx;
X  			niy = omy;
X--- 81,87 ----
X  			edog->droptime = moves;
X  		}
X  	} else {
X! 		if((obj=level.objects[omx][omy]) && !index(nofetch,obj->olet)){
X  		    if((otyp = dogfood(mtmp, obj)) <= CADAVER){
X  			nix = omx;
X  			niy = omy;
X***************
X*** 211,217 ****
X  		if(dist(nx, ny) > 4 && mtmp->mleashed) continue;
X  #endif
X  		if(info[i] & ALLOW_M) {
X! 			if(levl[nx][ny].mmask) {
X  			    register struct monst *mtmp2 = m_at(nx,ny);
X  
X  			    if(mtmp2->m_lev >= mtmp->m_lev+2 ||
X--- 211,217 ----
X  		if(dist(nx, ny) > 4 && mtmp->mleashed) continue;
X  #endif
X  		if(info[i] & ALLOW_M) {
X! 			if(MON_AT(nx, ny)) {
X  			    register struct monst *mtmp2 = m_at(nx,ny);
X  
X  			    if(mtmp2->m_lev >= mtmp->m_lev+2 ||
X***************
X*** 318,327 ****
X  			(void) mattacku(mtmp);
X  			return(0);
X  		}
X! 		levl[omx][omy].mmask = 0;
X! 		levl[nix][niy].mmask = 1;
X! 		mtmp->mx = nix;
X! 		mtmp->my = niy;
X  		for(j=MTSZ-1; j>0; j--) mtmp->mtrack[j] = mtmp->mtrack[j-1];
X  		mtmp->mtrack[0].x = omx;
X  		mtmp->mtrack[0].y = omy;
X--- 318,325 ----
X  			(void) mattacku(mtmp);
X  			return(0);
X  		}
X! 		remove_monster(omx, omy);
X! 		place_monster(mtmp, nix, niy);
X  		for(j=MTSZ-1; j>0; j--) mtmp->mtrack[j] = mtmp->mtrack[j-1];
X  		mtmp->mtrack[0].x = omx;
X  		mtmp->mtrack[0].y = omy;
X***************
X*** 350,366 ****
X  		cc.x = mtmp->mx;
X  		cc.y = mtmp->my;
X  dognext:
X! 		levl[mtmp->mx][mtmp->my].mmask = 0;
X! 		levl[cc.x][cc.y].mmask = 1;
X! 		mtmp->mx = cc.x;
X! 		mtmp->my = cc.y;
X  		pmon(mtmp);
X  		set_apparxy(mtmp);
X  	}
X  #endif
X- 
X- 	if(mintrap(mtmp) == 2)		/* he died */
X- 		return(2);
X- 	pmon(mtmp);
X  	return(1);
X  }
X--- 348,358 ----
X  		cc.x = mtmp->mx;
X  		cc.y = mtmp->my;
X  dognext:
X! 		remove_monster(mtmp->mx, mtmp->my);
X! 		place_monster(mtmp, cc.x, cc.y);
X  		pmon(mtmp);
X  		set_apparxy(mtmp);
X  	}
X  #endif
X  	return(1);
X  }
X*** src/Old/dokick.c	Wed Sep 27 11:23:37 1989
X--- src/dokick.c	Mon Sep 25 21:29:30 1989
X***************
X*** 60,69 ****
X  	    	mdy = mon->my + u.dy;
X  	    	if(goodpos(mdx, mdy, mon->data)) {
X  			kludge("%s reels from the blow.", Monnam(mon));
X! 			levl[mon->mx][mon->my].mmask = 0;
X! 			levl[mdx][mdy].mmask = 1;
X! 			mon->mx = mdx;
X! 			mon->my = mdy;
X  			pmon(mon);
X  			set_apparxy(mon);
X  	    	}
X--- 60,67 ----
X  	    	mdy = mon->my + u.dy;
X  	    	if(goodpos(mdx, mdy, mon->data)) {
X  			kludge("%s reels from the blow.", Monnam(mon));
X! 			remove_monster(mon->mx, mon->my);
X! 			place_monster(mon, mdx, mdy);
X  			pmon(mon);
X  			set_apparxy(mon);
X  	    	}
X***************
X*** 214,221 ****
X  			} else {
X  				if(mtmp->mpeaceful) {
X  				    ESHK(mtmp)->credit += amount;
X! 				    You("have %ld zorkmids in credit.",
X! 						ESHK(mtmp)->credit);
X  				} else verbalize("Thanks, scum!");
X  			}
X  		}
X--- 212,220 ----
X  			} else {
X  				if(mtmp->mpeaceful) {
X  				    ESHK(mtmp)->credit += amount;
X! 				    You("have %ld zorkmid%s in credit.",
X! 					ESHK(mtmp)->credit, 
X! 					plur(ESHK(mtmp)->credit));
X  				} else verbalize("Thanks, scum!");
X  			}
X  		}
X***************
X*** 256,262 ****
X  	while(range-- > 0) {
X  		bhitpos.x += ddx;
X  		bhitpos.y += ddy;
X! 		if(levl[bhitpos.x][bhitpos.y].mmask) {
X  			mtmp = m_at(bhitpos.x,bhitpos.y);
X  			tmp_at(-1, -1); /* close call */
X  			return(mtmp);
X--- 255,261 ----
X  	while(range-- > 0) {
X  		bhitpos.x += ddx;
X  		bhitpos.y += ddy;
X! 		if(MON_AT(bhitpos.x, bhitpos.y)) {
X  			mtmp = m_at(bhitpos.x,bhitpos.y);
X  			tmp_at(-1, -1); /* close call */
X  			return(mtmp);
X***************
X*** 444,450 ****
X  	/* will move, so there is no need to worry about the location,	*/
X  	/* which merely needs to be something other than ox, oy.	*/
X  	move_object(obj, u.ux, u.uy);
X! 	if(cnt == 1 && !levl[x][y].mmask) newsym(x, y);
X  
X  	mon = bhit(u.dx, u.dy, range, obj->olet,
X  			(int (*)()) 0, (int (*)()) 0, obj);
X--- 443,450 ----
X  	/* will move, so there is no need to worry about the location,	*/
X  	/* which merely needs to be something other than ox, oy.	*/
X  	move_object(obj, u.ux, u.uy);
X! 	if(cnt == 1 && !MON_AT(x, y))
X! 	    newsym(x, y);
X  
X  	mon = bhit(u.dx, u.dy, range, obj->olet,
X  			(int (*)()) 0, (int (*)()) 0, obj);
X***************
X*** 460,466 ****
X  	if(costly && !costly_spot(bhitpos.x,bhitpos.y)) addtobill(obj, FALSE);
X  	move_object(obj, bhitpos.x, bhitpos.y);
X  	stackobj(obj);
X! 	if(!levl[obj->ox][obj->oy].mmask) newsym(obj->ox, obj->oy);
X  	return(1);
X  }
X  #endif /* KICK */
X--- 460,467 ----
X  	if(costly && !costly_spot(bhitpos.x,bhitpos.y)) addtobill(obj, FALSE);
X  	move_object(obj, bhitpos.x, bhitpos.y);
X  	stackobj(obj);
X! 	if(!MON_AT(obj->ox, obj->oy))
X! 	    newsym(obj->ox, obj->oy);
X  	return(1);
X  }
X  #endif /* KICK */
X***************
X*** 532,538 ****
X  	/* their present order: monsters, objects, */
X  	/* non-doors, doors.			   */ 
X  
X! 	if(maploc->mmask) {
X  		kick_monster(x, y);
X  		return(1);
X  	}
X--- 533,539 ----
X  	/* their present order: monsters, objects, */
X  	/* non-doors, doors.			   */ 
X  
X! 	if(MON_AT(x, y)) {
X  		kick_monster(x, y);
X  		return(1);
X  	}
X*** src/Old/dothrow.c	Wed Sep 27 11:24:13 1989
X--- src/dothrow.c	Tue Sep 26 16:08:03 1989
X***************
X*** 113,119 ****
X  			return(1);
X  		}
X  	} else {
X! 		if(obj->otyp == PICK_AXE && shkcatch(obj))
X  		    return(1);
X  
X  		range = (int)((ACURR(A_STR) > 18 ? 20 : ACURR(A_STR))/2 - obj->owt/4);
X--- 113,119 ----
X  			return(1);
X  		}
X  	} else {
X! 		if(shkcatch(obj))
X  		    return(1);
X  
X  		range = (int)((ACURR(A_STR) > 18 ? 20 : ACURR(A_STR))/2 - obj->owt/4);
X***************
X*** 150,156 ****
X--- 150,160 ----
X  		/* the code following might become part of dropy() */
X  		if (breaks(obj, TRUE)) {
X  			tmp_at(-1, let);
X+ #ifdef TEXTCOLOR
X+ 			tmp_at(-3, (int)objects[obj->otyp].oc_color);
X+ #else
X  			tmp_at(-3, (int)AT_OBJ);
X+ #endif
X  			tmp_at(bhitpos.x, bhitpos.y);
X  			tmp_at(-1, -1);
X  			return(1);
X***************
X*** 166,172 ****
X  		if(obj != uball && costly_spot(bhitpos.x, bhitpos.y) &&
X  		   !(mon && mon->isshk && bhitpos.x == mon->mx &&
X  		     bhitpos.y == mon->my && !(obj->unpaid)))
X! 			subfrombill(obj);
X  		stackobj(obj);
X  		if(obj == uball &&
X  			(bhitpos.x != u.ux || bhitpos.y != u.uy)){
X--- 170,176 ----
X  		if(obj != uball && costly_spot(bhitpos.x, bhitpos.y) &&
X  		   !(mon && mon->isshk && bhitpos.x == mon->mx &&
X  		     bhitpos.y == mon->my && !(obj->unpaid)))
X! 			sellobj(obj);
X  		stackobj(obj);
X  		if(obj == uball &&
X  			(bhitpos.x != u.ux || bhitpos.y != u.uy)){
X***************
X*** 260,265 ****
X--- 264,270 ----
X  		    else    tmp += uwep->spe;
X  		} else if(obj->otyp == BOOMERANG) tmp += 4;
X  		tmp += obj->spe;
X+ 		tmp += hitval(obj, mon->data);
X  		if(tmp >= rnd(20)) {
X  			if(hmon(mon,obj,1) == TRUE){
X  			  /* mon still alive */
X***************
X*** 329,335 ****
X  		    if(mon->data == &mons[
X  				((u.ualigntyp== U_CHAOTIC) ? PM_BLACK_UNICORN :
X  				 (u.ualigntyp == U_LAWFUL) ? PM_WHITE_UNICORN
X! 						  : PM_GREY_UNICORN)]) {
X  			    Strcat(buf, addluck);
X  			    change_luck(5);
X  		    } else {
X--- 334,340 ----
X  		    if(mon->data == &mons[
X  				((u.ualigntyp== U_CHAOTIC) ? PM_BLACK_UNICORN :
X  				 (u.ualigntyp == U_LAWFUL) ? PM_WHITE_UNICORN
X! 						  : PM_GRAY_UNICORN)]) {
X  			    Strcat(buf, addluck);
X  			    change_luck(5);
X  		    } else {
X*** src/Old/eat.c	Wed Sep 27 11:24:41 1989
X--- src/eat.c	Tue Sep 26 12:59:35 1989
X***************
X*** 347,353 ****
X  #ifdef LINT	/* problem if more than 320K moves before try to eat */
X  	rotted = 0;
X  #else
X! 	rotted = (moves - otmp->age)/((long)(10 + rn2(20)));	/* how decomposed? */
X  #endif
X  
X  	if(otmp->cursed) rotted += 2;
X--- 347,353 ----
X  #ifdef LINT	/* problem if more than 320K moves before try to eat */
X  	rotted = 0;
X  #else
X! 	rotted = (monstermoves - otmp->age)/((long)(10 + rn2(20)));
X  #endif
X  
X  	if(otmp->cursed) rotted += 2;
X***************
X*** 505,511 ****
X  	    if (otmp->otyp != FORTUNE_COOKIE &&
X  		otmp->otyp != DEAD_LIZARD &&
X  		(otmp->cursed ||
X! 		 ((moves - otmp->age) > otmp->blessed ? 50 : 30)) &&
X  		  !rn2(7)) {
X  
X  		rottenfood();
X--- 505,511 ----
X  	    if (otmp->otyp != FORTUNE_COOKIE &&
X  		otmp->otyp != DEAD_LIZARD &&
X  		(otmp->cursed ||
X! 		 ((monstermoves - otmp->age) > otmp->blessed ? 50 : 30)) &&
X  		  !rn2(7)) {
X  
X  		rottenfood();
X
END_OF_FILE
if test 55684 -ne `wc -c <'patches04a'`; then
    echo shar: \"'patches04a'\" unpacked with wrong size!
fi
# end of 'patches04a'
fi
echo shar: End of archive 1 \(of 11\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
