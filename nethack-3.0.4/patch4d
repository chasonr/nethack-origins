Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i040:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch4d
Message-ID: <4630@tekred.CNA.TEK.COM>
Date: 29 Sep 89 21:10:03 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2046
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 40
Archive-name: NetHack3/Patch4d
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 11)."
# Contents:  patches04d
# Wrapped by billr@saab on Fri Sep 29 13:14:06 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches04d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches04d'\"
else
echo shar: Extracting \"'patches04d'\" \(52224 characters\)
sed "s/^X//" >'patches04d' <<'END_OF_FILE'
X*** src/Old/polyself.c	Wed Sep 27 12:09:55 1989
X--- src/polyself.c	Mon Sep 25 21:35:23 1989
X***************
X*** 102,109 ****
X--- 102,115 ----
X  		    goto newname;
X  		}
X  		(void)strncpy(plname, buf, sizeof(plname)-1);
X+ #ifdef VMS
X+ 		Sprintf(SAVEF, "[.save]%d%s", getuid(), plname);
X+ 		regularize(SAVEF+7);
X+ 		Strcat(SAVEF, ";1");
X+ #else
X  		Sprintf(SAVEF, "save/%d%s", getuid(), plname);
X  		regularize(SAVEF+5);		/* avoid . or / in name */
X+ #endif
X  #ifdef WIZARD
X  	}
X  #endif
X***************
X*** 123,129 ****
X  	int mntmp = -1;
X  	int tries=0;
X  	boolean draconian = (uarm && uarm->otyp==DRAGON_SCALE_MAIL &&
X! 		uarm->corpsenm >= PM_GREY_DRAGON &&
X  		uarm->corpsenm <= PM_YELLOW_DRAGON);
X  	boolean iswere = (u.ulycn > -1 || is_were(uasmon));
X  	boolean isvamp = (u.usym == S_VAMPIRE || u.umonnum == PM_VAMPIRE_BAT);
X--- 129,135 ----
X  	int mntmp = -1;
X  	int tries=0;
X  	boolean draconian = (uarm && uarm->otyp==DRAGON_SCALE_MAIL &&
X! 		uarm->corpsenm >= PM_GRAY_DRAGON &&
X  		uarm->corpsenm <= PM_YELLOW_DRAGON);
X  	boolean iswere = (u.ulycn > -1 || is_were(uasmon));
X  	boolean isvamp = (u.usym == S_VAMPIRE || u.umonnum == PM_VAMPIRE_BAT);
X***************
X*** 222,230 ****
X--- 228,245 ----
X  		u.acurr = u.macurr;
X  		u.amax = u.mamax;
X  	}
X+ 	tmp = u.umonnum;
X  	u.umonnum = mntmp;
X  	set_uasmon();
X  	u.usym = mons[mntmp].mlet;
X+ 
X+ 	if (tmp != mntmp)
X+ 		You("turn into a%s %s!",
X+ 			index(vowels, *(mons[mntmp].mname)) ? "n" : "",
X+ 			mons[mntmp].mname);
X+ 	else
X+ 		You("feel like a new %s!", mons[mntmp].mname);
X+ 
X  	/* New stats for monster, to last only as long as polymorphed.
X  	 * Currently only strength gets changed.
X  	 */
X***************
X*** 238,244 ****
X  		Sick = 0;
X  		You("no longer feel sick.");
X  	}
X! 	if (u.usym == S_DRAGON && mntmp >= PM_GREY_DRAGON) u.mhmax = 80;
X  #ifdef GOLEMS
X  	else if (is_golem(uasmon)) u.mhmax = golemhp(mntmp);
X  #endif /* GOLEMS */
X--- 253,259 ----
X  		Sick = 0;
X  		You("no longer feel sick.");
X  	}
X! 	if (u.usym == S_DRAGON && mntmp >= PM_GRAY_DRAGON) u.mhmax = 80;
X  #ifdef GOLEMS
X  	else if (is_golem(uasmon)) u.mhmax = golemhp(mntmp);
X  #endif /* GOLEMS */
X***************
X*** 255,263 ****
X  		else u.mhmax = d(tmp, 8);
X  	}
X  	u.mh = u.mhmax;
X- 	You("turn into a%s %s!",
X- 		index(vowels, *(mons[mntmp].mname)) ? "n" : "",
X- 		mons[mntmp].mname);
X  	if (uskin && mntmp != uskin->corpsenm)
X  		skinback();
X  	break_armor();
X--- 270,275 ----
X***************
X*** 433,438 ****
X--- 445,451 ----
X  
X  	if (!getdir(1)) return(0);
X  	otmp = mksobj(u.umonnum==PM_COBRA ? BLINDING_VENOM : ACID_VENOM, FALSE);
X+ 	otmp->spe = 1; /* to indicate it's yours */
X  	(void) throwit(otmp);
X  	return(1);
X  }
X*** src/Old/potion.c	Wed Sep 27 12:10:40 1989
X--- src/potion.c	Mon Sep 25 21:30:15 1989
X***************
X*** 146,164 ****
X  	register struct obj *otmp;
X  
X  #ifdef FOUNTAINS
X! 
X!       /* Is there something to drink here, i.e., a fountain? */
X!        if (IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X! 	   pline("Drink from the fountain? ");
X! 	   if(yn() == 'y') {
X! 	    (void) drinkfountain();
X! 	    return(1);
X! 	  }
X!        }
X! 
X! #endif /* FOUNTAINS /**/
X  #ifdef SINKS
X! 	/* Now, check for kitchen sinks... */
X  	if (IS_SINK(levl[u.ux][u.uy].typ)) {
X  		pline("Drink from the sink? ");
X  		if (yn() == 'y') {
X--- 146,162 ----
X  	register struct obj *otmp;
X  
X  #ifdef FOUNTAINS
X! 	/* Is there a fountain to drink from here? */
X!         if (IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X! 		pline("Drink from the fountain? ");
X! 		if(yn() == 'y') {
X! 			(void) drinkfountain();
X! 			return 1;
X! 		}
X! 	}
X! #endif
X  #ifdef SINKS
X! 	/* Or a kitchen sink? */
X  	if (IS_SINK(levl[u.ux][u.uy].typ)) {
X  		pline("Drink from the sink? ");
X  		if (yn() == 'y') {
X***************
X*** 168,174 ****
X  	}
X  #endif
X  
X- 	unkn = 0;
X  	otmp = getobj(beverages, "drink");
X  	if(!otmp) return(0);
X  	if(objects[otmp->otyp].oc_descr && !strcmp(objects[otmp->otyp].oc_descr, "smoky") && !rn2(13)) {
X--- 166,171 ----
X***************
X*** 190,196 ****
X  {
X  	int retval;
X  
X! 	nothing = 0;
X  	if((retval = peffects(otmp)) >= 0) return(retval);
X  
X  	if(nothing) {
X--- 187,193 ----
X  {
X  	int retval;
X  
X! 	nothing = unkn = 0;
X  	if((retval = peffects(otmp)) >= 0) return(retval);
X  
X  	if(nothing) {
X***************
X*** 807,814 ****
X  	if(!(obj = getobj("#", "dip")))
X  		return(0);
X  #ifdef FOUNTAINS
X! 	/* Is there something to dip into here, i.e., a fountain? */
X! 	if (levl[u.ux][u.uy].typ == FOUNTAIN) {
X  		pline("Dip it into the fountain? ");
X  		if(yn() == 'y') {
X  			dipfountain(obj);
X--- 804,811 ----
X  	if(!(obj = getobj("#", "dip")))
X  		return(0);
X  #ifdef FOUNTAINS
X! 	/* Is there a fountain to dip into here? */
X! 	if (IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X  		pline("Dip it into the fountain? ");
X  		if(yn() == 'y') {
X  			dipfountain(obj);
X***************
X*** 959,965 ****
X  		char buf[BUFSZ];
X  		Strcpy(buf, xname(potion));
X  		pline("The %s form%s a coating on the %s.",
X! 			buf, (potion->quan==1) ? "s" : "", xname(obj));
X  		obj->opoisoned = 1;
X  		goto poof;
X  	    } else if(obj->opoisoned && 
X--- 956,962 ----
X  		char buf[BUFSZ];
X  		Strcpy(buf, xname(potion));
X  		pline("The %s form%s a coating on the %s.",
X! 			buf, potion->quan==1 ? "s" : "", xname(obj));
X  		obj->opoisoned = 1;
X  		goto poof;
X  	    } else if(obj->opoisoned && 
X*** src/Old/pray.c	Wed Sep 27 12:11:32 1989
X--- src/pray.c	Tue Sep 26 12:59:40 1989
X***************
X*** 38,62 ****
X  0,0,0,0
X  };
X  
X! #define TROUBLE_STONED 8
X! #define TROUBLE_STRANGLED 7
X! #define TROUBLE_SICK 6
X! #define TROUBLE_STARVING 5
X! #define TROUBLE_HIT 4
X  #define TROUBLE_STUCK_IN_WALL 3
X  #define TROUBLE_CURSED_BLINDFOLD 2
X  #define TROUBLE_CURSED_LEVITATION 1
X  
X! #define TROUBLE_LYCANTHROPE (-1)
X! #define TROUBLE_PUNISHED (-2)
X! #define TROUBLE_CURSED_ITEMS (-3)
X! #define TROUBLE_BLIND (-4)
X! #define TROUBLE_HUNGRY (-5)
X! #define TROUBLE_POISONED (-6)
X! #define TROUBLE_WOUNDED_LEGS (-7)
X! #define TROUBLE_STUNNED (-8)
X! #define TROUBLE_CONFUSED (-9)
X! #define TROUBLE_HALLUCINATION (-10)
X  
X  /* We could force rehumanize of polyselfed people, but we can't tell
X     unintentional shape changes from the other kind. Oh well. */
X--- 38,62 ----
X  0,0,0,0
X  };
X  
X! #define TROUBLE_STONED 9
X! #define TROUBLE_STRANGLED 8
X! #define TROUBLE_SICK 7
X! #define TROUBLE_STARVING 6
X! #define TROUBLE_HIT 5
X! #define TROUBLE_LYCANTHROPE 4
X  #define TROUBLE_STUCK_IN_WALL 3
X  #define TROUBLE_CURSED_BLINDFOLD 2
X  #define TROUBLE_CURSED_LEVITATION 1
X  
X! #define TROUBLE_PUNISHED (-1)
X! #define TROUBLE_CURSED_ITEMS (-2)
X! #define TROUBLE_BLIND (-3)
X! #define TROUBLE_HUNGRY (-4)
X! #define TROUBLE_POISONED (-5)
X! #define TROUBLE_WOUNDED_LEGS (-6)
X! #define TROUBLE_STUNNED (-7)
X! #define TROUBLE_CONFUSED (-8)
X! #define TROUBLE_HALLUCINATION (-9)
X  
X  /* We could force rehumanize of polyselfed people, but we can't tell
X     unintentional shape changes from the other kind. Oh well. */
X***************
X*** 102,107 ****
X--- 102,110 ----
X  		if (!isok(u.ux+i, u.uy+j) || IS_ROCK(levl[u.ux+i][u.uy+j].typ))
X  			count++;
X  	}
X+ #ifdef POLYSELF
X+ 	if(u.ulycn >= 0) return(TROUBLE_LYCANTHROPE);
X+ #endif
X  	if(count==8
X  #ifdef POLYSELF
X  	    && !passes_walls(uasmon)
X***************
X*** 113,121 ****
X  		return(TROUBLE_CURSED_LEVITATION);
X  	if(ublindf && ublindf->cursed) return(TROUBLE_CURSED_BLINDFOLD);
X  
X- #ifdef POLYSELF
X- 	if(u.ulycn >= 0) return(TROUBLE_LYCANTHROPE);
X- #endif
X  	if(Punished) return(TROUBLE_PUNISHED);
X  	for(otmp=invent; otmp; otmp=otmp->nobj)
X  		if((otmp->otyp==LOADSTONE || otmp->otyp==LUCKSTONE) &&
X--- 116,121 ----
X***************
X*** 411,417 ****
X  	int trouble = in_trouble ();	/* what's your worst difficulty? */
X  	int pat_on_head = 0;
X  
X- 	if (u.ugangr > 0) u.ugangr--;
X  	You("feel that %s is pleased.",
X  #ifndef ALTARS
X  		   u_gname());
X--- 411,416 ----
X***************
X*** 675,680 ****
X--- 674,681 ----
X  {
X  	if (Hallucination)
X      pline ("Your sacrifice sprouts wings and a propeller and roars away!");
X+ 	else if (Blind && u.ualigntyp == U_LAWFUL)
X+ 		pline("Your sacrifice disappears!");
X  	else pline ("Your sacrifice is consumed in a %s!",
X  		    u.ualigntyp == U_LAWFUL ? "flash of light" : "burst of flame");
X  	useup(otmp);
X***************
X*** 718,724 ****
X  	    register struct permonst *mtmp = &mons[otmp->corpsenm];
X  	    extern int monstr[];
X  
X! 	    if (otmp->corpsenm == PM_ACID_BLOB || (moves <= otmp->age + 50))
X  		value = monstr[otmp->corpsenm] + 1;
X  
X  	    if (is_human(mtmp)) { /* Human sacrifice! */
X--- 719,725 ----
X  	    register struct permonst *mtmp = &mons[otmp->corpsenm];
X  	    extern int monstr[];
X  
X! 	    if (otmp->corpsenm == PM_ACID_BLOB || (monstermoves <= otmp->age + 50))
X  		value = monstr[otmp->corpsenm] + 1;
X  
X  	    if (is_human(mtmp)) { /* Human sacrifice! */
X***************
X*** 777,783 ****
X  		int unicalign;
X  
X  		if (mtmp == &mons[PM_BLACK_UNICORN]) unicalign = -1;
X! 		else if (mtmp == &mons[PM_GREY_UNICORN]) unicalign = 0;
X  		else if (mtmp == &mons[PM_WHITE_UNICORN]) unicalign = 1;
X  		if (unicalign == u.ualigntyp) {
X  		    pline("Such an action is an insult to %s!", (unicalign== -1)
X--- 778,784 ----
X  		int unicalign;
X  
X  		if (mtmp == &mons[PM_BLACK_UNICORN]) unicalign = -1;
X! 		else if (mtmp == &mons[PM_GRAY_UNICORN]) unicalign = 0;
X  		else if (mtmp == &mons[PM_WHITE_UNICORN]) unicalign = 1;
X  		if (unicalign == u.ualigntyp) {
X  		    pline("Such an action is an insult to %s!", (unicalign== -1)
X*** src/Old/pri.c	Wed Sep 27 12:12:22 1989
X--- src/pri.c	Wed Sep 27 11:25:39 1989
X***************
X*** 10,20 ****
X  #include "epri.h"
X  #endif
X  
X! static void hilite P((UCHAR_P, UCHAR_P));
X  static void cornbot P((int));
X  static boolean ismnst P((CHAR_P));
X! #if !defined(DECRAINBOW) && !defined(UNIX)
X  #  define g_putch  (void) putchar
X  #endif
X  
X  #ifndef g_putch
X--- 10,31 ----
X  #include "epri.h"
X  #endif
X  
X! static void hilite P((int,int,UCHAR_P, UCHAR_P));
X  static void cornbot P((int));
X  static boolean ismnst P((CHAR_P));
X! #ifdef TEXTCOLOR
X! static uchar mimic_color P((UCHAR_P));
X! #endif
X! 
X! #if defined(MSDOS) && !defined(TERMLIB) && !defined(DECRAINBOW)
X! #  define g_putch  (void) putchar
X! #endif
X! 
X! /* This is the same logic used for "#define IBMXASCII" in file "termcap.c" */
X! #if !defined(AMIGA) && !defined(TOS)
X! # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X  #  define g_putch  (void) putchar
X+ # endif
X  #endif
X  
X  #ifndef g_putch
X***************
X*** 49,55 ****
X  	curx = u.ux+2;
X  	curs(u.ux-1, u.uy+2);
X  	(void) putchar('|');
X! 	hilite(u.usym, AT_MON);
X  	(void) putchar('|');
X  	curx = u.ux+2;
X  	curs(u.ux-1, u.uy+3);
X--- 60,66 ----
X  	curx = u.ux+2;
X  	curs(u.ux-1, u.uy+2);
X  	(void) putchar('|');
X! 	hilite(u.ux, u.uy, u.usym, AT_MON);
X  	(void) putchar('|');
X  	curx = u.ux+2;
X  	curs(u.ux-1, u.uy+3);
X***************
X*** 140,146 ****
X  	y += 2;
X  	curs(x,y);
X  
X! 	hilite(ch,typ);
X  	curx++;
X  }
X  
X--- 151,157 ----
X  	y += 2;
X  	curs(x,y);
X  
X! 	hilite(x, y-2, ch, typ);
X  	curx++;
X  }
X  
X***************
X*** 385,397 ****
X  	    if(obj->olet == FOOD_SYM && obj->otyp == CORPSE) {
X  
X  		if(mons[obj->corpsenm].mlet == S_TROLL &&
X! 		    obj->age + 20 < moves) {
X  			boolean visible = cansee(obj->ox,obj->oy);
X  			struct monst *mtmp = revive(obj, FALSE);
X  
X  			if (mtmp && visible)
X  				pline("%s rises from the dead!", Monnam(mtmp));
X! 		} else if (obj->age + 250 < moves) delobj(obj);
X  	    }
X  	}
X  
X--- 396,408 ----
X  	    if(obj->olet == FOOD_SYM && obj->otyp == CORPSE) {
X  
X  		if(mons[obj->corpsenm].mlet == S_TROLL &&
X! 		    obj->age + 20 < monstermoves) {
X  			boolean visible = cansee(obj->ox,obj->oy);
X  			struct monst *mtmp = revive(obj, FALSE);
X  
X  			if (mtmp && visible)
X  				pline("%s rises from the dead!", Monnam(mtmp));
X! 		} else if (obj->age + 250 < monstermoves) delobj(obj);
X  	    }
X  	}
X  
X***************
X*** 399,405 ****
X  	    obj2 = obj->nobj;
X  	    if(obj->otyp == CORPSE) {
X  		if(mons[obj->corpsenm].mlet == S_TROLL
X! 			    && obj->age + 20 < moves) {
X  		    boolean wielded = (obj==uwep);
X  		    struct monst *mtmp = revive(obj, TRUE);
X  
X--- 410,416 ----
X  	    obj2 = obj->nobj;
X  	    if(obj->otyp == CORPSE) {
X  		if(mons[obj->corpsenm].mlet == S_TROLL
X! 			    && obj->age + 20 < monstermoves) {
X  		    boolean wielded = (obj==uwep);
X  		    struct monst *mtmp = revive(obj, TRUE);
X  
X***************
X*** 408,414 ****
X  				mtmp->data->mname, xname(obj));
X  		    else if (mtmp)
X  			You("feel squirming in your backpack!");
X! 		} else if (obj->age + 250 < moves) useup(obj);
X  	    }
X  	}
X  }
X--- 419,425 ----
X  				mtmp->data->mname, xname(obj));
X  		    else if (mtmp)
X  			You("feel squirming in your backpack!");
X! 		} else if (obj->age + 250 < monstermoves) useup(obj);
X  	    }
X  	}
X  }
X***************
X*** 1070,1095 ****
X  	return hcolors[rn2(SIZE(hcolors))];
X  }
X  
X! /*  Bug: if a level character is the same as an object/monster, it may be
X!  *  hilited, because we use a kludge to figure out if a character is an
X!  *  object/monster symbol.  It's smarter than it was in 2.3, but you
X!  *  can still fool it (ex. if an object is in a doorway you have not seen,
X!  *  and you look at a map, the '+' will be taken as a spellbook symbol).
X!  *
X!  *  The problem is that whenever a portion of the map needs to be redrawn
X!  *  (by ^R, after an inventory dropover, after regurgitation...), the
X!  *  levl[][].scrsym field is used to redraw the map.  A great duplication
X!  *  of code would be needed to trace back every scrsym to find out what color
X!  *  it should be.
X!  *
X!  *  What is really needed is a levl[][].color field; the color be figured
X!  *  out at the same time as the screen symbol, and be restored with
X!  *  redraws.  Unfortunately, as this requires much time and testing,
X!  *  it will have to wait for NetHack 3.1.  -3.
X!  */
X! 
X  static void
X! hilite(let,typ)
X  uchar let, typ;
X  {
X  
X--- 1081,1090 ----
X  	return hcolors[rn2(SIZE(hcolors))];
X  }
X  
X! /*ARGSUSED*/
X  static void
X! hilite(x, y, let, typ)
X! int x, y;
X  uchar let, typ;
X  {
X  
X***************
X*** 1122,1152 ****
X  		    case S_MIMIC_DEF:
X  			typ = HI_OBJ;
X  			break;
X- 		    case S_YLIGHT:	/* make 'em "glow" */
X- 			typ = YELLOW;
X- 			break;
X  		    default:
X! 			typ = HI_MON;
X  		}
X  		break;
X  	    case AT_OBJ:
X! 		switch (let) {
X! 		    case GOLD_SYM:
X! 			typ = HI_GOLD;
X! 			break;
X! 		    case WEAPON_SYM:
X! 		    case ARMOR_SYM:
X! 		    case RING_SYM:
X! 		    case AMULET_SYM:
X! 			typ = HI_METAL;
X! 			break;
X! 		    case FOOD_SYM:
X! 		    case POTION_SYM:
X! 			typ = HI_ORGANIC;
X! 			break;
X! 		    default:
X! 			typ = HI_OBJ;
X! 		}
X  		break;
X  	    case AT_MAP:
X  #ifdef FOUNTAINS
X--- 1117,1137 ----
X  		    case S_MIMIC_DEF:
X  			typ = HI_OBJ;
X  			break;
X  		    default:
X!                         if (u.ux == x && u.uy == y)
X!                             typ = uasmon->mcolor;
X! 			else
X! 			    typ = level.monsters[x][y]->data->mcolor;
X  		}
X  		break;
X  	    case AT_OBJ:
X! 		if (let == GOLD_SYM)
X! 		    typ = HI_GOLD;
X! 		else if (level.objects[x][y] && 
X! 			 let == objects[level.objects[x][y]->otyp].oc_olet)
X! 		    typ = objects[level.objects[x][y]->otyp].oc_color;
X! 		else
X! 		    typ = mimic_color(let);
X  		break;
X  	    case AT_MAP:
X  #ifdef FOUNTAINS
X***************
X*** 1154,1178 ****
X  #else
X  		typ = (let == POOL_SYM
X  #endif
X! 			&& HI_COLOR[BLUE] != HI ? BLUE : 0);
X  		break;
X  	    case AT_ZAP:
X  		typ = HI_ZAP;
X  		break;
X  	}
X! 	if (typ)
X! 		xputs(HI_COLOR[typ]);
X! #else
X! 	if (typ == AT_MON) revbeg();
X  #endif
X  
X  	g_putch(let);
X  
X  #ifdef TEXTCOLOR
X! 	if (typ) xputs(HE);
X! #else
X! 	if (typ == AT_MON) m_end();
X  #endif
X  }
X  
X  static boolean
X--- 1139,1166 ----
X  #else
X  		typ = (let == POOL_SYM
X  #endif
X! 			&& hilites[BLUE] != HI ? BLUE :
X! #ifdef THRONES
X! 		       let == THRONE_SYM && hilites[HI_GOLD] != HI ? HI_GOLD :
X! #endif
X! 		       0);
X  		break;
X  	    case AT_ZAP:
X  		typ = HI_ZAP;
X  		break;
X  	}
X! 	if (typ && flags.use_color)
X! 		xputs(hilites[typ]);
X! 	else
X  #endif
X+ 	if (typ == AT_MON) revbeg();
X  
X  	g_putch(let);
X  
X  #ifdef TEXTCOLOR
X! 	if (typ && flags.use_color) xputs(HE); else
X  #endif
X+ 	if (typ == AT_MON) m_end();
X  }
X  
X  static boolean
X***************
X*** 1194,1196 ****
X--- 1182,1201 ----
X  #endif
X  	return 0;
X  }
X+ 
X+ #ifdef TEXTCOLOR
X+ /* pick an appropriate color for a mimic imitating an object */
X+ 
X+ static uchar
X+ mimic_color(let)
X+ uchar let;
X+ {
X+ 	int i;
X+ 
X+ 	for(i = 0; i < NROFOBJECTS; i++) {
X+ 		if (objects[i].oc_olet == let)
X+ 			return objects[i].oc_color;
X+ 	}
X+ 	return HI_OBJ;
X+ }
X+ #endif
X*** src/Old/priest.c	Wed Sep 27 12:13:05 1989
X--- src/priest.c	Thu Sep 14 23:31:18 1989
X***************
X*** 85,94 ****
X  #endif
X  
X  	if(nix != omx || niy != omy) {
X! 		levl[omx][omy].mmask = 0;
X! 		levl[nix][niy].mmask = 1;
X! 		mtmp->mx = nix;
X! 		mtmp->my = niy;
X  		pmon(mtmp);
X  		if(ib) {
X  			if (cansee(mtmp->mx,mtmp->my))
X--- 85,92 ----
X  #endif
X  
X  	if(nix != omx || niy != omy) {
X! 		remove_monster(omx, omy);
X! 		place_monster(mtmp, nix, niy);
X  		pmon(mtmp);
X  		if(ib) {
X  			if (cansee(mtmp->mx,mtmp->my))
X***************
X*** 110,116 ****
X  {
X  	register int roomno = inroom(x, y);
X  
X! 	if (roomno < 0 || rooms[roomno].rtype != TEMPLE) return(FALSE);
X  	return(&rooms[roomno]);
X  }
X  
X--- 108,115 ----
X  {
X  	register int roomno = inroom(x, y);
X  
X! 	if (roomno < 0 || rooms[roomno].rtype != TEMPLE)
X! 		return((struct mkroom *)0);
X  	return(&rooms[roomno]);
X  }
X  
X***************
X*** 183,189 ****
X  #ifdef SPELLS
X  	register int cnt;
X  #endif
X! 	if(levl[sx+1][sy].mmask) rloc(m_at(sx+1, sy)); /* insurance */
X  
X  	if(priest = makemon(&mons[!rn2(2) ? PM_TEMPLE_PRIEST : 
X  			PM_TEMPLE_PRIESTESS], sx+1, sy)) {
X--- 182,188 ----
X  #ifdef SPELLS
X  	register int cnt;
X  #endif
X! 	if(MON_AT(sx+1, sy)) rloc(m_at(sx+1, sy)); /* insurance */
X  
X  	if(priest = makemon(&mons[!rn2(2) ? PM_TEMPLE_PRIEST : 
X  			PM_TEMPLE_PRIESTESS], sx+1, sy)) {
X*** src/Old/prisym.c	Wed Sep 27 12:13:29 1989
X--- src/prisym.c	Thu Sep 14 14:11:55 1989
X***************
X*** 216,222 ****
X  	    /* the only lit corridor squares should be the entrances to
X  	     * outside castle areas */
X  		return;
X! 	if(room->mmask) mtmp = m_at(x,y);
X  	if(mtmp && !mtmp->mhide &&
X  		(!mtmp->minvis || See_invisible)) {
X  #ifdef WORM
X--- 216,222 ----
X  	    /* the only lit corridor squares should be the entrances to
X  	     * outside castle areas */
X  		return;
X! 	if(MON_AT(x, y)) mtmp = m_at(x,y);
X  	if(mtmp && !mtmp->mhide &&
X  		(!mtmp->minvis || See_invisible)) {
X  #ifdef WORM
X***************
X*** 227,233 ****
X  		pmon(mtmp);
X  	}
X  	else if(OBJ_AT(x, y) && !is_pool(x,y)) {
X! 		otmp = o_at(x,y);
X  		atl(x,y,Hallucination ? rndobjsym() : otmp->olet);
X  	}
X  	else if(room->gmask && !is_pool(x,y))
X--- 227,233 ----
X  		pmon(mtmp);
X  	}
X  	else if(OBJ_AT(x, y) && !is_pool(x,y)) {
X! 		otmp = level.objects[x][y];
X  		atl(x,y,Hallucination ? rndobjsym() : otmp->olet);
X  	}
X  	else if(room->gmask && !is_pool(x,y))
X***************
X*** 263,269 ****
X  	if(!room->seen) tmp = STONE_SYM;
X  	else if(room->typ == POOL || room->typ == MOAT) tmp = POOL_SYM;
X  	else if(OBJ_AT(x, y) && !Blind && room->scrsym) {
X! 		otmp = o_at(x,y);
X  		tmp = Hallucination ? rndobjsym() : otmp->olet;
X  	}
X  	else if(room->gmask && !Blind && room->scrsym) 
X--- 263,269 ----
X  	if(!room->seen) tmp = STONE_SYM;
X  	else if(room->typ == POOL || room->typ == MOAT) tmp = POOL_SYM;
X  	else if(OBJ_AT(x, y) && !Blind && room->scrsym) {
X! 		otmp = level.objects[x][y];
X  		tmp = Hallucination ? rndobjsym() : otmp->olet;
X  	}
X  	else if(room->gmask && !Blind && room->scrsym) 
X***************
X*** 483,489 ****
X  {
X  	if(x == u.ux && y == u.uy && !Invisible) return(1);
X  
X! 	if(levl[x][y].mmask)
X  		if (Blind && Telepat || canseemon(m_at(x,y)))
X  		    return(1);
X  		else return ((HTelepat & WORN_HELMET) &&
X--- 483,489 ----
X  {
X  	if(x == u.ux && y == u.uy && !Invisible) return(1);
X  
X! 	if(MON_AT(x, y))
X  		if (Blind && Telepat || canseemon(m_at(x,y)))
X  		    return(1);
X  		else return ((HTelepat & WORN_HELMET) &&
X*** src/Old/read.c	Wed Sep 27 12:13:53 1989
X--- src/read.c	Sat Sep 23 00:46:44 1989
X***************
X*** 216,222 ****
X  			return(1);
X  		    }
X  		} else {	/* armor and scroll both cursed */
X! 		    Your("%s vibrates", xname(otmp));
X  		    otmp->spe--;
X  		    make_stunned(HStun + rn1(10, 10), TRUE);
X  		}
X--- 216,222 ----
X  			return(1);
X  		    }
X  		} else {	/* armor and scroll both cursed */
X! 		    Your("%s vibrates.", xname(otmp));
X  		    otmp->spe--;
X  		    make_stunned(HStun + rn1(10, 10), TRUE);
X  		}
X***************
X*** 363,369 ****
X  		register struct monst *mtmp;
X  
X  		for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X! 		if(levl[u.ux+i][u.uy+j].mmask && (mtmp = m_at(u.ux+i, u.uy+j))) {
X  		    if(sobj->cursed) {
X  			if(!mtmp->mtame) mtmp->mpeaceful = 0;
X  		    } else {
X--- 363,369 ----
X  		register struct monst *mtmp;
X  
X  		for(i = -bd; i <= bd; i++) for(j = -bd; j <= bd; j++)
X! 		if(MON_AT(u.ux+i, u.uy+j) && (mtmp = m_at(u.ux+i, u.uy+j))) {
X  		    if(sobj->cursed) {
X  			if(!mtmp->mtame) mtmp->mpeaceful = 0;
X  		    } else {
X*** src/Old/restore.c	Wed Sep 27 12:14:35 1989
X--- src/restore.c	Tue Sep 26 16:08:35 1989
X***************
X*** 39,44 ****
X--- 39,72 ----
X  		}
X  }
X  
X+ /* Recalculate level.objects[x][y], since this info was not saved. */
X+ static void
X+ find_lev_obj()
X+ {
X+ 	register struct obj *fobjtmp = (struct obj *)0;
X+ 	register struct obj *otmp;
X+ 	int x,y;
X+ 
X+ 	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++)
X+ 		level.objects[x][y] = (struct obj *)0;
X+ 
X+ 	/* Reverse the entire fobj chain, which is necessary so that we can
X+ 	 * place the objects in the proper order.
X+ 	 */
X+ 	while(otmp = fobj) {
X+ 		fobj = otmp->nobj;
X+ 		otmp->nobj = fobjtmp;
X+ 		fobjtmp = otmp;
X+ 	}
X+ 	/* Set level.objects (as well as reversing the chain back again) */
X+ 	while(otmp = fobjtmp) {
X+ 		place_object(otmp, otmp->ox, otmp->oy);
X+ 		fobjtmp = otmp->nobj;
X+ 		otmp->nobj = fobj;
X+ 		fobj = otmp;
X+ 	}
X+ }
X+ 
X  static struct obj *
X  restobjchn(fd, ghostly)
X  register int fd;
X***************
X*** 74,80 ****
X  	 * new player's clock.  Assumption: new player arrived immediately
X  	 * after old player died.
X  	 */
X! 		if (ghostly) otmp->age = moves-omoves+otmp->age;
X  		otmp2 = otmp;
X  	}
X  	if(first && otmp2->nobj){
X--- 102,108 ----
X  	 * new player's clock.  Assumption: new player arrived immediately
X  	 * after old player died.
X  	 */
X! 		if (ghostly) otmp->age = monstermoves-omoves+otmp->age;
X  		otmp2 = otmp;
X  	}
X  	if(first && otmp2->nobj){
X***************
X*** 211,216 ****
X--- 239,245 ----
X  	mread(fd, (genericptr_t) &dlevel, sizeof dlevel);
X  	mread(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X  	mread(fd, (genericptr_t) &moves, sizeof moves);
X+ 	mread(fd, (genericptr_t) &monstermoves, sizeof monstermoves);
X  	mread(fd, (genericptr_t) &wiz_level, sizeof wiz_level);
X  	mread(fd, (genericptr_t) &medusa_level, sizeof medusa_level);
X  	mread(fd, (genericptr_t) &bigroom_level, sizeof bigroom_level);
X***************
X*** 328,335 ****
X  #endif
X  	getlev(fd, 0, (xchar)0, FALSE);
X  	(void) close(fd);
X! #ifdef EXPLORE_MODE
X! 	if(!discover)
X  #endif
X  		(void) unlink(SAVEF);
X  #ifdef REINCARNATION
X--- 357,374 ----
X  #endif
X  	getlev(fd, 0, (xchar)0, FALSE);
X  	(void) close(fd);
X! #if defined(WIZARD) || defined(EXPLORE_MODE)
X! 	if(
X! # ifdef WIZARD
X! 	   !wizard
X! #  ifdef EXPLORE_MODE
X! 		   &&
X! #  endif
X! # endif
X! # ifdef EXPLORE_MODE
X! 		      !discover
X! # endif
X! 				)
X  #endif
X  		(void) unlink(SAVEF);
X  #ifdef REINCARNATION
X***************
X*** 372,377 ****
X--- 411,417 ----
X  {
X  	register struct gold *gold;
X  	register struct trap *trap;
X+ 	register struct monst *mtmp;
X  #ifdef WORM
X  	register struct wseg *wtmp;
X  	register int tmp;
X***************
X*** 666,671 ****
X--- 706,712 ----
X  	}
X  	free((genericptr_t) trap);
X  	fobj = restobjchn(fd, ghostly);
X+ 	find_lev_obj();
X  	billobjs = restobjchn(fd, ghostly);
X  	rest_engravings(fd);
X  	mread(fd, (genericptr_t)rooms, sizeof(rooms));
X***************
X*** 683,688 ****
X--- 724,737 ----
X  	}
X  	mread(fd, (genericptr_t)wgrowtime, sizeof(wgrowtime));
X  #endif
X+ 
X+ 	/* reset level.monsters for new level */
X+ 	for (x = 0; x < COLNO; x++)
X+ 	    for (y = 0; y < ROWNO; y++)
X+ 		level.monsters[x][y] = (struct monst *) 0;
X+ 	for (mtmp = level.monlist; mtmp; mtmp = mtmp->nmon)
X+ 	    place_monster(mtmp, mtmp->mx, mtmp->my);
X+ 
X  #ifdef TUTTI_FRUTTI
X  	/* Now get rid of all the temp fruits... */
X  	if (ghostly) {
X*** src/Old/rnd.c	Wed Sep 27 12:15:19 1989
X--- src/rnd.c	Thu Sep 14 13:21:51 1989
X***************
X*** 28,33 ****
X--- 28,39 ----
X  rn2(x)		/* 0 <= rn2(x) < x */
X  register int x;
X  {
X+ #ifdef DEBUG
X+ 	if (x == 0) {
X+ 		impossible("rn2(0) attempted");
X+ 		return(0);
X+ 	}
X+ #endif
X  	return(RND(x));
X  }
X  
X***************
X*** 50,55 ****
X--- 56,67 ----
X  rnd(x)		/* 1 <= rnd(x) <= x */
X  register int x;
X  {
X+ #ifdef DEBUG
X+ 	if (x == 0) {
X+ 		impossible("rnd(0) attempted");
X+ 		return(1);
X+ 	}
X+ #endif
X  	return(RND(x)+1);
X  }
X  
X*** src/Old/rumors.c	Wed Sep 27 12:15:31 1989
X--- src/rumors.c	Mon Sep 25 21:29:05 1989
X***************
X*** 223,229 ****
X  			You("have no money.");
X  			return(0);
X  		}
X! 		pline("\"Wilt thou settle for a minor consultation?\"  (50 Zorkmids) ");
X  		ans = ynq();
X  		if(ans == 'y') {
X  			if(u.ugold < 50) {
X--- 223,229 ----
X  			You("have no money.");
X  			return(0);
X  		}
X! 		pline("\"Wilt thou settle for a minor consultation?\"  (50 zorkmids) ");
X  		ans = ynq();
X  		if(ans == 'y') {
X  			if(u.ugold < 50) {
X***************
X*** 237,243 ****
X  			return(1);
X  		} else if(ans == 'q') return(0);
X  		else {
X! 			pline("\"Then dost thou desire a major one?\"  (1000 Zorkmids) ");
X  			if (yn() != 'y') return(0);
X  		}
X  		if(u.ugold < 1000) {
X--- 237,243 ----
X  			return(1);
X  		} else if(ans == 'q') return(0);
X  		else {
X! 			pline("\"Then dost thou desire a major one?\"  (1000 zorkmids) ");
X  			if (yn() != 'y') return(0);
X  		}
X  		if(u.ugold < 1000) {
X*** src/Old/save.c	Wed Sep 27 12:15:46 1989
X--- src/save.c	Tue Sep 26 16:08:38 1989
X***************
X*** 14,20 ****
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #ifdef EXPLORE_MODE
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X--- 14,20 ----
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #if defined(EXPLORE_MODE) && !defined(O_RDONLY)
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X***************
X*** 75,83 ****
X  #ifndef NOSAVEONHANGUP
X  int
X  hangup(){
X! 	hu = TRUE;
X! 	(void) dosave0();
X! 	exit(1);
X  	return 0;
X  }
X  #endif
X--- 75,88 ----
X  #ifndef NOSAVEONHANGUP
X  int
X  hangup(){
X! 	if (!hu)
X! 	{
X! 		hu = TRUE;
X! 		(void) dosave0();
X! # ifndef VMS
X! 		exit(1);
X! # endif
X! 	}
X  	return 0;
X  }
X  #endif
X***************
X*** 95,101 ****
X  #ifdef COMPRESS
X  	char	cmd[80];
X  #endif
X! #ifdef UNIX
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X  #if !defined(__TURBOC__) && !defined(OLD_TOS)
X--- 100,110 ----
X  #ifdef COMPRESS
X  	char	cmd[80];
X  #endif
X! 
X! 	if (!SAVEF[0])
X! 		return 0;
X! 
X! #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X  #if !defined(__TURBOC__) && !defined(OLD_TOS)
X***************
X*** 164,169 ****
X--- 173,179 ----
X  	bwrite(fd, (genericptr_t) &dlevel, sizeof dlevel);
X  	bwrite(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X  	bwrite(fd, (genericptr_t) &moves, sizeof moves);
X+ 	bwrite(fd, (genericptr_t) &monstermoves, sizeof monstermoves);
X  	bwrite(fd, (genericptr_t) &wiz_level, sizeof wiz_level);
X  	bwrite(fd, (genericptr_t) &medusa_level, sizeof medusa_level);
X  	bwrite(fd, (genericptr_t) &bigroom_level, sizeof bigroom_level);
X***************
X*** 355,361 ****
X  	else
X  #endif
X  		bwrite(fd, (genericptr_t) &showsyms, sizeof(struct symbols));
X! 	bwrite(fd,(genericptr_t) &moves,sizeof(long));
X  	bwrite(fd,(genericptr_t) &xupstair,sizeof(xupstair));
X  	bwrite(fd,(genericptr_t) &yupstair,sizeof(yupstair));
X  	bwrite(fd,(genericptr_t) &xdnstair,sizeof(xdnstair));
X--- 365,371 ----
X  	else
X  #endif
X  		bwrite(fd, (genericptr_t) &showsyms, sizeof(struct symbols));
X! 	bwrite(fd,(genericptr_t) &monstermoves,sizeof(long));
X  	bwrite(fd,(genericptr_t) &xupstair,sizeof(xupstair));
X  	bwrite(fd,(genericptr_t) &yupstair,sizeof(yupstair));
X  	bwrite(fd,(genericptr_t) &xdnstair,sizeof(xdnstair));
X*** src/Old/search.c	Wed Sep 27 12:16:28 1989
X--- src/search.c	Thu Sep 14 14:12:00 1989
X***************
X*** 36,42 ****
X  		    atl(zx,zy,(char)((ttmp->ttyp==WEB) ? WEB_SYM : TRAP_SYM));
X  			(*num)++;
X  		}
X! 	} else if(levl[zx][zy].mmask) {
X  		mtmp = m_at(zx,zy);
X  		if(mtmp->mimic) {
X  		        seemimic(mtmp);
X--- 36,42 ----
X  		    atl(zx,zy,(char)((ttmp->ttyp==WEB) ? WEB_SYM : TRAP_SYM));
X  			(*num)++;
X  		}
X! 	} else if(MON_AT(zx, zy)) {
X  		mtmp = m_at(zx,zy);
X  		if(mtmp->mimic) {
X  		        seemimic(mtmp);
X***************
X*** 122,128 ****
X  			prl(x,y);
X  		    } else {
X  		/* Be careful not to find anything in an SCORR or SDOOR */
X! 			if(levl[x][y].mmask) {
X  			    mtmp = m_at(x,y);
X  			    if(!aflag && mtmp->mimic) {
X  				seemimic(mtmp);
X--- 122,128 ----
X  			prl(x,y);
X  		    } else {
X  		/* Be careful not to find anything in an SCORR or SDOOR */
X! 			if(MON_AT(x, y)) {
X  			    mtmp = m_at(x,y);
X  			    if(!aflag && mtmp->mimic) {
X  				seemimic(mtmp);
X*** src/Old/shk.c	Wed Sep 27 12:17:07 1989
X--- src/shk.c	Mon Sep 25 23:01:31 1989
X***************
X*** 9,15 ****
X  #include "eshk.h"
X  
X  #ifdef KOPS
X! static int makekops();
X  static void kops_gone();
X  #endif /* KOPS */
X  
X--- 9,15 ----
X  #include "eshk.h"
X  
X  #ifdef KOPS
X! static int makekops P((coord *));
X  static void kops_gone();
X  #endif /* KOPS */
X  
X***************
X*** 125,132 ****
X  			    You("escaped the shop without paying!");
X  			addupbill();
X  			total += ESHK(shopkeeper)->debit;
X! 			You("stole %ld zorkmids worth of merchandise.",
X! 				total);
X  			ESHK(shopkeeper)->robbed += total;
X  			ESHK(shopkeeper)->credit = 0L;
X  			ESHK(shopkeeper)->debit = 0L;
X--- 125,132 ----
X  			    You("escaped the shop without paying!");
X  			addupbill();
X  			total += ESHK(shopkeeper)->debit;
X! 			You("stole %ld zorkmid%s worth of merchandise.",
X! 				total, plur(total));
X  			ESHK(shopkeeper)->robbed += total;
X  			ESHK(shopkeeper)->credit = 0L;
X  			ESHK(shopkeeper)->debit = 0L;
X***************
X*** 404,415 ****
X  register struct monst *shkp;
X  {
X  	register xchar x = ESHK(shkp)->shk.x, y = ESHK(shkp)->shk.y;
X! 	if(levl[x][y].mmask)
X  		mnearto(m_at(x,y), x, y, FALSE);
X! 	levl[shkp->mx][shkp->my].mmask = 0;
X! 	shkp->mx = x;
X! 	shkp->my = y;
X! 	levl[shkp->mx][shkp->my].mmask = 1;
X  	unpmon(shkp);
X  }
X  
X--- 404,413 ----
X  register struct monst *shkp;
X  {
X  	register xchar x = ESHK(shkp)->shk.x, y = ESHK(shkp)->shk.y;
X! 	if(MON_AT(x, y))
X  		mnearto(m_at(x,y), x, y, FALSE);
X! 	remove_monster(shkp->mx, shkp->my);
X! 	place_monster(shkp, x, y);
X  	unpmon(shkp);
X  }
X  
X***************
X*** 468,476 ****
X  		else {
X  		    long ugold = u.ugold;
X  
X! 		    if(ugold  > ltmp) {
X! 			You("give %s the %ld gold pieces %s asked for.",
X! 			    mon_nam(shkp), ltmp,
X  			    ESHK(shkp)->ismale ? "he" : "she");
X  			pay(ltmp, shkp);
X  		    } else {
X--- 466,474 ----
X  		else {
X  		    long ugold = u.ugold;
X  
X! 		    if(ugold > ltmp) {
X! 			You("give %s the %ld gold piece%s %s asked for.",
X! 			    mon_nam(shkp), ltmp, plur(ltmp),
X  			    ESHK(shkp)->ismale ? "he" : "she");
X  			pay(ltmp, shkp);
X  		    } else {
X***************
X*** 538,545 ****
X  	}
X  	/* pay debt, if any, first */
X  	if(ESHK(shopkeeper)->debit) {
X! 	        You("owe %s %ld zorkmids for the use of merchandise.",
X! 			shkname(shopkeeper), ESHK(shopkeeper)->debit);
X  	        if(u.ugold + ESHK(shopkeeper)->credit < 
X  					ESHK(shopkeeper)->debit) {
X  		    pline("But you don't have enough gold%s.",
X--- 536,544 ----
X  	}
X  	/* pay debt, if any, first */
X  	if(ESHK(shopkeeper)->debit) {
X! 	        You("owe %s %ld zorkmid%s for the use of merchandise.",
X! 			shkname(shopkeeper), ESHK(shopkeeper)->debit,
X! 		        plur(ESHK(shopkeeper)->debit));
X  	        if(u.ugold + ESHK(shopkeeper)->credit < 
X  					ESHK(shopkeeper)->debit) {
X  		    pline("But you don't have enough gold%s.",
X***************
X*** 722,732 ****
X  		} else {
X  			u.ugold -= loss;
X  			shopkeeper->mgold += loss;
X! 			pline("%s comes and takes %ld zorkmids %sowed %s.",
X! 			       Monnam(shopkeeper),
X! 			       loss,
X! 			       strncmp(ESHK(shopkeeper)->customer, plname, PL_NSIZ) ? "" : "you ",
X! 			       ESHK(shopkeeper)->ismale ? "him" : "her");
X  		}
X  
X  		/* in case we create bones */
X--- 721,732 ----
X  		} else {
X  			u.ugold -= loss;
X  			shopkeeper->mgold += loss;
X! 			pline("%s comes and takes %ld zorkmid%s %sowed %s.",
X! 			      Monnam(shopkeeper),
X! 			      loss,
X! 			      plur(loss),
X! 			      strncmp(ESHK(shopkeeper)->customer, plname, PL_NSIZ) ? "" : "you ",
X! 			      ESHK(shopkeeper)->ismale ? "him" : "her");
X  		}
X  
X  		/* in case we create bones */
X***************
X*** 847,854 ****
X  		pline("%s; only %d %s %s.\"", buf, bp->price,
X  			(bp->bquan > 1) ? "per" : "for this", xname(obj));
X  		obj->quan = bp->bquan;
X! 	} else pline("The %s will cost you %d zorkmids%s.",
X! 			xname(obj), bp->price,
X  			(bp->bquan > 1) ? " each" : "");
X  	ESHK(shopkeeper)->billct++;
X  	obj->unpaid = 1;
X--- 847,854 ----
X  		pline("%s; only %d %s %s.\"", buf, bp->price,
X  			(bp->bquan > 1) ? "per" : "for this", xname(obj));
X  		obj->quan = bp->bquan;
X! 	} else pline("The %s will cost you %d zorkmid%s%s.",
X! 			xname(obj), bp->price, plur((long)bp->price),
X  			(bp->bquan > 1) ? " each" : "");
X  	ESHK(shopkeeper)->billct++;
X  	obj->unpaid = 1;
X***************
X*** 886,900 ****
X  	}
X  }
X  
X! void
X  subfrombill(obj)
X  register struct obj *obj;
X  {
X- 	long ltmp;
X  	register struct bill_x *bp;
X  
X- 	if(!costly_spot(u.ux,u.uy))
X- 		return;
X  	if((bp = onbill(obj)) != 0) {
X  		register struct obj *otmp;
X  
X--- 886,897 ----
X  	}
X  }
X  
X! static void
X  subfrombill(obj)
X  register struct obj *obj;
X  {
X  	register struct bill_x *bp;
X  
X  	if((bp = onbill(obj)) != 0) {
X  		register struct obj *otmp;
X  
X***************
X*** 914,927 ****
X  		ESHK(shopkeeper)->billct--;
X  		*bp = bill[ESHK(shopkeeper)->billct];
X  		return;
X! 	}
X! 	if(obj->unpaid) {
X! 		if(inhishop(shopkeeper))
X! 		    pline("%s didn't notice.", Monnam(shopkeeper));
X  		obj->unpaid = 0;
X- 		return;		/* %% */
X  	}
X! 	/* he dropped something of his own - probably wants to sell it */
X  	if(shopkeeper->msleep || shopkeeper->mfroz || !inhishop(shopkeeper))
X  		return;
X  	ltmp = (long) getprice(obj) * (long) obj->quan;
X--- 911,932 ----
X  		ESHK(shopkeeper)->billct--;
X  		*bp = bill[ESHK(shopkeeper)->billct];
X  		return;
X! 	} else if (obj->unpaid) {
X! 		impossible("subfrombill: unpaid object not on bill");
X  		obj->unpaid = 0;
X  	}
X! }
X! 
X! void
X! sellobj(obj)
X! register struct obj *obj;
X! {
X! 	long ltmp;
X! 
X! 	if(!costly_spot(u.ux,u.uy))
X! 		return;
X! 	subfrombill(obj);
X! 	/* you dropped something of your own - probably want to sell it */
X  	if(shopkeeper->msleep || shopkeeper->mfroz || !inhishop(shopkeeper))
X  		return;
X  	ltmp = (long) getprice(obj) * (long) obj->quan;
X***************
X*** 1007,1018 ****
X  		for(cnt = 0; buf[cnt]; cnt++);
X  		while(cnt < 50)
X  			buf[cnt++] = ' ';
X! 		Sprintf(&buf[cnt], " %5ld zorkmids", thisused);
X  		if(page_line(buf))
X  			goto quit;
X  	    }
X  	}
X! 	Sprintf(buf, "Total:%50ld zorkmids", totused);
X  	if(page_line("") || page_line(buf))
X  		goto quit;
X  	set_pager(1);
X--- 1012,1023 ----
X  		for(cnt = 0; buf[cnt]; cnt++);
X  		while(cnt < 50)
X  			buf[cnt++] = ' ';
X! 		Sprintf(&buf[cnt], " %5ld zorkmid%s", thisused, plur(thisused));
X  		if(page_line(buf))
X  			goto quit;
X  	    }
X  	}
X! 	Sprintf(buf, "Total:%50ld zorkmid%s", totused, plur(totused));
X  	if(page_line("") || page_line(buf))
X  		goto quit;
X  	set_pager(1);
X***************
X*** 1039,1044 ****
X--- 1044,1050 ----
X  	case FOOD_SYM:
X  		/* simpler hunger check, (2-4)*cost */
X  		if (u.uhs >= HUNGRY) tmp *= u.uhs;
X+ 		if (OEATEN(obj)) tmp /= 2;		/* partly eaten */
X  		break;
X  	case WAND_SYM:
X  		if (obj->spe == -1) tmp = 0;
X***************
X*** 1064,1071 ****
X  {
X  	register struct monst *shkp = shopkeeper;
X  
X  	if(u.uinshop && shkp && !shkp->mfroz && !shkp->msleep &&
X- 	    u.dx && u.dy &&
X  	    inroom(u.ux+u.dx, u.uy+u.dy) + 1 == u.uinshop &&
X  	    shkp->mx == ESHK(shkp)->shk.x && shkp->my == ESHK(shkp)->shk.y &&
X  	    u.ux == ESHK(shkp)->shd.x && u.uy == ESHK(shkp)->shd.y) {
X--- 1070,1077 ----
X  {
X  	register struct monst *shkp = shopkeeper;
X  
X+ 	if(obj->otyp != PICK_AXE) return(0);
X  	if(u.uinshop && shkp && !shkp->mfroz && !shkp->msleep &&
X  	    inroom(u.ux+u.dx, u.uy+u.dy) + 1 == u.uinshop &&
X  	    shkp->mx == ESHK(shkp)->shk.x && shkp->my == ESHK(shkp)->shk.y &&
X  	    u.ux == ESHK(shkp)->shd.x && u.uy == ESHK(shkp)->shd.y) {
X***************
X*** 1072,1077 ****
X--- 1078,1084 ----
X  		pline("%s nimbly catches the %s.", Monnam(shkp), xname(obj));
X  		obj->nobj = shkp->minvent;
X  		shkp->minvent = obj;
X+ 		subfrombill(obj);
X  		return(1);
X  	}
X  	return(0);
X***************
X*** 1227,1233 ****
X  	    pline("\"%s, do not damage the floor here!\"",
X  			flags.female ? "Madam" : "Sir");
X  	if (pl_character[0] == 'K') adjalign(-sgn(u.ualigntyp));
X!     } else if(um_dist(shopkeeper->mx, shopkeeper->my, 2)) {
X  	register struct obj *obj, *obj2;
X  
X  	if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X--- 1234,1240 ----
X  	    pline("\"%s, do not damage the floor here!\"",
X  			flags.female ? "Madam" : "Sir");
X  	if (pl_character[0] == 'K') adjalign(-sgn(u.ualigntyp));
X!     } else if(!um_dist(shopkeeper->mx, shopkeeper->my, 5)) {
X  	register struct obj *obj, *obj2;
X  
X  	if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X***************
X*** 1248,1255 ****
X  		freeinv(obj);
X  		obj->nobj = shopkeeper->minvent;
X  		shopkeeper->minvent = obj;
X! 		if(obj->unpaid)
X! 			subfrombill(obj);
X  	}
X      }
X  }
X--- 1255,1261 ----
X  		freeinv(obj);
X  		obj->nobj = shopkeeper->minvent;
X  		shopkeeper->minvent = obj;
X! 		subfrombill(obj);
X  	}
X      }
X  }
X***************
X*** 1328,1341 ****
X  	if(!in_shop(shopkeeper->mx ,shopkeeper->my)) return;
X  
X  	/* if a !shopkeeper shows up at the door, move him */
X! 	if(levl[x][y].mmask && (mtmp = m_at(x, y)) != shopkeeper) {
X  		if(flags.soundok) {
X  		    You("hear an angry voice: \"Out of my way, scum!\"");
X  		    (void) fflush(stdout);
X! #if defined(SYSV) || defined(ULTRIX)
X  		    (void)
X  #endif
X! #ifdef UNIX
X  			sleep(1);
X  #endif
X  		}
X--- 1334,1347 ----
X  	if(!in_shop(shopkeeper->mx ,shopkeeper->my)) return;
X  
X  	/* if a !shopkeeper shows up at the door, move him */
X! 	if(MON_AT(x, y) && (mtmp = m_at(x, y)) != shopkeeper) {
X  		if(flags.soundok) {
X  		    You("hear an angry voice: \"Out of my way, scum!\"");
X  		    (void) fflush(stdout);
X! #if defined(SYSV) || defined(ULTRIX) || defined(VMS)
X  		    (void)
X  #endif
X! #if defined(UNIX) || defined(VMS)
X  			sleep(1);
X  #endif
X  		}
X***************
X*** 1343,1352 ****
X  	}
X  
X  	/* make shk show up at the door */
X! 	levl[shopkeeper->mx][shopkeeper->my].mmask = 0;
X! 	levl[x][y].mmask = 1;
X! 	shopkeeper->mx = x;
X! 	shopkeeper->my = y;
X  	pmon(shopkeeper);
X  
X  	damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X--- 1349,1356 ----
X  	}
X  
X  	/* make shk show up at the door */
X! 	remove_monster(shopkeeper->mx, shopkeeper->my);
X! 	place_monster(shopkeeper, x, y);
X  	pmon(shopkeeper);
X  
X  	damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X***************
X*** 1374,1380 ****
X  		NOTANGRY(shopkeeper) = 1;
X  	}
X  	else {
X! 		pline("\"Oh, yes!  You'll pay!\"");
X  		ESHK(shopkeeper)->following = 1;
X  		NOTANGRY(shopkeeper) = 0;
X  		adjalign(-sgn(u.ualigntyp));
X--- 1378,1384 ----
X  		NOTANGRY(shopkeeper) = 1;
X  	}
X  	else {
X! 		verbalize("Oh, yes!  You'll pay!");
X  		ESHK(shopkeeper)->following = 1;
X  		NOTANGRY(shopkeeper) = 0;
X  		adjalign(-sgn(u.ualigntyp));
X*** src/Old/shknam.c	Wed Sep 27 12:17:56 1989
X--- src/shknam.c	Thu Sep 14 14:12:08 1989
X***************
X*** 186,192 ****
X  	register struct monst *mtmp;
X  	int atype;
X  
X! 	if (rn2(100) < dlevel && levl[sx][sy].mmask == 0 &&
X  				(mtmp=makemon(mkclass(S_MIMIC),sx,sy))) {
X  		mtmp->mimic = 1;
X  		/* note: makemon will set the mimic symbol to a shop item */
X--- 186,192 ----
X  	register struct monst *mtmp;
X  	int atype;
X  
X! 	if (rn2(100) < dlevel && !MON_AT(sx, sy) &&
X  				(mtmp=makemon(mkclass(S_MIMIC),sx,sy))) {
X  		mtmp->mimic = 1;
X  		/* note: makemon will set the mimic symbol to a shop item */
X***************
X*** 258,264 ****
X  			return(-1);
X  		    }
X  
X! 	if(levl[sx][sy].mmask) rloc(m_at(sx, sy)); /* insurance */
X  
X  	/* now initialize the shopkeeper monster structure */
X  	if(!(shk = makemon(&mons[PM_SHOPKEEPER], sx, sy))) return(-1);
X--- 258,264 ----
X  			return(-1);
X  		    }
X  
X! 	if(MON_AT(sx, sy)) rloc(m_at(sx, sy)); /* insurance */
X  
X  	/* now initialize the shopkeeper monster structure */
X  	if(!(shk = makemon(&mons[PM_SHOPKEEPER], sx, sy))) return(-1);
X*** src/Old/sounds.c	Wed Sep 27 12:18:36 1989
X--- src/sounds.c	Thu Sep 14 14:12:11 1989
X***************
X*** 381,390 ****
X  	case MS_HUMANOID:
X  	    /* Generic humanoid behaviour. */
X  	    if (!mtmp->mpeaceful && !mtmp->mtame) break;
X! 	    if (mtmp->mhp < 10)
X! 		kludge("%s moans.", Monnam(mtmp));
X! 	    else if (mtmp->mflee)
X  		kludge("%s wants nothing to do with you.", Monnam(mtmp));
X  	    else if (mtmp->mconf || mtmp->mstun)
X  		verbalize(!rn2(3) ? "Huh?" : rn2(2) ? "What?" : "Eh?");
X  	    else if (mtmp->mblinded)
X--- 381,390 ----
X  	case MS_HUMANOID:
X  	    /* Generic humanoid behaviour. */
X  	    if (!mtmp->mpeaceful && !mtmp->mtame) break;
X! 	    if (mtmp->mflee)
X  		kludge("%s wants nothing to do with you.", Monnam(mtmp));
X+ 	    else if (mtmp->mhp < mtmp->mhpmax/4)
X+ 		kludge("%s moans.", Monnam(mtmp));
X  	    else if (mtmp->mconf || mtmp->mstun)
X  		verbalize(!rn2(3) ? "Huh?" : rn2(2) ? "What?" : "Eh?");
X  	    else if (mtmp->mblinded)
X***************
X*** 587,593 ****
X      }
X  
X      tx = u.ux+u.dx; ty = u.uy+u.dy;
X!     if ((Blind && !Telepat) || !levl[tx][ty].mmask ||
X  	    (mtmp = m_at(tx, ty))->mimic || mtmp->mundetected) {
X  	pline("I see nobody there.");
X  	return(0);
X--- 587,593 ----
X      }
X  
X      tx = u.ux+u.dx; ty = u.uy+u.dy;
X!     if ((Blind && !Telepat) || !MON_AT(tx, ty) ||
X  	    (mtmp = m_at(tx, ty))->mimic || mtmp->mundetected) {
X  	pline("I see nobody there.");
X  	return(0);
X*** src/Old/spell.c	Wed Sep 27 12:19:31 1989
X--- src/spell.c	Thu Sep 14 14:06:53 1989
X***************
X*** 18,27 ****
X  #define spellid(spell)		spl_book[spell-1].sp_id
X  
X  static void
X! cursed_book(level)
X! 	register int	level;
X  {
X! 	switch(rn2(level)) {
X  	case 0:
X  		You("feel a wrenching sensation.");
X  		tele();		/* teleport him */
X--- 18,27 ----
X  #define spellid(spell)		spl_book[spell-1].sp_id
X  
X  static void
X! cursed_book(lev)
X! 	register int	lev;
X  {
X! 	switch(rn2(lev)) {
X  	case 0:
X  		You("feel a wrenching sensation.");
X  		tele();		/* teleport him */
X*** src/Old/termcap.c	Wed Sep 27 12:20:12 1989
X--- src/termcap.c	Wed Sep 27 11:25:44 1989
X***************
X*** 32,50 ****
X  # ifdef TERMLIB
X  static void init_hilite();
X  # endif
X! #define NONE		0
X! #define HIGH_INTENSITY	1
X! #define BLACK		0
X! #define HILITE_ATTRIB	HIGH_INTENSITY
X! #endif /* TEXTCOLOR */
X  
X  static char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X  static char *VS, *VE, *US, *UE;
X  static char *MR, *ME;
X  #if 0
X! static char *MB, *MD, *MH;
X  #endif
X  #ifdef TERMLIB
X  static int SG;
X  static char PC = '\0';
X  static char tbuf[512];
X--- 32,50 ----
X  # ifdef TERMLIB
X  static void init_hilite();
X  # endif
X! #endif
X  
X  static char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
X  static char *VS, *VE, *US, *UE;
X  static char *MR, *ME;
X  #if 0
X! static char *MB, *MH;
X! static char *MD;	/* may already be in use below */
X  #endif
X  #ifdef TERMLIB
X+ # ifdef TEXTCOLOR
X+ static char *MD;
X+ # endif
X  static int SG;
X  static char PC = '\0';
X  static char tbuf[512];
X***************
X*** 134,140 ****
X  		SO = "\033p";
X  		SE = "\033q";
X  		HI = "\033p";
X! 		HE = "\033q";
X  	}
X  #  else /* TOS */
X  	{
X--- 134,144 ----
X  		SO = "\033p";
X  		SE = "\033q";
X  		HI = "\033p";
X! 		HE = "\033q\033b\020";
X! 		for (i = 0; i < SIZE(hilites); i++) {
X! 			hilites[i] = (char *) alloc(sizeof("Eb1"));
X! 			Sprintf(hilites[i], (i%4)?"\033b%c","\033p", i);
X! 		}
X  	}
X  #  else /* TOS */
X  	{
X***************
X*** 173,182 ****
X  #   endif
X  		TE = VS = VE = "";
X  #   ifdef TEXTCOLOR
X! 		for (i = 0; i < SIZE(HI_COLOR); i++) {
X! 			HI_COLOR[i] = (char *) alloc(sizeof("E[0;33;44m"));
X! 			Sprintf(HI_COLOR[i], "\033[%d;3%dm",
X! 				i == BLACK ? NONE : HILITE_ATTRIB, i);
X  		}
X  #   endif
X  		return;
X--- 177,187 ----
X  #   endif
X  		TE = VS = VE = "";
X  #   ifdef TEXTCOLOR
X! 		for (i = 0; i < MAXCOLORS / 2; i++) {
X! 			hilites[i] = (char *) alloc(sizeof("\033[0;3%dm"));
X! 			hilites[i+BRIGHT] = (char *) alloc(sizeof("\033[1;3%dm"));
X! 			Sprintf(hilites[i], "\033[0;3%dm", i);
X! 			Sprintf(hilites[i+BRIGHT], "\033[1;3%dm", i);
X  		}
X  #   endif
X  		return;
X***************
X*** 282,287 ****
X--- 287,295 ----
X  	AS = Tgetstr("as");
X  	AE = Tgetstr("ae");
X  	CD = Tgetstr("cd");
X+ # ifdef TEXTCOLOR
X+ 	MD = Tgetstr("md");
X+ # endif
X  	set_whole_screen();		/* uses LI and CD */
X  	if(tbufptr-tbuf > sizeof(tbuf)) error("TERMCAP entry too big...\n");
X  	free((genericptr_t)tptr);
X***************
X*** 514,519 ****
X--- 522,528 ----
X  	(void) fflush(stdout);
X  }
X  
X+ #if defined(TERMLIB) || defined(DECRAINBOW)
X  void
X  graph_on() {
X  	if (AS) xputs(AS);
X***************
X*** 523,533 ****
X--- 532,550 ----
X  graph_off() {
X  	if (AE) xputs(AE);
X  }
X+ #endif
X  
X  #ifndef MSDOS
X+ # ifdef VMS
X+ static const short tmspc10[] = {		/* from termcap */
X+ 	0, 2000, 1333, 909, 743, 666, 333, 166, 83, 55, 50, 41, 27, 20, 13, 10,
X+ 	5
X+ };
X+ # else
X  static const short tmspc10[] = {		/* from termcap */
X  	0, 2000, 1333, 909, 743, 666, 500, 333, 166, 83, 55, 41, 20, 10, 5
X  };
X+ # endif
X  #endif
X  
X  void
X***************
X*** 594,600 ****
X   * code found in pri.c).  It is assumed that the background color is black.
X   */
X  /* terminfo indexes for the basic colors it guarantees */
X! #define COLOR_BLACK   0
X  #define COLOR_BLUE    1
X  #define COLOR_GREEN   2
X  #define COLOR_CYAN    3
X--- 611,617 ----
X   * code found in pri.c).  It is assumed that the background color is black.
X   */
X  /* terminfo indexes for the basic colors it guarantees */
X! #define COLOR_BLACK   1		/* fake out to avoid black on black */
X  #define COLOR_BLUE    1
X  #define COLOR_GREEN   2
X  #define COLOR_CYAN    3
X***************
X*** 611,633 ****
X  static void
X  init_hilite()
X  {
X- 	int erret;
X- 	char *setf, *scratch;
X  	register int c;
X! 	extern int setupterm();
X! 	extern char *tparm(), *tigetstr();
X  
X! 	for (c = 0; c < SIZE(HI_COLOR); c++)
X! 		HI_COLOR[c] = HI;
X  
X! 	if (tgetnum("Co") < 8 || (setf = tgetstr("Sf", 0)) == (char *)NULL)
X  		return;
X  
X! 	for (c = 0; c < SIZE(HI_COLOR); c++) {
X! 		scratch = tparm(setf, ti_map[c]);
X! 		HI_COLOR[c] = (char *)alloc(strlen(scratch) + 1);
X! 		Strcpy(HI_COLOR[c], scratch);
X  	}
X  }
X  
X  # else /* UNIX */
X--- 628,655 ----
X  static void
X  init_hilite()
X  {
X  	register int c;
X! #  ifdef TERMINFO
X! 	char *setf, *scratch;
X! 	extern char *tparm();
X! #  endif
X  
X! 	for (c = 0; c < MAXCOLORS; c++)
X! 		hilites[c] = HI;
X  
X! #  ifdef TERMINFO
X! 	if (tgetnum("Co") < 8 || (setf = tgetstr("Sf", 0)) == NULL)
X  		return;
X  
X! 	for (c = 0; c < MAXCOLORS / 2; c++) {
X!   		scratch = tparm(setf, ti_map[c]);
X! 		hilites[c] = (char *) alloc(strlen(scratch) + 1);
X! 		hilites[c+BRIGHT] = (char*) alloc(strlen(scratch)+strlen(MD)+1);
X! 		Strcpy(hilites[c], scratch);
X! 		Strcpy(hilites[c+BRIGHT], MD);
X! 		Strcat(hilites[c+BRIGHT], scratch);
X  	}
X+ #  endif
X  }
X  
X  # else /* UNIX */
X***************
X*** 644,652 ****
X  	int backg = BLACK, foreg = WHITE, len;
X  	register int c, color;
X  
X! 	for (c = 0; c < SIZE(HI_COLOR); c++)
X! 		HI_COLOR[c] = HI;
X  
X  	/* find the background color, HI[len] == 'm' */
X  	len = strlen(HI) - 1;
X  
X--- 666,683 ----
X  	int backg = BLACK, foreg = WHITE, len;
X  	register int c, color;
X  
X! 	for (c = 0; c < SIZE(hilites); c++)
X! 		hilites[c] = HI;
X  
X+ #  ifdef TOS
X+ 	hilites[RED] = hilites[BRIGHT+RED] = "\033b1";
X+ 	hilites[BLUE] = hilites[BRIGHT+BLUE] = "\033b2";
X+ 	hilites[CYAN] = hilites[BRIGHT+CYAN] = "\033b3\033c2";
X+ 	hilites[ORANGE_COLORED] = hilites[RED];
X+ 	hilites[WHITE] = hilites[GRAY] = "\033b3";
X+ 	hilites[MAGENTA] = hilites[BRIGHT+MAGENTA] = "\033b1\033c2";
X+ 	HE = "\033q\033b3\033c0";	/* to turn off the color stuff too */
X+ #  else /* TOS */
X  	/* find the background color, HI[len] == 'm' */
X  	len = strlen(HI) - 1;
X  
X***************
X*** 657,662 ****
X--- 688,697 ----
X  	    if ((color = atoi(&HI[c])) == 0) {
X  		/* this also catches errors */
X  		foreg = WHITE; backg = BLACK;
X+ 	    /*
X+ 	    } else if (color == 1) {
X+ 		foreg |= BRIGHT;
X+ 	    */
X  	    } else if (color >= 30 && color <= 37) {
X  		foreg = color - 30;
X  	    } else if (color >= 40 && color <= 47) {
X***************
X*** 666,679 ****
X  	    c++;
X  	}
X  
X! 	for (c = 0; c < SIZE(HI_COLOR); c++)
X  	    /* avoid invisibility */
X  	    if (foreg != c && backg != c) {
X! 		HI_COLOR[c] = (char *) alloc(sizeof("E[0;33;44;54m"));
X! 		Sprintf(HI_COLOR[c], "\033[%d;3%d;4%dm",
X! 			c == BLACK ? NONE : HILITE_ATTRIB,
X! 			c, backg);
X  	    }
X  }
X  # endif /* UNIX */
X  #endif /* TEXTCOLOR */
X--- 701,715 ----
X  	    c++;
X  	}
X  
X! 	for (c = 0; c < MAXCOLORS / 2; c++)
X  	    /* avoid invisibility */
X  	    if (foreg != c && backg != c) {
X! 		hilites[c] = (char *) alloc(sizeof("\033[0;3%d;4%dm"));
X! 		hilites[c+BRIGHT] = (char *) alloc(sizeof("\033[1;3%d;4%dm"));
X! 		Sprintf(hilites[c], "\033[0;3%d;4%dm", c, backg);
X! 		Sprintf(hilites[c+BRIGHT], "\033[1;3%d;4%dm", c, backg);
X  	    }
X+ #  endif /* TOS */
X  }
X  # endif /* UNIX */
X  #endif /* TEXTCOLOR */
X*** src/Old/timeout.c	Wed Sep 27 12:20:47 1989
X--- src/timeout.c	Tue Sep 26 12:59:23 1989
X***************
X*** 29,35 ****
X  	"You find it hard to breathe.",
X  	"You're gasping for air.",
X  	"You can no longer breathe.",
X! 	"You're turning blue.",
X  	"You suffocate."
X  };
X  
X--- 29,35 ----
X  	"You find it hard to breathe.",
X  	"You're gasping for air.",
X  	"You can no longer breathe.",
X! 	"You're turning %s.",
X  	"You suffocate."
X  };
X  
X***************
X*** 39,45 ****
X  	register long i = (Strangled & TIMEOUT);
X  
X  	if(i > 0 && i <= SIZE(choke_texts))
X! 		pline(choke_texts[SIZE(choke_texts) - i]);
X  }
X  
X  void
X--- 39,46 ----
X  	register long i = (Strangled & TIMEOUT);
X  
X  	if(i > 0 && i <= SIZE(choke_texts))
X! 		pline(choke_texts[SIZE(choke_texts) - i], Hallucination ?
X! 			hcolor() : blue);
X  }
X  
X  void
X***************
X*** 77,83 ****
X  		if(upp->p_tofn) (*upp->p_tofn)();
X  		else switch(upp - u.uprops){
X  		case STONED:
X! 			killer = "cockatrice";
X  			done(STONING);
X  			break;
X  		case SICK:
X--- 78,84 ----
X  		if(upp->p_tofn) (*upp->p_tofn)();
X  		else switch(upp - u.uprops){
X  		case STONED:
X! 			if (!killer) killer = "cockatrice";
X  			done(STONING);
X  			break;
X  		case SICK:
X***************
X*** 171,182 ****
X  	int yours = otmp->spe;
X  #endif
X  
X! 	if(moves-otmp->age > 200)  /* very old egg - it's dead */
X  	    otmp->corpsenm = -1;
X  #ifdef LINT	/* long conv. ok */
X  	else if(rnd(150) > 150) {
X  #else
X! 	else if(rnd((int)(moves-otmp->age)) > 150) {
X  #endif
X  	    mtmp = makemon(&mons[big_to_little(otmp->corpsenm)], u.ux, u.uy);
X  	    useup(otmp);
X--- 172,183 ----
X  	int yours = otmp->spe;
X  #endif
X  
X! 	if(monstermoves-otmp->age > 200)  /* very old egg - it's dead */
X  	    otmp->corpsenm = -1;
X  #ifdef LINT	/* long conv. ok */
X  	else if(rnd(150) > 150) {
X  #else
X! 	else if(rnd((int)(monstermoves-otmp->age)) > 150) {
X  #endif
X  	    mtmp = makemon(&mons[big_to_little(otmp->corpsenm)], u.ux, u.uy);
X  	    useup(otmp);
X***************
X*** 202,208 ****
X  		}
X  #endif
X  		if(mtmp->data->mlet == S_DRAGON) {
X! 		    pline("\"Gleep!\"");		/* Mything eggs :-) */
X  		    (void) tamedog(mtmp, (struct obj *)0);
X  		}
X  	    }
X--- 203,209 ----
X  		}
X  #endif
X  		if(mtmp->data->mlet == S_DRAGON) {
X! 		    verbalize("Gleep!");		/* Mything eggs :-) */
X  		    (void) tamedog(mtmp, (struct obj *)0);
X  		}
X  	    }
X
END_OF_FILE
if test 52224 -ne `wc -c <'patches04d'`; then
    echo shar: \"'patches04d'\" unpacked with wrong size!
fi
# end of 'patches04d'
fi
echo shar: End of archive 4 \(of 11\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
