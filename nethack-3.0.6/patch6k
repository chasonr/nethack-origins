Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!tut.cis.ohio-state.edu!gem.mps.ohio-state.edu!usc!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i064:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6k
Message-ID: <4853@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:54:11 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2059
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 64
Archive-name: NetHack3/Patch6k
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 15)."
# Contents:  patches06k
# Wrapped by billr@saab on Wed Nov 22 10:50:19 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches06k' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06k'\"
else
echo shar: Extracting \"'patches06k'\" \(53197 characters\)
sed "s/^X//" >'patches06k' <<'END_OF_FILE'
X*** src/Old/read.c	Sun Nov 19 13:09:00 1989
X--- src/read.c	Fri Nov 17 19:32:14 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)read.c	3.0	88/04/13
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)read.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 12,18 ****
X  #endif
X  	0 };
X  
X! static void explode P((struct obj *));
X  static void do_class_genocide();
X  
X  int
X--- 12,18 ----
X  #endif
X  	0 };
X  
X! static void FDECL(explode, (struct obj *));
X  static void do_class_genocide();
X  
X  int
X***************
X*** 52,58 ****
X--- 52,60 ----
X  		pline("Being blind, you cannot read the formula on the scroll.");
X  		return(0);
X  	    }
X+ #ifndef NO_SIGNAL
X  	scroll->in_use = TRUE;		/* now being read */
X+ #endif
X  #ifdef SPELLS
X  	if(scroll->olet == SPBOOK_SYM) {
X  	    if(confused) {
X***************
X*** 85,90 ****
X--- 87,95 ----
X  		}
X  		if(!(scroll->otyp == SCR_BLANK_PAPER) || confused)
X  			useup(scroll);
X+ #ifndef NO_SIGNAL
X+ 		else scroll->in_use = FALSE;
X+ #endif
X  	}
X  	return(1);
X  }
X***************
X*** 121,126 ****
X--- 126,297 ----
X  		Blind ? "" : Hallucination ? hcolor() : color);
X  }
X  
X+ /*
X+  * recharge an object; curse_bless is -1 if the recharging implement
X+  * was cursed, +1 if blessed, 0 otherwise.
X+  */
X+ static
X+ void
X+ recharge(obj, curse_bless)
X+ struct obj *obj;
X+ int curse_bless;
X+ {
X+ 	register int n;
X+ 	boolean cursed, blessed;
X+ 
X+ 	cursed = curse_bless < 0;
X+ 	blessed = curse_bless > 0;
X+ 
X+ 	if (obj->olet != WAND_SYM) {
X+ 	    switch(obj->otyp) {
X+ 	    case MAGIC_MARKER:
X+ 		if (cursed) stripspe(obj);
X+ 		else if (blessed) {
X+ 		    n = obj->spe;
X+ 		    if (n < 50) obj->spe = 50;
X+ 		    if (n >= 50 && n < 75) obj->spe = 75;
X+ 		    if (n >= 75) obj->spe += 10;
X+ 		    p_glow2(obj,blue);
X+ 		} else {
X+ 		    if (obj->spe < 50) obj->spe = 50;
X+ 		    else obj->spe++;
X+ 		    p_glow2(obj,white);
X+ 		}
X+ 		break;
X+ 	    case LAMP:
X+ 		if (cursed) stripspe(obj);
X+ 		else if (blessed) {
X+ 		    n = rn2(11);
X+ 		    if (obj->spe < n) obj->spe = n;
X+ 		    else obj->spe += rnd(3);
X+ 		    p_glow2(obj,blue);
X+ 		} else {
X+ 		    obj->spe++;
X+ 		    p_glow1(obj);
X+ 		}
X+ 		break;
X+ 	    case MAGIC_LAMP:
X+ 		if (cursed) stripspe(obj);
X+ 		else if (blessed > 0) {
X+ 		    if (obj->spe == 1 || obj->recharged)
X+ 			pline(nothing_happens);
X+ 		    else {
X+ 			obj->spe = 1;
X+ 			obj->recharged = 1;
X+ 			p_glow1(obj);
X+ 		    }
X+ 		} else {
X+ 		    if (obj->spe == 1 || obj->recharged)
X+ 			pline(nothing_happens);
X+ 		    else {
X+ 			n = rn2(2);
X+ 			if (!n) {
X+ 			    obj->spe = 1;
X+ 			    obj->recharged = 1;
X+ 			    p_glow1(obj);
X+ 			} else pline(nothing_happens);
X+ 		    }
X+ 		}
X+ 		break;
X+ 	    case CRYSTAL_BALL:
X+ 		if (cursed) stripspe(obj);
X+ 		else if (blessed) {
X+ 		    obj->spe = 6;
X+ 		    p_glow2(obj,blue);
X+ 		} else {
X+ 		    if (obj->spe < 5) {
X+ 			obj->spe++;
X+ 			p_glow1(obj);
X+ 		    } else pline(nothing_happens);
X+ 		}
X+ 		break;
X+ 	    case BAG_OF_TRICKS:
X+ 		if (cursed) stripspe(obj);
X+ 		else if (blessed) {
X+ 		    if (obj->spe <= 10)
X+ 			obj->spe += (5 + rnd(10));
X+ 		    else obj->spe += (5 + rnd(5));
X+ 		    p_glow2(obj,blue);
X+ 		} else {
X+ 		    obj->spe += rnd(5);
X+ 		    p_glow1(obj);
X+ 		}
X+ 		break;
X+ 	    default:
X+ 		You("have a feeling of loss.");
X+ 		return;
X+ 	    } /* switch */
X+ 	}
X+ 	else {
X+ 	    if (obj->otyp == WAN_WISHING) {
X+ 		if (obj->recharged) { /* recharged once already? */
X+ 		    explode(obj);
X+ 		    return;
X+ 		}
X+ 		if (cursed) stripspe(obj);
X+ 		else if (blessed) {
X+ 		    if (obj->spe != 3) {
X+ 			obj->spe = 3;
X+ 			p_glow2(obj,blue);
X+ 		    } else {
X+ 			explode(obj);
X+ 			return;
X+ 		    }
X+ 		} else {
X+ 		    if (obj->spe < 3) {
X+ 			obj->spe++;
X+ 			p_glow2(obj,blue);
X+ 		    } else pline(nothing_happens);
X+ 		}
X+ 		obj->recharged = 1; /* another recharging disallowed */
X+ 	    }
X+ 	    else {
X+ 		if (cursed) stripspe(obj);
X+ 		else if (blessed) {
X+ 		    if (objects[obj->otyp].bits & NODIR) {
X+ 			n = rn1(5,11);
X+ 			if (obj->spe < n) obj->spe = n;
X+ 			else obj->spe++;
X+ 		    }
X+ 		    else {
X+ 			n = rn1(5,4);
X+ 			if (obj->spe < n) obj->spe = n;
X+ 			else obj->spe++;
X+ 		    }
X+ 		    p_glow2(obj,blue);
X+ 		} else {
X+ 		    obj->spe++;
X+ 		    p_glow1(obj);
X+ 		}
X+ 	    }
X+ 	}
X+ }
X+ 
X+ /*
X+  * forget some things (e.g. after reading a scroll of amnesia). abs(howmuch)
X+  * controls the level of forgetfulness; 0 == part of the map, 1 == all of
X+  * of map,  2 == part of map + spells, 3 == all of map + spells.
X+  */
X+ 
X+ static
X+ void
X+ forget(howmuch)
X+ boolean howmuch;
X+ {
X+ 	register int zx, zy;
X+ 
X+ 	known = TRUE;
X+ 	for(zx = 0; zx < COLNO; zx++) for(zy = 0; zy < ROWNO; zy++)
X+ 	    if(howmuch & 1 || rn2(7))
X+ 		if(!cansee(zx,zy))
X+ 		    levl[zx][zy].seen = levl[zx][zy].new =
X+ 			levl[zx][zy].scrsym = 0;
X+ 	docrt();
X+ #ifdef SPELLS
X+ 	if(howmuch & 2) losespells();
X+ #endif
X+ }
X+ 
X  int
X  seffects(sobj)
X  register struct obj	*sobj;
X***************
X*** 127,132 ****
X--- 298,304 ----
X  {
X  	register int cval = 0;
X  	register boolean confused = (Confusion != 0);
X+ 	register struct obj *otmp;
X  
X  	switch(sobj->otyp) {
X  #ifdef MAIL
X***************
X*** 142,149 ****
X  #endif
X  	case SCR_ENCHANT_ARMOR:
X  	    {
X- 		register struct obj *otmp = some_armor();
X  		register schar s = 0;
X  		if(!otmp) {
X  			strange_feeling(sobj,
X  					!Blind ? "Your skin glows then fades." :
X--- 314,321 ----
X  #endif
X  	case SCR_ENCHANT_ARMOR:
X  	    {
X  		register schar s = 0;
X+ 		otmp = some_armor();
X  		if(!otmp) {
X  			strange_feeling(sobj,
X  					!Blind ? "Your skin glows then fades." :
X***************
X*** 162,169 ****
X  				  sobj->cursed ? black : "gold",
X  				sobj->cursed ? "glow" :
X  				  (is_shield(otmp) ? "layer" : "shield"));
X! 			if(!(otmp->rustfree))
X! 				otmp->rustfree = !(sobj->cursed);
X  			break;
X  		}
X  #ifdef TOLKIEN
X--- 334,341 ----
X  				  sobj->cursed ? black : "gold",
X  				sobj->cursed ? "glow" :
X  				  (is_shield(otmp) ? "layer" : "shield"));
X! 			if(!(sobj->cursed))
X! 				otmp->rustfree = TRUE;
X  			break;
X  		}
X  #ifdef TOLKIEN
X***************
X*** 200,214 ****
X  		break;
X  	    }
X  	case SCR_DESTROY_ARMOR:
X! 	    {   register struct obj *otmp = some_armor();
X! 
X  		if(confused) {
X  			if(!otmp) {
X  				strange_feeling(sobj,"Your bones itch.");
X  				return(1);
X  			}
X- 			p_glow2(otmp,purple);
X  			otmp->rustfree = sobj->cursed;
X  			break;
X  		}
X  		if(!sobj->cursed || (sobj->cursed && (!otmp || !otmp->cursed))) {
X--- 372,386 ----
X  		break;
X  	    }
X  	case SCR_DESTROY_ARMOR:
X! 	    {
X! 		otmp = some_armor();
X  		if(confused) {
X  			if(!otmp) {
X  				strange_feeling(sobj,"Your bones itch.");
X  				return(1);
X  			}
X  			otmp->rustfree = sobj->cursed;
X+ 			p_glow2(otmp,purple);
X  			break;
X  		}
X  		if(!sobj->cursed || (sobj->cursed && (!otmp || !otmp->cursed))) {
X***************
X*** 343,348 ****
X--- 515,521 ----
X  		if(uwep && (uwep->olet == WEAPON_SYM || uwep->otyp == PICK_AXE)
X  							&& confused) {
X  		/* olet check added 10/25/86 GAN */
X+                         uwep->rustfree = !(sobj->cursed);
X  			if(Blind)
X  			    Your("weapon feels warm for a moment.");
X  			else
X***************
X*** 352,358 ****
X  				Hallucination ? hcolor() :
X  				  sobj->cursed ? purple : "gold",
X  				sobj->cursed ? "glow" : "shield");
X- 			uwep->rustfree = !(sobj->cursed);
X  		} else return !chwepon(sobj, bcsign(sobj)*2+1);
X  		break;
X  	case SCR_TAMING:
X--- 525,530 ----
X***************
X*** 436,443 ****
X  		    while(invent && !ggetobj("identify", identify, cval));
X  		return(1);
X  	case SCR_CHARGING:
X- 	    {	register struct obj *obj;
X- 		register int n;
X  		if (confused) {
X  		    You("feel charged up!");
X  		    break;
X--- 608,613 ----
X***************
X*** 444,578 ****
X  		}
X  		known = TRUE;
X  		pline("This is a charging scroll.");
X! 		obj = getobj("0#", "charge");
X! 		if (!obj) break;
X! 		if (obj->olet != WAND_SYM) {
X! 		    switch(obj->otyp) {
X! 		    case MAGIC_MARKER:
X! 			if (sobj->cursed) stripspe(obj);
X! 			else if (sobj->blessed) {
X! 			    n = obj->spe;
X! 			    if (n < 50) obj->spe = 50;
X! 			    if (n >= 50 && n < 75) obj->spe = 75;
X! 			    if (n >= 75) obj->spe += 10;
X! 			    p_glow2(obj,blue);
X! 			} else {
X! 			    if (obj->spe < 50) obj->spe = 50;
X! 			    else obj->spe++;
X! 			    p_glow2(obj,white);
X! 			}
X! 			break;
X! 		    case LAMP:
X! 			if (sobj->cursed) stripspe(obj);
X! 			else if (sobj->blessed) {
X! 			    n = rn2(11);
X! 			    if (obj->spe < n) obj->spe = n;
X! 			    else obj->spe += rnd(3);
X! 			    p_glow2(obj,blue);
X! 			} else {
X! 			    obj->spe++;
X! 			    p_glow1(obj);
X! 			}
X! 			break;
X! 		    case MAGIC_LAMP:
X! 			if (sobj->cursed) stripspe(obj);
X! 			else if (sobj->blessed) {
X! 			    if (obj->spe == 1 || obj->recharged)
X! 				pline(nothing_happens);
X! 			    else {
X! 				obj->spe = 1;
X! 				obj->recharged = 1;
X! 				p_glow1(obj);
X! 			    }
X! 			} else {
X! 			    if (obj->spe == 1 || obj->recharged)
X! 				pline(nothing_happens);
X! 			    else {
X! 				n = rn2(2);
X! 				if (!n) {
X! 				    obj->spe = 1;
X! 				    obj->recharged = 1;
X! 				    p_glow1(obj);
X! 				} else pline(nothing_happens);
X! 			    }
X! 			}
X! 			break;
X! 		    case CRYSTAL_BALL:
X! 			if (sobj->cursed) stripspe(obj);
X! 			else if (sobj->blessed) {
X! 			    obj->spe = 6;
X! 			    p_glow2(obj,blue);
X! 			} else {
X! 			    if (obj->spe < 5) {
X! 				obj->spe++;
X! 				p_glow1(obj);
X! 			    } else pline(nothing_happens);
X! 			}
X! 			break;
X! 		    case BAG_OF_TRICKS:
X! 			if (sobj->cursed) stripspe(obj);
X! 			else if (sobj->blessed) {
X! 			    if (obj->spe <= 10)
X! 				obj->spe += (5 + rnd(10));
X! 			    else obj->spe += (5 + rnd(5));
X! 			    p_glow2(obj,blue);
X! 			} else {
X! 			    obj->spe += rnd(5);
X! 			    p_glow1(obj);
X! 			}
X! 			break;
X! 		    default:
X! 			pline("The scroll %s%s, and disintegrates.",
X! 				Blind ? "vibrates violently" : "glows ",
X! 				Blind ? "" : Hallucination ? hcolor() : "dark red");
X! 		    } /* switch */
X! 		    break;
X! 		}
X! 		else {
X! 		    if (obj->otyp == WAN_WISHING) {
X! 			if (obj->recharged) { /* recharged once already? */
X! 			    explode(obj);
X! 			    break;
X! 			}
X! 			if (sobj->cursed) stripspe(obj);
X! 			else if (sobj->blessed) {
X! 			    if (obj->spe != 3) {
X! 				obj->spe = 3;
X! 				p_glow2(obj,blue);
X! 			    } else {
X! 				explode(obj);
X! 				break;
X! 			    }
X! 			} else {
X! 			    if (obj->spe < 3) {
X! 				obj->spe++;
X! 				p_glow2(obj,blue);
X! 			    } else pline(nothing_happens);
X! 			}
X! 			obj->recharged = 1; /* another recharging disallowed */
X! 		    }
X! 		    else {
X! 			if (sobj->cursed) stripspe(obj);
X! 			else if (sobj->blessed) {
X! 			    if (objects[obj->otyp].bits & NODIR) {
X! 				n = rn1(5,11);
X! 				if (obj->spe < n) obj->spe = n;
X! 				else obj->spe++;
X! 			    }
X! 			    else {
X! 				n = rn1(5,4);
X! 				if (obj->spe < n) obj->spe = n;
X! 				else obj->spe++;
X! 			    }
X! 			    p_glow2(obj,blue);
X! 			} else {
X! 			    obj->spe++;
X! 			    p_glow1(obj);
X! 			}
X! 			break;
X! 		    }
X! 		}
X! 	    }
X  		break;
X  	case SCR_MAGIC_MAPPING:
X  		known = TRUE;
X--- 614,622 ----
X  		}
X  		known = TRUE;
X  		pline("This is a charging scroll.");
X! 		otmp = getobj("0#", "charge");
X! 		if (!otmp) break;
X! 		recharge(otmp, sobj->cursed ? -1 : (sobj->blessed ? 1 : 0));
X  		break;
X  	case SCR_MAGIC_MAPPING:
X  		known = TRUE;
X***************
X*** 589,603 ****
X  		}
X  		break;
X  	case SCR_AMNESIA:
X- 	    {	register int zx, zy;
X- 
X  		known = TRUE;
X! 		for(zx = 0; zx < COLNO; zx++) for(zy = 0; zy < ROWNO; zy++)
X! 		    if(!confused || sobj->cursed || rn2(7))
X! 			if(!cansee(zx,zy))
X! 			    levl[zx][zy].seen = levl[zx][zy].new =
X! 				levl[zx][zy].scrsym = 0;
X! 		docrt();
X  		if (Hallucination) /* Ommmmmm! */
X  			Your("mind releases itself from mundane concerns.");
X  		else if (!strncmp(plname, "Maud", 4))
X--- 633,640 ----
X  		}
X  		break;
X  	case SCR_AMNESIA:
X  		known = TRUE;
X! 		forget( ((!sobj->blessed) << 1) | (!confused || sobj->cursed) );
X  		if (Hallucination) /* Ommmmmm! */
X  			Your("mind releases itself from mundane concerns.");
X  		else if (!strncmp(plname, "Maud", 4))
X***************
X*** 606,616 ****
X  			pline("Who was that Maud person anyway?");
X  		else
X  			pline("Thinking of Maud you forget everything else.");
X- #ifdef SPELLS
X- 		if(!sobj->blessed) losespells();
X- #endif
X  		break;
X- 	    }
X  	case SCR_FIRE:
X  	    {	register int num;
X  		register struct monst *mtmp;
X--- 643,649 ----
X***************
X*** 762,769 ****
X  			pline(thats_enough_tries);
X  			return;
X  		}
X-     pline("What class of monsters do you wish to genocide? [type a letter] ");
X  		do {
X  			getlin(buf);
X  		} while (buf[0]=='\033' || strlen(buf) != 1);
X  		immunecnt = gonecnt = goodcnt = 0;
X--- 795,802 ----
X  			pline(thats_enough_tries);
X  			return;
X  		}
X  		do {
X+     pline("What class of monsters do you wish to genocide? [type a letter] ");
X  			getlin(buf);
X  		} while (buf[0]=='\033' || strlen(buf) != 1);
X  		immunecnt = gonecnt = goodcnt = 0;
X*** src/Old/restore.c	Sun Nov 19 13:09:44 1989
X--- src/restore.c	Sun Nov 19 11:00:40 1989
X***************
X*** 67,72 ****
X--- 67,93 ----
X  	}
X  }
X  
X+ #ifndef NO_SIGNAL
X+ static void
X+ inven_inuse()
X+ /* Things that were marked "in_use" when the game was saved (ex. via the
X+  * infamous "HUP" cheat) get used up here.
X+  */
X+ {
X+ 	register struct obj *otmp, *otmp2;
X+ 
X+ 	for(otmp = invent; otmp; otmp = otmp2) {
X+ 		otmp2 = otmp->nobj;
X+ 		if(otmp->olet != ARMOR_SYM && otmp->olet != WEAPON_SYM
X+ 			&& otmp->otyp != PICK_AXE && otmp->otyp != UNICORN_HORN
X+ 			&& otmp->in_use) {
X+ 			pline("Finishing off %s...", xname(otmp));
X+ 			useup(otmp);
X+ 		}
X+ 	}
X+ }
X+ #endif
X+ 
X  static struct obj *
X  restobjchn(fd, ghostly)
X  register int fd;
X***************
X*** 90,100 ****
X  		else otmp2->nobj = otmp;
X  		mread(fd, (genericptr_t) otmp, (unsigned) xl + sizeof(struct obj));
X  		if(!otmp->o_id) otmp->o_id = flags.ident++;
X- 	/* Things that were marked "in_use" when the game was saved (eg. via
X- 	 * the infamous "HUP" cheat get used up here.
X- 	 */
X- 		if(otmp->olet != ARMOR_SYM && otmp->olet != WEAPON_SYM
X- 			&& otmp->otyp != PICK_AXE && otmp->in_use) useup(otmp);
X  #ifdef TUTTI_FRUTTI
X  		if(ghostly && otmp->otyp == SLIME_MOLD) {
X  			for(oldf=oldfruit; oldf; oldf=oldf->nextf)
X--- 111,116 ----
X***************
X*** 240,246 ****
X--- 256,265 ----
X  #endif /* DECRAINBOW */
X  	flags.IBMBIOS = oldflags.IBMBIOS;
X  #endif
X+ #ifdef TEXTCOLOR
X+ 	flags.use_color = oldflags.use_color;
X  #endif
X+ #endif /* MSDOS */
X  	mread(fd, (genericptr_t) &dlevel, sizeof dlevel);
X  	mread(fd, (genericptr_t) &maxdlevel, sizeof maxdlevel);
X  	mread(fd, (genericptr_t) &moves, sizeof moves);
X***************
X*** 254,260 ****
X  #ifdef REINCARNATION
X  	mread(fd, (genericptr_t) &rogue_level, sizeof rogue_level);
X  	if (dlevel==rogue_level)
X! 		savesyms = showsyms;
X  #endif
X  #ifdef STRONGHOLD
X  	mread(fd, (genericptr_t) &stronghold_level, sizeof stronghold_level);
X--- 273,280 ----
X  #ifdef REINCARNATION
X  	mread(fd, (genericptr_t) &rogue_level, sizeof rogue_level);
X  	if (dlevel==rogue_level)
X! 		(void) memcpy((genericptr_t)savesyms,
X! 			      (genericptr_t)showsyms, sizeof savesyms);
X  #endif
X  #ifdef STRONGHOLD
X  	mread(fd, (genericptr_t) &stronghold_level, sizeof stronghold_level);
X***************
X*** 406,413 ****
X  #ifdef REINCARNATION
X  	/* this can't be done earlier because we need to check the initial
X  	 * showsyms against the one saved in each of the non-rogue levels */
X! 	if (dlevel==rogue_level)
X! 		showsyms = defsyms;
X  #endif
X  	if(u.ustuck) {
X  		register struct monst *mtmp;
X--- 426,437 ----
X  #ifdef REINCARNATION
X  	/* this can't be done earlier because we need to check the initial
X  	 * showsyms against the one saved in each of the non-rogue levels */
X! 	if (dlevel==rogue_level) {
X! 		(void) memcpy((genericptr_t)showsyms,
X! 			      (genericptr_t)defsyms, sizeof showsyms);
X! 		showsyms[S_ndoor] = showsyms[S_vodoor] =
X! 		    showsyms[S_hodoor] = '+';
X! 	}
X  #endif
X  	if(u.ustuck) {
X  		register struct monst *mtmp;
X***************
X*** 430,435 ****
X--- 454,466 ----
X  	for(otmp = fobj; otmp; otmp = otmp->nobj)
X  		if(otmp->owornmask)
X  			setworn(otmp, otmp->owornmask);
X+ #ifndef NO_SIGNAL
X+ 	/* in_use processing must be after:
X+ 	 *  inven has been read so fcobj has been built and freeinv() works
X+ 	 *  current level has been restored so billing information is available
X+ 	 */
X+ 	inven_inuse();
X+ #endif
X  	docrt();
X  	restoring = FALSE;
X  	return(1);
X***************
X*** 451,457 ****
X  	long nhp;
X  	int hpid;
X  	xchar dlvl;
X! 	struct symbols osymbol;
X  	int x, y;
X  	uchar osym, nsym;
X  #ifdef TOS
X--- 482,488 ----
X  	long nhp;
X  	int hpid;
X  	xchar dlvl;
X! 	symbol_array osymbol;
X  	int x, y;
X  	uchar osym, nsym;
X  #ifdef TOS
X***************
X*** 526,534 ****
X  #else
X  	mread(fd, (genericptr_t) levl, sizeof(levl));
X  #endif
X! 	mread(fd, (genericptr_t) &osymbol, sizeof(osymbol));
X! 	if (memcmp((genericptr_t) &osymbol,
X! 		   (genericptr_t) &showsyms, sizeof (struct symbols))
X  #ifdef REINCARNATION
X  		&& dlvl != rogue_level
X  		/* rogue level always uses default syms, and showsyms will still
X--- 557,565 ----
X  #else
X  	mread(fd, (genericptr_t) levl, sizeof(levl));
X  #endif
X! 	mread(fd, (genericptr_t) osymbol, sizeof(osymbol));
X! 	if (memcmp((genericptr_t) osymbol,
X! 		   (genericptr_t) showsyms, sizeof (showsyms))
X  #ifdef REINCARNATION
X  		&& dlvl != rogue_level
X  		/* rogue level always uses default syms, and showsyms will still
X***************
X*** 543,636 ****
X  				switch (levl[x][y].typ) {
X  				case STONE:
X  				case SCORR:
X! 					if (osym == osymbol.stone)
X! 						nsym = showsyms.stone;
X  					break;
X  				case ROOM:
X  #ifdef STRONGHOLD
X  				case DRAWBRIDGE_DOWN:
X  #endif /* STRONGHOLD /**/
X! 					if (osym == osymbol.room)
X! 						nsym = showsyms.room;
X  					break;
X  				case DOOR:
X! 					if (osym == osymbol.door)
X! 						nsym = showsyms.door;
X  					break;
X  				case CORR:
X! 					if (osym == osymbol.corr)
X! 						nsym = showsyms.corr;
X  					break;
X  				case VWALL:
X! 					if (osym == osymbol.vwall)
X! 						nsym = showsyms.vwall;
X  #ifdef STRONGHOLD
X! 					else if (osym == osymbol.dbvwall)
X! 						nsym = showsyms.dbvwall;
X  #endif
X  					break;
X  				case HWALL:
X! 					if (osym == osymbol.hwall)
X! 						nsym = showsyms.hwall;
X  #ifdef STRONGHOLD
X! 					else if (osym == osymbol.dbhwall)
X! 						nsym = showsyms.dbhwall;
X  #endif
X  					break;
X  				case TLCORNER:
X! 					if (osym == osymbol.tlcorn)
X! 						nsym = showsyms.tlcorn;
X  					break;
X  				case TRCORNER:
X! 					if (osym == osymbol.trcorn)
X! 						nsym = showsyms.trcorn;
X  					break;
X  				case BLCORNER:
X! 					if (osym == osymbol.blcorn)
X! 						nsym = showsyms.blcorn;
X  					break;
X  				case BRCORNER:
X! 					if (osym == osymbol.brcorn)
X! 						nsym = showsyms.brcorn;
X  					break;
X  				case SDOOR:
X! 					if (osym == osymbol.vwall)
X! 						nsym = showsyms.vwall;
X! 					else if (osym == osymbol.hwall)
X! 						nsym = showsyms.hwall;
X  					break;
X  				case CROSSWALL:
X! 					if (osym == osymbol.crwall)
X! 						nsym = showsyms.crwall;
X  					break;
X  				case TUWALL:
X! 					if (osym == osymbol.tuwall)
X! 						nsym = showsyms.tuwall;
X  					break;
X  				case TDWALL:
X! 					if (osym == osymbol.tdwall)
X! 						nsym = showsyms.tdwall;
X  					break;
X  				case TLWALL:
X! 					if (osym == osymbol.tlwall)
X! 						nsym = showsyms.tlwall;
X  					break;
X  				case TRWALL:
X! 					if (osym == osymbol.trwall)
X! 						nsym = showsyms.trwall;
X  					break;
X  				case STAIRS:
X! 					if (osym == osymbol.upstair)
X! 						nsym = showsyms.upstair;
X! 					else if (osym == osymbol.dnstair)
X! 						nsym = showsyms.dnstair;
X  					break;
X  #ifdef STRONGHOLD
X  				case LADDER:
X! 					if (osym == osymbol.upladder)
X! 						nsym = showsyms.upladder;
X! 					else if (osym == osymbol.dnladder)
X! 						nsym = showsyms.dnladder;
X  					break;
X  #endif /* STRONGHOLD /**/
X  				case POOL:
X--- 574,673 ----
X  				switch (levl[x][y].typ) {
X  				case STONE:
X  				case SCORR:
X! 					if (osym == osymbol[S_stone])
X! 						nsym = showsyms[S_stone];
X  					break;
X  				case ROOM:
X  #ifdef STRONGHOLD
X  				case DRAWBRIDGE_DOWN:
X  #endif /* STRONGHOLD /**/
X! 					if (osym == osymbol[S_room])
X! 						nsym = showsyms[S_room];
X  					break;
X  				case DOOR:
X! 					if (osym == osymbol[S_ndoor])
X! 						nsym = showsyms[S_ndoor];
X! 					else if (osym == osymbol[S_vodoor])
X! 						nsym = showsyms[S_vodoor];
X! 					else if (osym == osymbol[S_hodoor])
X! 						nsym = showsyms[S_hodoor];
X! 					else if (osym == osymbol[S_cdoor])
X! 						nsym = showsyms[S_cdoor];
X  					break;
X  				case CORR:
X! 					if (osym == osymbol[S_corr])
X! 						nsym = showsyms[S_corr];
X  					break;
X  				case VWALL:
X! 					if (osym == osymbol[S_vwall])
X! 						nsym = showsyms[S_vwall];
X  #ifdef STRONGHOLD
X! 					else if (osym == osymbol[S_dbvwall])
X! 						nsym = showsyms[S_dbvwall];
X  #endif
X  					break;
X  				case HWALL:
X! 					if (osym == osymbol[S_hwall])
X! 						nsym = showsyms[S_hwall];
X  #ifdef STRONGHOLD
X! 					else if (osym == osymbol[S_dbhwall])
X! 						nsym = showsyms[S_dbhwall];
X  #endif
X  					break;
X  				case TLCORNER:
X! 					if (osym == osymbol[S_tlcorn])
X! 						nsym = showsyms[S_tlcorn];
X  					break;
X  				case TRCORNER:
X! 					if (osym == osymbol[S_trcorn])
X! 						nsym = showsyms[S_trcorn];
X  					break;
X  				case BLCORNER:
X! 					if (osym == osymbol[S_blcorn])
X! 						nsym = showsyms[S_blcorn];
X  					break;
X  				case BRCORNER:
X! 					if (osym == osymbol[S_brcorn])
X! 						nsym = showsyms[S_brcorn];
X  					break;
X  				case SDOOR:
X! 					if (osym == osymbol[S_vwall])
X! 						nsym = showsyms[S_vwall];
X! 					else if (osym == osymbol[S_hwall])
X! 						nsym = showsyms[S_hwall];
X  					break;
X  				case CROSSWALL:
X! 					if (osym == osymbol[S_crwall])
X! 						nsym = showsyms[S_crwall];
X  					break;
X  				case TUWALL:
X! 					if (osym == osymbol[S_tuwall])
X! 						nsym = showsyms[S_tuwall];
X  					break;
X  				case TDWALL:
X! 					if (osym == osymbol[S_tdwall])
X! 						nsym = showsyms[S_tdwall];
X  					break;
X  				case TLWALL:
X! 					if (osym == osymbol[S_tlwall])
X! 						nsym = showsyms[S_tlwall];
X  					break;
X  				case TRWALL:
X! 					if (osym == osymbol[S_trwall])
X! 						nsym = showsyms[S_trwall];
X  					break;
X  				case STAIRS:
X! 					if (osym == osymbol[S_upstair])
X! 						nsym = showsyms[S_upstair];
X! 					else if (osym == osymbol[S_dnstair])
X! 						nsym = showsyms[S_dnstair];
X  					break;
X  #ifdef STRONGHOLD
X  				case LADDER:
X! 					if (osym == osymbol[S_upladder])
X! 						nsym = showsyms[S_upladder];
X! 					else if (osym == osymbol[S_dnladder])
X! 						nsym = showsyms[S_dnladder];
X  					break;
X  #endif /* STRONGHOLD /**/
X  				case POOL:
X***************
X*** 638,668 ****
X  #ifdef STRONGHOLD
X  				case DRAWBRIDGE_UP:
X  #endif /* STRONGHOLD /**/
X! 					if (osym == osymbol.pool)
X! 						nsym = showsyms.pool;
X  					break;
X  #ifdef FOUNTAINS
X  				case FOUNTAIN:
X! 					if (osym == osymbol.fountain)
X! 						nsym = showsyms.fountain;
X  					break;
X  #endif /* FOUNTAINS /**/
X  #ifdef THRONES
X  				case THRONE:
X! 					if (osym == osymbol.throne)
X! 						nsym = showsyms.throne;
X  					break;
X  #endif /* THRONES /**/
X  #ifdef SINKS
X  				case SINK:
X! 					if (osym == osymbol.sink)
X! 						nsym = showsyms.sink;
X  					break;
X  #endif /* SINKS /**/
X  #ifdef ALTARS
X  				case ALTAR:
X! 					if (osym == osymbol.altar)
X! 						nsym = showsyms.altar;
X  					break;
X  #endif /* ALTARS /**/
X  				default:
X--- 675,705 ----
X  #ifdef STRONGHOLD
X  				case DRAWBRIDGE_UP:
X  #endif /* STRONGHOLD /**/
X! 					if (osym == osymbol[S_pool])
X! 						nsym = showsyms[S_pool];
X  					break;
X  #ifdef FOUNTAINS
X  				case FOUNTAIN:
X! 					if (osym == osymbol[S_fountain])
X! 						nsym = showsyms[S_fountain];
X  					break;
X  #endif /* FOUNTAINS /**/
X  #ifdef THRONES
X  				case THRONE:
X! 					if (osym == osymbol[S_throne])
X! 						nsym = showsyms[S_throne];
X  					break;
X  #endif /* THRONES /**/
X  #ifdef SINKS
X  				case SINK:
X! 					if (osym == osymbol[S_sink])
X! 						nsym = showsyms[S_sink];
X  					break;
X  #endif /* SINKS /**/
X  #ifdef ALTARS
X  				case ALTAR:
X! 					if (osym == osymbol[S_altar])
X! 						nsym = showsyms[S_altar];
X  					break;
X  #endif /* ALTARS /**/
X  				default:
X***************
X*** 689,695 ****
X  	fmon = restmonchn(fd, ghostly);
X  
X  	/* regenerate animals while on another level */
X! 	{ long tmoves = (moves > omoves) ? moves-omoves : 0;
X  	  register struct monst *mtmp2;
X  
X  	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X--- 726,732 ----
X  	fmon = restmonchn(fd, ghostly);
X  
X  	/* regenerate animals while on another level */
X! 	{ long tmoves = (monstermoves > omoves) ? monstermoves-omoves : 0;
X  	  register struct monst *mtmp2;
X  
X  	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X*** src/Old/rip.c	Sun Nov 19 13:10:20 1989
X--- src/rip.c	Tue Oct 31 19:27:05 1989
X***************
X*** 3,8 ****
X--- 3,9 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X+ #include <ctype.h>
X  
X  static char *rip[] = {
X  "                       ----------",
X***************
X*** 41,58 ****
X  	register int x, y;
X  
X  	cls();
X! 	Sprintf(buf,"%s", plname);
X  	buf[16] = 0;
X  	center(6, buf);
X! 	Sprintf(buf, "%ld AU", u.ugold);
X  	center(7, buf);
X! 	Sprintf(buf, "killed by%s",
X! 		!strncmp(killer, "the ", 4) ? "" :
X! 		(!strcmp(eos(killer)-4, "tion") && *(eos(killer)-5)!='o') ? "" :
X! 		!strcmp(killer, "contaminated water") ? "" :
X! 		!strncmp(killer, "Mr.", 3) ? "" :
X! 		!strncmp(killer, "Ms.", 3) ? "" :
X! 		index(vowels, *killer) ? " an" : " a");
X  	center(8, buf);
X  	Strcpy(buf, killer);
X  	if(strlen(buf) > 16) {
X--- 42,57 ----
X  	register int x, y;
X  
X  	cls();
X! 	Sprintf(buf, "%s", plname);
X  	buf[16] = 0;
X  	center(6, buf);
X! 	Sprintf(buf, "%ld Au", u.ugold);
X  	center(7, buf);
X! 	Strcpy(buf, "killed by");
X! 	if (islower(*killer) && strncmp(killer, "the ", 4) &&
X! 	    (strcmp(eos(killer)-4, "tion") || *(eos(killer)-5) == 'o') &&
X! 	    strcmp(killer, "contaminated water"))
X! 		Strcat(buf, index(vowels, *killer) ? " an" : " a");
X  	center(8, buf);
X  	Strcpy(buf, killer);
X  	if(strlen(buf) > 16) {
X*** src/Old/rumors.c	Sun Nov 19 13:10:43 1989
X--- src/rumors.c	Tue Nov 14 20:31:55 1989
X***************
X*** 113,119 ****
X  #else
X  # ifdef MACOS
X  	if(rumors = fopen(RUMORFILE, "r"))
X! 		rumors = openFile(RUMORFILE);
X  	if (rumors) {
X  # else
X  	if(rumors = fopen(RUMORFILE, "r")) {
X--- 113,119 ----
X  #else
X  # ifdef MACOS
X  	if(rumors = fopen(RUMORFILE, "r"))
X! 		rumors = openFile(RUMORFILE, "r");
X  	if (rumors) {
X  # else
X  	if(rumors = fopen(RUMORFILE, "r")) {
X***************
X*** 177,183 ****
X  #else
X  # ifdef MACOS
X  	if(oracles = fopen(ORACLEFILE, "r"))
X! 		oracles = openFile(ORACLEFILE);
X  	if (oracles) {
X  # else
X  	if(oracles = fopen(ORACLEFILE, "r")) {
X--- 177,183 ----
X  #else
X  # ifdef MACOS
X  	if(oracles = fopen(ORACLEFILE, "r"))
X! 		oracles = openFile(ORACLEFILE, "r");
X  	if (oracles) {
X  # else
X  	if(oracles = fopen(ORACLEFILE, "r")) {
X*** src/Old/save.c	Sun Nov 19 13:10:59 1989
X--- src/save.c	Sun Nov 19 10:59:38 1989
X***************
X*** 433,443 ****
X  		/* if a game is saved off the rogue level, the usual showsyms
X  		 * will be written out for the rogue level too, but they will
X  		 * be ignored on restore so it doesn't matter */
X! 		bwrite(fd, (genericptr_t) &savesyms, sizeof(struct symbols));
X  	else
X  #endif
X! 		bwrite(fd, (genericptr_t) &showsyms, sizeof(struct symbols));
X! 	bwrite(fd,(genericptr_t) &monstermoves,sizeof(long));
X  	bwrite(fd,(genericptr_t) &xupstair,sizeof(xupstair));
X  	bwrite(fd,(genericptr_t) &yupstair,sizeof(yupstair));
X  	bwrite(fd,(genericptr_t) &xdnstair,sizeof(xdnstair));
X--- 433,443 ----
X  		/* if a game is saved off the rogue level, the usual showsyms
X  		 * will be written out for the rogue level too, but they will
X  		 * be ignored on restore so it doesn't matter */
X! 		bwrite(fd, (genericptr_t) savesyms, sizeof savesyms);
X  	else
X  #endif
X! 		bwrite(fd, (genericptr_t) showsyms, sizeof showsyms);
X! 	bwrite(fd,(genericptr_t) &monstermoves,sizeof(monstermoves));
X  	bwrite(fd,(genericptr_t) &xupstair,sizeof(xupstair));
X  	bwrite(fd,(genericptr_t) &yupstair,sizeof(yupstair));
X  	bwrite(fd,(genericptr_t) &xdnstair,sizeof(xdnstair));
X*** src/Old/shk.c	Sun Nov 19 13:11:37 1989
X--- src/shk.c	Fri Nov 17 19:32:17 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)shk.c	3.0	89/02/10
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)shk.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 9,15 ****
X  #include "eshk.h"
X  
X  #ifdef KOPS
X! static int makekops P((coord *));
X  static void kops_gone();
X  #endif /* KOPS */
X  
X--- 9,15 ----
X  #include "eshk.h"
X  
X  #ifdef KOPS
X! static int FDECL(makekops, (coord *));
X  static void kops_gone();
X  #endif /* KOPS */
X  
X***************
X*** 25,33 ****
X  				/* only accessed here and by save & restore */
X  static long int total;		/* filled by addupbill() */
X  static long int followmsg;	/* last time of follow message */
X! static void setpaid(), findshk P((int));
X! static int dopayobj P((struct bill_x *)), getprice P((struct obj *));
X! static struct obj *bp_to_obj P((struct bill_x *));
X  
X  /*
X  	invariants: obj->unpaid iff onbill(obj) [unless bp->useup]
X--- 25,33 ----
X  				/* only accessed here and by save & restore */
X  static long int total;		/* filled by addupbill() */
X  static long int followmsg;	/* last time of follow message */
X! static void setpaid(), FDECL(findshk, (int));
X! static int FDECL(dopayobj, (struct bill_x *)), FDECL(getprice, (struct obj *));
X! static struct obj *FDECL(bp_to_obj, (struct bill_x *));
X  
X  /*
X  	invariants: obj->unpaid iff onbill(obj) [unless bp->useup]
X***************
X*** 292,304 ****
X  }
X  
X  boolean
X! tended_shop(roomno)
X! register int roomno;
X  {
X  	register struct monst *mtmp;
X  
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 	    if(mtmp->isshk && ESHK(mtmp)->shoproom == roomno
X  		&& inhishop(mtmp)) return(TRUE);
X  	return(FALSE);
X  }
X--- 292,304 ----
X  }
X  
X  boolean
X! tended_shop(sroom)
X! struct mkroom *sroom;
X  {
X  	register struct monst *mtmp;
X  
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 	    if(mtmp->isshk && &rooms[ESHK(mtmp)->shoproom] == sroom
X  		&& inhishop(mtmp)) return(TRUE);
X  	return(FALSE);
X  }
X***************
X*** 945,951 ****
X  	ltmp = (long) getprice(obj) * (long) obj->quan;
X  	if(ESHK(shopkeeper)->billct == BILLSZ
X  	   || !saleable(rooms[ESHK(shopkeeper)->shoproom].rtype-SHOPBASE, obj)
X! 	   || obj->olet == BALL_SYM || ltmp == 0L) {
X  		pline("%s seems not interested.", Monnam(shopkeeper));
X  		obj->no_charge = 1;
X  		return;
X--- 945,952 ----
X  	ltmp = (long) getprice(obj) * (long) obj->quan;
X  	if(ESHK(shopkeeper)->billct == BILLSZ
X  	   || !saleable(rooms[ESHK(shopkeeper)->shoproom].rtype-SHOPBASE, obj)
X! 	   || obj->olet == BALL_SYM || ltmp == 0L
X! 	   || (obj->olet == FOOD_SYM && obj->oeaten)) {
X  		pline("%s seems not interested.", Monnam(shopkeeper));
X  		obj->no_charge = 1;
X  		return;
X***************
X*** 1114,1120 ****
X  	omx = shkp->mx;
X  	omy = shkp->my;
X  
X! 	if((udist = dist(omx,omy)) < 3) {
X  		if(ANGRY(shkp)) {
X  			if(Displaced)
X  			  Your("displaced image doesn't fool %s!",
X--- 1115,1122 ----
X  	omx = shkp->mx;
X  	omy = shkp->my;
X  
X! 	if((udist = dist(omx,omy)) < 3 &&
X! 	   (shkp->data != &mons[PM_GRID_BUG] || (omx==u.ux || omy==u.uy))) {
X  		if(ANGRY(shkp)) {
X  			if(Displaced)
X  			  Your("displaced image doesn't fool %s!",
X***************
X*** 1247,1253 ****
X  	    pline("\"%s, do not damage the floor here!\"",
X  			flags.female ? "Madam" : "Sir");
X  	if (pl_character[0] == 'K') adjalign(-sgn(u.ualigntyp));
X!     } else if(!um_dist(shopkeeper->mx, shopkeeper->my, 5)) {
X  	register struct obj *obj, *obj2;
X  
X  	if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X--- 1249,1256 ----
X  	    pline("\"%s, do not damage the floor here!\"",
X  			flags.female ? "Madam" : "Sir");
X  	if (pl_character[0] == 'K') adjalign(-sgn(u.ualigntyp));
X!     } else if(!um_dist(shopkeeper->mx, shopkeeper->my, 5) &&
X! 	      !shopkeeper->msleep && !shopkeeper->mfroz) {
X  	register struct obj *obj, *obj2;
X  
X  	if(dist(shopkeeper->mx, shopkeeper->my) > 2) {
X***************
X*** 1346,1353 ****
X  	/* if he's not in his shop.. */
X  	if(!in_shop(shopkeeper->mx ,shopkeeper->my)) return;
X  
X! 	/* if a !shopkeeper shows up at the door, move him */
X! 	if(MON_AT(x, y) && (mtmp = m_at(x, y)) != shopkeeper) {
X  		if(flags.soundok) {
X  		    You("hear an angry voice: \"Out of my way, scum!\"");
X  		    (void) fflush(stdout);
X--- 1349,1358 ----
X  	/* if he's not in his shop.. */
X  	if(!in_shop(shopkeeper->mx ,shopkeeper->my)) return;
X  
X! 	if(in_shop(u.ux, u.uy)) mnexto(shopkeeper);
X! 	else {
X! 	    /* if a !shopkeeper shows up at the door, move him */
X! 	    if(MON_AT(x, y) && (mtmp = m_at(x, y)) != shopkeeper) {
X  		if(flags.soundok) {
X  		    You("hear an angry voice: \"Out of my way, scum!\"");
X  		    (void) fflush(stdout);
X***************
X*** 1359,1372 ****
X  #endif
X  		}
X  		mnearto(mtmp, x, y, FALSE);
X! 	}
X  
X! 	/* make shk show up at the door */
X! 	remove_monster(shopkeeper->mx, shopkeeper->my);
X! 	place_monster(shopkeeper, x, y);
X! 	pmon(shopkeeper);
X  
X! 	damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X  
X  	if(um_dist(x, y, 1) || u.ugold < (long) damage || !rn2(50)) {
X  		if(um_dist(x, y, 1))
X--- 1364,1379 ----
X  #endif
X  		}
X  		mnearto(mtmp, x, y, FALSE);
X! 	    }
X  
X! 	    /* make shk show up at the door */
X! 	    remove_monster(shopkeeper->mx, shopkeeper->my);
X! 	    place_monster(shopkeeper, x, y);
X! 	    pmon(shopkeeper);
X! 	}
X  
X! 	if(!strcmp(dmgstr, "destroy")) damage = 400;
X! 	else damage = (ACURR(A_STR) > 18) ? 400 : 20 * ACURR(A_STR);
X  
X  	if(um_dist(x, y, 1) || u.ugold < (long) damage || !rn2(50)) {
X  		if(um_dist(x, y, 1))
X*** src/Old/shknam.c	Sun Nov 19 13:12:29 1989
X--- src/shknam.c	Wed Nov  8 22:57:41 1989
X***************
X*** 185,193 ****
X  {
X  	register struct monst *mtmp;
X  	int atype;
X  
X! 	if (rn2(100) < dlevel && !MON_AT(sx, sy) &&
X! 				(mtmp=makemon(mkclass(S_MIMIC),sx,sy))) {
X  		mtmp->mimic = 1;
X  		/* note: makemon will set the mimic symbol to a shop item */
X  		if (rn2(10) >= dlevel) mtmp->mappearance = S_MIMIC_DEF;
X--- 185,194 ----
X  {
X  	register struct monst *mtmp;
X  	int atype;
X+ 	struct permonst *ptr;
X  
X! 	if (rn2(100) < dlevel && !MON_AT(sx, sy) && (ptr = mkclass(S_MIMIC)) &&
X! 				(mtmp=makemon(ptr,sx,sy))) {
X  		mtmp->mimic = 1;
X  		/* note: makemon will set the mimic symbol to a shop item */
X  		if (rn2(10) >= dlevel) mtmp->mappearance = S_MIMIC_DEF;
X***************
X*** 314,321 ****
X      for(sx = sroom->lx - 1; sx <= sroom->hx + 1; sx++)
X  	for(sy = sroom->ly - 1; sy <= sroom->hy + 1; sy++) {
X  	    if(IS_DOOR(levl[sx][sy].typ))
X! 		if (levl[sx][sy].doormask == D_NODOOR)
X! 		    levl[sx][sy].doormask = D_ISOPEN;
X      }
X  
X      for(sx = sroom->lx; sx <= sroom->hx; sx++)
X--- 315,324 ----
X      for(sx = sroom->lx - 1; sx <= sroom->hx + 1; sx++)
X  	for(sy = sroom->ly - 1; sy <= sroom->hy + 1; sy++) {
X  	    if(IS_DOOR(levl[sx][sy].typ))
X! 		if (levl[sx][sy].doormask == D_NODOOR) {
X! 		  levl[sx][sy].doormask = D_ISOPEN;
X! 		  mnewsym(sx,sy);
X! 		}
X      }
X  
X      for(sx = sroom->lx; sx <= sroom->hx; sx++)
X*** src/Old/sounds.c	Sun Nov 19 13:12:59 1989
X--- src/sounds.c	Sun Nov  5 16:16:26 1989
X***************
X*** 56,62 ****
X  		You("seem to hear dishes being washed!");
X  		break;
X  	}
X!     if (!rn2(300)) {
X  	roomtype = OROOM;
X  	for (sroom = &rooms[0]; ; sroom++) {	/* find any special room */
X  	    if (sroom->hx < 0) break;		/* no more rooms */
X--- 56,62 ----
X  		You("seem to hear dishes being washed!");
X  		break;
X  	}
X!     if (!rn2(200)) {
X  	roomtype = OROOM;
X  	for (sroom = &rooms[0]; ; sroom++) {	/* find any special room */
X  	    if (sroom->hx < 0) break;		/* no more rooms */
X***************
X*** 179,185 ****
X  		}
X  		break;
X  	    case SHOPBASE:
X! 		if(tended_shop(croomno))
X  		  switch (rn2(2)+hallu) {
X  		    case 0:
X  			You("hear the chime of a cash register.");
X--- 179,185 ----
X  		}
X  		break;
X  	    case SHOPBASE:
X! 		if(tended_shop(sroom))
X  		  switch (rn2(2)+hallu) {
X  		    case 0:
X  			You("hear the chime of a cash register.");
X***************
X*** 364,369 ****
X--- 364,372 ----
X  	case MS_GURGLE:
X  	    kludge("%s gurgles.", Monnam(mtmp));
X  	    break;
X+ 	case MS_BURBLE:
X+ 	    kludge("%s burbles.", Monnam(mtmp));
X+ 	    break;
X  	case MS_SHRIEK:
X  	    kludge("%s shrieks.", Monnam(mtmp));
X  	    aggravate();
X***************
X*** 472,478 ****
X  		    kludge("%s laughs.", Monnam(mtmp));
X  	    }
X  	    break;
X! # ifdef HARD
X  	case MS_BRIBE:
X  	    if (mtmp->mpeaceful && !mtmp->mtame) {
X  		(void) demon_talk(mtmp);
X--- 475,481 ----
X  		    kludge("%s laughs.", Monnam(mtmp));
X  	    }
X  	    break;
X! # ifdef INFERNO
X  	case MS_BRIBE:
X  	    if (mtmp->mpeaceful && !mtmp->mtame) {
X  		(void) demon_talk(mtmp);
X*** src/Old/sp_lev.c	Sun Nov 19 13:13:23 1989
X--- src/sp_lev.c	Tue Nov 14 20:33:14 1989
X***************
X*** 14,20 ****
X  #ifdef STRONGHOLD
X  #include "sp_lev.h"
X  
X! #if defined(MSDOS) && !defined(AMIGA)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X--- 14,20 ----
X  #ifdef STRONGHOLD
X  #include "sp_lev.h"
X  
X! #if defined(MSDOS) || defined(MACOS) && !defined(AMIGA)
X  # define RDMODE "rb"
X  #else
X  # define RDMODE "r"
X***************
X*** 29,35 ****
X--- 29,39 ----
X  static walk walklist[50];
X  extern int x_maze_max, y_maze_max;
X  
X+ #ifdef MACOS
X+ char **Map;
X+ #else
X  static char Map[COLNO][ROWNO];
X+ #endif
X  static char robjects[10], rloc_x[10], rloc_y[10], rmonst[10],
X  	ralign[3] = { A_CHAOS, A_NEUTRAL, A_LAW };
X  static xchar xstart, ystart, xsize, ysize;
X***************
X*** 215,221 ****
X      object  tmpobj;
X      drawbridge tmpdb;
X      walk    tmpwalk;
X!     dig     tmpdig;
X      lad     tmplad;
X  #ifdef ALTARS
X      altar   tmpaltar;
X--- 219,225 ----
X      object  tmpobj;
X      drawbridge tmpdb;
X      walk    tmpwalk;
X!     digpos  tmpdig;
X      lad     tmplad;
X  #ifdef ALTARS
X      altar   tmpaltar;
X***************
X*** 327,332 ****
X--- 331,337 ----
X  
X  		get_location(&x, &y);
X  		levl[x][y].doormask = typ;
X+ 		mnewsym(x,y);
X  
X  		/* Now the complicated part, list it with each subroom */
X  		/* The dog move and mail daemon routines use this */
X***************
X*** 581,586 ****
X--- 586,595 ----
X  	fd = fopen(tmp, RDMODE);
X  #else
X  	fd = fopen(name, RDMODE);
X+ # ifdef MACOS
X+ 	if (!fd)
X+ 		fd = openFile(name, RDMODE);
X+ # endif
X  #endif
X  #ifdef OS2_CODEVIEW
X  	}
X*** src/Old/spell.c	Sun Nov 19 13:13:46 1989
X--- src/spell.c	Fri Nov 17 19:33:22 1989
X***************
X*** 77,83 ****
X  	return;
X  }
X  
X! static int
X  learn()
X  {
X  	register int	i;
X--- 77,86 ----
X  	return;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  learn()
X  {
X  	register int	i;
X***************
X*** 382,388 ****
X  		healup(0, 0, 0, 1);
X  		break;
X  	case SPE_CURE_SICKNESS:
X! 		You("are no longer ill.");
X  		healup(0, 0, 1, 0);
X  		break;
X  	case SPE_EXTRA_HEALING:
X--- 385,391 ----
X  		healup(0, 0, 0, 1);
X  		break;
X  	case SPE_CURE_SICKNESS:
X! 		if (Sick) You("are no longer ill.");
X  		healup(0, 0, 1, 0);
X  		break;
X  	case SPE_EXTRA_HEALING:
X*** src/Old/steal.c	Sun Nov 19 13:14:07 1989
X--- src/steal.c	Sun Nov 12 12:02:10 1989
X***************
X*** 61,67 ****
X  unsigned int stealoid;		/* object to be stolen */
X  unsigned int stealmid;		/* monster doing the stealing */
X  
X! static int
X  stealarm(){
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X--- 61,70 ----
X  unsigned int stealoid;		/* object to be stolen */
X  unsigned int stealmid;		/* monster doing the stealing */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  stealarm(){
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X***************
X*** 83,88 ****
X--- 86,92 ----
X  }
X  
X  /* Returns 1 when something was stolen (or at least, when N should flee now)
X+  * Returns -1 if the monster died in the attempt
X   * Avoid stealing the object stealoid
X   */
X  int
X***************
X*** 94,100 ****
X  	register int named = 0;
X  
X  	/* the following is true if successful on first of two attacks. */
X! 	if(dist(mtmp->mx, mtmp->my) > 3) return(0);
X  
X  	if(!invent){
X  	    /* Not even a thousand men in armor can strip a naked man. */
X--- 98,104 ----
X  	register int named = 0;
X  
X  	/* the following is true if successful on first of two attacks. */
X! 	if(!monnear(mtmp, u.ux, u.uy)) return(0);
X  
X  	if(!invent){
X  	    /* Not even a thousand men in armor can strip a naked man. */
X***************
X*** 125,132 ****
X  		impossible("Steal fails!");
X  		return(0);
X  	}
X  	/* can't steal armor while wearing cloak - so steal the cloak. */
X! 	if(otmp == uarm && uarmc) otmp = uarmc;
X  #ifdef SHIRT
X  	else if(otmp == uarmu && uarmc) otmp = uarmc;
X  	else if(otmp == uarmu && uarm) otmp = uarm;
X--- 129,139 ----
X  		impossible("Steal fails!");
X  		return(0);
X  	}
X+ 	/* can't steal gloves while wielding - so steal the wielded item. */
X+ 	if (otmp == uarmg && uwep)
X+ 	    otmp = uwep;
X  	/* can't steal armor while wearing cloak - so steal the cloak. */
X! 	else if(otmp == uarm && uarmc) otmp = uarmc;
X  #ifdef SHIRT
X  	else if(otmp == uarmu && uarmc) otmp = uarmc;
X  	else if(otmp == uarmu && uarm) otmp = uarm;
X***************
X*** 150,155 ****
X--- 157,165 ----
X  			Ring_gone(otmp);
X  			break;
X  		case ARMOR_SYM:
X+ 			/* Stop putting on armor which has been stolen. */
X+ 			if (donning(otmp))
X+ 			    afternmv = 0;
X  			if(multi < 0 || otmp == uarms){
X  			  if (otmp == uarm)  (void) Armor_off();
X  			  else if (otmp == uarmc) (void) Cloak_off();
X***************
X*** 209,214 ****
X--- 219,231 ----
X  	freeinv(otmp);
X  	pline("%s stole %s.", named ? "She" : Monnam(mtmp), doname(otmp));
X  	mpickobj(mtmp,otmp);
X+ 	if (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE
X+ 	    && !resists_ston(mtmp->data)) {
X+ 	    pline("%s turns to stone.", Monnam(mtmp));
X+ 	    stoned = TRUE;
X+ 	    xkilled(mtmp, 0);
X+ 	    return -1;
X+ 	}
X  	return((multi < 0) ? 0 : 1);
X  }
X  
X*** src/Old/termcap.c	Sun Nov 19 13:14:24 1989
X--- src/termcap.c	Fri Nov 17 19:30:12 1989
X***************
X*** 8,18 ****
X  
X  #include <ctype.h>	/* for isdigit() */
X  
X! #ifndef MSDOS
X! # ifndef MACOS
X! # define TERMLIB	/* include termcap code */
X! # endif
X! #endif
X  
X  #if !defined(SYSV) || defined(TOS) || defined(UNIXPC)
X  # ifndef LINT
X--- 8,14 ----
X  
X  #include <ctype.h>	/* for isdigit() */
X  
X! #include "termcap.h"
X  
X  #if !defined(SYSV) || defined(TOS) || defined(UNIXPC)
X  # ifndef LINT
X***************
X*** 23,28 ****
X--- 19,29 ----
X  short	ospeed = 0;	/* gets around "not defined" error message */
X  #endif
X  
X+ #ifdef ASCIIGRAPH
X+   boolean IBMgraphics = FALSE;
X+ #endif
X+ 
X+ 
X  #ifdef MICROPORT_286_BUG
X  #define Tgetstr(key) (tgetstr(key,tbuf))
X  #else
X***************
X*** 81,96 ****
X  	term = getenv("TERM");
X  #endif
X  	/* Set the default map symbols */
X! 	(void) memcpy((genericptr_t) &showsyms, 
X! 		(genericptr_t) &defsyms, sizeof(struct symbols));
X! 
X! #if !defined(AMIGA) && !defined(TOS) && !defined(MACOS)
X! # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X! #  define IBMXASCII
X! # endif
X! #endif
X  
X! #ifdef IBMXASCII
X  	/*
X  	 * If we're on an IBM box, default to the nice IBM Extended ASCII
X  	 * line-drawing characters (codepage 437).
X--- 82,91 ----
X  	term = getenv("TERM");
X  #endif
X  	/* Set the default map symbols */
X! 	(void) memcpy((genericptr_t) showsyms, 
X! 		(genericptr_t) defsyms, sizeof showsyms);
X  
X! #ifdef ASCIIGRAPH
X  	/*
X  	 * If we're on an IBM box, default to the nice IBM Extended ASCII
X  	 * line-drawing characters (codepage 437).
X***************
X*** 103,135 ****
X  	 * characters.
X  	 */
X  # if !defined(MSDOS) || defined(DECRAINBOW) || defined(OS2)
X  	if (strncmp("AT", term, 2) == 0)
X  # endif
X  	{
X! 	    showsyms.vwall = 0xb3;	/* meta-3, vertical rule */
X! 	    showsyms.hwall = 0xc4;	/* meta-D, horizontal rule */
X! 	    showsyms.tlcorn = 0xda;	/* meta-Z, top left corner */
X! 	    showsyms.trcorn = 0xbf;	/* meta-?, top right corner */
X! 	    showsyms.blcorn = 0xc0;	/* meta-@, bottom left */
X! 	    showsyms.brcorn = 0xd9;	/* meta-Y, bottom right */
X! 	    showsyms.crwall = 0xc5;	/* meta-E, cross */
X! 	    showsyms.tuwall = 0xc1;	/* meta-A, T up */
X! 	    showsyms.tdwall = 0xc2;	/* meta-B, T down */
X! 	    showsyms.tlwall = 0xb4;	/* meta-4, T left */
X! 	    showsyms.trwall = 0xc3;	/* meta-C, T right */
X! 	    showsyms.vbeam = 0xb3;	/* meta-3, vertical rule */
X! 	    showsyms.hbeam = 0xc4;	/* meta-D, horizontal rule */
X! 	    showsyms.room = 0xfa;	/* meta-z, centered dot */
X! 	    showsyms.pool = 0xf7;	/* meta-w, approx. equals */
X  	}
X! #endif /* IBMXASCII */
X! #undef IBMXASCII
X  
X  #ifdef TERMLIB
X  	if(!term)
X  #endif
X  #if defined(TOS) && defined(__GNUC__) && defined(TERMLIB)
X! 		term = "st52";		/* library has a default */
X  #else
X  # ifdef MACOS
X  	/* dummy termcap for the Mac */
X--- 98,135 ----
X  	 * characters.
X  	 */
X  # if !defined(MSDOS) || defined(DECRAINBOW) || defined(OS2)
X+ #  ifdef TERMLIB
X  	if (strncmp("AT", term, 2) == 0)
X+ #  endif
X  # endif
X  	{
X! 	    IBMgraphics = TRUE;
X! 	    showsyms[S_vwall] = 0xb3;	/* meta-3, vertical rule */
X! 	    showsyms[S_hodoor] = 0xb3;
X! 	    showsyms[S_hwall] = 0xc4;	/* meta-D, horizontal rule */
X! 	    showsyms[S_vodoor] = 0xc4;
X! 	    showsyms[S_tlcorn] = 0xda;	/* meta-Z, top left corner */
X! 	    showsyms[S_trcorn] = 0xbf;	/* meta-?, top right corner */
X! 	    showsyms[S_blcorn] = 0xc0;	/* meta-@, bottom left */
X! 	    showsyms[S_brcorn] = 0xd9;	/* meta-Y, bottom right */
X! 	    showsyms[S_crwall] = 0xc5;	/* meta-E, cross */
X! 	    showsyms[S_tuwall] = 0xc1;	/* meta-A, T up */
X! 	    showsyms[S_tdwall] = 0xc2;	/* meta-B, T down */
X! 	    showsyms[S_tlwall] = 0xb4;	/* meta-4, T left */
X! 	    showsyms[S_trwall] = 0xc3;	/* meta-C, T right */
X! 	    showsyms[S_vbeam] = 0xb3;	/* meta-3, vertical rule */
X! 	    showsyms[S_hbeam] = 0xc4;	/* meta-D, horizontal rule */
X! 	    showsyms[S_room] = 0xfa;	/* meta-z, centered dot */
X! 	    showsyms[S_ndoor] = 0xfa;
X! 	    showsyms[S_pool] = 0xf7;	/* meta-w, approx. equals */
X  	}
X! #endif /* ASCIIGRAPH */
X  
X  #ifdef TERMLIB
X  	if(!term)
X  #endif
X  #if defined(TOS) && defined(__GNUC__) && defined(TERMLIB)
X! 		term = "builtin";		/* library has a default */
X  #else
X  # ifdef MACOS
X  	/* dummy termcap for the Mac */
X***************
X*** 155,161 ****
X  		unsigned char   *sym;
X  		short   i;
X  
X! 		sym = &showsyms.stone;
X  		theRes = GetResource(HACK_DATA,102);
X  		HLock(theRes);
X  		strncpy((char *)sym,(char *)(*theRes),32);
X--- 155,161 ----
X  		unsigned char   *sym;
X  		short   i;
X  
X! 		sym = &showsyms[S_stone];
X  		theRes = GetResource(HACK_DATA,102);
X  		HLock(theRes);
X  		strncpy((char *)sym,(char *)(*theRes),32);
X***************
X*** 173,178 ****
X--- 173,180 ----
X  # ifdef ANSI_DEFAULT
X  #  ifdef TOS
X  	{
X+ 		CO = 80; LI = 25;
X+ 		TI = VS = VE = TE = "";
X  		HO = "\033H";
X  		CL = "\033E";		/* the VT52 termcap */
X  		CE = "\033K";
X***************
X*** 184,194 ****
X  		SO = "\033p";
X  		SE = "\033q";
X  		HI = "\033p";
X! 		HE = "\033q\033b\020";
X  		for (i = 0; i < SIZE(hilites); i++) {
X  			hilites[i] = (char *) alloc(sizeof("Eb1"));
X! 			Sprintf(hilites[i], (i%4)?"\033b%c","\033p", i);
X  		}
X  	}
X  #  else /* TOS */
X  	{
X--- 186,200 ----
X  		SO = "\033p";
X  		SE = "\033q";
X  		HI = "\033p";
X! #ifdef TEXTCOLOR
X! 		HE = "\033q\033b\017";
X  		for (i = 0; i < SIZE(hilites); i++) {
X  			hilites[i] = (char *) alloc(sizeof("Eb1"));
X! 			Sprintf(hilites[i], (i%4)?"\033b%c" : "\033p", i);
X  		}
X+ #else
X+ 		HE = "\033q";
X+ #endif
X  	}
X  #  else /* TOS */
X  	{
X***************
X*** 230,236 ****
X--- 236,246 ----
X  		for (i = 0; i < MAXCOLORS / 2; i++) {
X  			hilites[i] = (char *) alloc(sizeof("\033[0;3%dm"));
X  			hilites[i+BRIGHT] = (char *) alloc(sizeof("\033[1;3%dm"));
X+ #    ifdef MSDOS
X+ 			Sprintf(hilites[i], (i == BLUE ? "\033[1;3%dm" : "\033[0;3%dm"), i);
X+ #    else
X  			Sprintf(hilites[i], "\033[0;3%dm", i);
X+ #    endif
X  			Sprintf(hilites[i+BRIGHT], "\033[1;3%dm", i);
X  		}
X  #   endif
X***************
X*** 241,247 ****
X  		error("Can't get TERM.");
X  # endif /* ANSI_DEFAULT */
X  # endif /* MACOS */
X! #endif /* __GNUC__ */
X  #ifdef TERMLIB
X  	tptr = (char *) alloc(1024);
X  
X--- 251,257 ----
X  		error("Can't get TERM.");
X  # endif /* ANSI_DEFAULT */
X  # endif /* MACOS */
X! #endif /* __GNUC__ && TOS && TERMCAP */
X  #ifdef TERMLIB
X  	tptr = (char *) alloc(1024);
X  
X***************
X*** 279,288 ****
X--- 289,306 ----
X  	if (!CO) CO = tgetnum("co");
X  	if (!LI) LI = tgetnum("li");
X  # else
X+ #  if defined(TOS) && defined(__GNUC__)
X+ 	if (!strcmp(term, "builtin"))
X+ 		get_scr_size();
X+ 	else {
X+ #  endif
X  	CO = tgetnum("co");
X  	LI = tgetnum("li");
X  	if (!LI || !CO)			/* if we don't override it */
X  		get_scr_size();
X+ #  if defined(TOS) && defined(__GNUC__)
X+ 	}
X+ #  endif
X  # endif
X  	if(CO < COLNO || LI < ROWNO+3)
X  		setclipped();
X***************
X*** 314,319 ****
X--- 332,340 ----
X  	TI = Tgetstr("ti");
X  	TE = Tgetstr("te");
X  	VS = VE = "";
X+ # ifdef TERMINFO
X+ 	VS = Tgetstr("enacs");	/* graphics start */
X+ # endif
X  # if 0
X  	MB = Tgetstr("mb");	/* blink */
X  	MD = Tgetstr("md");	/* boldface */
X***************
X*** 378,383 ****
X--- 399,419 ----
X  
X  /* Cursor movements */
X  
X+ #ifdef CLIPPING
X+ /* if (x,y) is currently viewable, move the cursor there and return TRUE */
X+ boolean
X+ win_curs(x, y)
X+ int x, y;
X+ {
X+ 	if (clipping && (x<=clipx || x>=clipxmax || y<=clipy || y>=clipymax))
X+ 		return FALSE;
X+ 	y -= clipy;
X+ 	x -= clipx;
X+ 	curs(x, y+2);
X+ 	return TRUE;
X+ }
X+ #endif
X+ 
X  void
X  curs(x, y)
X  register int x, y;	/* not xchar: perhaps xchar is unsigned and
X***************
X*** 500,506 ****
X  		   but is better than nothing */
X  		register int cx = curx, cy = cury;
X  
X! 		while(curx < COLNO) {
X  			xputc(' ');
X  			curx++;
X  		}
X--- 536,542 ----
X  		   but is better than nothing */
X  		register int cx = curx, cy = cury;
X  
X! 		while(curx < CO) {
X  			xputc(' ');
X  			curx++;
X  		}
X***************
X*** 585,591 ****
X  	(void) fflush(stdout);
X  }
X  
X! #if defined(TERMLIB) || defined(DECRAINBOW)
X  void
X  graph_on() {
X  	if (AS) xputs(AS);
X--- 621,627 ----
X  	(void) fflush(stdout);
X  }
X  
X! #ifdef ASCIIGRAPH
X  void
X  graph_on() {
X  	if (AS) xputs(AS);
X***************
X*** 632,641 ****
X  		tputs("$<50>", 1, xputc);
X  #  endif
X  # else
X! 		tputs("50", 1, xputs);
X  # endif
X  
X! 	else if(ospeed > 0 || ospeed < SIZE(tmspc10)) if(CM) {
X  		/* delay by sending cm(here) an appropriate number of times */
X  		register int cmlen = strlen(tgoto(CM, curx-1, cury-1));
X  		register int i = 500 + tmspc10[ospeed]/2;
X--- 668,677 ----
X  		tputs("$<50>", 1, xputc);
X  #  endif
X  # else
X! 		tputs("50", 1, xputc);
X  # endif
X  
X! 	else if(ospeed > 0 && ospeed < SIZE(tmspc10)) if(CM) {
X  		/* delay by sending cm(here) an appropriate number of times */
X  		register int cmlen = strlen(tgoto(CM, curx-1, cury-1));
X  		register int i = 500 + tmspc10[ospeed]/2;
X***************
X*** 769,774 ****
X--- 805,815 ----
X  	    if (foreg != c && backg != c) {
X  		hilites[c] = (char *) alloc(sizeof("\033[0;3%d;4%dm"));
X  		hilites[c+BRIGHT] = (char *) alloc(sizeof("\033[1;3%d;4%dm"));
X+ #ifdef MSDOS    /* brighten low-visibility colors */
X+ 		if (c == BLUE)
X+ 		    Sprintf(hilites[c], "\033[1;3%d;4%dm", c, backg);
X+ 		else
X+ #endif
X  		Sprintf(hilites[c], "\033[0;3%d;4%dm", c, backg);
X  		Sprintf(hilites[c+BRIGHT], "\033[1;3%d;4%dm", c, backg);
X  	    }
X*** src/Old/timeout.c	Sun Nov 19 13:14:54 1989
X--- src/timeout.c	Sun Nov  5 16:16:14 1989
X***************
X*** 112,118 ****
X  			make_vomiting(0L, TRUE);
X  			break;
X  		case SICK:
X! 			You("die from food poisoning.");
X  			killer = u.usick_cause;
X  			done(POISONING);
X  			break;
X--- 112,118 ----
X  			make_vomiting(0L, TRUE);
X  			break;
X  		case SICK:
X! 			You("die from your illness.");
X  			killer = u.usick_cause;
X  			done(POISONING);
X  			break;
X***************
X*** 216,228 ****
X  		if(Blind)
X  		    You("feel something %s from your pack!",
X  			  (index(slithy, mtmp->data->mlet)) ?
X! 			  "slither" : "drop");
X  		else
X! 		    pline("A%s %s just %s out of your pack!",
X! 			  (index(vowels, *(mtmp->data->mname))) ? "n" : "",
X! 			  mtmp->data->mname,
X  			  (index(slithy, mtmp->data->mlet)) ?
X! 			  "slithered" : "dropped");
X  
X  #ifdef POLYSELF
X  		if (yours) {
X--- 216,227 ----
X  		if(Blind)
X  		    You("feel something %s from your pack!",
X  			  (index(slithy, mtmp->data->mlet)) ?
X! 			      "slither" : "drop");
X  		else
X! 		    pline("%s just %s out of your pack!",
X! 			  An(mtmp->data->mname),
X  			  (index(slithy, mtmp->data->mlet)) ?
X! 			      "slithered" : "dropped");
X  
X  #ifdef POLYSELF
X  		if (yours) {
X***************
X*** 229,234 ****
X--- 228,234 ----
X  		    pline("Its cries sound like \"%s.\"",
X  			flags.female ? "mommy" : "daddy");
X  		    (void) tamedog(mtmp, (struct obj *)0);
X+ 		    mtmp->mtame = 20;
X  		    return;
X  		}
X  #endif
END_OF_FILE
if test 53197 -ne `wc -c <'patches06k'`; then
    echo shar: \"'patches06k'\" unpacked with wrong size!
fi
# end of 'patches06k'
fi
echo shar: End of archive 11 \(of 15\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
