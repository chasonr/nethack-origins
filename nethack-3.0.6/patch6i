Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i062:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6i
Message-ID: <4851@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:52:58 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1930
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 62
Archive-name: NetHack3/Patch6i
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 15)."
# Contents:  patches06i
# Wrapped by billr@saab on Wed Nov 22 11:10:41 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches06i' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06i'\"
else
echo shar: Extracting \"'patches06i'\" \(57020 characters\)
sed "s/^X//" >'patches06i' <<'END_OF_FILE'
X*** src/Old/mondata.c	Sun Nov 19 13:46:38 1989
X--- src/mondata.c	Sun Nov 19 09:25:29 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mondata.c	3.0	89/01/10
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mondata.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 61,68 ****
X  breakarm(ptr)	/* creature will break out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return(bigmonst(ptr) || (!verysmall(ptr) && !humanoid(ptr))
X! #ifdef HARD
X  	       || ptr == &mons[PM_MARILITH]
X  #endif
X  	       );
X--- 61,68 ----
X  breakarm(ptr)	/* creature will break out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return(bigmonst(ptr) || (ptr->msize > MZ_SMALL && !humanoid(ptr))
X! #ifdef INFERNO
X  	       || ptr == &mons[PM_MARILITH]
X  #endif
X  	       );
X***************
X*** 77,83 ****
X  sliparm(ptr)	/* creature will slide out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return(!bigmonst(ptr) && (verysmall(ptr) || ptr == &mons[PM_GHOST]));
X  }
X  #endif
X  
X--- 77,84 ----
X  sliparm(ptr)	/* creature will slide out of armor */
X  	register struct permonst *ptr;
X  {
X! 	return(ptr->msize < MZ_LARGE &&
X! 	       (ptr->msize <= MZ_SMALL || ptr == &mons[PM_GHOST]));
X  }
X  #endif
X  
X***************
X*** 162,168 ****
X  	else if (!strncmp(str, "an ", 3)) str += 3;
X  
X  	/* Some irregular plurals */
X! #ifdef HARD
X  	if (!strncmp(str, "incubi", 6)) return PM_INCUBUS;
X  	if (!strncmp(str, "succubi", 7)) return PM_SUCCUBUS;
X  #endif
X--- 163,169 ----
X  	else if (!strncmp(str, "an ", 3)) str += 3;
X  
X  	/* Some irregular plurals */
X! #ifdef INFERNO
X  	if (!strncmp(str, "incubi", 6)) return PM_INCUBUS;
X  	if (!strncmp(str, "succubi", 7)) return PM_SUCCUBUS;
X  #endif
X***************
X*** 234,240 ****
X  	if (mtmp->data->mflags1 & M1_FEM) return 1;
X  	if (mtmp->data == &mons[PM_CAVEMAN]
X  		|| mtmp->data == &mons[PM_PRIEST]
X! #ifdef HARD
X  		|| mtmp->data == &mons[PM_INCUBUS]
X  #endif
X  						) return 0;
X--- 235,241 ----
X  	if (mtmp->data->mflags1 & M1_FEM) return 1;
X  	if (mtmp->data == &mons[PM_CAVEMAN]
X  		|| mtmp->data == &mons[PM_PRIEST]
X! #ifdef INFERNO
X  		|| mtmp->data == &mons[PM_INCUBUS]
X  #endif
X  						) return 0;
X***************
X*** 327,338 ****
X  
X  int
X  bigmonst(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_BIG) != 0L);
X  }
X  
X  int
X  verysmall(ptr) struct permonst *ptr; {
X! 	return((ptr->mflags1 & M1_VSMALL) != 0L);
X  }
X  
X  int
X--- 328,339 ----
X  
X  int
X  bigmonst(ptr) struct permonst *ptr; {
X! 	return(ptr->msize >= MZ_LARGE);
X  }
X  
X  int
X  verysmall(ptr) struct permonst *ptr; {
X! 	return(ptr->msize < MZ_SMALL);
X  }
X  
X  int
X***************
X*** 569,586 ****
X  	return((ptr->mflags1 & M1_PRINCE) != 0L);
X  }
X  
X! # ifdef HARD
X  int
X  is_ndemon(ptr) struct permonst *ptr; {
X  	return(is_demon(ptr) &&
X  		(ptr->mflags1 & (M1_LORD | M1_PRINCE)) == 0L);
X  }
X! # else /* HARD */
X  int
X  is_ndemon(ptr) struct permonst *ptr; {
X  	return(ptr == &mons[PM_DEMON]);
X  }
X! # endif /* HARD */
X  
X  int
X  is_dlord(ptr) struct permonst *ptr; {
X--- 570,587 ----
X  	return((ptr->mflags1 & M1_PRINCE) != 0L);
X  }
X  
X! # ifdef INFERNO
X  int
X  is_ndemon(ptr) struct permonst *ptr; {
X  	return(is_demon(ptr) &&
X  		(ptr->mflags1 & (M1_LORD | M1_PRINCE)) == 0L);
X  }
X! # else
X  int
X  is_ndemon(ptr) struct permonst *ptr; {
X  	return(ptr == &mons[PM_DEMON]);
X  }
X! # endif
X  
X  int
X  is_dlord(ptr) struct permonst *ptr; {
X*** src/Old/monmove.c	Sun Nov 19 13:47:18 1989
X--- src/monmove.c	Wed Nov  8 22:56:55 1989
X***************
X*** 43,50 ****
X  			!(here->diggable & W_NONDIGGABLE)) {
X  		if(flags.soundok && flags.verbose && !rn2(5))
X  		       You("hear the sound of crashing rock.");
X! 		here->typ = DOOR;
X! 		here->doormask = D_NODOOR;
X  	    }
X  	}
X  	/* Eats away door if present & closed or locked */
X--- 43,55 ----
X  			!(here->diggable & W_NONDIGGABLE)) {
X  		if(flags.soundok && flags.verbose && !rn2(5))
X  		       You("hear the sound of crashing rock.");
X! 		if(!is_maze_lev) {
X! 		  here->typ = DOOR;
X! 		  here->doormask = D_NODOOR;
X! 		}
X! 		else
X! 		  here->typ = ROOM;
X! 		mnewsym(mtmp->mx, mtmp->my);
X  	    }
X  	}
X  	/* Eats away door if present & closed or locked */
X***************
X*** 52,62 ****
X--- 57,69 ----
X  		(here->doormask & (D_LOCKED | D_CLOSED))) {
X  		if(here->doormask & D_TRAPPED) {
X  		    here->doormask = D_NODOOR;
X+ 		    mnewsym(mtmp->mx, mtmp->my);
X  		    if(mb_trapped(mtmp)) return(FALSE);
X  		} else {
X  		    if(!rn2(3) && flags.verbose) /* not too often.. */
X  		        You("feel an unexpected draft of air.");
X  		    here->doormask = D_BROKEN;
X+ 		    mnewsym(mtmp->mx, mtmp->my);
X  		}
X  	    }
X  	else return TRUE; /* it doesn't leave rocks if it didn't dig */
X***************
X*** 132,138 ****
X  
X  	*inrange = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) <=
X  							(BOLT_LIM * BOLT_LIM));
X! 	*nearby = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) < 3);
X  
X  	/* Note: if your image is displaced, the monster sees the Elbereth
X  	 * at your displaced position, thus never attacking your displaced
X--- 139,145 ----
X  
X  	*inrange = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) <=
X  							(BOLT_LIM * BOLT_LIM));
X! 	*nearby = monnear(mtmp, mtmp->mux, mtmp->muy);
X  
X  	/* Note: if your image is displaced, the monster sees the Elbereth
X  	 * at your displaced position, thus never attacking your displaced
X***************
X*** 232,238 ****
X  	/* check distance and scariness of attacks */
X  	distfleeck(mtmp,&inrange,&nearby,&scared);
X  
X! #ifdef HARD	/* Demonic Blackmail!!! */
X  	if(nearby && is_demon(mdat) && mtmp->mpeaceful && !mtmp->mtame) {
X  		if (mtmp->mux != u.ux || mtmp->muy != u.uy) {
X  			pline("%s whispers something to thin air.",
X--- 239,245 ----
X  	/* check distance and scariness of attacks */
X  	distfleeck(mtmp,&inrange,&nearby,&scared);
X  
X! #ifdef INFERNO		/* Demonic Blackmail!!! */
X  	if(nearby && is_demon(mdat) && mtmp->mpeaceful && !mtmp->mtame) {
X  		if (mtmp->mux != u.ux || mtmp->muy != u.uy) {
X  			pline("%s whispers something to thin air.",
X***************
X*** 619,638 ****
X  			/* can't lock out shk */
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			if(mb_trapped(mtmp)) return(2);
X  		    } else {
X  			if (flags.verbose) {
X  			    if (canseeit)
X! 			       You("see a door being unlocked and opened.");
X  			    else if (flags.soundok)
X  			       You("hear a door being unlocked and opened.");
X  		        }
X  		        here->doormask = D_ISOPEN;
X  		    }
X  		} else if (here->doormask == D_CLOSED && 
X  					!nohands(mtmp->data)) {
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X  			if(mb_trapped(mtmp)) return(2);
X  		    } else {
X  		        if (flags.verbose) {
X--- 626,651 ----
X  			/* can't lock out shk */
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X+ 			mnewsym(mtmp->mx, mtmp->my);
X+ 			if (canseeit) prl(mtmp->mx,mtmp->my);
X  			if(mb_trapped(mtmp)) return(2);
X  		    } else {
X  			if (flags.verbose) {
X  			    if (canseeit)
X! 			      You("see a door being unlocked and opened.");
X  			    else if (flags.soundok)
X  			       You("hear a door being unlocked and opened.");
X  		        }
X  		        here->doormask = D_ISOPEN;
X+ 			mnewsym(mtmp->mx, mtmp->my);
X+ 			if (canseeit) prl(mtmp->mx,mtmp->my);
X  		    }
X  		} else if (here->doormask == D_CLOSED && 
X  					!nohands(mtmp->data)) {
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X+ 			mnewsym(mtmp->mx, mtmp->my);
X+ 			if (canseeit) prl(mtmp->mx,mtmp->my);
X  			if(mb_trapped(mtmp)) return(2);
X  		    } else {
X  		        if (flags.verbose) {
X***************
X*** 642,652 ****
X--- 655,669 ----
X  			         You("hear the sound of a door opening.");
X  		        }
X  		        here->doormask = D_ISOPEN;
X+ 			mnewsym(mtmp->mx, mtmp->my);
X+ 			if (canseeit) prl(mtmp->mx,mtmp->my);
X  		    }
X  		} else if(here->doormask & (D_LOCKED | D_CLOSED)) {
X  			/* mfndpos guarantees monster is a giant */
X  		    if(btrapped) {
X  			here->doormask = D_NODOOR;
X+ 			mnewsym(mtmp->mx, mtmp->my);
X+ 			if (canseeit) prl(mtmp->mx,mtmp->my);
X  			if(mb_trapped(mtmp)) return(2);
X  		    } else {
X  		        if (flags.verbose) {
X***************
X*** 658,666 ****
X  		        if (here->doormask & D_LOCKED && !rn2(2))
X  			        here->doormask = D_NODOOR;
X  		        else here->doormask = D_BROKEN;
X  		    }
X  		}
X! 	    }
X  	    /* Maybe a rock mole just ate something? */
X  	    if(can_tunnel) if(!mdig_tunnel(mtmp)) return(2); /* died? */
X  
X--- 675,685 ----
X  		        if (here->doormask & D_LOCKED && !rn2(2))
X  			        here->doormask = D_NODOOR;
X  		        else here->doormask = D_BROKEN;
X+ 			mnewsym(mtmp->mx, mtmp->my);
X+ 			if (canseeit) prl(mtmp->mx,mtmp->my);
X  		    }
X  		}
X! 	      }
X  	    /* Maybe a rock mole just ate something? */
X  	    if(can_tunnel) if(!mdig_tunnel(mtmp)) return(2); /* died? */
X  
X*** src/Old/mthrowu.c	Sun Nov 19 13:50:51 1989
X--- src/mthrowu.c	Tue Oct 31 11:04:38 1989
X***************
X*** 28,50 ****
X  	struct obj *obj;
X  	register char *name;
X  {
X! 	char buf[BUFSZ];
X  	boolean acidic = (obj && obj->otyp == ACID_VENOM);
X  
X- 	setan(name, buf);
X  	if(u.uac + tlev <= rnd(20)) {
X  		if(Blind || !flags.verbose) pline("It misses.");
X! 		else You("are almost hit by %s!", buf);
X  		return(0);
X  	} else {
X  		if(Blind || !flags.verbose) You("are hit!");
X! 		else You("are hit by %s!", buf);
X  #ifdef POLYSELF
X  		if (obj && obj->otyp == SILVER_ARROW && (u.ulycn != -1 ||
X  				is_demon(uasmon) || u.usym == S_VAMPIRE ||
X  				(u.usym == S_IMP && u.umonnum != PM_TENGU))) {
X  			dam += rnd(20);
X! 			pline("You feel the %sarrow sear your flesh!",
X  				Blind ? "" : "silver ");
X  		}
X  		if (acidic && resists_acid(uasmon))
X--- 28,49 ----
X  	struct obj *obj;
X  	register char *name;
X  {
X! 	char *oname = an(name);
X  	boolean acidic = (obj && obj->otyp == ACID_VENOM);
X  
X  	if(u.uac + tlev <= rnd(20)) {
X  		if(Blind || !flags.verbose) pline("It misses.");
X! 		else You("are almost hit by %s!", oname);
X  		return(0);
X  	} else {
X  		if(Blind || !flags.verbose) You("are hit!");
X! 		else You("are hit by %s!", oname);
X  #ifdef POLYSELF
X  		if (obj && obj->otyp == SILVER_ARROW && (u.ulycn != -1 ||
X  				is_demon(uasmon) || u.usym == S_VAMPIRE ||
X  				(u.usym == S_IMP && u.umonnum != PM_TENGU))) {
X  			dam += rnd(20);
X! 			pline("The %sarrow sears your flesh!",
X  				Blind ? "" : "silver ");
X  		}
X  		if (acidic && resists_acid(uasmon))
X***************
X*** 268,273 ****
X--- 267,276 ----
X  {
X  	struct obj *otmp, *prev;
X  
X+ 	if (obj->quan > 1) {
X+ 		obj->quan--;
X+ 		return;
X+ 	}
X  	prev = ((struct obj *) 0);
X  	for (otmp = mon->minvent; otmp; otmp = otmp->nobj) {
X  		if (otmp == obj) {
X***************
X*** 315,323 ****
X  			|| otmp->otyp == CROSSBOW_BOLT) verb = "shoots";
X  		    otmp->quan = 1;
X  		    if (canseemon(mtmp))
X! 			pline("%s %s a%s %s!", Monnam(mtmp), verb,
X! 				index(vowels,*(xname(otmp))) ? "n" : "",
X! 				xname(otmp));
X  		    otmp->quan = savequan;
X  		    m_throw(mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X--- 318,324 ----
X  			|| otmp->otyp == CROSSBOW_BOLT) verb = "shoots";
X  		    otmp->quan = 1;
X  		    if (canseemon(mtmp))
X! 			pline("%s %s %s!", Monnam(mtmp), verb, an(xname(otmp)));
X  		    otmp->quan = savequan;
X  		    m_throw(mtmp->mx, mtmp->my, sgn(tbx), sgn(tby), 
X  			movedist(mtmp->mx,mtmp->mux,mtmp->my,mtmp->muy), otmp);
X*** src/Old/music.c	Sun Nov 19 13:51:12 1989
X--- src/music.c	Fri Nov 10 11:01:03 1989
X***************
X*** 253,260 ****
X--- 253,262 ----
X  			    if (cansee(x,y))
X  				pline("The door collapses.");
X  			    levl[x][y].doormask = D_NODOOR;
X+ 			    mnewsym(x,y);
X  			    if (!MON_AT(x, y) && !(x == u.ux && y == u.uy))
X  				newsym(x,y);
X+ 			    if (cansee(x,y)) prl(x,y);
X  			    break;
X  		    }
X  	    }
X***************
X*** 280,287 ****
X  		  charm_snakes((int)u.ulevel*3);
X  		break;
X  	      case MAGIC_FLUTE: /* Make monster fall asleep */
X! 		You("produce soft music.");
X! 		put_monsters_to_sleep((int)u.ulevel*5);
X  		break;
X  	      case HORN:	/* Awaken monsters or scare monsters */
X  		You("produce a frightful, grave sound.");
X--- 282,292 ----
X  		  charm_snakes((int)u.ulevel*3);
X  		break;
X  	      case MAGIC_FLUTE: /* Make monster fall asleep */
X! 		if (instr->spe > 0) {
X! 			instr->spe--;
X! 			You("produce soft music.");
X! 			put_monsters_to_sleep((int)u.ulevel*5);
X! 		}
X  		break;
X  	      case HORN:	/* Awaken monsters or scare monsters */
X  		You("produce a frightful, grave sound.");
X***************
X*** 317,323 ****
X  		break;
X  	      case MAGIC_HARP:	/* Charm monsters */
X  		if (instr->spe > 0) {
X! 			pline("The %s produces very attractive music.",xname(instr));
X  			instr->spe--;
X  			charm_monsters(((int)u.ulevel - 1) / 3 + 1);
X  		}
X--- 322,328 ----
X  		break;
X  	      case MAGIC_HARP:	/* Charm monsters */
X  		if (instr->spe > 0) {
X! 			pline("The %s produces very attractive music.", xname(instr));
X  			instr->spe--;
X  			charm_monsters(((int)u.ulevel - 1) / 3 + 1);
X  		}
X***************
X*** 330,337 ****
X  		if (instr->spe > 0) {
X  			You("produce a heavy, thunderous rolling!");
X  			pline("The entire dungeon is shaking around you!");
X- 			do_earthquake(((int)u.ulevel - 1) / 3 + 1);
X  			instr->spe--;
X  			makeknown(DRUM_OF_EARTHQUAKE);
X  		}
X  		break;
X--- 335,342 ----
X  		if (instr->spe > 0) {
X  			You("produce a heavy, thunderous rolling!");
X  			pline("The entire dungeon is shaking around you!");
X  			instr->spe--;
X+ 			do_earthquake(((int)u.ulevel - 1) / 3 + 1);
X  			makeknown(DRUM_OF_EARTHQUAKE);
X  		}
X  		break;
X*** src/Old/objects.c	Sun Nov 19 13:51:52 1989
X--- src/objects.c	Tue Nov 14 20:31:49 1989
X***************
X*** 6,11 ****
X--- 6,12 ----
X   * function declarations for all of nethack
X   */
X  #define EXTERN_H
X+ /* #define MAKEDEFS_C	1	/* for Mac compilers with 32K data limit */
X  #include "config.h"
X  #include "obj.h"
X  #include "objclass.h"
X***************
X*** 24,37 ****
X--- 25,52 ----
X  #define C(n)
X  #endif
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ struct objclass *objects;
X+ struct small_objclass sm_obj[] = {
X+ #else
X  struct objclass objects[] = {
X+ #endif
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ 	{ "strange object", NULL},
X+ #else
X  	{ "strange object", NULL, NULL, 1,0,0,0,0, 0,
X  		ILLOBJ_SYM, 0, 0, 0, 0, 0, 0, 0, C(0) },
X+ #endif
X  /* amulets ... - THE Amulet comes last because it is special */
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X  #define AMULET(name,desc,power,prob,weight) { \
X+ 	name, desc}
X+ #else
X+ #define AMULET(name,desc,power,prob,weight) { \
X  	name, desc, NULL, 0,0,0,0,METAL, power, AMULET_SYM, prob, 0, weight, \
X  	150, 0, 0, 0, C(HI_METAL) }
X+ #endif
X  
X  	AMULET("amulet of esp", 	  "circular",	TELEPAT,    190, 2),
X  	AMULET("amulet of life saving",   "spherical",	LIFESAVED,   90, 2),
X***************
X*** 41,53 ****
X--- 56,78 ----
X  	AMULET("amulet of change",	  "square",	0,	    150, 2),
X  								/* POLYMORPH */
X  	AMULET("amulet of reflection",	  "hexagonal",	REFLECTING,  90, 2),
X+ 
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ 	{ "Amulet of Yendor", NULL},
X+ #else
X  	{ "Amulet of Yendor", NULL, NULL, 1,0,1,0,METAL, 0,
X  		AMULET_SYM, 0, 0, 2, 3500, 0, 0, 0, C(HI_METAL) },
X+ #endif
X  #undef AMULET
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define FOOD(name,prob,delay,wt,uk,tin,nutrition,color) { \
X+ 	name, NULL}
X+ #else
X  #define FOOD(name,prob,delay,wt,uk,tin,nutrition,color) { \
X  	name, NULL, NULL, 1,1,uk,0,tin, 0, FOOD_SYM, prob, delay, wt, \
X  	nutrition/20 + 5, 0, 0, nutrition, C(color) }
X+ #endif
X  
X  /* all types of food (except tins & corpses) must have a delay of at least 1. */
X  /* delay on corpses is computed and is weight dependant */
X***************
X*** 64,80 ****
X  #else
X  	FOOD("tripe ration",	   150, 2, 2, 0, 0, 200, BROWN),
X  #endif
X- 	FOOD("dead lizard",	    35, 1, 1, 0, 0,  40, GREEN),
X  	FOOD("corpse",		     0, 1, 0, 0, 0,   0, BROWN),
X! 	FOOD("egg",		    75, 1, 1, 1, 0,  80, WHITE),
X  	/* fruits & veggies */
X! 	FOOD("apple",		    10, 1, 1, 0, 0,  50, RED),
X! 	FOOD("orange",		     7, 1, 1, 0, 0,  80, ORANGE_COLORED),
X! 	FOOD("pear",		     7, 1, 1, 0, 0,  50, GREEN+BRIGHT),
X! 	FOOD("melon",		     7, 1, 1, 0, 0, 100, GREEN+BRIGHT),
X! 	FOOD("banana",		     7, 1, 1, 0, 0,  80, YELLOW),
X  	FOOD("carrot",		    15, 1, 1, 0, 0,  50, ORANGE_COLORED),
X! 	FOOD("clove of garlic",      5, 1, 1, 0, 0,  40, WHITE),
X  #ifdef TUTTI_FRUTTI
X  	FOOD("slime mold",	    75, 1, 1, 0, 0, 250, BROWN),
X  #else
X--- 89,104 ----
X  #else
X  	FOOD("tripe ration",	   150, 2, 2, 0, 0, 200, BROWN),
X  #endif
X  	FOOD("corpse",		     0, 1, 0, 0, 0,   0, BROWN),
X! 	FOOD("egg",		    85, 1, 1, 1, 0,  80, WHITE),
X  	/* fruits & veggies */
X! 	FOOD("apple",		    15, 1, 1, 0, 0,  50, RED),
X! 	FOOD("orange",		    10, 1, 1, 0, 0,  80, ORANGE_COLORED),
X! 	FOOD("pear",		    10, 1, 1, 0, 0,  50, GREEN|BRIGHT),
X! 	FOOD("melon",		    10, 1, 1, 0, 0, 100, GREEN|BRIGHT),
X! 	FOOD("banana",		    10, 1, 1, 0, 0,  80, YELLOW),
X  	FOOD("carrot",		    15, 1, 1, 0, 0,  50, ORANGE_COLORED),
X! 	FOOD("clove of garlic",      7, 1, 1, 0, 0,  40, WHITE),
X  #ifdef TUTTI_FRUTTI
X  	FOOD("slime mold",	    75, 1, 1, 0, 0, 250, BROWN),
X  #else
X***************
X*** 83,93 ****
X  	/* human food */
X  	FOOD("lump of royal jelly",  0, 1, 1, 0, 0, 200, YELLOW),
X  	FOOD("cream pie",	    25, 1, 1, 0, 0, 100, WHITE),
X! 	FOOD("candy bar",	     7, 1, 1, 0, 0, 100, BROWN),
X  	FOOD("fortune cookie",	    55, 1, 1, 0, 0,  40, BROWN),
X  #ifdef TOLKIEN
X  	FOOD("pancake", 	    25, 2, 1, 0, 0, 200, BROWN),
X! 	FOOD("lembas wafer",	    20, 2, 1, 0, 0, 800, WHITE+BRIGHT),
X  	FOOD("cram ration",	    20, 3, 3, 0, 0, 600, HI_ORGANIC),
X  	FOOD("food ration",	   385, 5, 4, 0, 0, 800, HI_ORGANIC),
X  #else
X--- 107,117 ----
X  	/* human food */
X  	FOOD("lump of royal jelly",  0, 1, 1, 0, 0, 200, YELLOW),
X  	FOOD("cream pie",	    25, 1, 1, 0, 0, 100, WHITE),
X! 	FOOD("candy bar",	    13, 1, 1, 0, 0, 100, BROWN),
X  	FOOD("fortune cookie",	    55, 1, 1, 0, 0,  40, BROWN),
X  #ifdef TOLKIEN
X  	FOOD("pancake", 	    25, 2, 1, 0, 0, 200, BROWN),
X! 	FOOD("lembas wafer",	    20, 2, 1, 0, 0, 800, WHITE|BRIGHT),
X  	FOOD("cram ration",	    20, 3, 3, 0, 0, 600, HI_ORGANIC),
X  	FOOD("food ration",	   385, 5, 4, 0, 0, 800, HI_ORGANIC),
X  #else
X***************
X*** 101,115 ****
X--- 125,154 ----
X  	FOOD("tin",		    75, 0, 1, 1, METAL, 0, HI_METAL),
X  #undef FOOD
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define WEAPON(name,app,kn,mg,bi,prob,wt,cost,sdam,ldam,metal,color) { \
X+ 	name, app}
X+ #else
X  #define WEAPON(name,app,kn,mg,bi,prob,wt,cost,sdam,ldam,metal,color) { \
X  	name, app, NULL, kn,mg,1,bi,metal, 0, WEAPON_SYM, prob, 0, wt, \
X  	cost, sdam, ldam, 0, C(color) }
X+ #endif
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define PROJECTILE(name,app,kn,bi,prob,wt,cost,sdam,ldam,metal,prop,color) { \
X+ 	name, app}
X+ #else
X  #define PROJECTILE(name,app,kn,bi,prob,wt,cost,sdam,ldam,metal,prop,color) { \
X  	name, app, NULL, kn,1,1,bi,metal, 0, WEAPON_SYM, prob, 0, wt, \
X  	cost, sdam, ldam, prop, C(color) }
X+ #endif
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define BOW(name,app,kn,bi,prob,wt,cost,sdam,ldam,metal,prop,color) { \
X+ 	name, app}
X+ #else
X  #define BOW(name,app,kn,bi,prob,wt,cost,sdam,ldam,metal,prop,color) { \
X  	name, app, NULL, kn,0,1,bi,metal, 0, WEAPON_SYM, prob, 0, wt, \
X  	cost, sdam, ldam, -(prop), C(color) }
X+ #endif
X  
X  /* Note: for weapons that don't do an even die of damage (ex. 2-7 or 3-18)
X   * the extra damage is added on in weapon.c, not here! */
X***************
X*** 263,271 ****
X--- 302,315 ----
X  #undef BOW
X  
X  /* tools ... - PICK AXE comes last because it has special characteristics */
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define TOOL(name,desc,kn,chg,prob,weight,cost,material,color) {\
X+ 	name, desc}
X+ #else
X  #define TOOL(name,desc,kn,chg,prob,weight,cost,material,color) {\
X  	name, desc, NULL, kn,0,chg,chg,material, 0, TOOL_SYM, prob, 0, \
X  	weight, cost, 0, 0, 0, C(color)}
X+ #endif
X  
X  #ifdef WALKIES
X  	TOOL("leash",		NULL,	1, 0,  70,  3,	20, 0, HI_LEATHER),
X***************
X*** 321,328 ****
X--- 365,383 ----
X  	TOOL("drum of earthquake", "drum", 0, 1, 2,  4,	25, 0, BROWN),
X  #endif
X  #undef TOOL
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ 	{ "pick-axe", NULL},
X+ 	{ "unicorn horn", NULL},
X+ 	{ "blinding venom", "splash of venom"},
X+ 	{ "acid venom", "splash of venom"},
X+ 	    /* +d6 small or large */
X+ 	{ "heavy iron ball", NULL},
X+ 	{ "iron chain", NULL},
X+ #else
X  	{ "pick-axe", NULL, NULL, 1,0,1,1,METAL, 0, TOOL_SYM, 20,
X  						0, 10, 50, 6, 3, 0, C(HI_METAL)},
X+ 	{ "unicorn horn", NULL, NULL, 1,0,1,0,0, 0, TOOL_SYM, 0,
X+ 						0, 4, 100, 12, 12, 0, C(WHITE)},
X  	{ "blinding venom", "splash of venom", NULL,
X  		0,1,0,0,0, 0, VENOM_SYM, 500, 0, 0, 0, 0, 0, 0, C(HI_ORGANIC)},
X  	{ "acid venom", "splash of venom", NULL,
X***************
X*** 332,349 ****
X--- 387,415 ----
X  		BALL_SYM, 1000, 0, 20, 10, 0, 0, 0, C(HI_METAL)},
X  	{ "iron chain", NULL, NULL, 1,0,0,0,METAL, 0,
X  		CHAIN_SYM, 1000, 0, 20, 0, 0, 0, 0, C(HI_METAL)},
X+ #endif
X  
X  	/* Note: boulders and rocks normally do not appear at random; the
X  	 * probabilities only come into effect when you try to polymorph them.
X  	 */
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ 	{ "boulder", NULL},
X+ 	{ "statue", NULL},
X+ #else
X  	{ "boulder", NULL, NULL, 1,0,0,0,MINERAL, 0, ROCK_SYM, 100, 0,
X  		200 /* > MAX_CARR_CAP */, 0, 20, 20, 0, C(HI_MINERAL)},
X  	{ "statue", NULL, NULL, 1,0,0,0,MINERAL, 0, ROCK_SYM, 900, 0,
X  	        250, 0, 20, 20, 0, C(HI_MINERAL)},
X+ #endif
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define ARMOR(name,desc,kn,blk,power,prob,delay,weight,cost,ac,can,metal,c) \
X+ 	{name, desc}
X+ #else
X  #define ARMOR(name,desc,kn,blk,power,prob,delay,weight,cost,ac,can,metal,c) \
X  	{name, desc, NULL, kn,0,1,blk,metal, power, ARMOR_SYM, prob,\
X  	delay, weight, cost, ac, can, 0, C(c)}
X+ #endif
X  #ifdef TOLKIEN
X  ARMOR("elven leather helm", "leather hat",
X  			0, 0, 0,  6, 1, 2,   8, 9, 0, 0, HI_LEATHER),
X***************
X*** 371,377 ****
X  ARMOR("plate mail", NULL,
X  			1, 1, 0, 44, 5, 9, 600, 3, 2, METAL, HI_METAL),
X  ARMOR("crystal plate mail", NULL,
X! 			1, 1, 0, 10, 5, 9, 820, 3, 2, 0, WHITE+BRIGHT),
X  #ifdef SHIRT
X  ARMOR("bronze plate mail", NULL,
X  			1, 1, 0, 25, 5, 9, 400, 4, 0, COPPER, HI_COPPER),
X--- 437,443 ----
X  ARMOR("plate mail", NULL,
X  			1, 1, 0, 44, 5, 9, 600, 3, 2, METAL, HI_METAL),
X  ARMOR("crystal plate mail", NULL,
X! 			1, 1, 0, 10, 5, 9, 820, 3, 2, 0, WHITE|BRIGHT),
X  #ifdef SHIRT
X  ARMOR("bronze plate mail", NULL,
X  			1, 1, 0, 25, 5, 9, 400, 4, 0, COPPER, HI_COPPER),
X***************
X*** 483,491 ****
X--- 549,562 ----
X  			0, 0, LEVITATION,  12, 2, 4, 30, 9, 0, 0, BROWN),
X  #undef ARMOR
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define POTION(name,desc,power,prob,cost,color) \
X+ 	{ name, desc}
X+ #else
X  #define POTION(name,desc,power,prob,cost,color) \
X  		{ name, desc, NULL, 0,1,0,0,0, power,\
X  		POTION_SYM, prob, 0, 2, cost, 0, 0, 0, C(color)}
X+ #endif
X  
X  #ifdef SPELLS
X  POTION("fruit juice",		"smoky",	0,	45, 50,	WHITE),
X***************
X*** 496,522 ****
X  POTION("booze", 		"bubbly",	0,	65, 50,	WHITE),
X  #endif
X  POTION("gain ability",		"swirly",	0,	45,300,	WHITE),
X! POTION("restore ability",	"pink",		0,	45,100,	MAGENTA+BRIGHT),
X! POTION("sickness",		"ruby",		SICK,	45, 50,	RED),
X  POTION("confusion",		"orange",	CONFUSION, 45, 100, ORANGE_COLORED),
X  POTION("blindness",		"yellow",	BLINDED, 45,150, YELLOW),
X! POTION("paralysis",		"emerald", 	0,	45,300,	GREEN+BRIGHT),
X  POTION("speed", 		"dark green", 	FAST,	45,200,	GREEN),
X  POTION("levitation",		"cyan",		LEVITATION, 45,200, CYAN),
X! POTION("hallucination", 	"brilliant blue", HALLUC, 45,100, BLUE+BRIGHT),
X  POTION("invisibility",		"sky blue",	INVIS,	45,150,	CYAN),
X  POTION("see invisible", 	"magenta",	SEE_INVIS, 45,50, MAGENTA),
X  POTION("healing",		"purple", 	0,	65,100,	MAGENTA),
X  POTION("extra healing", 	"purple-red",	0,	50,100,	MAGENTA),
X! POTION("gain level",		"puce",		0,	20,300,	MAGENTA+BRIGHT),
X  POTION("enlightenment",		"brown",	0,	20,200,	BROWN),
X  POTION("monster detection",	"white",	0,	45,150,	WHITE),
X! POTION("object detection",	"glowing",	0,	45,150,	WHITE+BRIGHT),
X  POTION("water", 		"clear",	0,	125,100,CYAN),
X  #undef POTION
X  
X! #define SCROLL(name,text,prob,cost) { name, text, NULL, 0,1,0,0,0, 0,\
X  		SCROLL_SYM, prob, 0, 3, cost, 0, 0, 0, C(HI_PAPER)}
X  #ifdef MAIL
X  	SCROLL("mail",			"KIRJE",	     0,   0),
X  #endif
X--- 567,599 ----
X  POTION("booze", 		"bubbly",	0,	65, 50,	WHITE),
X  #endif
X  POTION("gain ability",		"swirly",	0,	45,300,	WHITE),
X! POTION("restore ability",	"pink",		0,	45,100,	MAGENTA|BRIGHT),
X! POTION("sickness",		"ruby",		0,	45, 50,	RED),
X  POTION("confusion",		"orange",	CONFUSION, 45, 100, ORANGE_COLORED),
X  POTION("blindness",		"yellow",	BLINDED, 45,150, YELLOW),
X! POTION("paralysis",		"emerald", 	0,	45,300,	GREEN|BRIGHT),
X  POTION("speed", 		"dark green", 	FAST,	45,200,	GREEN),
X  POTION("levitation",		"cyan",		LEVITATION, 45,200, CYAN),
X! POTION("hallucination", 	"brilliant blue", HALLUC, 45,100, BLUE|BRIGHT),
X  POTION("invisibility",		"sky blue",	INVIS,	45,150,	CYAN),
X  POTION("see invisible", 	"magenta",	SEE_INVIS, 45,50, MAGENTA),
X  POTION("healing",		"purple", 	0,	65,100,	MAGENTA),
X  POTION("extra healing", 	"purple-red",	0,	50,100,	MAGENTA),
X! POTION("gain level",		"puce",		0,	20,300,	MAGENTA|BRIGHT),
X  POTION("enlightenment",		"brown",	0,	20,200,	BROWN),
X  POTION("monster detection",	"white",	0,	45,150,	WHITE),
X! POTION("object detection",	"glowing",	0,	45,150,	WHITE|BRIGHT),
X  POTION("water", 		"clear",	0,	125,100,CYAN),
X  #undef POTION
X  
X! #if defined(MACOS) && !defined(MAKEDEFS_C)
X! #define SCROLL(name,text,prob,cost) \
X! 	{ name, text}
X! #else
X! #define SCROLL(name,text,prob,cost) \
X! 	{ name, text, NULL, 0,1,0,0,0, 0,\
X  		SCROLL_SYM, prob, 0, 3, cost, 0, 0, 0, C(HI_PAPER)}
X+ #endif
X  #ifdef MAIL
X  	SCROLL("mail",			"KIRJE",	     0,   0),
X  #endif
X***************
X*** 546,554 ****
X--- 623,636 ----
X  	SCROLL(NULL,			"GARVEN DEH",	     0, 100),
X  #undef SCROLL
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X  #define WAND(name,typ,prob,cost,flags,metal,c)	{ \
X+ 	name, typ}
X+ #else
X+ #define WAND(name,typ,prob,cost,flags,metal,c)	{ \
X  	name, typ, NULL, 0,0,1,0,metal, 0, WAND_SYM, \
X  	prob, 0, 3, cost, flags, 0, 0, C(c) }
X+ #endif
X  
X  WAND("light",		"glass",	95, 100, NODIR,    GLASS,HI_GLASS),
X  WAND("secret door detection", "balsa",	50, 150, NODIR,    WOOD,HI_WOOD),
X***************
X*** 585,593 ****
X--- 667,680 ----
X  
X  #ifdef SPELLS
X  /* books */
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X  #define SPELL(name,desc,prob,delay,level,flags,color) \
X+ 	{ name, desc}
X+ #else
X+ #define SPELL(name,desc,prob,delay,level,flags,color) \
X  	{ name, desc, NULL, 0,1,0,0,0, 0, SPBOOK_SYM, prob, delay, \
X  	5, level*100, flags, 0, level, C(color)}
X+ #endif
X  
X  SPELL("magic missile",	 "parchment",	45,  3, 2, RAY,		HI_PAPER),
X  SPELL("fireball",	 "vellum",	20,  6, 4, RAY,		HI_PAPER),
X***************
X*** 597,611 ****
X  SPELL("light",		 "cloth",	45,  1, 1, NODIR,	HI_CLOTH),
X  SPELL("detect monsters", "leather", 	45,  1, 1, NODIR,	HI_LEATHER),
X  SPELL("healing",	 "white",	40,  2, 1, NODIR,	WHITE),
X! SPELL("knock",		 "pink",	40,  1, 1, IMMEDIATE,	MAGENTA+BRIGHT),
X  SPELL("force bolt",	 "red",		40,  2, 1, IMMEDIATE,	RED),
X  SPELL("confuse monster", "orange",	37,  2, 2, IMMEDIATE,	ORANGE_COLORED),
X  SPELL("cure blindness",  "yellow", 	27,  2, 2, IMMEDIATE,	YELLOW),
X! SPELL("slow monster",	 "light green",	37,  2, 2, IMMEDIATE,	GREEN+BRIGHT),
X  SPELL("wizard lock",	 "dark green",	35,  3, 2, IMMEDIATE,	GREEN),
X! SPELL("create monster",  "turquoise",	37,  3, 2, NODIR,	CYAN+BRIGHT),
X  SPELL("detect food",	 "cyan",	37,  3, 2, NODIR,	CYAN),
X! SPELL("cause fear",	 "light blue",	25,  3, 3, NODIR,	BLUE+BRIGHT),
X  SPELL("clairvoyance",	 "dark blue",	15,  3, 3, NODIR,	BLUE),
X  SPELL("cure sickness",	 "indigo",	32,  3, 3, NODIR,	BLUE),
X  SPELL("charm monster",	 "magenta",	20,  3, 3, IMMEDIATE,	MAGENTA),
X--- 684,698 ----
X  SPELL("light",		 "cloth",	45,  1, 1, NODIR,	HI_CLOTH),
X  SPELL("detect monsters", "leather", 	45,  1, 1, NODIR,	HI_LEATHER),
X  SPELL("healing",	 "white",	40,  2, 1, NODIR,	WHITE),
X! SPELL("knock",		 "pink",	40,  1, 1, IMMEDIATE,	MAGENTA|BRIGHT),
X  SPELL("force bolt",	 "red",		40,  2, 1, IMMEDIATE,	RED),
X  SPELL("confuse monster", "orange",	37,  2, 2, IMMEDIATE,	ORANGE_COLORED),
X  SPELL("cure blindness",  "yellow", 	27,  2, 2, IMMEDIATE,	YELLOW),
X! SPELL("slow monster",	 "light green",	37,  2, 2, IMMEDIATE,	GREEN|BRIGHT),
X  SPELL("wizard lock",	 "dark green",	35,  3, 2, IMMEDIATE,	GREEN),
X! SPELL("create monster",  "turquoise",	37,  3, 2, NODIR,	CYAN|BRIGHT),
X  SPELL("detect food",	 "cyan",	37,  3, 2, NODIR,	CYAN),
X! SPELL("cause fear",	 "light blue",	25,  3, 3, NODIR,	BLUE|BRIGHT),
X  SPELL("clairvoyance",	 "dark blue",	15,  3, 3, NODIR,	BLUE),
X  SPELL("cure sickness",	 "indigo",	32,  3, 3, NODIR,	BLUE),
X  SPELL("charm monster",	 "magenta",	20,  3, 3, IMMEDIATE,	MAGENTA),
X***************
X*** 623,631 ****
X  SPELL("turn undead",	 "copper",	17,  8, 6, IMMEDIATE,	HI_COPPER),
X  SPELL("polymorph",	 "silver",	12,  8, 6, IMMEDIATE,	HI_SILVER),
X  SPELL("teleport away",	 "gold",	15,  6, 6, IMMEDIATE,	HI_GOLD),
X! SPELL("create familiar", "glittering", 	10,  7, 6, NODIR,	WHITE+BRIGHT),
X! SPELL("cancellation",	 "shining",	12,  8, 7, IMMEDIATE,	WHITE+BRIGHT),
X! SPELL("genocide",	 "glowing",	 5, 10, 7, NODIR,	WHITE+BRIGHT),
X  SPELL(NULL,		 "dull",	 0,  0, 0, 0,		HI_PAPER),
X  SPELL(NULL,		 "thin",	 0,  0, 0, 0,		HI_PAPER),
X  SPELL(NULL,		 "thick",	 0,  0, 0, 0,		HI_PAPER),
X--- 710,718 ----
X  SPELL("turn undead",	 "copper",	17,  8, 6, IMMEDIATE,	HI_COPPER),
X  SPELL("polymorph",	 "silver",	12,  8, 6, IMMEDIATE,	HI_SILVER),
X  SPELL("teleport away",	 "gold",	15,  6, 6, IMMEDIATE,	HI_GOLD),
X! SPELL("create familiar", "glittering", 	10,  7, 6, NODIR,	WHITE|BRIGHT),
X! SPELL("cancellation",	 "shining",	12,  8, 7, IMMEDIATE,	WHITE|BRIGHT),
X! SPELL("genocide",	 "glowing",	 5, 10, 7, NODIR,	WHITE|BRIGHT),
X  SPELL(NULL,		 "dull",	 0,  0, 0, 0,		HI_PAPER),
X  SPELL(NULL,		 "thin",	 0,  0, 0, 0,		HI_PAPER),
X  SPELL(NULL,		 "thick",	 0,  0, 0, 0,		HI_PAPER),
X***************
X*** 632,644 ****
X  #undef SPELL
X  #endif /* SPELLS /**/
X  
X  #define RING(name,stone,power,cost,spec,metal,color) \
X  		{ name, stone, NULL, 0,0,spec,spec,metal, \
X  		power, RING_SYM, 0, 0, 1, cost, 0, 0, 0, C(color)}
X  
X  RING("adornment",	"wooden",	ADORNED,	100, 1, WOOD, HI_WOOD),
X  RING("gain strength",	"granite",	0,		150, 1, MINERAL, HI_MINERAL),
X! RING("increase damage", "coral",	0,		150, 1, MINERAL, RED+BRIGHT),
X  RING("protection",	"black onyx",	PROTECTION,	100, 1, MINERAL, BLACK),
X  RING("regeneration",	"moonstone",	REGENERATION,	200, 0, MINERAL, HI_MINERAL),
X  RING("searching",	"tiger eye",	SEARCHING,	200, 0, MINERAL, BROWN),
X--- 719,736 ----
X  #undef SPELL
X  #endif /* SPELLS /**/
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define RING(name,stone,power,cost,spec,metal,color) \
X+ 	{ name, stone}
X+ #else
X  #define RING(name,stone,power,cost,spec,metal,color) \
X  		{ name, stone, NULL, 0,0,spec,spec,metal, \
X  		power, RING_SYM, 0, 0, 1, cost, 0, 0, 0, C(color)}
X+ #endif
X  
X  RING("adornment",	"wooden",	ADORNED,	100, 1, WOOD, HI_WOOD),
X  RING("gain strength",	"granite",	0,		150, 1, MINERAL, HI_MINERAL),
X! RING("increase damage", "coral",	0,		150, 1, MINERAL, RED|BRIGHT),
X  RING("protection",	"black onyx",	PROTECTION,	100, 1, MINERAL, BLACK),
X  RING("regeneration",	"moonstone",	REGENERATION,	200, 0, MINERAL, HI_MINERAL),
X  RING("searching",	"tiger eye",	SEARCHING,	200, 0, MINERAL, BROWN),
X***************
X*** 647,653 ****
X  RING("hunger",		"topaz",	HUNGER, 	100, 0, MINERAL, CYAN),
X  RING("aggravate monster", "sapphire",	AGGRAVATE_MONSTER, 150, 0, METAL, BLUE),
X  RING("conflict",	"ruby", 	CONFLICT,	300, 0, METAL, RED),
X! RING("warning", 	"diamond", 	WARNING,	100, 0, METAL, WHITE+BRIGHT),
X  RING("poison resistance", "pearl",	POISON_RES,	150, 0, METAL, WHITE),
X  RING("fire resistance", "iron",		FIRE_RES,	200, 0, METAL, HI_METAL),
X  RING("cold resistance", "brass",	COLD_RES,	150, 0, COPPER, HI_COPPER),
X--- 739,745 ----
X  RING("hunger",		"topaz",	HUNGER, 	100, 0, MINERAL, CYAN),
X  RING("aggravate monster", "sapphire",	AGGRAVATE_MONSTER, 150, 0, METAL, BLUE),
X  RING("conflict",	"ruby", 	CONFLICT,	300, 0, METAL, RED),
X! RING("warning", 	"diamond", 	WARNING,	100, 0, METAL, WHITE|BRIGHT),
X  RING("poison resistance", "pearl",	POISON_RES,	150, 0, METAL, WHITE),
X  RING("fire resistance", "iron",		FIRE_RES,	200, 0, METAL, HI_METAL),
X  RING("cold resistance", "brass",	COLD_RES,	150, 0, COPPER, HI_COPPER),
X***************
X*** 658,664 ****
X  #ifdef POLYSELF
X  RING("polymorph",	"ivory",	POLYMORPH,	300, 0, 0, WHITE),
X  RING("polymorph control","emerald",	POLYMORPH_CONTROL,
X! 							300, 0, METAL, GREEN+BRIGHT),
X  #endif
X  RING("invisibility",	"wire",		INVIS,		150, 0, METAL, HI_METAL),
X  RING("see invisible",	"engagement",	SEE_INVIS,	150, 0, METAL, HI_METAL),
X--- 750,756 ----
X  #ifdef POLYSELF
X  RING("polymorph",	"ivory",	POLYMORPH,	300, 0, 0, WHITE),
X  RING("polymorph control","emerald",	POLYMORPH_CONTROL,
X! 							300, 0, METAL, GREEN|BRIGHT),
X  #endif
X  RING("invisibility",	"wire",		INVIS,		150, 0, METAL, HI_METAL),
X  RING("see invisible",	"engagement",	SEE_INVIS,	150, 0, METAL, HI_METAL),
X***************
X*** 667,675 ****
X--- 759,772 ----
X  #undef RING
X  
X  /* gems ************************************************************/
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ #define GEM(name,desc,prob,wt,gval,glass, color) \
X+ 	{ name, desc}
X+ #else
X  #define GEM(name,desc,prob,wt,gval,glass, color) \
X  		{ name, desc, NULL, 0,1,0,0,glass, 0,\
X  		GEM_SYM, prob, 0, wt, gval, 3, 3, WP_SLING, C(color)}
X+ #endif
X  GEM("dilithium crystal", "white",	 3, 1, 4500, MINERAL, WHITE),
X  GEM("diamond", "white", 		 4, 1, 4000, MINERAL, WHITE),
X  GEM("ruby", "red",			 5, 1, 3500, MINERAL, RED),
X***************
X*** 694,704 ****
X--- 791,809 ----
X  GEM("worthless piece of violet glass", "violet",131, 1, 0, GLASS, MAGENTA),
X  GEM("luckstone", "gray",		 10, 1,  60, MINERAL, GRAY),
X  GEM("loadstone", "gray",		 10, 50,  1, MINERAL, GRAY),
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ { "rock", NULL},
X+ #else
X  { "rock", NULL, NULL, 1,1,0,0,MINERAL, 0,
X  		GEM_SYM, 10, 0, 1, 0, 3, 3, WP_SLING, C(HI_MINERAL)},
X+ #endif
X  #undef GEM
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ 	{ NULL, NULL}
X+ #else
X  	{ NULL, NULL, NULL, 0,0,0,0,0, 0, ILLOBJ_SYM, 0, 0, 0, 0, 0, 0, 0, C(0) }
X+ #endif
X  };
X  
X  #undef C
X*** src/Old/objnam.c	Sun Nov 19 13:52:54 1989
X--- src/objnam.c	Fri Nov 17 19:31:57 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)objnam.c	3.0	88/11/30
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)objnam.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 17,23 ****
X  			    "octagonal", "hexagonal", "wide",
X  			    "notched", "large round", "large square" };
X  
X! static int rnd_class P((int,int));
X  
X  static int
X  named_key(s) register char *s; {
X--- 17,23 ----
X  			    "octagonal", "hexagonal", "wide",
X  			    "notched", "large round", "large square" };
X  
X! static int FDECL(rnd_class, (int,int));
X  
X  static int
X  named_key(s) register char *s; {
X***************
X*** 80,86 ****
X  static char buf[BUFSZ];
X  #endif
X  register struct objclass *ocl = &objects[otyp];
X! register char *an = ocl->oc_name;
X  register char *dn = ocl->oc_descr;
X  register char *un = ocl->oc_uname;
X  register int nn = ocl->oc_name_known;
X--- 80,86 ----
X  static char buf[BUFSZ];
X  #endif
X  register struct objclass *ocl = &objects[otyp];
X! register char *actualn = ocl->oc_name;
X  register char *dn = ocl->oc_descr;
X  register char *un = ocl->oc_uname;
X  register int nn = ocl->oc_name_known;
X***************
X*** 104,110 ****
X  		break;
X  	case AMULET_SYM:
X  		if(nn)
X! 			Strcpy(buf,an);
X  		else
X  			Strcpy(buf,"amulet");
X  		if(un)
X--- 104,110 ----
X  		break;
X  	case AMULET_SYM:
X  		if(nn)
X! 			Strcpy(buf,actualn);
X  		else
X  			Strcpy(buf,"amulet");
X  		if(un)
X***************
X*** 114,120 ****
X  		return(buf);
X  	default:
X  		if(nn) {
X! 			Strcpy(buf, an);
X  			if(otyp >= TURQUOISE && otyp <= JADE)
X  				Strcat(buf, " stone");
X  			if(un)
X--- 114,120 ----
X  		return(buf);
X  	default:
X  		if(nn) {
X! 			Strcpy(buf, actualn);
X  			if(otyp >= TURQUOISE && otyp <= JADE)
X  				Strcat(buf, " stone");
X  			if(un)
X***************
X*** 122,128 ****
X  			if(dn)
X  				Sprintf(eos(buf), " (%s)", dn);
X  		} else {
X! 			Strcpy(buf, dn ? dn : an);
X  			if(ocl->oc_olet == GEM_SYM) {
X  				if (otyp == LOADSTONE || otyp == LUCKSTONE)
X  					Strcat(buf, " stone");
X--- 122,128 ----
X  			if(dn)
X  				Sprintf(eos(buf), " (%s)", dn);
X  		} else {
X! 			Strcpy(buf, dn ? dn : actualn);
X  			if(ocl->oc_olet == GEM_SYM) {
X  				if (otyp == LOADSTONE || otyp == LUCKSTONE)
X  					Strcat(buf, " stone");
X***************
X*** 136,142 ****
X  	}
X  	/* here for ring/scroll/potion/wand */
X  	if(nn)
X! 		Sprintf(eos(buf), " of %s", an);
X  	if(un)
X  		Sprintf(eos(buf), " called %s", un);
X  	if(dn)
X--- 136,142 ----
X  	}
X  	/* here for ring/scroll/potion/wand */
X  	if(nn)
X! 		Sprintf(eos(buf), " of %s", actualn);
X  	if(un)
X  		Sprintf(eos(buf), " called %s", un);
X  	if(dn)
X***************
X*** 154,160 ****
X  char *
X  distant_name(obj, func)
X  register struct obj *obj;
X! char *(*func) P((struct obj *));
X  {
X  	char *str;
X  
X--- 154,160 ----
X  char *
X  distant_name(obj, func)
X  register struct obj *obj;
X! char *FDECL((*func), (struct obj *));
X  {
X  	char *str;
X  
X***************
X*** 176,182 ****
X  #endif
X  register char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
X  register int nn = objects[obj->otyp].oc_name_known;
X! register char *an = objects[obj->otyp].oc_name;
X  register char *dn = objects[obj->otyp].oc_descr;
X  register char *un = objects[obj->otyp].oc_uname;
X  
X--- 176,182 ----
X  #endif
X  register char *buf = &(bufr[PREFIX]);	/* leave room for "17 -3 " */
X  register int nn = objects[obj->otyp].oc_name_known;
X! register char *actualn = objects[obj->otyp].oc_name;
X  register char *dn = objects[obj->otyp].oc_descr;
X  register char *un = objects[obj->otyp].oc_uname;
X  
X***************
X*** 187,197 ****
X  		if(obj->otyp == AMULET_OF_YENDOR) {
X  		    Strcpy(buf, (obj->spe < 0 && obj->known) ?
X  			   "cheap plastic imitation of the " : "");
X! 		    Strcat(buf, an);
X  		} else if (!obj->dknown)
X  			Strcpy(buf, "amulet");
X  		else if (nn)
X! 			Strcpy(buf, an);
X  		else if (un)
X  			Sprintf(buf,"amulet called %s", un);
X  		else
X--- 187,197 ----
X  		if(obj->otyp == AMULET_OF_YENDOR) {
X  		    Strcpy(buf, (obj->spe < 0 && obj->known) ?
X  			   "cheap plastic imitation of the " : "");
X! 		    Strcat(buf, actualn);
X  		} else if (!obj->dknown)
X  			Strcpy(buf, "amulet");
X  		else if (nn)
X! 			Strcpy(buf, actualn);
X  		else if (un)
X  			Sprintf(buf,"amulet called %s", un);
X  		else
X***************
X*** 202,216 ****
X  			Strcpy(buf, "poisoned ");
X  	    case VENOM_SYM:
X  	    case TOOL_SYM:
X! 		if(nn)	Strcat(buf, an);
X  		else	Strcat(buf, dn);
X! 		if(obj->otyp == FIGURINE) {
X! 			Sprintf(eos(buf), " of a%s %s",
X! 				index(vowels, *mons[obj->corpsenm].mname)
X! 								? "n" : "",
X! 				mons[obj->corpsenm].mname);
X! 			break;
X! 		}
X  		break;
X  	    case ARMOR_SYM:
X  		if(obj->otyp==DRAGON_SCALE_MAIL) {
X--- 202,212 ----
X  			Strcpy(buf, "poisoned ");
X  	    case VENOM_SYM:
X  	    case TOOL_SYM:
X! 		if(nn)	Strcat(buf, actualn);
X  		else	Strcat(buf, dn);
X! 		if(obj->otyp == FIGURINE)
X! 			Sprintf(eos(buf), " of %s",
X! 				an(mons[obj->corpsenm].mname));
X  		break;
X  	    case ARMOR_SYM:
X  		if(obj->otyp==DRAGON_SCALE_MAIL) {
X***************
X*** 221,227 ****
X  
X  		if(is_boots(obj) || is_gloves(obj)) Strcpy(buf,"pair of ");
X  
X! 		if(nn)	Strcat(buf, an);
X  		else if(un) {
X  			if(is_boots(obj))
X  				Strcat(buf,"boots");
X--- 217,223 ----
X  
X  		if(is_boots(obj) || is_gloves(obj)) Strcpy(buf,"pair of ");
X  
X! 		if(nn)	Strcat(buf, actualn);
X  		else if(un) {
X  			if(is_boots(obj))
X  				Strcat(buf,"boots");
X***************
X*** 254,260 ****
X  			break;
X  		}
X  #endif
X! 		Strcpy(buf, an);
X  		if(obj->otyp == TIN && obj->known) {
X  		    if(obj->spe > 0)
X  			Strcat(buf, " of spinach");
X--- 250,256 ----
X  			break;
X  		}
X  #endif
X! 		Strcpy(buf, actualn);
X  		if(obj->otyp == TIN && obj->known) {
X  		    if(obj->spe > 0)
X  			Strcat(buf, " of spinach");
X***************
X*** 266,279 ****
X  		}
X  		break;
X  	    case CHAIN_SYM:
X! 		Strcpy(buf, an);
X  		break;
X  	    case ROCK_SYM:
X  		if(obj->otyp == STATUE)
X! 		    Sprintf(buf, "%s of a%s %s", an,
X! 			    (index(vowels, *(mons[obj->corpsenm].mname))) ? "n" : "",
X! 			    mons[obj->corpsenm].mname);
X! 		else Strcpy(buf, an);
X  		break;
X  	    case BALL_SYM:
X  		Sprintf(buf, "%sheavy iron ball",
X--- 262,273 ----
X  		}
X  		break;
X  	    case CHAIN_SYM:
X! 		Strcpy(buf, actualn);
X  		break;
X  	    case ROCK_SYM:
X  		if(obj->otyp == STATUE)
X! 		    Sprintf(buf, "%s of %s", actualn, an(mons[obj->corpsenm].mname));
X! 		else Strcpy(buf, actualn);
X  		break;
X  	    case BALL_SYM:
X  		Sprintf(buf, "%sheavy iron ball",
X***************
X*** 291,297 ****
X  			       (obj->blessed || obj->cursed)) {
X  				Strcat(buf, obj->blessed ? "holy " : "unholy ");
X  			    }
X! 			    Strcat(buf, an);
X  			} else {
X  				Strcat(buf, " called ");
X  				Strcat(buf, un);
X--- 285,291 ----
X  			       (obj->blessed || obj->cursed)) {
X  				Strcat(buf, obj->blessed ? "holy " : "unholy ");
X  			    }
X! 			    Strcat(buf, actualn);
X  			} else {
X  				Strcat(buf, " called ");
X  				Strcat(buf, un);
X***************
X*** 306,312 ****
X  		if(!obj->dknown) break;
X  		if(nn) {
X  			Strcat(buf, " of ");
X! 			Strcat(buf, an);
X  		} else if(un) {
X  			Strcat(buf, " called ");
X  			Strcat(buf, un);
X--- 300,306 ----
X  		if(!obj->dknown) break;
X  		if(nn) {
X  			Strcat(buf, " of ");
X! 			Strcat(buf, actualn);
X  		} else if(un) {
X  			Strcat(buf, " called ");
X  			Strcat(buf, un);
X***************
X*** 319,325 ****
X  		if(!obj->dknown)
X  			Sprintf(buf, "wand");
X  		else if(nn)
X! 			Sprintf(buf, "wand of %s", an);
X  		else if(un)
X  			Sprintf(buf, "wand called %s", un);
X  		else
X--- 313,319 ----
X  		if(!obj->dknown)
X  			Sprintf(buf, "wand");
X  		else if(nn)
X! 			Sprintf(buf, "wand of %s", actualn);
X  		else if(un)
X  			Sprintf(buf, "wand called %s", un);
X  		else
X***************
X*** 330,336 ****
X  		if(!obj->dknown)
X  			Sprintf(buf, "spellbook");
X  		else if(nn)
X! 			Sprintf(buf, "spellbook of %s", an);
X  		else if(un)
X  			Sprintf(buf, "spellbook called %s", un);
X  		else
X--- 324,330 ----
X  		if(!obj->dknown)
X  			Sprintf(buf, "spellbook");
X  		else if(nn)
X! 			Sprintf(buf, "spellbook of %s", actualn);
X  		else if(un)
X  			Sprintf(buf, "spellbook called %s", un);
X  		else
X***************
X*** 341,347 ****
X  		if(!obj->dknown)
X  			Sprintf(buf, "ring");
X  		else if(nn)
X! 			Sprintf(buf, "ring of %s", an);
X  		else if(un)
X  			Sprintf(buf, "ring called %s", un);
X  		else
X--- 335,341 ----
X  		if(!obj->dknown)
X  			Sprintf(buf, "ring");
X  		else if(nn)
X! 			Sprintf(buf, "ring of %s", actualn);
X  		else if(un)
X  			Sprintf(buf, "ring called %s", un);
X  		else
X***************
X*** 363,369 ****
X  			else	Sprintf(buf, "%s %s", dn, rock);
X  			break;
X  		}
X! 		Strcpy(buf, an);
X  		if(obj->otyp >= TURQUOISE && obj->otyp <= JADE)
X  			Strcat(buf, " stone");
X  		break;
X--- 357,363 ----
X  			else	Sprintf(buf, "%s %s", dn, rock);
X  			break;
X  		}
X! 		Strcpy(buf, actualn);
X  		if(obj->otyp >= TURQUOISE && obj->otyp <= JADE)
X  			Strcat(buf, " stone");
X  		break;
X***************
X*** 484,490 ****
X  			Sprintf(eos(bp), " (%s keyhole)", lockstr[obj->spe]);
X  			break;
X  		}
X! 		if(obj->otyp == PICK_AXE) goto plus;
X  		if(!objects[obj->otyp].oc_charged) break;
X  		/* if special tool, fall through to show charges */
X  	case WAND_SYM:
X--- 478,485 ----
X  			Sprintf(eos(bp), " (%s keyhole)", lockstr[obj->spe]);
X  			break;
X  		}
X! 		if(obj->otyp == PICK_AXE || obj->otyp == UNICORN_HORN)
X! 			goto plus;
X  		if(!objects[obj->otyp].oc_charged) break;
X  		/* if special tool, fall through to show charges */
X  	case WAND_SYM:
X***************
X*** 539,545 ****
X  		Strcat(bp, " (unpaid)");
X  	if (!strncmp(prefix, "a ", 2) &&
X  			index(vowels, *(prefix+2) ? *(prefix+2) : *bp)
X! 			&& (*(prefix+2) || strncmp(bp, "uranium", 7))) {
X  		Strcpy(tmpbuf, prefix);
X  		Strcpy(prefix, "an ");
X  		Strcpy(prefix+3, tmpbuf+2);
X--- 534,541 ----
X  		Strcat(bp, " (unpaid)");
X  	if (!strncmp(prefix, "a ", 2) &&
X  			index(vowels, *(prefix+2) ? *(prefix+2) : *bp)
X! 			&& (*(prefix+2) || (strncmp(bp, "uranium", 7)
X! 				&& strncmp(bp, "unicorn", 7)))) {
X  		Strcpy(tmpbuf, prefix);
X  		Strcpy(prefix, "an ");
X  		Strcpy(prefix+3, tmpbuf+2);
X***************
X*** 553,587 ****
X   */
X  
X  char *
X! singular(otmp)
X  register struct obj *otmp;
X  {
X  	int savequan;
X  	char *nam;
X  
X  	/* Note: using xname for corpses will not give the monster type */
X! 	if (otmp->otyp == CORPSE) {
X  		static char buf[31];
X  
X! 		sprintf(buf, "%s corpse", mons[otmp->corpsenm].mname);
X  		return buf;
X  	}
X  	savequan = otmp->quan;
X  	otmp->quan = 1;
X! 	nam = xname(otmp);
X  	otmp->quan = savequan;
X  	return nam;
X  }
X  
X! /* used only in mthrowu.c (thitu) */
X! void
X! setan(str,buf)
X! register char *str,*buf;
X  {
X! 	if(index(vowels,*str))
X! 		Sprintf(buf, "an %s", str);
X! 	else
X! 		Sprintf(buf, "a %s", str);
X  }
X  
X  char *
X--- 549,602 ----
X   */
X  
X  char *
X! singular(otmp, func)
X  register struct obj *otmp;
X+ char *FDECL((*func), (struct obj *));
X  {
X  	int savequan;
X  	char *nam;
X  
X  	/* Note: using xname for corpses will not give the monster type */
X! 	if (otmp->otyp == CORPSE && func == xname) {
X  		static char buf[31];
X  
X! 		Sprintf(buf, "%s corpse", mons[otmp->corpsenm].mname);
X  		return buf;
X  	}
X  	savequan = otmp->quan;
X  	otmp->quan = 1;
X! 	nam = (*func)(otmp);
X  	otmp->quan = savequan;
X  	return nam;
X  }
X  
X! char *
X! an(str)
X! register char *str;
X  {
X! 	static char buf[BUFSZ];
X! 
X! 	buf[0] = '\0';
X! 
X! 	if (strncmp(str, "the ", 4))
X! 	    if (index(vowels, *str) &&
X! 		strncmp(str, "unicorn", 7) &&
X! 		strncmp(str, "uranium", 7))
X! 		    Strcpy(buf, "an ");
X! 	    else
X! 		    Strcpy(buf, "a ");
X! 
X! 	Strcat(buf, str);
X! 	return buf;
X! }
X! 
X! char *
X! An(str)
X! register char *str;
X! {
X! 	str = an(str);
X! 	if (*str == 'a') *str = 'A';
X! 	return str;
X  }
X  
X  char *
X***************
X*** 752,758 ****
X  	}
X  
X  	/* fungus/fungi, homunculus/homunculi, but wumpuses */
X! 	if (!strcmp(spot-1, "us") && strcmp(spot-6, "wumpus")) {
X  		*(spot--) = (char)0;
X  		*spot = 'i';
X  		goto bottom;
X--- 767,773 ----
X  	}
X  
X  	/* fungus/fungi, homunculus/homunculi, but wumpuses */
X! 	if (!strcmp(spot-1, "us") && strcmp(spot-5, "wumpus")) {
X  		*(spot--) = (char)0;
X  		*spot = 'i';
X  		goto bottom;
X***************
X*** 838,851 ****
X  	return str;
X  }
X  
X! static const char *armor_classes[] = {
X! 	/* "shield called reflection" gives a specific type of shield.
X! 	 * "shield" gives a random type of shield--but not of all armor.
X! 	 */
X! 	"gloves", "boots", "cloak", "shield", "helmet"
X  };
X! #define ARMOR_CLASSES 5
X  
X  /* Return something wished for.  If not an object, return &zeroobj; if an error
X   * (no matching object), return (struct obj *)0.  Giving readobjnam() a null
X   * pointer skips the error return and creates a random object instead.
X--- 853,944 ----
X  	return str;
X  }
X  
X! /* wishable subranges of objects */
X! static const struct o_range {
X! 	char *name, osym;
X! 	int  f_o_range, l_o_range;
X! } o_ranges[] = {
X! 	{ "bag",	TOOL_SYM,   SACK,	    BAG_OF_TRICKS },
X! 	{ "gloves",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X! 	{ "gauntlets",	ARMOR_SYM,  LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY },
X! 	{ "boots",	ARMOR_SYM,  LOW_BOOTS,	    LEVITATION_BOOTS },
X! 	{ "shoes",	ARMOR_SYM,  LOW_BOOTS,	    IRON_SHOES },
X! 	{ "cloak",	ARMOR_SYM,  MUMMY_WRAPPING, CLOAK_OF_DISPLACEMENT },
X! 	{ "shield",	ARMOR_SYM,  SMALL_SHIELD,   SHIELD_OF_REFLECTION },
X! #ifdef TOLKIEN	/* note: "helmet" is a specific item */
X! 	{ "helm",	ARMOR_SYM,  ELVEN_LEATHER_HELM, HELM_OF_TELEPATHY },
X! #else
X! 	{ "helm",	ARMOR_SYM,  ORCISH_HELM,    HELM_OF_TELEPATHY },
X! #endif
X! 	{ "sword",	WEAPON_SYM, SHORT_SWORD,    KATANA }
X  };
X! 
X! 
X! /*
X!  * Singularize a string the user typed in; this helps reduce the complexity
X!  * of readobjnam.
X!  */
X! 
X! static
X! void
X! singularize(bp)
X! char *bp;
X! {
X! 	char *p;
X  
X+ 	/* find "cloves of garlic", "worthless pieces of blue glass" */
X+ 	for(p = bp; *p; p++) 
X+ 	    if(!strncmp(p, "s of ", 5)){
X+ 		/* but don't singularize "gauntlets" */
X+ 		if(strncmp(p-8, "gauntlet", 8))
X+ 			while(*p = p[1]) p++;
X+ 		return;
X+ 	    }
X+ 
X+ 	/* remove -s or -es (boxes) or -ies (rubies) */
X+ 	p = eos(bp);
X+ 	if(p[-1] == 's') {
X+ 		if(p[-2] == 'e') {
X+ 			if(p[-3] == 'i') {
X+ 				if(!strcmp(p-7, "cookies") ||
X+ 				   !strcmp(p-4, "pies"))
X+ 					goto mins;
X+ 				Strcpy(p-3, "y");
X+ 				return;
X+ 			}
X+ 
X+ 			/* note: cloves / knives from clove / knife */
X+ 			if(!strcmp(p-6, "knives")) {
X+ 				Strcpy(p-3, "fe");
X+ 				return;
X+ 			}
X+ 
X+ 			if(!strcmp(p-6, "staves")) {
X+ 				Strcpy(p-3, "ff");
X+ 				return;
X+ 			}
X+ 
X+ 			/* note: nurses, axes but boxes */
X+ 			if(!strcmp(p-5, "boxes")) {
X+ 				p[-2] = 0;
X+ 				return;
X+ 			}
X+ 		}
X+ 		/* but don't singularize boots or gloves */
X+ 		else if(!strcmp(p-5, "boots") ||
X+ 			!strcmp(p-6, "gloves"))
X+ 				return;
X+ 	mins:
X+ 		p[-1] = 0;
X+ 	} else {
X+ 		if(!strcmp(p-5, "teeth")) {
X+ 			Strcpy(p-5, "tooth");
X+ 			return;
X+ 		}
X+ 		/* here we cannot find the plural suffix */
X+ 	}
X+ }
X+ 
X  /* Return something wished for.  If not an object, return &zeroobj; if an error
X   * (no matching object), return (struct obj *)0.  Giving readobjnam() a null
X   * pointer skips the error return and creates a random object instead.
X***************
X*** 994,1002 ****
X  		/* "helmet called telepathy" is not "helmet" (a specific type)
X  		 * "shield called reflection" is not "shield" (a general type)
X  		 */
X! 		for(i=0; i<ARMOR_CLASSES; i++)
X! 		    if(!strncmp(bp,armor_classes[i], strlen(armor_classes[i]))){
X! 			let = ARMOR_SYM;
X  			goto srch;
X  		    }
X  	}
X--- 1087,1095 ----
X  		/* "helmet called telepathy" is not "helmet" (a specific type)
X  		 * "shield called reflection" is not "shield" (a general type)
X  		 */
X! 		for(i = 0; i < SIZE(o_ranges); i++)
X! 		    if(!strcmp(bp, o_ranges[i].name)) {
X! 			let = o_ranges[i].osym;
X  			goto srch;
X  		    }
X  	}
X***************
X*** 1042,1100 ****
X  	}
X  
X  	/* first change to singular if necessary */
X! 	if(cnt != 1) {
X! 		/* find "cloves of garlic", "worthless pieces of blue glass" */
X! 		for(p = bp; *p; p++) 
X! 		    if(!strncmp(p, "s of ", 5)){
X! 			/* but don't singularize "gauntlets" */
X! 			if(strncmp(p-8, "gauntlet", 8))
X! 				while(*p = p[1]) p++;
X! 			goto sing;
X! 		    }
X! 		/* remove -s or -es (boxes) or -ies (rubies) */
X! 		p = eos(bp);
X! 		if(p[-1] == 's') {
X! 			if(p[-2] == 'e') {
X! 				if(p[-3] == 'i') {
X! 
X! 					if(!strcmp(p-7, "cookies") ||
X! 					   !strcmp(p-4, "pies"))
X! 						goto mins;
X! 					Strcpy(p-3, "y");
X! 					goto sing;
X! 				}
X! 
X! 				/* note: cloves / knives from clove / knife */
X! 				if(!strcmp(p-6, "knives")) {
X! 					Strcpy(p-3, "fe");
X! 					goto sing;
X! 				}
X! 
X! 				if(!strcmp(p-6, "staves")) {
X! 					Strcpy(p-3, "ff");
X! 					goto sing;
X! 				}
X  
X- 				/* note: nurses, axes but boxes */
X- 				if(!strcmp(p-5, "boxes")) {
X- 					p[-2] = 0;
X- 					goto sing;
X- 				}
X- 			}
X- 			/* but don't singularize boots or gloves */
X- 			else if(!strcmp(p-5, "boots") ||
X- 				!strcmp(p-6, "gloves"))
X- 					goto sing;
X- 		mins:
X- 			p[-1] = 0;
X- 		} else {
X- 			if(!strcmp(p-5, "teeth")) {
X- 				Strcpy(p-5, "tooth");
X- 				goto sing;
X- 			}
X- 			/* here we cannot find the plural suffix */
X- 		}
X- 	}
X  sing:
X  	/* Maybe we need a special strcmp() which ignores capitalization and
X  	 * dashes/spaces/underscores, so the below 3 special cases would be
X--- 1135,1143 ----
X  	}
X  
X  	/* first change to singular if necessary */
X! 	if(cnt != 1)
X! 		singularize(bp);
X  
X  sing:
X  	/* Maybe we need a special strcmp() which ignores capitalization and
X  	 * dashes/spaces/underscores, so the below 3 special cases would be
X***************
X*** 1229,1255 ****
X  		typ = HEAVY_IRON_BALL;
X  		goto typfnd;
X  	}
X! 	if(!strcmp(bp, "bag")) {
X! 		typ = rnd_class(SACK, BAG_OF_TRICKS);
X! 		goto typfnd;
X! 	}
X! 	if(!strcmp(bp, armor_classes[0])){ /* pair of gloves */
X! 		typ = rnd_class(LEATHER_GLOVES, GAUNTLETS_OF_DEXTERITY);
X! 		goto typfnd;
X! 	}
X! 	if(!strcmp(bp, armor_classes[1])){ /* pair of boots */
X! 		typ = rnd_class(LOW_BOOTS, LEVITATION_BOOTS);
X! 		goto typfnd;
X! 	}
X! 	if(!strcmp(bp, armor_classes[2])){ /* cloak */
X! 		typ = rnd_class(MUMMY_WRAPPING, CLOAK_OF_DISPLACEMENT);
X! 		goto typfnd;
X! 	}
X! 	if(!strcmp(bp, armor_classes[3])){ /* shield */
X! 		typ = rnd_class(SMALL_SHIELD, SHIELD_OF_REFLECTION);
X  		goto typfnd;
X! 	}
X! 	/* helmet is not generic */
X  
X  	an = bp;
X  	if (!dn) dn = an; /* ex. "black cap" */
X--- 1272,1282 ----
X  		typ = HEAVY_IRON_BALL;
X  		goto typfnd;
X  	}
X! 	for (i = 0; i < SIZE(o_ranges); i++)
X! 	    if(!strcmp(bp, o_ranges[i].name)) {
X! 		typ = rnd_class(o_ranges[i].f_o_range, o_ranges[i].l_o_range);
X  		goto typfnd;
X! 	    }
X  
X  	an = bp;
X  	if (!dn) dn = an; /* ex. "black cap" */
X***************
X*** 1332,1337 ****
X--- 1359,1365 ----
X  	else if (wizard) /* no alteration to spe */ ;
X  #endif
X  	else if (let == ARMOR_SYM || let == WEAPON_SYM || typ == PICK_AXE ||
X+ 			typ == UNICORN_HORN ||
X  			(let==RING_SYM && objects[typ].oc_charged)) {
X  		if(spe > rnd(5) && spe > otmp->spe) spe = 0;
X  		if(spe > 2 && u.uluck < 0) spesgn = -1;
X***************
X*** 1461,1467 ****
X  	if (name) otmp = oname(otmp, name, 0);
X  	otmp->owt = weight(otmp);
X  	if (heavy) otmp->owt += 15;
X! 	if (halfeaten && otmp->olet == FOOD_SYM) otmp->oeaten = TRUE;
X  	return(otmp);
X  }
X  
X--- 1489,1503 ----
X  	if (name) otmp = oname(otmp, name, 0);
X  	otmp->owt = weight(otmp);
X  	if (heavy) otmp->owt += 15;
X! 	if (halfeaten && otmp->olet == FOOD_SYM) {
X! 		if (otmp->otyp == CORPSE)
X! 			otmp->oeaten = mons[otmp->corpsenm].cnutrit;
X! 		else otmp->oeaten = objects[otmp->otyp].nutrition;
X! 		otmp->owt /= 2;
X! 		otmp->oeaten /= 2;
X! 		if (!otmp->owt) otmp->owt = 1;
X! 		if (!otmp->oeaten) otmp->oeaten = 1;
X! 	}
X  	return(otmp);
X  }
X  
X*** src/Old/options.c	Sun Nov 19 13:53:46 1989
X--- src/options.c	Fri Nov 17 19:31:59 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)options.c	3.0	88/11/09
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)options.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,12 ****
X  #include "hack.h"
X  static boolean set_order;
X  
X! static void nmcpy P((char *, char *, int));
X! static int next_opt P((char *));
X  
X  void
X  initoptions()
X--- 5,12 ----
X  #include "hack.h"
X  static boolean set_order;
X  
X! static void FDECL(nmcpy, (char *, char *, int));
X! static int FDECL(next_opt, (char *));
X  
X  void
X  initoptions()
X***************
X*** 143,192 ****
X  register unsigned int *graph_ints;
X  register int glth;
X  {
X! #define SETPCHAR(f, n)	showsyms.f = (glth > n) ? graph_ints[n] : defsyms.f
X! 	SETPCHAR(stone, 0);
X! 	SETPCHAR(vwall, 1);
X! 	SETPCHAR(hwall, 2);
X! 	SETPCHAR(tlcorn, 3);
X! 	SETPCHAR(trcorn, 4);
X! 	SETPCHAR(blcorn, 5);
X! 	SETPCHAR(brcorn, 6);
X! 	SETPCHAR(crwall, 7);
X! 	SETPCHAR(tuwall, 8);
X! 	SETPCHAR(tdwall, 9);
X! 	SETPCHAR(tlwall, 10);
X! 	SETPCHAR(trwall, 11);
X! 	SETPCHAR(vbeam, 12);
X! 	SETPCHAR(hbeam, 13);
X! 	SETPCHAR(lslant, 14);
X! 	SETPCHAR(rslant, 15);
X! 	SETPCHAR(door, 16);
X! 	SETPCHAR(room, 17);
X! 	SETPCHAR(corr, 18);
X! 	SETPCHAR(upstair, 19);
X! 	SETPCHAR(dnstair, 20);
X! 	SETPCHAR(trap, 21);
X! 	SETPCHAR(web, 22);
X! 	SETPCHAR(pool, 23);
X! #ifdef FOUNTAINS
X! 	SETPCHAR(fountain, 24);
X! #endif
X! #ifdef SINKS
X! 	SETPCHAR(sink, 25);
X! #endif
X! #ifdef THRONES
X! 	SETPCHAR(throne, 26);
X! #endif
X! #ifdef ALTARS
X! 	SETPCHAR(altar, 27);
X! #endif
X! #ifdef STRONGHOLD
X! 	SETPCHAR(upladder, 28);
X! 	SETPCHAR(dnladder, 29);
X! 	SETPCHAR(dbvwall, 30);
X! 	SETPCHAR(dbhwall, 31);
X! #endif
X! #undef SETPCHAR
X  }
X  
X  void
X--- 143,155 ----
X  register unsigned int *graph_ints;
X  register int glth;
X  {
X! 	register int i;
X! 
X! 	if (glth > MAXPCHARS) glth = MAXPCHARS;		/* sanity check */
X! 	for (i = 0; i < glth; i++)
X! 		showsyms[i] = graph_ints[i];
X! 	for (i = glth; i < MAXPCHARS; i++)
X! 		showsyms[i] = defsyms[i];
X  }
X  
X  void
END_OF_FILE
if test 57020 -ne `wc -c <'patches06i'`; then
    echo shar: \"'patches06i'\" unpacked with wrong size!
fi
# end of 'patches06i'
fi
echo shar: End of archive 9 \(of 15\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
