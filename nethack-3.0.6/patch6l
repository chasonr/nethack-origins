Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i065:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6l
Message-ID: <4854@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:55:04 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2038
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 65
Archive-name: NetHack3/Patch6l
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 15)."
# Contents:  patches06l
# Wrapped by billr@saab on Wed Nov 22 10:50:19 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches06l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06l'\"
else
echo shar: Extracting \"'patches06l'\" \(52555 characters\)
sed "s/^X//" >'patches06l' <<'END_OF_FILE'
X*** src/Old/topl.c	Sun Nov 19 13:15:11 1989
X--- src/topl.c	Sun Oct 22 11:45:53 1989
X***************
X*** 320,326 ****
X  
X  void
X  putstr(s)
X! register char *s;
X  {
X  	while(*s) putsym(*s++);
X  }
X--- 320,326 ----
X  
X  void
X  putstr(s)
X! register const char *s;
X  {
X  	while(*s) putsym(*s++);
X  }
X***************
X*** 327,333 ****
X  
X  char
X  yn_function(resp, def)
X! char *resp, def;
X  /*
X   *   Generic yes/no function
X   */
X--- 327,334 ----
X  
X  char
X  yn_function(resp, def)
X! const char *resp;
X! char def;
X  /*
X   *   Generic yes/no function
X   */
X*** src/Old/topten.c	Sun Nov 19 13:15:26 1989
X--- src/topten.c	Sat Nov 18 21:20:51 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)topten.c	3.0	88/11/24
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)topten.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 37,45 ****
X  	char date[7];		/* yymmdd */
X  } *tt_head;
X  
X! static char *itoa P((int)), *ordin P((int));
X  static void outheader();
X! static int outentry P((int,struct toptenentry *,int));
X  
X  void
X  topten(){
X--- 37,45 ----
X  	char date[7];		/* yymmdd */
X  } *tt_head;
X  
X! static char *FDECL(itoa, (int)), *FDECL(ordin, (int));
X  static void outheader();
X! static int FDECL(outentry, (int,struct toptenentry *,int));
X  
X  void
X  topten(){
X***************
X*** 416,422 ****
X  		Strcat(linebuf, "starved to death");
X  		starv = TRUE;
X  	  } else if(!strcmp(t1->death,"poisoned")) {
X! 		Strcat(linebuf, "was posioned");
X  	  } else if(!strcmp(t1->death,"crushed")) {
X  		Strcat(linebuf, "was crushed to death");
X  	  } else if(!strncmp(t1->death, "turned to stone by ",19)) {
X--- 416,422 ----
X  		Strcat(linebuf, "starved to death");
X  		starv = TRUE;
X  	  } else if(!strcmp(t1->death,"poisoned")) {
X! 		Strcat(linebuf, "was poisoned");
X  	  } else if(!strcmp(t1->death,"crushed")) {
X  		Strcat(linebuf, "was crushed to death");
X  	  } else if(!strncmp(t1->death, "turned to stone by ",19)) {
X***************
X*** 437,452 ****
X  	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X  	  if(quit && t1->death[4]) Strcat(linebuf, t1->death + 4);
X  	}
X! 	if(iskilled) Sprintf(eos(linebuf), " by %s%s",
X  	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X  	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X  	   || !strcmp(t1->death, "contaminated water")
X  	   || (!strncmp(eos(t1->death)-4,"tion",4) && *(eos(t1->death)-5)!='o')
X! 	   ) ? "" :
X! 	  index(vowels,*t1->death) ? "an " : "a ",
X! 	  t1->death);
X! 	if (isstoned) Sprintf(eos(linebuf), " by %s%s", index(vowels,
X! 		*(t1->death + 19)) ? "an " : "a ", t1->death + 19);
X  	Strcat(linebuf, ".");
X  	if(t1->maxhp) {
X  	  register char *bp = eos(linebuf);
X--- 437,449 ----
X  	    Sprintf(eos(linebuf), " [max %d]", t1->maxlvl);
X  	  if(quit && t1->death[4]) Strcat(linebuf, t1->death + 4);
X  	}
X! 	if(iskilled) Sprintf(eos(linebuf), " by %s",
X  	  (!strncmp(t1->death, "trick", 5) || !strncmp(t1->death, "the ", 4)
X  	   || !strncmp(t1->death, "Mr. ", 4) || !strncmp(t1->death, "Ms. ", 4)
X  	   || !strcmp(t1->death, "contaminated water")
X  	   || (!strncmp(eos(t1->death)-4,"tion",4) && *(eos(t1->death)-5)!='o')
X! 	   ) ? t1->death : an(t1->death));
X! 	if (isstoned) Sprintf(eos(linebuf), " by %s", an(t1->death + 19));
X  	Strcat(linebuf, ".");
X  	if(t1->maxhp) {
X  	  register char *bp = eos(linebuf);
X***************
X*** 566,572 ****
X  		if(!argv[1][2]){
X  			argc--;
X  			argv++;
X! 		} else if(!argv[1][3] && index("ABCEHKPRSTVW", argv[1][2])) {
X  			argv[1]++;
X  			argv[1][0] = '-';
X  		} else	argv[1] += 2;
X--- 563,569 ----
X  		if(!argv[1][2]){
X  			argc--;
X  			argv++;
X! 		} else if(!argv[1][3] && index(pl_classes, argv[1][2])) {
X  			argv[1]++;
X  			argv[1][0] = '-';
X  		} else	argv[1] += 2;
X***************
X*** 680,688 ****
X  	   .hacklog or something in his home directory. */
X  	flags.beginner = (total_score < 6000);
X  	for(i=0; i<6; i++)
X! 	    if(!index(totchars, "ABCEHKPRSTVW"[i])) {
X  		flags.beginner = 1;
X! 		if(!pl_character[0]) pl_character[0] = "ABCEHKPRSTVW"[i];
X  		break;
X  	}
X  #endif /* nonsense /**/
X--- 677,685 ----
X  	   .hacklog or something in his home directory. */
X  	flags.beginner = (total_score < 6000);
X  	for(i=0; i<6; i++)
X! 	    if(!index(totchars, pl_classes[i])) {
X  		flags.beginner = 1;
X! 		if(!pl_character[0]) pl_character[0] = pl_classes[i];
X  		break;
X  	}
X  #endif /* nonsense /**/
X*** src/Old/trap.c	Sun Nov 19 13:16:07 1989
X--- src/trap.c	Sat Nov 11 17:06:43 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)trap.c	3.0	88/10/22
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)trap.c	3.0	89/11/10
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 196,201 ****
X--- 196,207 ----
X  			      Levitation ? "float" : "fly");
X  			break;
X  		    }
X+ #ifdef POLYSELF
X+ 		    if(amorphous(uasmon)) {
X+ 			pline("A bear trap closes harmlessly through you.");
X+ 			break;
X+ 		    }
X+ #endif
X  		    u.utrap = 4 + rn2(4);
X  		    u.utraptype = TT_BEARTRAP;
X  		    pline("A bear trap closes on your %s!",
X***************
X*** 207,221 ****
X  		    break;
X  		case STATUE_TRAP:
X  		    deltrap(trap);
X! 		    for(otmp=fobj; otmp; otmp=otmp->nobj) {
X! 			if(otmp->otyp == STATUE && otmp->ox == u.ux &&
X! 				otmp->oy == u.uy && otmp->corpsenm == trap->pm)
X  			    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X  				pline("The statue comes to life!");
X  				delobj(otmp);
X  				break;
X  			    }
X- 		    }
X  		    break;
X  		case MONST_TRAP:
X  		    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X--- 213,226 ----
X  		    break;
X  		case STATUE_TRAP:
X  		    deltrap(trap);
X! 		    for(otmp=level.objects[u.ux][u.uy];
X! 						otmp; otmp = otmp->nexthere)
X! 			if(otmp->otyp == STATUE && otmp->corpsenm == trap->pm)
X  			    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X  				pline("The statue comes to life!");
X  				delobj(otmp);
X  				break;
X  			    }
X  		    break;
X  		case MONST_TRAP:
X  		    if(mtmp=makemon(&mons[trap->pm],u.ux,u.uy)) {
X***************
X*** 323,329 ****
X  		    } else {
X  #ifdef ENDGAME
X  			if(dlevel == ENDLEVEL) {
X! 			    pline("A shiver runs down your spine...");
X  			    break;
X  			}
X  #endif
X--- 328,334 ----
X  		    } else {
X  #ifdef ENDGAME
X  			if(dlevel == ENDLEVEL) {
X! 			    You("feel a wrenching sensation.");
X  			    break;
X  			}
X  #endif
X***************
X*** 344,351 ****
X  			You("are covered with rust!");
X  			rehumanize();
X  			break;
X! 		    }
X  #endif /* GOLEMS */
X  #endif
X  		/* Unlike monsters, traps cannot aim their rust attacks at
X  		 * you, so instead of looping through and taking either the
X--- 349,364 ----
X  			You("are covered with rust!");
X  			rehumanize();
X  			break;
X! 		    } else
X  #endif /* GOLEMS */
X+ 		    if (u.umonnum == PM_GREMLIN && rn2(3)) {
X+ 			pline("A gush of water hits you!");
X+ 			if(mtmp = cloneu()) {
X+ 			    mtmp->mhpmax = (u.mhmax /= 2);
X+ 			    You("multiply.");
X+ 			}
X+ 			break;
X+ 		    }
X  #endif
X  		/* Unlike monsters, traps cannot aim their rust attacks at
X  		 * you, so instead of looping through and taking either the
X***************
X*** 635,641 ****
X  	    mtmp->mtrapseen |= (1 << tt);
X  	    switch (tt) {
X  		case BEAR_TRAP:
X! 			if(bigmonst(mtmp->data)) {
X  				if(in_sight)
X  				  pline("%s is caught in a bear trap!",
X  					Monnam(mtmp));
X--- 648,656 ----
X  	    mtmp->mtrapseen |= (1 << tt);
X  	    switch (tt) {
X  		case BEAR_TRAP:
X! 			if(mtmp->data->msize > MZ_SMALL &&
X! 			   !amorphous(mtmp->data)) {
X! 				mtmp->mtrapped = 1;
X  				if(in_sight)
X  				  pline("%s is caught in a bear trap!",
X  					Monnam(mtmp));
X***************
X*** 644,650 ****
X  					|| mtmp->data == &mons[PM_BUGBEAR])
X  					&& flags.soundok)
X  			    You("hear the roaring of an angry bear!");
X- 				mtmp->mtrapped = 1;
X  			}
X  			break;
X  #ifdef POLYSELF
X--- 659,664 ----
X***************
X*** 665,672 ****
X  								mon_nam(mtmp));
X  				mondied(mtmp);
X  				trapkilled = TRUE;
X! 			}
X  #endif /* GOLEMS */
X  			break;
X  		case PIT:
X  		case SPIKED_PIT:
X--- 679,695 ----
X  								mon_nam(mtmp));
X  				mondied(mtmp);
X  				trapkilled = TRUE;
X! 			} else
X  #endif /* GOLEMS */
X+ 			if (mtmp->data == &mons[PM_GREMLIN] && rn2(3)) {
X+ 				struct monst *mtmp2 = clone_mon(mtmp);
X+ 
X+ 				if (mtmp2) {
X+ 				    mtmp2->mhpmax = (mtmp->mhpmax /= 2);
X+ 				    if(in_sight)
X+ 					pline("%s multiplies.", Monnam(mtmp));
X+ 				}
X+ 			}
X  			break;
X  		case PIT:
X  		case SPIKED_PIT:
X***************
X*** 740,746 ****
X  			if(!is_flyer(mtmp->data)
X  #ifdef WORM
X  				&& !mtmp->wormno
X! 			    /* long worms cannot be allowed to change levels */
X  #endif
X  			    ){
X  #ifdef WALKIES
X--- 763,769 ----
X  			if(!is_flyer(mtmp->data)
X  #ifdef WORM
X  				&& !mtmp->wormno
X! 			    /* long worms with tails mustn't change levels */
X  #endif
X  			    ){
X  #ifdef WALKIES
X***************
X*** 866,872 ****
X  		}
X  	} else
X  		if (Hallucination)
X! 			pline("Oh wow!  You're floating in the air!");
X  		else
X  			You("start to float in the air!");
X  }
X--- 889,895 ----
X  		}
X  	} else
X  		if (Hallucination)
X! 			pline("Up, up, and awaaaay!  You're walking on air!");
X  		else
X  			You("start to float in the air!");
X  }
X***************
X*** 1009,1015 ****
X  			}
X  		}
X  		if (trap)
X! 			You("jump onto the teleportation trap...");
X  	}
X  	if(!trap && (!Teleportation ||
X  	   (u.ulevel < (pl_character[0] == 'W' ? 8 : 12)
X--- 1032,1043 ----
X  			}
X  		}
X  		if (trap)
X! #ifdef POLYSELF
X! 			You("%s onto the teleportation trap.",
X! 			    nolimbs(uasmon) ? "slither" : "jump");
X! #else
X! 			You("jump onto the teleportation trap.");
X! #endif
X  	}
X  	if(!trap && (!Teleportation ||
X  	   (u.ulevel < (pl_character[0] == 'W' ? 8 : 12)
X***************
X*** 1088,1094 ****
X  int attach;
X  {
X  	if(!uchain || !uball){
X! 		impossible("Where are your chain and ball??");
X  		return;
X  	}
X  	if(!carried(uball))
X--- 1116,1122 ----
X  int attach;
X  {
X  	if(!uchain || !uball){
X! 		impossible("Where are your ball and chain?");
X  		return;
X  	}
X  	if(!carried(uball))
X***************
X*** 1230,1236 ****
X  	  }  else
X  		You("hear a deafening roar!");
X  	  while(cnt--)
X! 	   (void) makemon((struct permonst *) 0, u.ux, u.uy);
X  	}
X  	else
X  	  switch (fate) {
X--- 1258,1264 ----
X  	  }  else
X  		You("hear a deafening roar!");
X  	  while(cnt--)
X! 		(void) makemon((struct permonst *) 0, u.ux, u.uy);
X  	}
X  	else
X  	  switch (fate) {
X***************
X*** 1256,1262 ****
X  			} else {
X  				num = rnd(6);
X  				u.uhpmax -= num;
X! 				losehp(num,"a burst of flame");
X  				break;
X  			}
X  		      }
X--- 1284,1290 ----
X  			} else {
X  				num = rnd(6);
X  				u.uhpmax -= num;
X! 				losehp(num,"burst of flame");
X  				break;
X  			}
X  		      }
X***************
X*** 1263,1276 ****
X  
X  	     /* odd feelings */
X  	     case 13:   pline("A shiver runs up and down your spine!");
X  			break;
X! 	     case 14:   You("hear distant howling.");
X  			break;
X  	     case 15:   You("suddenly yearn for your distant homeland.");
X  			break;
X  	     case 16:   Your("pack shakes violently!");
X  			break;
X! 	     case 17:	You("smell charred flesh.");
X  			break;
X  
X  	     /* very occasionally something nice happens. */
X--- 1291,1309 ----
X  
X  	     /* odd feelings */
X  	     case 13:   pline("A shiver runs up and down your spine!");
X+              /* TO DO: What if you're polymorphed into something spineless? */
X  			break;
X! 	     case 14:	You(Hallucination ?
X! 				"hear the moon howling at you." :
X! 				"hear distant howling.");
X  			break;
X  	     case 15:   You("suddenly yearn for your distant homeland.");
X  			break;
X  	     case 16:   Your("pack shakes violently!");
X  			break;
X! 	     case 17:	You(Hallucination ?
X! 				"smell hamburgers." :
X! 				"smell charred flesh.");
X  			break;
X  
X  	     /* very occasionally something nice happens. */
X***************
X*** 1292,1301 ****
X  		   {  register struct obj *obj;
X  
X  			/* below plines added by GAN 10/30/86 */
X! 			if (Hallucination)
X! 			    You("feel in touch with the Universal Oneness.");
X! 			else
X! 			    You("feel like someone is helping you.");
X  			for(obj = invent; obj ; obj = obj->nobj)
X  			       if(obj->owornmask || obj->otyp == LOADSTONE)
X  					obj->cursed = 0;
X--- 1325,1333 ----
X  		   {  register struct obj *obj;
X  
X  			/* below plines added by GAN 10/30/86 */
X! 			You(Hallucination ?
X! 				"feel in touch with the Universal Oneness." :
X! 				"feel like someone is helping you.");
X  			for(obj = invent; obj ; obj = obj->nobj)
X  			       if(obj->owornmask || obj->otyp == LOADSTONE)
X  					obj->cursed = 0;
X***************
X*** 1328,1334 ****
X  	}
X  
X  #ifdef POLYSELF
X! 	if(u.usym == S_GREMLIN && rn2(3)) {
X  		struct monst *mtmp;
X  		if(mtmp = cloneu()) {
X  			mtmp->mhpmax = (u.mhmax /= 2);
X--- 1360,1366 ----
X  	}
X  
X  #ifdef POLYSELF
X! 	if(u.umonnum == PM_GREMLIN && rn2(3)) {
X  		struct monst *mtmp;
X  		if(mtmp = cloneu()) {
X  			mtmp->mhpmax = (u.mhmax /= 2);
X***************
X*** 1376,1382 ****
X  int
X  dountrap() {	/* disarm a trapped object */
X  	register struct obj *otmp;
X! 	register boolean confused = (Confusion > 0);
X  	register int x,y;
X  	int ch;
X  	struct trap *ttmp;
X--- 1408,1414 ----
X  int
X  dountrap() {	/* disarm a trapped object */
X  	register struct obj *otmp;
X! 	register boolean confused = (Confusion > 0 || Hallucination > 0);
X  	register int x,y;
X  	int ch;
X  	struct trap *ttmp;
X***************
X*** 1392,1440 ****
X  	y = u.uy + u.dy;
X  
X  	if(!u.dx && !u.dy) {
X! 	    if(OBJ_AT(x, y))
X! 		for(otmp = fobj; otmp; otmp = otmp->nobj)
X! 		    if((otmp->ox == x) && (otmp->oy == y))
X! 			if(Is_box(otmp)) {
X! 			    pline("There is %s here, check for traps? ",
X! 				  doname(otmp));
X! 
X! 			    switch (ynq()) {
X! 				case 'q': return(0);
X! 				case 'n': continue;
X! 			    }
X! 
X! 			    if((otmp->otrapped && !confused 
X! 					&& rn2(MAXLEVEL+2-dlevel) < 10)
X! 			       || confused && !rn2(3)) {
X! 				You("find a trap on the %s!  Disarm it? ",
X! 				       xname(otmp));
X  
X! 				switch (ynq()) {
X! 				    case 'q': return(1);
X! 				    case 'n': continue;
X! 				}
X! 
X! 				if(otmp->otrapped) {
X! 				    ch = 15 +
X! 					 (pl_character[0] == 'R') ? u.ulevel*3 :
X! 					 u.ulevel;
X! 				    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X! 					You("set it off!");
X! 					chest_trap(otmp, FINGER);
X! 				    } else {
X! 					You("disarm it!");
X! 				        otmp->otrapped = 0;
X! 				    }
X! 				} else pline("That %s was not trapped.",
X! 					     doname(otmp));
X! 				return(1);
X  			    } else {
X! 				You("find no traps on the %s.",
X! 				    xname(otmp));
X! 				return(1);
X  			    }
X! 			}
X  	    if ((ttmp = t_at(x,y)) && ttmp->tseen)
X  		You("cannot disable this trap.");
X  	    else
X--- 1424,1465 ----
X  	y = u.uy + u.dy;
X  
X  	if(!u.dx && !u.dy) {
X! 	    for(otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X! 		if(Is_box(otmp)) {
X! 		    pline("There is %s here, check for traps? ", doname(otmp));
X  
X! 		    switch (ynq()) {
X! 			case 'q': return(0);
X! 			case 'n': continue;
X! 		    }
X! 
X! 		    if((otmp->otrapped && !confused 
X! 				&& rn2(MAXLEVEL+2-dlevel) < 10)
X! 		       || confused && !rn2(3)) {
X! 			You("find a trap on the %s!  Disarm it? ", xname(otmp));
X! 
X! 			switch (ynq()) {
X! 			    case 'q': return(1);
X! 			    case 'n': continue;
X! 			}
X! 
X! 			if(otmp->otrapped) {
X! 			    ch = 15 + (pl_character[0] == 'R') ? u.ulevel*3
X! 								: u.ulevel;
X! 			    if(confused || Fumbling || rnd(75+dlevel/2) > ch) {
X! 				You("set it off!");
X! 				chest_trap(otmp, FINGER);
X  			    } else {
X! 				You("disarm it!");
X! 				otmp->otrapped = 0;
X  			    }
X! 			} else pline("That %s was not trapped.", doname(otmp));
X! 			return(1);
X! 		    } else {
X! 			You("find no traps on the %s.", xname(otmp));
X! 			return(1);
X! 		    }
X! 		}
X  	    if ((ttmp = t_at(x,y)) && ttmp->tseen)
X  		You("cannot disable this trap.");
X  	    else
X***************
X*** 1505,1514 ****
X  			Sprintf(buf, "exploding %s", xname(obj));
X  
X  			delete_contents(obj);
X! 			for(otmp = fobj; otmp; otmp = otmp2) {
X! 			    otmp2 = otmp->nobj;
X! 			    if((otmp->ox == u.ux) && (otmp->oy == u.uy))
X! 				delobj(otmp);
X  			}
X  
X  			losehp(d(6,6), buf);
X--- 1530,1539 ----
X  			Sprintf(buf, "exploding %s", xname(obj));
X  
X  			delete_contents(obj);
X! 			for(otmp = level.objects[u.ux][u.uy];
X! 							otmp; otmp = otmp2) {
X! 			    otmp2 = otmp->nexthere;
X! 			    delobj(otmp);
X  			}
X  
X  			losehp(d(6,6), buf);
X***************
X*** 1689,1696 ****
X  unconscious()
X  {
X  	return (multi < 0 && (!nomovemsg ||
X! 	      !strncmp(nomovemsg,"You wake", 8) ||
X! 	      !strncmp(nomovemsg,"You awake", 9) ||
X! 	      !strncmp(nomovemsg,"You regain con", 15) ||
X! 	      !strncmp(nomovemsg,"You are consci", 15)));
X  }
X--- 1714,1721 ----
X  unconscious()
X  {
X  	return (multi < 0 && (!nomovemsg ||
X! 		!strncmp(nomovemsg,"You wake", 8) ||
X! 		!strncmp(nomovemsg,"You awake", 9) ||
X! 		!strncmp(nomovemsg,"You regain con", 15) ||
X! 		!strncmp(nomovemsg,"You are consci", 15)));
X  }
X*** src/Old/u_init.c	Sun Nov 19 13:17:03 1989
X--- src/u_init.c	Fri Nov 17 19:32:23 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)u_init.c	3.0	88/04/13
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)u_init.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 13,19 ****
X  	Bitfield(trbless,2);
X  };
X  
X! static void ini_inv P((struct trobj *));
X  
X  #define	UNDEF_TYP	0
X  #define	UNDEF_SPE	'\177'
X--- 13,19 ----
X  	Bitfield(trbless,2);
X  };
X  
X! static void FDECL(ini_inv, (struct trobj *));
X  
X  #define	UNDEF_TYP	0
X  #define	UNDEF_SPE	'\177'
X***************
X*** 27,36 ****
X  	"Priest", "Rogue", "Samurai", "Tourist", "Valkyrie", "Wizard"
X  };
X  
X! struct you zerou;
X  
X! #define	NR_OF_ROLES	SIZE(roles)
X! char rolesyms[NR_OF_ROLES + 1];		/* filled by u_init() */
X  
X  struct trobj Cave_man[] = {
X  #define C_ARROWS	2
X--- 27,35 ----
X  	"Priest", "Rogue", "Samurai", "Tourist", "Valkyrie", "Wizard"
X  };
X  
X! const char *pl_classes = "ABCEHKPRSTVW";
X  
X! struct you zerou;
X  
X  struct trobj Cave_man[] = {
X  #define C_ARROWS	2
X***************
X*** 235,246 ****
X  static int
X  role_index(pc)
X  char pc;
X! {		/* must be called only from u_init() */
X! 		/* so that rolesyms[] is defined */
X  	register char *cp;
X  
X! 	if(cp = index(rolesyms, pc))
X! 		return(cp - rolesyms);
X  	return(-1);
X  }
X  
X--- 234,244 ----
X  static int
X  role_index(pc)
X  char pc;
X! {
X  	register char *cp;
X  
X! 	if(cp = index(pl_classes, pc))
X! 		return(cp - pl_classes);
X  	return(-1);
X  }
X  
X***************
X*** 258,266 ****
X  		roles[2] = "Cave-woman";
X  		roles[6] = "Priestess";
X  	}
X- 	for(i = 0; i < NR_OF_ROLES; i++)
X- 		rolesyms[i] = roles[i][0];
X- 	rolesyms[i] = 0;
X  
X  	if(pc = pl_character[0]) {
X  		if('a' <= pc && pc <= 'z') pc += 'A'-'a';
X--- 256,261 ----
X***************
X*** 290,305 ****
X  		goto beginner;
X  
X  	Printf("\nWhat kind of character are you:\n\n");
X! 	Printf("         An");
X! 	Printf(" %s,",roles[0]);
X! 	for(i = 1; i < NR_OF_ROLES; i++) {
X! 		Printf(" a%s %s", index(vowels,roles[i][0]) ? "n" : "", roles[i]);
X! 		if((((i + 1) % 4) == 0) && (i != NR_OF_ROLES -1)) Printf(",\n        ");
X! 		else if(i < NR_OF_ROLES - 2)	Printf(",");
X! 		if(i == NR_OF_ROLES - 2)	Printf(" or");
X  	}
X  	Printf("?\n         [");
X! 	for(i = 0; i < NR_OF_ROLES; i++) Printf("%c,", rolesyms[i]);
X  	Printf(" or Q] ");
X  
X  	while(pc = readchar()) {
X--- 285,300 ----
X  		goto beginner;
X  
X  	Printf("\nWhat kind of character are you:\n\n");
X! 	Printf(" 	 %s,", An(roles[0]));
X! 	for(i = 1; i < SIZE(roles); i++) {
X! 		Printf(" %s", an(roles[i]));
X! 		if((((i + 1) % 4) == 0) && (i != SIZE(roles) -1)) 
X! 			Printf(",\n        ");
X! 		else if(i < SIZE(roles) - 2)	Printf(",");
X! 		if(i == SIZE(roles) - 2)	Printf(" or");
X  	}
X  	Printf("?\n         [");
X! 	for(i = 0; i < SIZE(roles); i++) Printf("%c,", pl_classes[i]);
X  	Printf(" or Q] ");
X  
X  	while(pc = readchar()) {
X***************
X*** 321,331 ****
X  
X  beginner:
X  	if(!pc) {
X! 		i = rn2(NR_OF_ROLES);
X! 		pc = rolesyms[i];
X! 		Printf("\nThis game you will be %s %s.\n",
X! 			index("AEIOU", roles[i][0]) ? "an" : "a",
X! 			roles[i]);
X  		getret();
X  		/* give him some feedback in case mklev takes much time */
X  		(void) putchar('\n');
X--- 316,324 ----
X  
X  beginner:
X  	if(!pc) {
X! 		i = rn2(SIZE(roles));
X! 		pc = pl_classes[i];
X! 		Printf("\nThis game you will be %s.\n", an(roles[i]));
X  		getret();
X  		/* give him some feedback in case mklev takes much time */
X  		(void) putchar('\n');
X***************
X*** 503,509 ****
X  		ini_inv(Wishing);
X  #endif
X  	find_ac();			/* get initial ac value */
X! 	init_attr((pick != 'Y') ? 69 : 72);	/* init attribute values */
X  	max_rank_sz();			/* set max str size for class ranks */
X  /*
X   *	Do we really need this?
X--- 496,502 ----
X  		ini_inv(Wishing);
X  #endif
X  	find_ac();			/* get initial ac value */
X! 	init_attr((pick != 'Y') ? 75 : 77);	/* init attribute values */
X  	max_rank_sz();			/* set max str size for class ranks */
X  /*
X   *	Do we really need this?
X***************
X*** 619,626 ****
X  		if(obj->olet == FOOD_SYM && undefined) {
X  			obj->known = 1;
X  			/* needed for tins and eggs; harmless otherwise */
X! 			obj->bknown = (obj->otyp != DEAD_LIZARD);
X! 			/* only for dead lizards does the blessing not matter */
X  		}
X  		/*
X  		 * The below lines not needed because they don't correspond
X--- 612,618 ----
X  		if(obj->olet == FOOD_SYM && undefined) {
X  			obj->known = 1;
X  			/* needed for tins and eggs; harmless otherwise */
X! 			obj->bknown = 1;
X  		}
X  		/*
X  		 * The below lines not needed because they don't correspond
X*** src/Old/uhitm.c	Sun Nov 19 13:17:33 1989
X--- src/uhitm.c	Sun Nov 19 09:25:37 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)uhitm.c	3.0	88/04/11
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)uhitm.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 344,353 ****
X  	    }
X  	} else {
X  	    if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X! 	       obj->olet == ROCK_SYM) {
X  
X  		if(obj == uwep && (obj->otyp > VOULGE || obj->otyp < BOOMERANG)
X! 				&& obj->otyp != PICK_AXE)
X  		    tmp = rnd(2);
X  		else {
X  		    tmp = dmgval(obj, mon->data);
X--- 344,353 ----
X  	    }
X  	} else {
X  	    if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X! 	       obj->otyp == UNICORN_HORN || obj->olet == ROCK_SYM) {
X  
X  		if(obj == uwep && (obj->otyp > VOULGE || obj->otyp < BOOMERANG)
X! 			&& obj->otyp != PICK_AXE && obj->otyp != UNICORN_HORN)
X  		    tmp = rnd(2);
X  		else {
X  		    tmp = dmgval(obj, mon->data);
X***************
X*** 430,436 ****
X  			    xkilled(mon,0);
X  			    return(FALSE);
X  			}
X! 			tmp = bigmonst(&mons[obj->corpsenm]) ? 5 : 2 ;
X  			break;
X  		case EGG: /* only possible if hand-to-hand */
X  			if(obj->corpsenm > -1
X--- 430,436 ----
X  			    xkilled(mon,0);
X  			    return(FALSE);
X  			}
X! 			tmp = mons[obj->corpsenm].msize + 1;
X  			break;
X  		case EGG: /* only possible if hand-to-hand */
X  			if(obj->corpsenm > -1
X***************
X*** 629,635 ****
X  
X  	stoned = FALSE;
X  	if (is_demon(uasmon) && !rn2(13) && !uwep
X! # ifdef HARD
X  		&& u.umonnum != PM_SUCCUBUS && u.umonnum != PM_INCUBUS
X  		&& u.umonnum != PM_BALROG
X  # endif
X--- 629,635 ----
X  
X  	stoned = FALSE;
X  	if (is_demon(uasmon) && !rn2(13) && !uwep
X! # ifdef INFERNO
X  		&& u.umonnum != PM_SUCCUBUS && u.umonnum != PM_INCUBUS
X  		&& u.umonnum != PM_BALROG
X  # endif
X***************
X*** 1311,1317 ****
X  		}
X  		break;
X  	      case AD_COLD:		/* brown mold or blue jelly */
X! 		if(dist(mon->mx, mon->my) <= 3) {
X  		    tmp = d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X  		    if(Cold_resistance) {
X    			shieldeff(u.ux, u.uy);
X--- 1311,1317 ----
X  		}
X  		break;
X  	      case AD_COLD:		/* brown mold or blue jelly */
X! 		if(monnear(mon, u.ux, u.uy)) {
X  		    tmp = d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X  		    if(Cold_resistance) {
X    			shieldeff(u.ux, u.uy);
X***************
X*** 1347,1353 ****
X  		    make_stunned((long)d((int)mon->m_lev+1, (int)ptr->mattk[i].damd), TRUE);
X  		break;
X  	      case AD_FIRE:
X! 		if(dist(mon->mx, mon->my) <= 3) {
X  		    tmp = d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X  		    if(Fire_resistance) {
X    			shieldeff(u.ux, u.uy);
X--- 1347,1353 ----
X  		    make_stunned((long)d((int)mon->m_lev+1, (int)ptr->mattk[i].damd), TRUE);
X  		break;
X  	      case AD_FIRE:
X! 		if(monnear(mon, u.ux, u.uy)) {
X  		    tmp = d((int)mon->m_lev+1, (int)ptr->mattk[i].damd);
X  		    if(Fire_resistance) {
X    			shieldeff(u.ux, u.uy);
X***************
X*** 1379,1385 ****
X  	if(!u.ustuck && !mtmp->mflee && dmgtype(mtmp->data,AD_STCK))
X  		u.ustuck = mtmp;
X  	if (Blind) goto generic;
X! 	else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == DOOR_SYM)
X  #ifdef SPELLS
X  	{
X  		if (IS_ROCK(levl[u.ux+u.dx][u.uy+u.dy].typ) ||
X--- 1379,1385 ----
X  	if(!u.ustuck && !mtmp->mflee && dmgtype(mtmp->data,AD_STCK))
X  		u.ustuck = mtmp;
X  	if (Blind) goto generic;
X! 	else if (levl[u.ux+u.dx][u.uy+u.dy].scrsym == CLOSED_DOOR_SYM)
X  #ifdef SPELLS
X  	{
X  		if (IS_ROCK(levl[u.ux+u.dx][u.uy+u.dy].typ) ||
X*** src/Old/unixtty.c	Sun Nov 19 14:51:27 1989
X--- src/unixtty.c	Sun Nov 19 14:45:10 1989
X***************
X*** 38,43 ****
X--- 38,44 ----
X  #define CBRKMASK	ICANON
X  #define CBRKON		! /* reverse condition */
X  #define OSPEED(x)	((x).c_cflag & CBAUD)
X+ #define IS_7BIT(x)	((x).c_cflag & CS7)
X  #define inputflags	c_iflag
X  #define STRIPHI		ISTRIP
X  #define GTTY(x)		(ioctl(0, TCGETA, x))
X***************
X*** 63,68 ****
X--- 64,70 ----
X  #define CBRKMASK	CBREAK
X  #define CBRKON		/* empty */
X  #define inputflags	sg_flags	/* don't know how enabling meta bits */
X+ #define IS_7BIT(x)	(FALSE)
X  #define STRIPHI		0		/* should actually be done on BSD */
X  #define OSPEED(x)	(x).sg_ospeed
X  #define GTTY(x)		(gtty(0, x))
X***************
X*** 154,160 ****
X  #endif
X  		change++;
X  	}
X! 	curttyb.inputflags &=~ STRIPHI;
X  	/* If an interrupt character is used, it will be overriden and
X  	 * set to ^C.
X  	 */
X--- 156,162 ----
X  #endif
X  		change++;
X  	}
X! 	if(!IS_7BIT(inittyb)) curttyb.inputflags &=~ STRIPHI;
X  	/* If an interrupt character is used, it will be overriden and
X  	 * set to ^C.
X  	 */
X*** src/Old/vault.c	Sun Nov 19 13:19:02 1989
X--- src/vault.c	Sat Oct 21 20:52:11 1989
X***************
X*** 147,153 ****
X  int
X  gd_move(){
X  	int x, y, nx, ny;
X! 	int dx, dy, gx, gy, typ, i;
X  	struct fakecorridor *fcp;
X  	register struct rm *crm;
X  
X--- 147,154 ----
X  int
X  gd_move(){
X  	int x, y, nx, ny;
X! 	int dx, dy, gx, gy, i;
X! 	uchar typ;
X  	struct fakecorridor *fcp;
X  	register struct rm *crm;
X  
X*** src/Old/weapon.c	Sun Nov 19 13:19:28 1989
X--- src/weapon.c	Sun Nov 19 09:25:40 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)weapon.c	3.0	89/04/24
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)weapon.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 22,28 ****
X  {
X  	int	tmp = 0;
X  
X! 	if(otmp->olet == WEAPON_SYM || otmp->otyp == PICK_AXE)
X  		tmp += otmp->spe;
X  
X  /*	Put weapon specific "to hit" bonuses in below:		*/
X--- 22,29 ----
X  {
X  	int	tmp = 0;
X  
X! 	if(otmp->olet == WEAPON_SYM || otmp->otyp == PICK_AXE
X! 						|| otmp->otyp == UNICORN_HORN)
X  		tmp += otmp->spe;
X  
X  /*	Put weapon specific "to hit" bonuses in below:		*/
X***************
X*** 75,81 ****
X  
X  	if(otmp->otyp == CREAM_PIE)	return(0);
X  
X! 	if(bigmonst(ptr)) {
X  	    if(objects[otmp->otyp].wldam)
X  		tmp = rnd(objects[otmp->otyp].wldam);
X  	    switch (otmp->otyp) {
X--- 76,82 ----
X  
X  	if(otmp->otyp == CREAM_PIE)	return(0);
X  
X! 	if(ptr->msize >= MZ_HUMAN) {
X  	    if(objects[otmp->otyp].wldam)
X  		tmp = rnd(objects[otmp->otyp].wldam);
X  	    switch (otmp->otyp) {
X***************
X*** 132,138 ****
X  	if (otmp->otyp == BULLWHIP && thick_skinned(ptr))
X  		/* thick skinned/scaled creatures don't feel it */
X  		tmp = 0;
X! 	if (otmp->olet == WEAPON_SYM || otmp->otyp == PICK_AXE)
X  		tmp += otmp->spe;
X  
X  /*	Put weapon vs. monster type damage bonuses in below:	*/
X--- 133,140 ----
X  	if (otmp->otyp == BULLWHIP && thick_skinned(ptr))
X  		/* thick skinned/scaled creatures don't feel it */
X  		tmp = 0;
X! 	if (otmp->olet == WEAPON_SYM || otmp->otyp == PICK_AXE
X! 						|| otmp->otyp == UNICORN_HORN)
X  		tmp += otmp->spe;
X  
X  /*	Put weapon vs. monster type damage bonuses in below:	*/
X***************
X*** 256,261 ****
X--- 258,264 ----
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X  static const int hwep[][2] =
X  	{ {DWARVISH_MATTOCK,1}, {TWO_HANDED_SWORD,1}, {KATANA,0},
X+ 	  {UNICORN_HORN,1},
X  #ifdef WORM
X  	  {CRYSKNIFE,0},
X  #endif
X***************
X*** 281,287 ****
X  #else /* TOLKIEN */
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X  static const int hwep[][2] =
X! 	{ {TWO_HANDED_SWORD,1}, {KATANA,0},
X  #ifdef WORM
X  	  {CRYSKNIFE,0},
X  #endif
X--- 284,290 ----
X  #else /* TOLKIEN */
X  /* 0 = used by any monster; 1 = only used by strong monsters */
X  static const int hwep[][2] =
X! 	{ {TWO_HANDED_SWORD,1}, {KATANA,0}, {UNICORN_HORN,1},
X  #ifdef WORM
X  	  {CRYSKNIFE,0},
X  #endif
X***************
X*** 336,341 ****
X--- 339,349 ----
X  	else if(ACURR(A_STR) < 69) sbon = 1;	/* up to 18/50 */
X  	else if(ACURR(A_STR) < 118) sbon = 2;
X  	else sbon = 3;
X+ /*
X+  *	Temporary kludge - make it a bit easier for a low level character
X+  *			   to hit until we tune the game a little better.
X+  */
X+ 	sbon += (u.ulevel < 3) ? 2 : (u.ulevel < 5) ? 1 : 0;
X  
X  	if(ACURR(A_DEX) < 4) return(sbon-3);
X  	else if(ACURR(A_DEX) < 6) return(sbon-2);
X*** src/Old/wield.c	Sun Nov 19 13:19:57 1989
X--- src/wield.c	Thu Oct 19 14:23:32 1989
X***************
X*** 28,34 ****
X  	}
X  }
X  
X! static const char wield_objs[] = { '#', '-', WEAPON_SYM, 0 };
X  
X  int
X  dowield()
X--- 28,34 ----
X  	}
X  }
X  
X! static const char wield_objs[] = { '#', '-', WEAPON_SYM, TOOL_SYM, 0 };
X  
X  int
X  dowield()
X***************
X*** 76,81 ****
X--- 76,82 ----
X  		res++;
X  		if(wep->cursed && (wep->olet == WEAPON_SYM ||
X  			wep->otyp == HEAVY_IRON_BALL || wep->otyp == PICK_AXE ||
X+ 			wep->otyp == UNICORN_HORN ||
X  			wep->otyp == TIN_OPENER)) {
X  		    pline("The %s %s to your %s!",
X  			aobjnam(wep, "weld"),
X***************
X*** 96,104 ****
X  		}
X  		setuwep(wep);
X  	}
X  	if(res && uwep)
X! 		unweapon = (uwep->otyp >= BOW || uwep->otyp <= BOOMERANG) ?
X! 		TRUE : FALSE;
X  	return(res);
X  }
X  
X--- 97,108 ----
X  		}
X  		setuwep(wep);
X  	}
X+ 	/* Note: Explicitly wielding a pick-axe will not give a "bashing"
X+ 	 * message.  Wielding one via 'a'pplying it will.
X+ 	 */
X  	if(res && uwep)
X! 		unweapon = ((uwep->otyp >= BOW || uwep->otyp <= BOOMERANG) &&
X! 			uwep->otyp != PICK_AXE && uwep->otyp != UNICORN_HORN);
X  	return(res);
X  }
X  
X***************
X*** 182,188 ****
X  {
X  	if (obj && obj == uwep && obj->cursed &&
X  		  (obj->olet == WEAPON_SYM || obj->otyp == HEAVY_IRON_BALL ||
X! 		   obj->otyp == TIN_OPENER || obj->otyp == PICK_AXE))
X  	{
X  		obj->bknown = 1;
X  		return 1;
X--- 186,193 ----
X  {
X  	if (obj && obj == uwep && obj->cursed &&
X  		  (obj->olet == WEAPON_SYM || obj->otyp == HEAVY_IRON_BALL ||
X! 		   obj->otyp == TIN_OPENER || obj->otyp == PICK_AXE ||
X! 		   obj->otyp == UNICORN_HORN))
X  	{
X  		obj->bknown = 1;
X  		return 1;
X*** src/Old/worm.c	Sun Nov 19 13:20:24 1989
X--- src/worm.c	Mon Nov 13 21:23:17 1989
X***************
X*** 142,147 ****
X--- 142,151 ----
X  			newsym(wtmp->wx, wtmp->wy);
X  			wtmp->wdispl = 0;
X  		}
X+ 		else if (cansee(wtmp->wx, wtmp->wy) && !wtmp->wdispl) {
X+ 			atl(wtmp->wx, wtmp->wy, S_WORM_TAIL);
X+ 			wtmp->wdispl = 1;
X+ 		}
X  }
X  
X  void
X*** src/Old/worn.c	Sun Nov 19 13:20:37 1989
X--- src/worn.c	Fri Nov 17 19:32:24 1989
X***************
X*** 1,11 ****
X! /*	SCCS Id: @(#)worn.c	3.0	88/12/23
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X  
X! static const char crispy[] = "The flames of Hell burn you to a crisp.";
X! static void set_armor_intrinsic P((struct obj *,long,BOOLEAN_P));
X  
X  const struct worn {
X  	long w_mask;
X--- 1,11 ----
X! /*	SCCS Id: @(#)worn.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include "hack.h"
X  
X! static const char crispy[] = "The flames of hell burn you to a crisp.";
X! static void FDECL(set_armor_intrinsic, (struct obj *,BOOLEAN_P));
X  
X  const struct worn {
X  	long w_mask;
X***************
X*** 49,63 ****
X  		    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs & 
X  				~wp->w_mask;
X! 		    set_armor_intrinsic(oobj, wp->w_mask, 0);
X  		}
X  		*(wp->w_obj) = obj;
X  		if(obj) {
X  		    obj->owornmask |= wp->w_mask;
X! 		    u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[obj->otyp].oc_oprop].p_flgs | 
X  				wp->w_mask;
X! 		    set_armor_intrinsic(obj, wp->w_mask, 1);
X  		}
X  	}
X  	/* A kludge to solve the problem of someone gaining fire resistance
X--- 49,67 ----
X  		    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[oobj->otyp].oc_oprop].p_flgs & 
X  				~wp->w_mask;
X! 		    set_armor_intrinsic(oobj, 0);
X  		}
X  		*(wp->w_obj) = obj;
X  		if(obj) {
X  		    obj->owornmask |= wp->w_mask;
X! 		/* prevent getting intrinsics from wielding potions, etc... */
X! 		/* wp_mask should be same as mask at this point */
X! 		    if(obj->olet == WEAPON_SYM || mask != W_WEP) {
X! 			u.uprops[objects[obj->otyp].oc_oprop].p_flgs = 
X  			    u.uprops[objects[obj->otyp].oc_oprop].p_flgs | 
X  				wp->w_mask;
X! 			set_armor_intrinsic(obj, 1);
X! 		    }
X  		}
X  	}
X  	/* A kludge to solve the problem of someone gaining fire resistance
X***************
X*** 98,104 ****
X  				u.uprops[objects[obj->otyp].oc_oprop].p_flgs & 
X  					~wp->w_mask;
X  			obj->owornmask &= ~wp->w_mask;
X! 			set_armor_intrinsic(obj, wp->w_mask, 0);
X  		}
X  	/* See comments above in setworn().  The major difference is the
X  	 * need to check AMULET_SYM so if someone goes to Hell without
X--- 102,108 ----
X  				u.uprops[objects[obj->otyp].oc_oprop].p_flgs & 
X  					~wp->w_mask;
X  			obj->owornmask &= ~wp->w_mask;
X! 			set_armor_intrinsic(obj, 0);
X  		}
X  	/* See comments above in setworn().  The major difference is the
X  	 * need to check AMULET_SYM so if someone goes to Hell without
X***************
X*** 129,137 ****
X  }
X  
X  static void
X! set_armor_intrinsic(obj,maskbit,on)
X  register struct obj *obj;
X- long maskbit;	/* people can do funny things like wield armor */
X  boolean on;
X  {
X  	long *mask;
X--- 133,140 ----
X  }
X  
X  static void
X! set_armor_intrinsic(obj,on)
X  register struct obj *obj;
X  boolean on;
X  {
X  	long *mask;
X***************
X*** 163,168 ****
X  		default:
X  			return;
X  	}
X! 	if (on) *mask |= maskbit;
X! 	else *mask &= ~maskbit;
X  }
X--- 166,171 ----
X  		default:
X  			return;
X  	}
X! 	if (on) *mask |= WORN_ARMOR;
X! 	else *mask &= ~WORN_ARMOR;
X  }
X*** src/Old/zap.c	Sun Nov 19 13:21:06 1989
X--- src/zap.c	Sat Nov 11 17:59:32 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)zap.c	3.0	88/10/25
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)zap.c	3.0	89/11/08
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 45,51 ****
X  
X  #ifdef TEXTCOLOR
X  static const int zapcolor[10] = {
X! 	AT_ZAP, RED, AT_ZAP, WHITE, AT_ZAP, WHITE,
X  	AT_ZAP, AT_ZAP, AT_ZAP, AT_ZAP
X  };
X  #endif
X--- 45,51 ----
X  
X  #ifdef TEXTCOLOR
X  static const int zapcolor[10] = {
X! 	AT_ZAP, RED|BRIGHT, AT_ZAP, WHITE|BRIGHT, AT_ZAP, WHITE|BRIGHT,
X  	AT_ZAP, AT_ZAP, AT_ZAP, AT_ZAP
X  };
X  #endif
X***************
X*** 52,58 ****
X  
X  /* Routines for IMMEDIATE wands and spells. */
X  /* bhitm: monster mtmp was hit by the effect of wand or spell otmp */
X! static int
X  bhitm(mtmp, otmp)
X  register struct monst *mtmp;
X  register struct obj *otmp;
X--- 52,61 ----
X  
X  /* Routines for IMMEDIATE wands and spells. */
X  /* bhitm: monster mtmp was hit by the effect of wand or spell otmp */
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  bhitm(mtmp, otmp)
X  register struct monst *mtmp;
X  register struct obj *otmp;
X***************
X*** 168,188 ****
X  register struct obj *obj;
X  boolean ininv;
X  {
X! 	register struct monst *mtmp;
X  
X  	if(obj->otyp == CORPSE) {
X! 		int montype,x,y,nl;
X! 		char buf[BUFSZ];
X  
X- 		if (nl = obj->onamelth) Strcpy(buf, ONAME(obj));
X- 		montype = obj->corpsenm;
X- 		if (ininv) {
X- 			x = u.ux; y = u.uy;
X- 			useup(obj);
X- 		} else {
X- 			x = obj->ox; y = obj->oy;
X- 			useupf(obj);
X- 		}
X  		if (cant_create(&montype)) { /* will make zombie instead */
X  			mtmp = makemon(&mons[PM_HUMAN_ZOMBIE], x, y);
X  			if (mtmp) {
X--- 171,183 ----
X  register struct obj *obj;
X  boolean ininv;
X  {
X! 	register struct monst *mtmp = (struct monst *)0;
X  
X  	if(obj->otyp == CORPSE) {
X! 		int montype = obj->corpsenm;
X! 		int x = ininv ? u.ux : obj->ox;
X! 		int y = ininv ? u.uy : obj->oy;
X  
X  		if (cant_create(&montype)) { /* will make zombie instead */
X  			mtmp = makemon(&mons[PM_HUMAN_ZOMBIE], x, y);
X  			if (mtmp) {
X***************
X*** 190,213 ****
X  				mtmp->mspeed = MFAST;
X  			}
X  		} else {
X  #ifdef ARMY
X  			if (is_mercenary(&mons[montype]))
X  				montype = PM_UNARMORED_SOLDIER;
X  #endif
X! 			mons[montype].pxlth += nl;
X  			mtmp = makemon(&mons[montype], x, y);
X! 			mons[montype].pxlth -= nl;
X  			if (mtmp) {
X  				/* Monster retains its name */
X! 				mtmp->mnamelth = nl;
X! 				if (nl) Strcpy(NAME(mtmp), buf);
X  				/* No inventory for newly revived monsters */
X! 				while(obj = (mtmp->minvent)) {
X! 					mtmp->minvent = obj->nobj;
X! 					free((genericptr_t)obj);
X  				}
X  			}
X! 		}
X  	}
X  	return mtmp;
X  }
X--- 185,214 ----
X  				mtmp->mspeed = MFAST;
X  			}
X  		} else {
X+ 			struct obj *otmp;
X  #ifdef ARMY
X  			if (is_mercenary(&mons[montype]))
X  				montype = PM_UNARMORED_SOLDIER;
X  #endif
X! 			mons[montype].pxlth += obj->onamelth;
X  			mtmp = makemon(&mons[montype], x, y);
X! 			mons[montype].pxlth -= obj->onamelth;
X  			if (mtmp) {
X  				/* Monster retains its name */
X! 				if (mtmp->mnamelth = obj->onamelth)
X! 					Strcpy(NAME(mtmp), ONAME(obj));
X  				/* No inventory for newly revived monsters */
X! 				while(otmp = (mtmp->minvent)) {
X! 					mtmp->minvent = otmp->nobj;
X! 					free((genericptr_t)otmp);
X  				}
X  			}
X! 		}
X! 		if (mtmp && obj->oeaten)
X! 			mtmp->mhp = eaten_stat(mtmp->mhp, obj);
X! 		if (ininv) useup(obj);
X! 		else useupf(obj);
X! 		newsym(x, y);
X  	}
X  	return mtmp;
X  }
X***************
X*** 247,252 ****
X--- 248,272 ----
X  }
X  
X  static int
X+ bhitgold(gold, otmp)
X+ register struct gold *gold;
X+ register struct obj *otmp;
X+ {
X+ 	switch(otmp->otyp) {
X+ 	case WAN_TELEPORTATION:
X+ #ifdef SPELLS
X+ 	case SPE_TELEPORT_AWAY:
X+ #endif
X+ 		rlocgold(gold);
X+ 		break;
X+ 	}
X+ 	return 1;
X+ }
X+ 
X+ #ifndef OVERLAY
X+ static 
X+ #endif
X+ int
X  bhito(obj, otmp)	/* object obj was hit by the effect of wand otmp */
X  register struct obj *obj, *otmp;	/* returns TRUE if sth was done */
X  {
X***************
X*** 294,301 ****
X  		    (otmp2->olet == WEAPON_SYM && otmp2->otyp <= SHURIKEN))
X  			otmp2->opoisoned = 1;
X  
X! 		/* Turn dragon corpses into dragon armors */
X! 		if (obj->otyp == CORPSE && obj->corpsenm >= PM_GRAY_DRAGON
X  				&& obj->corpsenm <= PM_YELLOW_DRAGON) {
X  			if (!rn2(10)) { /* Random failure */
X  				otmp2->otyp = TIN;
X--- 314,322 ----
X  		    (otmp2->olet == WEAPON_SYM && otmp2->otyp <= SHURIKEN))
X  			otmp2->opoisoned = 1;
X  
X! 		if (obj->otyp == CORPSE){
X! 		    /* Turn dragon corpses into dragon armors */
X! 		    if (obj->corpsenm >= PM_GRAY_DRAGON
X  				&& obj->corpsenm <= PM_YELLOW_DRAGON) {
X  			if (!rn2(10)) { /* Random failure */
X  				otmp2->otyp = TIN;
X***************
X*** 309,314 ****
X--- 330,344 ----
X  				otmp2->cursed = 0;
X  			}
X  			otmp2->corpsenm = obj->corpsenm;
X+ 		    /* and croc corpses into shoes */
X+ 		    } else if (obj->corpsenm == PM_CROCODILE) {
X+ 			otmp2->otyp = LOW_BOOTS;
X+ 			otmp2->olet = ARMOR_SYM;
X+ 			otmp2->spe = 0;
X+ 			otmp2->rustfree = 1;
X+ 			otmp2->quan = 1;
X+ 			otmp2->cursed = 0;
X+ 		    }
X  		}
X  
X  		/* update the weight */
X***************
X*** 732,746 ****
X  				(void)close_drawbridge(u.ux, u.uy);
X  		    else
X  #endif
X! 		    if (OBJ_AT(u.ux, u.uy)) {
X! 			register struct obj *otmp,*otmp2;
X  
X! 			/* changed by GAN to hit all objects there */
X! 			for(otmp = fobj; otmp ; otmp = otmp2) {
X! 				otmp2 = otmp->nobj;
X  				/* save pointer as bhito may destroy otmp */
X! 				if(otmp->ox == u.ux && otmp->oy == u.uy)
X! 			    		(void) bhito(otmp, obj);
X  			}
X  		    }
X  		}
X--- 762,778 ----
X  				(void)close_drawbridge(u.ux, u.uy);
X  		    else
X  #endif
X! 		    {
X! 			register struct obj *otmp, *otmp2;
X  
X! 			if(levl[u.ux][u.uy].gmask)
X! 				(void) bhitgold(g_at(u.ux, u.uy), obj);
X! 			for(otmp = level.objects[u.ux][u.uy];
X! 							otmp; otmp = otmp2) {
X! 				/* changed by GAN to hit all objects there */
X! 				otmp2 = otmp->nexthere;
X  				/* save pointer as bhito may destroy otmp */
X! 				(void) bhito(otmp, obj);
X  			}
X  		    }
X  		}
X***************
X*** 842,852 ****
X  						room->typ == SDOOR) {
X  					    room->typ = DOOR;
X  					    room->doormask = D_NODOOR;
X! 					    if(in_shop(zx,zy)) {
X! 						shopdoor = TRUE;
X! 						dlx = zx;
X! 						dly = zy;
X! 					    }
X  					    digdepth -= 2;
X  					} else {
X  					    room->typ = CORR;
X--- 874,881 ----
X  						room->typ == SDOOR) {
X  					    room->typ = DOOR;
X  					    room->doormask = D_NODOOR;
X! 					    mnewsym(zx, zy);
X! 					    if (cansee(zx,zy)) prl(zx, zy);
X  					    digdepth -= 2;
X  					} else {
X  					    room->typ = CORR;
X***************
X*** 857,862 ****
X--- 886,893 ----
X  				else if(room->typ == DOOR &&
X  					(room->doormask & (D_LOCKED | D_CLOSED))) {
X  				    room->doormask = D_NODOOR;
X+ 				    mnewsym(zx, zy);
X+ 				    if (cansee(zx,zy)) prl(zx, zy);
X  				    if(in_shop(zx,zy)) {
X  					shopdoor = TRUE;
X  					dlx = zx;
X***************
X*** 870,876 ****
X  			}
X  			mnewsym(zx,zy);	/* not always necessary */
X  			Tmp_at2(-1,-1);	/* closing call */
X! 			if(shopdoor && !in_shop(u.ux, u.uy))
X  				pay_for_door(dlx, dly, "destroy");
X  			break;
X  			}
X--- 901,908 ----
X  			}
X  			mnewsym(zx,zy);	/* not always necessary */
X  			Tmp_at2(-1,-1);	/* closing call */
X! 			if(!Blind) prl(u.ux+u.dx, u.uy+u.dy);
X! 			if(shopdoor)
X  				pay_for_door(dlx, dly, "destroy");
X  			break;
X  			}
X***************
X*** 907,915 ****
X  
X  void
X  hit(str,mtmp,force)
X! register char *str;
X  register struct monst *mtmp;
X! register char *force;		/* usually either "." or "!" */
X  {
X  	if(!cansee(mtmp->mx,mtmp->my) || !flags.verbose) pline("The %s hits it.", str);
X  	else pline("The %s hits %s%s", str, mon_nam(mtmp), force);
X--- 939,947 ----
X  
X  void
X  hit(str,mtmp,force)
X! register const char *str;
X  register struct monst *mtmp;
X! register const char *force;		/* usually either "." or "!" */
X  {
X  	if(!cansee(mtmp->mx,mtmp->my) || !flags.verbose) pline("The %s hits it.", str);
X  	else pline("The %s hits %s%s", str, mon_nam(mtmp), force);
X***************
X*** 917,923 ****
X  
X  void
X  miss(str,mtmp)
X! register char *str;
X  register struct monst *mtmp;
X  {
X  	pline("The %s misses %s.", str,
X--- 949,955 ----
X  
X  void
X  miss(str,mtmp)
X! register const char *str;
X  register struct monst *mtmp;
X  {
X  	pline("The %s misses %s.", str,
X***************
X*** 941,947 ****
X  {
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X! 	register int typ;
X  	boolean shopdoor = FALSE;
X  	xchar dlx, dly;
X  
X--- 973,979 ----
X  {
X  	register struct monst *mtmp;
X  	register struct obj *otmp;
X! 	register uchar typ;
X  	boolean shopdoor = FALSE;
X  	xchar dlx, dly;
X  
X***************
X*** 995,1011 ****
X  			range -= 3;
X  		}
X  		/* modified by GAN to hit all objects */
X! 		if(fhito && OBJ_AT(bhitpos.x, bhitpos.y)){
X  		    int hitanything = 0;
X! 		    otmp = fobj;
X! 		    /* Fix for polymorph bug, Tim Wright */
X! 		    while(otmp) { /* was a "for" loop.  */
X! 			register struct obj *next_obj;
X  
X! 			next_obj = otmp->nobj;
X! 			if(otmp->ox == bhitpos.x && otmp->oy == bhitpos.y)
X! 			    hitanything += (*fhito)(otmp, obj);
X! 			otmp = next_obj;
X  		    }
X  		    if(hitanything)	range--;
X  		}
X--- 1027,1043 ----
X  			range -= 3;
X  		}
X  		/* modified by GAN to hit all objects */
X! 		if(fhito){
X  		    int hitanything = 0;
X! 		    register struct obj *next_obj;
X  
X! 		    if((fhito == bhito) && levl[bhitpos.x][bhitpos.y].gmask)
X! 			hitanything += bhitgold(g_at(bhitpos.x,bhitpos.y),obj);
X! 		    for(otmp = level.objects[bhitpos.x][bhitpos.y];
X! 							otmp; otmp = next_obj) {
X! 			/* Fix for polymorph bug, Tim Wright */
X! 			next_obj = otmp->nexthere;
X! 			hitanything += (*fhito)(otmp, obj);
X  		    }
X  		    if(hitanything)	range--;
X  		}
X***************
X*** 1049,1055 ****
X  	if(sym)
X  	   tmp_at(-1, is_pool(bhitpos.x,bhitpos.y) ? -1 : 0);
X  
X! 	if(shopdoor && !in_shop(u.ux, u.uy))
X  		pay_for_door(dlx, dly, "destroy");
X  
X  	return (struct monst *)0;
X--- 1081,1087 ----
X  	if(sym)
X  	   tmp_at(-1, is_pool(bhitpos.x,bhitpos.y) ? -1 : 0);
X  
X! 	if(shopdoor)
X  		pay_for_door(dlx, dly, "destroy");
X  
X  	return (struct monst *)0;
X***************
X*** 1216,1237 ****
X  	register struct obj *obj, *obj2;
X  	register int scrquan, i, cnt = 0;
X  
X! 	if(OBJ_AT(x, y))
X! 	for(obj = fobj; obj; obj = obj2) {
X! 	    obj2 = obj->nobj;
X  	    /* Bug fix - KAA */
X- 	    if(obj->ox == x && obj->oy == y &&
X  #ifdef SPELLS
X! 	       (obj->olet == SCROLL_SYM || obj->olet == SPBOOK_SYM)) {
X  #else
X! 	       obj->olet == SCROLL_SYM) {
X  #endif
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X  		    if(!rn2(3))  {
X  			cnt++;
X- 			if(in_shop(u.ux, u.uy))
X- 				addtobill(obj, FALSE);
X  			useupf(obj);
X  		    }
X  	    }
X--- 1248,1265 ----
X  	register struct obj *obj, *obj2;
X  	register int scrquan, i, cnt = 0;
X  
X! 	for(obj = level.objects[x][y]; obj; obj = obj2) {
X! 	    obj2 = obj->nexthere;
X  	    /* Bug fix - KAA */
X  #ifdef SPELLS
X! 	    if((obj->olet == SCROLL_SYM || obj->olet == SPBOOK_SYM)) {
X  #else
X! 	    if(obj->olet == SCROLL_SYM) {
X  #endif
X  		scrquan = obj->quan;
X  		for(i = 1; i <= scrquan ; i++)
X  		    if(!rn2(3))  {
X  			cnt++;
X  			useupf(obj);
X  		    }
X  	    }
X***************
X*** 1252,1258 ****
X  register int dx,dy;
X  {
X  	int abstype = abs(type) % 10;
X! 	register char *fltxt = fl[abs(type)];
X  	struct rm *lev;
X  	xchar range, olx, oly;
X  	struct monst *mon;
X--- 1280,1286 ----
X  register int dx,dy;
X  {
X  	int abstype = abs(type) % 10;
X! 	register const char *fltxt = fl[abs(type)];
X  	struct rm *lev;
X  	xchar range, olx, oly;
X  	struct monst *mon;
X***************
X*** 1307,1313 ****
X  			Tmp_at2(-2,(int) dirlet(dx,dy));
X  			continue;
X  		}
X! 		if(is_pool(sx,sy) && abstype == 1 /* fire */) {
X  #ifdef STRONGHOLD
X  			if(lev->typ != POOL) {	/* MOAT or DRAWBRIDGE_UP */
X  			    if(cansee(sx,sy))
X--- 1335,1348 ----
X  			Tmp_at2(-2,(int) dirlet(dx,dy));
X  			continue;
X  		}
X! 		if(abstype == 1 /* fire */ &&
X! 		   (is_pool(sx,sy) || (lev->typ == ROOM && lev->icedpool))) {
X! 		    if(lev->typ == ROOM) {
X! 			lev->typ = (lev->icedpool == ICED_POOL ? POOL : MOAT);
X! 			lev->icedpool = 0;
X! 			pline("The ice crackles and melts.");
X! 			mnewsym(sx,sy);
X! 		    } else {
X  #ifdef STRONGHOLD
X  			if(lev->typ != POOL) {	/* MOAT or DRAWBRIDGE_UP */
X  			    if(cansee(sx,sy))
X***************
X*** 1329,1345 ****
X  #ifdef STRONGHOLD
X  			}
X  #endif
X  		}
X! 		if(is_pool(sx,sy) && abstype == 3 /* cold */) {
X  			boolean moat = (lev->typ != POOL);
X  
X  			range -= 3;
X  #ifdef STRONGHOLD
X! 			if(lev->typ == DRAWBRIDGE_UP)
X! 				lev->drawbridgemask |= DB_FLOOR;
X! 			else
X  #endif
X  				lev->typ = ROOM;
X  			mnewsym(sx,sy);
X  			if(cansee(sx,sy)) {
X  				if(moat)
X--- 1364,1385 ----
X  #ifdef STRONGHOLD
X  			}
X  #endif
X+ 		    }
X  		}
X! 		if(abstype == 3 /* cold */ && is_pool(sx,sy)) {
X  			boolean moat = (lev->typ != POOL);
X  
X  			range -= 3;
X  #ifdef STRONGHOLD
X! 			if(lev->typ == DRAWBRIDGE_UP) {
X! 				lev->drawbridgemask |= DB_ICE;
X! 			} else {
X  #endif
X  				lev->typ = ROOM;
X+ 				lev->icedpool = (moat ? ICED_MOAT : ICED_POOL);
X+ #ifdef STRONGHOLD
X+ 			}
X+ #endif
X  			mnewsym(sx,sy);
X  			if(cansee(sx,sy)) {
X  				if(moat)
X***************
X*** 1353,1360 ****
X  			switch(abstype) {
X  			case 1:
X  			   lev->doormask = D_NODOOR;
X! 			   if(cansee(sx,sy))
X  				pline("The door is consumed in flames!");
X  			   else You("smell smoke.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X  				shopdoor = TRUE;
X--- 1393,1403 ----
X  			switch(abstype) {
X  			case 1:
X  			   lev->doormask = D_NODOOR;
X! 			   mnewsym(sx,sy);
X! 			   if(cansee(sx,sy)) {
X  				pline("The door is consumed in flames!");
X+ 				prl(sx,sy);
X+ 			   }
X  			   else You("smell smoke.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X  				shopdoor = TRUE;
X***************
X*** 1364,1371 ****
X  			   break;
X  			case 3:
X  			   lev->doormask = D_NODOOR;
X! 			   if(cansee(sx,sy))
X  				pline("The door freezes and shatters!");
X  			   else You("feel cold.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X  				shopdoor = TRUE;
X--- 1407,1417 ----
X  			   break;
X  			case 3:
X  			   lev->doormask = D_NODOOR;
X! 			   mnewsym(sx,sy);
X! 			   if(cansee(sx,sy)) {
X  				pline("The door freezes and shatters!");
X+ 				prl(sx,sy);
X+ 			   }
X  			   else You("feel cold.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X  				shopdoor = TRUE;
X***************
X*** 1375,1382 ****
X  			   break;
X  			case 4:
X  			   lev->doormask = D_NODOOR;
X! 			   if(cansee(sx,sy))
X  				pline("The door disintegrates!");
X  			   else if(flags.soundok)
X  				You("hear a crashing sound.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X--- 1421,1431 ----
X  			   break;
X  			case 4:
X  			   lev->doormask = D_NODOOR;
X! 			   mnewsym(sx,sy);
X! 			   if(cansee(sx,sy)) {
X  				pline("The door disintegrates!");
X+ 				prl(sx,sy);
X+ 			   }
X  			   else if(flags.soundok)
X  				You("hear a crashing sound.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X***************
X*** 1387,1394 ****
X  			   break;
X  			case 5:
X  			   lev->doormask = D_BROKEN;
X! 			   if(cansee(sx,sy))
X  				pline("The door splinters!");
X  			   else if(flags.soundok)
X  				You("hear a crackling sound.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X--- 1436,1446 ----
X  			   break;
X  			case 5:
X  			   lev->doormask = D_BROKEN;
X! 			   mnewsym(sx,sy);
X! 			   if(cansee(sx,sy)) {
X  				pline("The door splinters!");
X+ 				prl(sx,sy);
X+ 			   }
X  			   else if(flags.soundok)
X  				You("hear a crackling sound.");
X  			   if(type >= 0 && in_shop(sx, sy)) {
X***************
X*** 1590,1596 ****
X  			stop_occupation();
X  		}
X  		if(!ZAP_POS(lev->typ)) {
X! 			int bounce = 0, rmn;
X  			if(cansee(sx,sy)) pline("The %s bounces!", fltxt);
X  			range--;
X  			if(!dx || !dy || !rn2(20)){
X--- 1642,1649 ----
X  			stop_occupation();
X  		}
X  		if(!ZAP_POS(lev->typ)) {
X! 			int bounce = 0;
X! 			uchar rmn;
X  			if(cansee(sx,sy)) pline("The %s bounces!", fltxt);
X  			range--;
X  			if(!dx || !dy || !rn2(20)){
X***************
X*** 1627,1632 ****
X--- 1680,1706 ----
X  				       abstype == 3 ? "shatter" :
X  				       abstype == 4 ? "disintegrate" :
X  				       "destroy");
X+ }
X+ 
X+ void
X+ rlocgold(gold)
X+ register struct gold *gold;
X+ {
X+ 	register int tx, ty, otx, oty;
X+ 	long val = gold->amount;
X+ 
X+ 	otx = gold->gx;
X+ 	oty = gold->gy;
X+ 	do {
X+ 		tx = rn1(COLNO-3,2);
X+ 		ty = rn2(ROWNO);
X+ 	} while(!goodpos(tx,ty,(struct permonst *)0));
X+ 	freegold(g_at(otx,oty));
X+ 	mkgold(val, tx, ty);
X+ 	if(cansee(otx,oty))
X+ 		newsym(otx,oty);
X+ 	if(cansee(tx,ty))
X+ 		newsym(tx,ty);
X  }
X  
X  void
END_OF_FILE
if test 52555 -ne `wc -c <'patches06l'`; then
    echo shar: \"'patches06l'\" unpacked with wrong size!
fi
# end of 'patches06l'
fi
echo shar: End of archive 12 \(of 15\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
