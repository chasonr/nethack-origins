Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i056:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6c
Message-ID: <4845@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:47:03 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2164
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 56
Archive-name: NetHack3/Patch6c
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 15)."
# Contents:  UPDATE6 patches06f
# Wrapped by billr@saab on Wed Nov 22 10:50:07 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'UPDATE6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'UPDATE6'\"
else
echo shar: Extracting \"'UPDATE6'\" \(1267 characters\)
sed "s/^X//" >'UPDATE6' <<'END_OF_FILE'
XThis patch contains two major improvements:
X
XFirst, thanks to Ari Huttunen, different door states show up as different
X(configurable) characters on the screen.
X
XSecond, doors can now be entered/exited diagonally both for player and
Xmonster.
X
XThird, a gaggle of people credited in the appropriate files developed an
Xoverlay manager for MS-DOS and MSC such that all the options of NetHack can
Xbe supported.  See Install.dos and ovlmgr.* for further details.
X
XIn more minor news:
X
XYou no longer have to pick up food to eat it, and you no longer necessarily
Xresume eating your interrupted meal.
X
XYou can no longer get properties from wielding a non-weapon.
X
XThere is a new option, CLIPPING, which allows playing on small screens or
Xwindows.
X
XThe multiple demon types portion of HARD has been split off into the new
XINFERNO option.
X
XThe Macintosh port has been further refined.
X
XThe / command now takes configurable characters into account when identifying
Xitems.
X
XLeprechauns and lichs and nymphs and nagas had their letters switched so that
Xthe more formidable monsters get capital letters.  Several new low-level
Xmonsters were added.
X
XDrawbridge interactions are much smarter, thanks to Kevin Darcy.
X
XAnd a large number of minor bug fixes and efficiency enhancements.
X
END_OF_FILE
if test 1267 -ne `wc -c <'UPDATE6'`; then
    echo shar: \"'UPDATE6'\" unpacked with wrong size!
fi
# end of 'UPDATE6'
fi
if test -f 'patches06f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06f'\"
else
echo shar: Extracting \"'patches06f'\" \(55539 characters\)
sed "s/^X//" >'patches06f' <<'END_OF_FILE'
X*** src/Old/dog.c	Sun Nov 19 12:37:40 1989
X--- src/dog.c	Wed Nov  8 22:56:30 1989
X***************
X*** 150,156 ****
X  keepdogs(){
X  register struct monst *mtmp;
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 	    if(((dist(mtmp->mx,mtmp->my) < 3 && levl_follower(mtmp)) ||
X  		/* the wiz will level t-port from anywhere to chase
X  		   the amulet; if you don't have it, will chase you
X  		   only if in range. -3. */
X--- 150,156 ----
X  keepdogs(){
X  register struct monst *mtmp;
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 	    if(((monnear(mtmp, u.ux, u.uy) && levl_follower(mtmp)) ||
X  		/* the wiz will level t-port from anywhere to chase
X  		   the amulet; if you don't have it, will chase you
X  		   only if in range. -3. */
X***************
X*** 160,166 ****
X  		/* Bug "fix" for worm changing levels collapsing dungeon
X  		 */
X  		if (mtmp->data == &mons[PM_LONG_WORM]) {
X! 			if (canseemon(mtmp) || (Blind && Telepat))
X  				pline("The worm can't fit down the stairwell.");
X  # ifdef WALKIES
X  			if (mtmp->mleashed) {
X--- 160,166 ----
X  		/* Bug "fix" for worm changing levels collapsing dungeon
X  		 */
X  		if (mtmp->data == &mons[PM_LONG_WORM]) {
X! 			if (showmon(mtmp))
X  				pline("The worm can't fit down the stairwell.");
X  # ifdef WALKIES
X  			if (mtmp->mleashed) {
X***************
X*** 244,256 ****
X  			return POISON;
X  		    return (carni ? CADAVER : MANFOOD);
X  		case CORPSE:
X! 		    if ((obj->age+50 <= moves && mon->data->mlet != S_FUNGUS) ||
X  			(poisonous(&mons[obj->corpsenm]) &&
X  						!resists_poison(mon->data)))
X  			return POISON;
X  		    else return (carni ? CADAVER : MANFOOD);
X- 		case DEAD_LIZARD:
X- 		    return (carni ? ACCFOOD : MANFOOD);
X  		case CLOVE_OF_GARLIC:
X  		    return (is_undead(mon->data) ? TABU :
X  			    (herbi ? ACCFOOD : MANFOOD));
X--- 244,255 ----
X  			return POISON;
X  		    return (carni ? CADAVER : MANFOOD);
X  		case CORPSE:
X! 		    if ((obj->age+50 <= moves && obj->corpsenm != PM_LIZARD
X! 					    && mon->data->mlet != S_FUNGUS) ||
X  			(poisonous(&mons[obj->corpsenm]) &&
X  						!resists_poison(mon->data)))
X  			return POISON;
X  		    else return (carni ? CADAVER : MANFOOD);
X  		case CLOVE_OF_GARLIC:
X  		    return (is_undead(mon->data) ? TABU :
X  			    (herbi ? ACCFOOD : MANFOOD));
X*** src/Old/dogmove.c	Sun Nov 19 12:37:57 1989
X--- src/dogmove.c	Sat Nov 11 17:05:22 1989
X***************
X*** 9,14 ****
X--- 9,59 ----
X  
X  static const char nofetch[] = { BALL_SYM, CHAIN_SYM, ROCK_SYM, 0 };
X  
X+ static void
X+ dog_eat(mtmp, obj, otyp, x, y)
X+ register struct monst *mtmp;
X+ register struct obj * obj;
X+ xchar otyp;
X+ int x, y;
X+ {
X+ 	register struct edog *edog = EDOG(mtmp);
X+ 	int nutrit;
X+ 
X+ 	if(edog->hungrytime < moves)
X+ 	    edog->hungrytime = moves;
X+ 	/* Note: to get the correct percentage-eaten in case oeaten is set,
X+ 	 * use "obj->owt / obj->quan / base-weight".  It so happens that here
X+ 	 * we want to multiply by obj->quan, which thus cancels out.
X+ 	 * It is arbitrary that the pet takes the same length of time to eat
X+ 	 * as a human, but gets 5X as much nutrition.
X+ 	 */
X+ 	if(obj->otyp == CORPSE) {
X+ 	    mtmp->meating = 3 + (mons[obj->corpsenm].cwt >> 2);
X+ 	    nutrit = 5 * mons[obj->corpsenm].cnutrit;
X+ 	} else {
X+ 	    mtmp->meating = objects[obj->otyp].oc_delay;
X+ 	    nutrit = 5 * objects[obj->otyp].nutrition;
X+ 	}
X+ 	if(obj->oeaten) {
X+ 	    mtmp->meating = eaten_stat(mtmp->meating, obj);
X+ 	    nutrit = eaten_stat(nutrit, obj);
X+ 	}
X+ 	edog->hungrytime += nutrit;
X+ 	mtmp->mconf = 0;
X+ 	if (mtmp->mtame < 20) mtmp->mtame++;
X+ 	if(cansee(x,y))
X+ 	    pline("%s eats %s.", Monnam(mtmp), doname(obj));
X+ 	/* perhaps this was a reward */
X+ 	if(otyp != CADAVER)
X+ #ifdef LINT
X+ 	    edog->apport = 0;
X+ #else
X+ 	    edog->apport += (unsigned)(200L/
X+ 		((long)edog->dropdist+moves-edog->droptime));
X+ #endif
X+ 	delobj(obj);
X+ }
X+ 
X  /* return 0 (no move), 1 (move) or 2 (dead) */
X  int
X  dog_move(mtmp, after)
X***************
X*** 32,41 ****
X  
X  	omx = mtmp->mx;
X  	omy = mtmp->my;
X! 	whappr = (moves - EDOG(mtmp)->whistletime < 5);
X! 	if(moves > EDOG(mtmp)->hungrytime + 500) {
X  		if(!carnivorous(mtmp->data) && !herbivorous(mtmp->data)) {
X! 			EDOG(mtmp)->hungrytime = moves + 500;
X  			/* but not too high; it might polymorph */
X  		} else if (!mtmp->mconf) {
X  			mtmp->mconf = 1;
X--- 77,86 ----
X  
X  	omx = mtmp->mx;
X  	omy = mtmp->my;
X! 	whappr = (moves - edog->whistletime < 5);
X! 	if(moves > edog->hungrytime + 500) {
X  		if(!carnivorous(mtmp->data) && !herbivorous(mtmp->data)) {
X! 			edog->hungrytime = moves + 500;
X  			/* but not too high; it might polymorph */
X  		} else if (!mtmp->mconf) {
X  			mtmp->mconf = 1;
X***************
X*** 45,51 ****
X  			if(cansee(omx,omy))
X  			    pline("%s is confused from hunger.", Monnam(mtmp));
X  			else You("feel worried about %s.", mon_nam(mtmp));
X! 		} else if(moves > EDOG(mtmp)->hungrytime + 750 ||
X  							mtmp->mhp < 1) {
X  #ifdef WALKIES
X  			if(mtmp->mleashed)
X--- 90,96 ----
X  			if(cansee(omx,omy))
X  			    pline("%s is confused from hunger.", Monnam(mtmp));
X  			else You("feel worried about %s.", mon_nam(mtmp));
X! 		} else if(moves > edog->hungrytime + 750 ||
X  							mtmp->mhp < 1) {
X  #ifdef WALKIES
X  			if(mtmp->mleashed)
X***************
X*** 85,91 ****
X  		    if((otyp = dogfood(mtmp, obj)) <= CADAVER){
X  			nix = omx;
X  			niy = omy;
X! 			goto eatobj;
X  		    }
X  		    if(can_carry(mtmp, obj))
X  		    if(rn2(20) < edog->apport+3)
X--- 130,137 ----
X  		    if((otyp = dogfood(mtmp, obj)) <= CADAVER){
X  			nix = omx;
X  			niy = omy;
X! 			dog_eat(mtmp, obj, otyp, nix, niy);
X! 			goto newdogpos;
X  		    }
X  		    if(can_carry(mtmp, obj))
X  		    if(rn2(20) < edog->apport+3)
X***************
X*** 137,143 ****
X  	    }
X  
X  	if(gtyp == UNDEF ||
X! 	  (gtyp != DOGFOOD && gtyp != APPORT && moves < EDOG(mtmp)->hungrytime)){
X  		if(dogroom < 0 || dogroom == uroom){
X  			gx = u.ux;
X  			gy = u.uy;
X--- 183,189 ----
X  	    }
X  
X  	if(gtyp == UNDEF ||
X! 	  (gtyp != DOGFOOD && gtyp != APPORT && moves < edog->hungrytime)){
X  		if(dogroom < 0 || dogroom == uroom){
X  			gx = u.ux;
X  			gy = u.uy;
X***************
X*** 246,308 ****
X  
X  		/* dog eschews cursed objects */
X  		/* but likes dog food */
X! 		obj = fobj;
X! 		if(OBJ_AT(nx, ny)) 
X! 		  while(obj){
X! 		    if(obj->ox != nx || obj->oy != ny)
X! 			goto nextobj;
X  		    if(obj->cursed && !mtmp->mleashed) goto nxti;
X  		    if(obj->olet == FOOD_SYM &&
X  			(otyp = dogfood(mtmp, obj)) < MANFOOD &&
X! 			(otyp < ACCFOOD || EDOG(mtmp)->hungrytime <= moves)){
X  			/* Note: our dog likes the food so much that he
X  			might eat it even when it conceals a cursed object */
X  			nix = nx;
X  			niy = ny;
X  			chi = i;
X! 		     eatobj:
X! 			if(EDOG(mtmp)->hungrytime < moves)
X! 			    EDOG(mtmp)->hungrytime = moves;
X! 			/* Note: to get the correct percentage-eaten in case
X! 			 * oeaten is set, use "obj->owt / obj->quan /
X! 			 * base-weight".  It so happens that here we want to
X! 			 * multiply by obj->quan, which thus cancels out.
X! 			 * It is arbitrary that the pet takes the same length
X! 			 * of time to eat as a human, but gets 5X as much
X! 			 * nutrition.
X! 			 */
X! 			if(obj->otyp == CORPSE) {
X! 			    mtmp->meating =
X! 				(3 + (mons[obj->corpsenm].cwt >> 2))
X! 				* obj->owt / mons[obj->corpsenm].cwt;
X! 			    EDOG(mtmp)->hungrytime += 5 * 
X! 				mons[obj->corpsenm].cnutrit
X! 				* obj->owt / mons[obj->corpsenm].cwt;
X! 			} else {
X! 			    mtmp->meating =
X! 				objects[obj->otyp].oc_delay
X! 				* obj->owt / objects[obj->otyp].oc_weight;
X! 			    EDOG(mtmp)->hungrytime += 5 *
X! 				objects[obj->otyp].nutrition
X! 				* obj->owt / objects[obj->otyp].oc_weight;
X! 			}
X! 			mtmp->mconf = 0;
X! 			if (mtmp->mtame < 20) mtmp->mtame++;
X! 			if(cansee(nix,niy))
X! 			    pline("%s eats %s.", Monnam(mtmp), doname(obj));
X! 			/* perhaps this was a reward */
X! 			if(otyp != CADAVER)
X! #ifdef LINT	/* edog->apport += (unsigned) (200L/((long) edog->dropdist...*/
X! 			edog->apport = 0;
X! #else
X! 			edog->apport += (unsigned)(200L/
X! 				((long)edog->dropdist+moves-edog->droptime));
X! #endif
X! 			delobj(obj);
X  			goto newdogpos;
X  		    }
X- 		nextobj:
X- 		    obj = obj->nobj;
X  		}
X  
X  		for(j=0; j<MTSZ && j<cnt-1; j++)
X--- 292,310 ----
X  
X  		/* dog eschews cursed objects */
X  		/* but likes dog food */
X! 		for(obj = level.objects[nx][ny]; obj; obj = obj->nexthere) {
X  		    if(obj->cursed && !mtmp->mleashed) goto nxti;
X  		    if(obj->olet == FOOD_SYM &&
X  			(otyp = dogfood(mtmp, obj)) < MANFOOD &&
X! 			(otyp < ACCFOOD || edog->hungrytime <= moves)){
X  			/* Note: our dog likes the food so much that he
X  			might eat it even when it conceals a cursed object */
X  			nix = nx;
X  			niy = ny;
X  			chi = i;
X! 			dog_eat(mtmp, obj, otyp, nix, niy);
X  			goto newdogpos;
X  		    }
X  		}
X  
X  		for(j=0; j<MTSZ && j<cnt-1; j++)
X*** src/Old/dokick.c	Sun Nov 19 12:38:19 1989
X--- src/dokick.c	Sat Nov 18 23:06:56 1989
X***************
X*** 150,156 ****
X  	if(!rn2(clumsy ? 3 : 4) && (clumsy || !bigmonst(mon->data)) && 
X  	   mon->mcansee && !mon->mtrapped && !thick_skinned(mon->data) && 
X  	   mon->data->mlet != S_EEL && haseyes(mon->data) && !mon->mfroz && 
X! 	   !mon->mstun && !mon->mconf && mon->data->mmove >= 12) {
X  		if(!nohands(mon->data) && !rn2(martial() ? 5 : 3)) {
X  		    kludge("%s blocks your %skick.", Monnam(mon), 
X  				clumsy ? "clumsy " : "");
X--- 150,157 ----
X  	if(!rn2(clumsy ? 3 : 4) && (clumsy || !bigmonst(mon->data)) && 
X  	   mon->mcansee && !mon->mtrapped && !thick_skinned(mon->data) && 
X  	   mon->data->mlet != S_EEL && haseyes(mon->data) && !mon->mfroz && 
X! 	   !mon->mstun && !mon->mconf && !mon->msleep &&
X! 	   mon->data->mmove >= 12) {
X  		if(!nohands(mon->data) && !rn2(martial() ? 5 : 3)) {
X  		    kludge("%s blocks your %skick.", Monnam(mon), 
X  				clumsy ? "clumsy " : "");
X***************
X*** 289,300 ****
X  	boolean costly = FALSE;
X  
X  	/* if a pile, the "top" object gets kicked */
X! 	for (otmp = fobj; otmp; otmp = otmp->nobj)
X! 		if(otmp->ox == x && otmp->oy == y)
X! 		    if(!otmp->cobj) {
X! 			    cnt++;
X! 			    if(cnt == 1) obj = otmp;
X! 		    }
X  
X  	/* range < 2 means the object will not move.	*/
X  	/* maybe dexterity should also figure here.     */
X--- 290,300 ----
X  	boolean costly = FALSE;
X  
X  	/* if a pile, the "top" object gets kicked */
X! 	for (otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X! 		if(!otmp->cobj) {
X! 			cnt++;
X! 			if(cnt == 1) obj = otmp;
X! 		}
X  
X  	/* range < 2 means the object will not move.	*/
X  	/* maybe dexterity should also figure here.     */
X***************
X*** 302,309 ****
X  				ACURR(A_STR))/2 - obj->owt/4);
X  	else range = rnd((int)ACURR(A_STR));
X  
X- 	if(range < 1) range = 1; /* safety... */
X  	if(martial()) range = range + rnd(3);
X  
X  	/* see if the object has a place to move into */
X  	odx = x + u.dx;
X--- 302,309 ----
X  				ACURR(A_STR))/2 - obj->owt/4);
X  	else range = rnd((int)ACURR(A_STR));
X  
X  	if(martial()) range = range + rnd(3);
X+ 	if(range < 1) range = 1; /* safety... */
X  
X  	/* see if the object has a place to move into */
X  	odx = x + u.dx;
X***************
X*** 355,361 ****
X  		return(1);
X  	}
X  
X! 	if(obj->otyp == BOULDER || obj == uball || obj == uchain)
X  		return(0);
X  
X  	/* a box gets a chance of breaking open here */
X--- 355,363 ----
X  		return(1);
X  	}
X  
X! 	/* cnt should always be >= 1 here (meaning obj is set) due to
X! 	 * conditions of call */
X! 	if(!cnt || obj->otyp == BOULDER || obj == uball || obj == uchain)
X  		return(0);
X  
X  	/* a box gets a chance of breaking open here */
X***************
X*** 365,380 ****
X  		if (!obj->olocked && (!rn2(3) ||
X  					(martial() && !rn2(2)))) {
X  		    pline("The lid slams open, then falls shut.");
X! 		    if(otrp) goto gotcha;
X  		    return(1);
X  		} else if (obj->olocked && 
X  				(!rn2(5) || (martial() && !rn2(2)))) {
X  		    You("break open the lock!");
X  		    obj->olocked = 0;
X! 	            if(otrp) {
X! gotcha:
X! 		        chest_trap(obj, LEG);
X! 		    }
X  		    return(1);
X  		}
X  		/* let it fall through to the next cases... */
X--- 367,379 ----
X  		if (!obj->olocked && (!rn2(3) ||
X  					(martial() && !rn2(2)))) {
X  		    pline("The lid slams open, then falls shut.");
X! 		    if(otrp) chest_trap(obj, LEG);
X  		    return(1);
X  		} else if (obj->olocked && 
X  				(!rn2(5) || (martial() && !rn2(2)))) {
X  		    You("break open the lock!");
X  		    obj->olocked = 0;
X! 	            if(otrp) chest_trap(obj, LEG);
X  		    return(1);
X  		}
X  		/* let it fall through to the next cases... */
X***************
X*** 393,402 ****
X  	/* potions get a chance of breaking here */
X  	if(obj->olet == POTION_SYM) {
X  		if(rn2(2)) {
X! 		    You("smash the %s!", xname(obj));
X! 		    if(costly) addtobill(obj, FALSE);
X  		    potionbreathe(obj);
X! 		    delobj(obj);
X  		    return(1);
X  		}
X  	}
X--- 392,400 ----
X  	/* potions get a chance of breaking here */
X  	if(obj->olet == POTION_SYM) {
X  		if(rn2(2)) {
X! 		    You("smash %s %s!", obj->quan==1 ? "the" : "a", xname(obj));
X  		    potionbreathe(obj);
X! 		    useupf(obj);
X  		    return(1);
X  		}
X  	}
X***************
X*** 438,443 ****
X--- 436,443 ----
X  	    return(0);
X  	}
X  
X+ 	if (obj->quan > 1) (void) splitobj(obj, 1);
X+ 
X  	/* Needed to fool bhit's display-cleanup to show immediately	*/
X  	/* the next object in the pile.  We know here that the object	*/
X  	/* will move, so there is no need to worry about the location,	*/
X***************
X*** 448,453 ****
X--- 448,454 ----
X  
X  	mon = bhit(u.dx, u.dy, range, obj->olet,
X  			(int (*)()) 0, (int (*)()) 0, obj);
X+ 	freeobj(obj);
X  	if(mon) {
X  # ifdef WORM
X  		if (mon->mx != bhitpos.x || mon->my != bhitpos.y)
X***************
X*** 459,464 ****
X--- 460,467 ----
X  	}
X  	if(costly && !costly_spot(bhitpos.x,bhitpos.y)) addtobill(obj, FALSE);
X  	move_object(obj, bhitpos.x, bhitpos.y);
X+ 	obj->nobj = fobj;
X+ 	fobj = obj;
X  	stackobj(obj);
X  	if(!MON_AT(obj->ox, obj->oy))
X  	    newsym(obj->ox, obj->oy);
X***************
X*** 548,559 ****
X  		    if(rn2(30) < avrg_attrib) { 
X  			pline("Crash!  You kick open a secret door!");
X  			maploc->typ = DOOR;
X- 			atl(x, y, (char) DOOR_SYM);
X  			if(maploc->doormask & D_TRAPPED) {
X  			    b_trapped("door");
X  			    maploc->doormask = D_NODOOR;
X  			} else
X  			    maploc->doormask = D_ISOPEN;
X  			return(1);
X  		    } else goto ouch;
X  		}
X--- 551,563 ----
X  		    if(rn2(30) < avrg_attrib) { 
X  			pline("Crash!  You kick open a secret door!");
X  			maploc->typ = DOOR;
X  			if(maploc->doormask & D_TRAPPED) {
X  			    b_trapped("door");
X  			    maploc->doormask = D_NODOOR;
X  			} else
X  			    maploc->doormask = D_ISOPEN;
X+ 			mnewsym(x,y);
X+ 			prl(x,y);
X  			return(1);
X  		    } else goto ouch;
X  		}
X***************
X*** 561,567 ****
X  		    if(rn2(30) < avrg_attrib) { 
X  			pline("Crash!  You kick open a secret passage!");
X  			maploc->typ = CORR;
X! 			atl(x, y, (char) CORR_SYM);
X  			return(1);
X  		    } else goto ouch;
X  		}
X--- 565,572 ----
X  		    if(rn2(30) < avrg_attrib) { 
X  			pline("Crash!  You kick open a secret passage!");
X  			maploc->typ = CORR;
X! 			mnewsym(x,y);
X! 			prl(x,y);
X  			return(1);
X  		    } else goto ouch;
X  		}
X***************
X*** 575,581 ****
X  			mkgold((long)rnd(200), x, y);
X  			prl(x, y);
X  			return(1);
X! 		    } else if(u.uluck && !rn2(3) && !maploc->doormask) {
X  			You("kick loose some ornamental coins and gems!");
X  			mkgold((300L+(long)rn2(201)), x, y);
X  			i = u.uluck + 1;
X--- 580,586 ----
X  			mkgold((long)rnd(200), x, y);
X  			prl(x, y);
X  			return(1);
X! 		    } else if(u.uluck && !rn2(3) && !maploc->looted) {
X  			You("kick loose some ornamental coins and gems!");
X  			mkgold((300L+(long)rn2(201)), x, y);
X  			i = u.uluck + 1;
X***************
X*** 583,589 ****
X  			while(i--) (void) mkobj_at(GEM_SYM, x, y);
X  			prl(x, y);
X  			/* prevent endless milking */
X! 			maploc->doormask = T_LOOTED; 
X  			return(1);
X  		    } else if (!rn2(4)) {
X  			register struct trap *ttmp = 
X--- 588,594 ----
X  			while(i--) (void) mkobj_at(GEM_SYM, x, y);
X  			prl(x, y);
X  			/* prevent endless milking */
X! 			maploc->looted = T_LOOTED;
X  			return(1);
X  		    } else if (!rn2(4)) {
X  			register struct trap *ttmp = 
X***************
X*** 617,623 ****
X  			      Hallucination ? hcolor() : black);
X  			pmon(makemon(&mons[PM_BLACK_PUDDING], x, y));
X  			return(1);
X! #  ifdef HARD
X  		    } else if(!rn2(3) &&
X  #   ifndef POLYSELF
X  			      poly_gender() != 2 &&
X--- 622,628 ----
X  			      Hallucination ? hcolor() : black);
X  			pmon(makemon(&mons[PM_BLACK_PUDDING], x, y));
X  			return(1);
X! #  ifdef INFERNO
X  		    } else if(!rn2(3) &&
X  #   ifndef POLYSELF
X  			      poly_gender() != 2 &&
X***************
X*** 630,641 ****
X  #  endif
X  		    } else if(!rn2(3)) {
X  			pline("Flupp!  Muddy waste pops up from the drain.");
X! 			if(!maploc->doormask) { /* only once per sink */
X  			    if(!Blind) 
X  				You("see a ring shining in its midst.");
X  			    (void) mkobj_at(RING_SYM, x, y);
X  			    prl(x, y);
X! 			    maploc->doormask = T_LOOTED;
X  			}
X  			return(1);
X  		    }
X--- 635,646 ----
X  #  endif
X  		    } else if(!rn2(3)) {
X  			pline("Flupp!  Muddy waste pops up from the drain.");
X! 			if(!maploc->looted) { /* only once per sink */
X  			    if(!Blind) 
X  				You("see a ring shining in its midst.");
X  			    (void) mkobj_at(RING_SYM, x, y);
X  			    prl(x, y);
X! 			    maploc->looted = T_LOOTED;
X  			}
X  			return(1);
X  		    }
X***************
X*** 692,700 ****
X  		} else {
X  		    pline("As you kick the door, it crashes open!");
X  		    maploc->doormask = D_BROKEN;
X! 		    if(in_shop(x, y) && !in_shop(u.ux, u.uy))
X  			pay_for_door(x, y, "break");
X  		}
X  	} else	pline("WHAMMM!!!");
X  
X  	return(1);
X--- 697,707 ----
X  		} else {
X  		    pline("As you kick the door, it crashes open!");
X  		    maploc->doormask = D_BROKEN;
X! 		    if(in_shop(x, y))
X  			pay_for_door(x, y, "break");
X  		}
X+ 		mnewsym(x,y);
X+ 		prl(x,y);
X  	} else	pline("WHAMMM!!!");
X  
X  	return(1);
X*** src/Old/dothrow.c	Sun Nov 19 12:38:45 1989
X--- src/dothrow.c	Fri Nov 17 19:31:32 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)dothrow.c	3.0	88/10/22
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)dothrow.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 6,13 ****
X  
X  #include "hack.h"
X  
X! static void gem_accept P((struct monst *, struct obj *));
X! static int throw_gold P((struct obj *));
X  static const char toss_objs[] = { '0', GOLD_SYM, '#', WEAPON_SYM, 0 };
X  #ifdef WORM
X  extern boolean notonhead;
X--- 6,13 ----
X  
X  #include "hack.h"
X  
X! static void FDECL(gem_accept, (struct monst *, struct obj *));
X! static int FDECL(throw_gold, (struct obj *));
X  static const char toss_objs[] = { '0', GOLD_SYM, '#', WEAPON_SYM, 0 };
X  #ifdef WORM
X  extern boolean notonhead;
X***************
X*** 255,261 ****
X  		}
X  		return(1);
X  	}
X! 	if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE || obj->olet == GEM_SYM) {
X  		if(obj->otyp < DART || obj->olet == GEM_SYM) {
X  		    if (!uwep ||
X  			objects[obj->otyp].w_propellor !=
X--- 255,262 ----
X  		}
X  		return(1);
X  	}
X! 	if(obj->olet == WEAPON_SYM || obj->otyp == PICK_AXE ||
X! 	   obj->otyp == UNICORN_HORN || obj->olet == GEM_SYM) {
X  		if(obj->otyp < DART || obj->olet == GEM_SYM) {
X  		    if (!uwep ||
X  			objects[obj->otyp].w_propellor !=
X*** src/Old/eat.c	Sun Nov 19 12:39:11 1989
X--- src/eat.c	Sat Nov 18 18:18:49 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)eat.c	3.0	88/10/22
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)eat.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,22 ****
X  #include	"hack.h"
X  /*#define DEBUG 	/* uncomment to enable new eat code debugging */
X  
X! static int fpostfx P((struct obj *));
X! static int cpostfx P((int));
X  
X  char corpsename[60];
X  char msgbuf[BUFSZ];
X  
X  /* hunger texts used on bottom line (each 8 chars long) */
X! #define	SATIATED	0
X  #define NOT_HUNGRY	1
X! #define	HUNGRY		2
X! #define	WEAK		3
X! #define	FAINTING	4
X  #define FAINTED		5
X  #define STARVED		6
X  
X--- 5,30 ----
X  #include	"hack.h"
X  /*#define DEBUG 	/* uncomment to enable new eat code debugging */
X  
X! #ifdef DEBUG
X! # ifdef WIZARD
X! #define debug	if (wizard) pline
X! # else
X! #define debug	pline
X! # endif
X! #endif
X! 
X! static void FDECL(fpostfx, (struct obj *));
X! static void FDECL(cpostfx, (int));
X  
X  char corpsename[60];
X  char msgbuf[BUFSZ];
X  
X  /* hunger texts used on bottom line (each 8 chars long) */
X! #define SATIATED	0
X  #define NOT_HUNGRY	1
X! #define HUNGRY		2
X! #define WEAK		3
X! #define FAINTING	4
X  #define FAINTED		5
X  #define STARVED		6
X  
X***************
X*** 34,50 ****
X  
X  /* calculate x/y, rounding as appropriate */
X  
X! static int
X  rounddiv(x, y)
X! int x, y;
X  {
X! 	int divsgn;
X! 	int r, m;
X  
X  	if (y == 0)
X  		panic("division by zero in rounddiv");
X! 	divsgn = (x*y > 0) ? 1 : -1;
X! 	x = abs(x); y = abs(y);
X  	r = x/y;
X  	m = x%y;
X  	if (2*m >= y)
X--- 42,62 ----
X  
X  /* calculate x/y, rounding as appropriate */
X  
X! static long
X  rounddiv(x, y)
X! long x, y;
X  {
X! 	int divsgn = 1;
X! 	long r, m;
X  
X  	if (y == 0)
X  		panic("division by zero in rounddiv");
X! 	if (x < 0) {
X! 		divsgn = -divsgn; x = -x;
X! 	}
X! 	if (y < 0) {
X! 		divsgn = -divsgn; y = -y;
X! 	}
X  	r = x/y;
X  	m = x%y;
X  	if (2*m >= y)
X***************
X*** 79,86 ****
X  				 * a tin, which uses the tin structure above */
X  	int	usedtime,	/* turns spent eating */
X  		reqtime;	/* turns required to eat */
X! 	int	nutrit,		/* total nutrition at beginning */
X! 		nmod;		/* coded nutrition per turn */
X  	Bitfield(canchoke,1);	/* was satiated at beginning */
X  	Bitfield(fullwarn,1);	/* have warned about being full */
X  	Bitfield(eating,1);	/* victual currently being eaten */
X--- 91,97 ----
X  				 * a tin, which uses the tin structure above */
X  	int	usedtime,	/* turns spent eating */
X  		reqtime;	/* turns required to eat */
X! 	int	nmod;		/* coded nutrition per turn */
X  	Bitfield(canchoke,1);	/* was satiated at beginning */
X  	Bitfield(fullwarn,1);	/* have warned about being full */
X  	Bitfield(eating,1);	/* victual currently being eaten */
X***************
X*** 87,93 ****
X  	Bitfield(doreset,1);	/* stop eating at end of turn */
X  } victual;
X  
X! static int
X  Meatdone() {		/* called after mimicing is over */
X  	u.usym =
X  #ifdef POLYSELF
X--- 98,107 ----
X  	Bitfield(doreset,1);	/* stop eating at end of turn */
X  } victual;
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  Meatdone() {		/* called after mimicing is over */
X  	u.usym =
X  #ifdef POLYSELF
X***************
X*** 101,110 ****
X  /* Created by GAN 01/28/87
X   * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X   * Amended by 3.  06/12/89: if not hard, sometimes choke anyway, to keep risk.
X   */
X  /*ARGSUSED*/
X  static void
X! choke(food)
X  	register struct obj *food;
X  {
X  	/* only happens if you were satiated */
X--- 115,125 ----
X  /* Created by GAN 01/28/87
X   * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X   * Amended by 3.  06/12/89: if not hard, sometimes choke anyway, to keep risk.
X+  *		  11/10/89: if hard, rarely vomit anyway, for slim chance.
X   */
X  /*ARGSUSED*/
X  static void
X! choke(food)	/* To a full belly all food is bad. (It.) */
X  	register struct obj *food;
X  {
X  	/* only happens if you were satiated */
X***************
X*** 113,152 ****
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL)
X  		u.ualign--;	/* gluttony is unchivalrous */
X  
X! #ifndef HARD
X  	if (rn2(20)) {
X  		You("stuff yourself and then vomit voluminously.");
X  		morehungry(1000);	/* you just got *very* sick! */
X  		vomit();
X  	} else {
X- #endif
X  		if(food) {
X! 			killer = singular(food);
X  		} else
X  			killer = "exuberant appetite";
X  		You("choke over your food.");
X  		You("die...");
X  		done(CHOKING);
X- #ifndef HARD
X  	}
X- #endif
X  }
X  
X  static void
X  recalc_wt() {	/* modify object wt. depending on time spent consuming it */
X! 	int baseweight = weight(victual.piece);	/* weight of full item */
X  
X  #ifdef DEBUG
X! 	pline("Old weight = %d", victual.piece->owt);
X! 	pline("Used time = %d, Req'd time = %d",
X  		victual.usedtime, victual.reqtime);
X  #endif
X! 	if(victual.usedtime)
X! 	    victual.piece->owt = (unsigned)rounddiv(
X! 			    baseweight * (victual.reqtime - victual.usedtime),
X! 			    victual.reqtime );
X  #ifdef DEBUG
X! 	pline("New weight = %d", victual.piece->owt);
X  #endif
X  }
X  
X--- 128,166 ----
X  	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL)
X  		u.ualign--;	/* gluttony is unchivalrous */
X  
X! #ifdef HARD
X! 	if (!rn2(20)) {
X! #else
X  	if (rn2(20)) {
X+ #endif
X  		You("stuff yourself and then vomit voluminously.");
X  		morehungry(1000);	/* you just got *very* sick! */
X  		vomit();
X  	} else {
X  		if(food) {
X! 			killer = singular(food, xname);
X  		} else
X  			killer = "exuberant appetite";
X  		You("choke over your food.");
X  		You("die...");
X  		done(CHOKING);
X  	}
X  }
X  
X  static void
X  recalc_wt() {	/* modify object wt. depending on time spent consuming it */
X! 	register struct obj *piece = victual.piece;
X  
X  #ifdef DEBUG
X! 	debug("Old weight = %d", piece->owt);
X! 	debug("Used time = %d, Req'd time = %d",
X  		victual.usedtime, victual.reqtime);
X  #endif
X! 	/* weight(piece) = weight of full item */
X!   	if(victual.usedtime)
X! 	    piece->owt = eaten_stat(weight(piece), piece);
X  #ifdef DEBUG
X! 	debug("New weight = %d", piece->owt);
X  #endif
X  }
X  
X***************
X*** 158,164 ****
X       */
X  	if(victual.eating && !victual.doreset) {
X  #ifdef DEBUG
X! 	    pline("reset_eat...");
X  #endif
X  	    victual.doreset = TRUE;
X  	}
X--- 172,178 ----
X       */
X  	if(victual.eating && !victual.doreset) {
X  #ifdef DEBUG
X! 	    debug("reset_eat...");
X  #endif
X  	    victual.doreset = TRUE;
X  	}
X***************
X*** 169,191 ****
X  touchfood(otmp)
X  register struct obj *otmp;
X  {
X! 	if(otmp->quan > 1) {
X! 
X  	    otmp = splitobj(otmp, (int)otmp->quan-1);
X  #ifdef DEBUG
X! 	    pline("split object,");
X  #endif
X! 
X! 	    otmp->oeaten = TRUE;
X! 	    if(carried(otmp)) {
X! 		freeinv(otmp);
X! 		if(inv_cnt() >= 52)
X! 		    dropy(otmp);
X! 		else
X! 		    otmp = addinv(otmp); /* unlikely but a merge is possible */
X! 	    }
X! 	} else
X! 	    otmp->oeaten = TRUE;
X  	return(otmp);
X  }
X  
X--- 183,205 ----
X  touchfood(otmp)
X  register struct obj *otmp;
X  {
X! 	if (otmp->quan > 1) {
X  	    otmp = splitobj(otmp, (int)otmp->quan-1);
X  #ifdef DEBUG
X! 	    debug("split object,");
X  #endif
X! 	}
X! 	if (!otmp->oeaten)
X! 	    otmp->oeaten = (otmp->otyp == CORPSE ?
X! 				(int)mons[otmp->corpsenm].cnutrit :
X! 				objects[otmp->otyp].nutrition);
X! 	if (carried(otmp)) {
X! 	    freeinv(otmp);
X! 	    if(inv_cnt() >= 52)
X! 		dropy(otmp);
X! 	    else
X! 		otmp = addinv(otmp); /* unlikely but a merge is possible */
X! 	}
X  	return(otmp);
X  }
X  
X***************
X*** 193,199 ****
X  do_reset_eat() {
X  
X  #ifdef DEBUG
X! 	pline("do_reset_eat...");
X  #endif
X  	victual.piece = touchfood(victual.piece);
X  	recalc_wt();
X--- 207,213 ----
X  do_reset_eat() {
X  
X  #ifdef DEBUG
X! 	debug("do_reset_eat...");
X  #endif
X  	victual.piece = touchfood(victual.piece);
X  	recalc_wt();
X***************
X*** 202,216 ****
X  	stop_occupation();
X  }
X  
X! static int
X  eatfood() {		/* called each move during eating process */
X! 
X  	if(!victual.eating) return(0);
X  	if(victual.usedtime++ < victual.reqtime) {
X  	/* You can only choke if you were satiated before you started
X  	 * eating.
X  	 */
X! 	    if(victual.canchoke && u.uhunger >= 2000) choke(victual.piece);
X  
X  	    if(victual.nmod < 0)
X  		lesshungry(-victual.nmod);
X--- 216,241 ----
X  	stop_occupation();
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  eatfood() {		/* called each move during eating process */
X! 	if(!carried(victual.piece) && !obj_here(victual.piece, u.ux, u.uy)) {
X! 		/* maybe it was stolen? */
X! 		do_reset_eat();
X! 		return(0);
X! 	}
X  	if(!victual.eating) return(0);
X  	if(victual.usedtime++ < victual.reqtime) {
X  	/* You can only choke if you were satiated before you started
X  	 * eating.
X  	 */
X! 	    if(victual.canchoke && u.uhunger >= 2000) {
X! 		choke(victual.piece);
X! 		do_reset_eat(); /* if they were lifesaved, stop eating */
X! 		return 0;
X! 	    }
X  
X  	    if(victual.nmod < 0)
X  		lesshungry(-victual.nmod);
X***************
X*** 218,240 ****
X  		lesshungry(1);
X  
X  	    if(victual.doreset) do_reset_eat();
X  	    return 1;	/* still busy */
X  	} else {	/* done */
X! 
X! 	    register int tp;
X  
X  	    if(victual.piece->otyp == CORPSE)
X! 		tp = cpostfx(victual.piece->corpsenm);
X  	    else
X! 		tp = fpostfx(victual.piece);
X! 
X! 	    You("finish eating the %s.", singular(victual.piece));
X  
X! 	    useup(victual.piece);
X  	    victual.piece = (struct obj *) 0;
X  	    victual.fullwarn = victual.eating = victual.doreset = 
X  		victual.canchoke = FALSE;
X! 	    return(tp);
X  	}
X  }
X  
X--- 243,283 ----
X  		lesshungry(1);
X  
X  	    if(victual.doreset) do_reset_eat();
X+ 	    else {
X+ 		/* We have to calculate this every move--sometimes the thing
X+ 		 * which interrupts eating also needs to know the state of your
X+ 		 * food, so it's no good to recalculate the state of your food
X+ 		 * only after you stopped eating.  Currently, the only meal-
X+ 		 * interruptor which needs to know it is troll revivication,
X+ 		 * and it only needs to know oeaten and the weight.
X+ 		 */
X+ 		if (victual.nmod < 0)
X+ 			victual.piece->oeaten -= -victual.nmod;
X+ 		else if (victual.nmod > 0 && (victual.usedtime % victual.nmod))
X+ 			victual.piece->oeaten--;
X+ 		recalc_wt();
X+ 	    }
X  	    return 1;	/* still busy */
X  	} else {	/* done */
X! #ifndef NO_SIGNAL
X! 	    victual.piece->in_use = TRUE;
X! #endif
X! 	    if (nomovemsg) {
X! 		pline(nomovemsg);
X! 		nomovemsg = 0;
X! 	    } else You("finish eating the %s.", singular(victual.piece, xname));
X  
X  	    if(victual.piece->otyp == CORPSE)
X! 		cpostfx(victual.piece->corpsenm);
X  	    else
X! 		fpostfx(victual.piece);
X  
X! 	    if (carried(victual.piece)) useup(victual.piece);
X! 	    else useupf(victual.piece);
X  	    victual.piece = (struct obj *) 0;
X  	    victual.fullwarn = victual.eating = victual.doreset = 
X  		victual.canchoke = FALSE;
X! 	    return(0);
X  	}
X  }
X  
X***************
X*** 243,249 ****
X  register int pm;
X  {
X  	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X! 		You("cannibal!  You will be sorry for this!");
X  		Aggravate_monster |= INTRINSIC;
X  	}
X  
X--- 286,292 ----
X  register int pm;
X  {
X  	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X! 		You("cannibal!	You will regret this!");
X  		Aggravate_monster |= INTRINSIC;
X  	}
X  
X***************
X*** 270,275 ****
X--- 313,325 ----
X  #ifdef POLYSELF
X  		}
X  		break;
X+ 	    case PM_LIZARD:
X+ 		/* Relief from cockatrices -dgk */
X+ 		if (Stoned) {
X+ 			Stoned = 0;
X+ 			You("feel limber!");
X+ 		}
X+ 		break;
X  	    default:
X  
X  		if(dmgtype(&mons[pm], AD_ACID) && Stoned) {
X***************
X*** 281,291 ****
X  	return;
X  }
X  
X! static int
X  cpostfx(pm)		/* called after completely consuming a corpse */
X  register int pm;
X  {
X! 	register int tmp = 0, tp = 0;
X  
X  	switch(pm) {
X  	    case PM_WRAITH:
X--- 331,341 ----
X  	return;
X  }
X  
X! static void
X  cpostfx(pm)		/* called after completely consuming a corpse */
X  register int pm;
X  {
X! 	register int tmp = 0;
X  
X  	switch(pm) {
X  	    case PM_WRAITH:
X***************
X*** 334,342 ****
X  	    case PM_SMALL_MIMIC:
X  		tmp += 20;
X  		if(u.usym == S_HUMAN) {
X! 		    You("cannot resist the temptation to mimic a treasure chest.");
X! 		    nomul(tmp);
X! 		    tp++;
X  		    afternmv = Meatdone;
X  		    if (pl_character[0]=='E')
X  			nomovemsg = "You now again prefer mimicking an elf.";
X--- 384,391 ----
X  	    case PM_SMALL_MIMIC:
X  		tmp += 20;
X  		if(u.usym == S_HUMAN) {
X! 		    You("cannot resist the temptation to mimic a pile of gold.");
X! 		    nomul(-tmp);
X  		    afternmv = Meatdone;
X  		    if (pl_character[0]=='E')
X  			nomovemsg = "You now again prefer mimicking an elf.";
X***************
X*** 363,368 ****
X--- 412,421 ----
X  			You("seem faster.");
X  		}
X  		break;
X+ 	    case PM_LIZARD:
X+ 		if (HStun > 2)  make_stunned(2L,FALSE);
X+ 		if (HConfusion > 2)  make_confused(2L,FALSE);
X+ 		break;
X  #ifdef POLYSELF
X  	    case PM_CHAMELEON:
X  		You("feel a change coming over you.");
X***************
X*** 427,440 ****
X  	    }
X  	    break;
X  	}
X! 	return(tp);
X  }
X  
X! static int
X! opentin() {		/* called during each move whilst opening a tin */
X  	register int r;
X  
X! 	if(!carried(tin.tin))		/* perhaps it was stolen? */
X  		return(0);		/* %% probably we should use tinoid */
X  	if(tin.usedtime++ >= 50) {
X  		You("give up your attempt to open the tin.");
X--- 480,498 ----
X  	    }
X  	    break;
X  	}
X! 	return;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X! opentin()		/* called during each move whilst opening a tin */
X! {
X  	register int r;
X  
X! 	if(!carried(tin.tin) && !obj_here(tin.tin, u.ux, u.uy))
X! 					/* perhaps it was stolen? */
X  		return(0);		/* %% probably we should use tinoid */
X  	if(tin.usedtime++ >= 50) {
X  		You("give up your attempt to open the tin.");
X***************
X*** 444,451 ****
X  		return(1);		/* still busy */
X  	if(tin.tin->cursed && !rn2(8)) {
X  		b_trapped("tin");
X! 		useup(tin.tin);
X! 		return(0);
X  	}
X  	You("succeed in opening the tin.");
X  	if(!tin.tin->spe) {
X--- 502,508 ----
X  		return(1);		/* still busy */
X  	if(tin.tin->cursed && !rn2(8)) {
X  		b_trapped("tin");
X! 		goto use_me;
X  	}
X  	You("succeed in opening the tin.");
X  	if(!tin.tin->spe) {
X***************
X*** 452,459 ****
X  	    if(tin.tin->corpsenm == -1) {
X  		pline("It turns out to be empty.");
X  		tin.tin->dknown = tin.tin->known = TRUE;
X! 		useup(tin.tin);
X! 		return(0);
X  	    }
X  	    r = tin.tin->cursed ? 4 : rn2(TTSZ-1); /* Always rotten if cursed */
X  	    pline("It smells like %s.", makeplural(
X--- 509,515 ----
X  	    if(tin.tin->corpsenm == -1) {
X  		pline("It turns out to be empty.");
X  		tin.tin->dknown = tin.tin->known = TRUE;
X! 		goto use_me;
X  	    }
X  	    r = tin.tin->cursed ? 4 : rn2(TTSZ-1); /* Always rotten if cursed */
X  	    pline("It smells like %s.", makeplural(
X***************
X*** 461,473 ****
X  	    pline("Eat it? ");
X  	    if (yn() == 'n') {
X  		if (!Hallucination) tin.tin->dknown = tin.tin->known = TRUE;
X! 		useup(tin.tin);
X! 		return 0;
X  	    }
X  	    You("consume %s %s.", tintxts[r].txt,
X  		  mons[tin.tin->corpsenm].mname);
X  	    tin.tin->dknown = tin.tin->known = TRUE;
X! 	    cprefx(tin.tin->corpsenm); (void) cpostfx(tin.tin->corpsenm);
X  
X  	    /* check for vomiting added by GAN 01/16/87 */
X  	    if(tintxts[r].nut < 0) make_vomiting((long)rn1(15,10), FALSE);
X--- 517,529 ----
X  	    pline("Eat it? ");
X  	    if (yn() == 'n') {
X  		if (!Hallucination) tin.tin->dknown = tin.tin->known = TRUE;
X! 		if (flags.verbose) You("discard the open tin.");
X! 		goto use_me;
X  	    }
X  	    You("consume %s %s.", tintxts[r].txt,
X  		  mons[tin.tin->corpsenm].mname);
X  	    tin.tin->dknown = tin.tin->known = TRUE;
X! 	    cprefx(tin.tin->corpsenm); cpostfx(tin.tin->corpsenm);
X  
X  	    /* check for vomiting added by GAN 01/16/87 */
X  	    if(tintxts[r].nut < 0) make_vomiting((long)rn1(15,10), FALSE);
X***************
X*** 483,496 ****
X  		pline("It contains some decaying %s substance.",
X  			Hallucination ? hcolor() : green);
X  	    else
X! 		pline("It contains spinach - this makes you feel like %s!",
X! 			Hallucination ? "Swee'pea" : "Popeye");
X  
X  	    lesshungry(600);
X  	    gainstr(tin.tin, 0);
X  	}
X  	tin.tin->dknown = tin.tin->known = TRUE;
X! 	useup(tin.tin);
X  	return(0);
X  }
X  
X--- 539,564 ----
X  		pline("It contains some decaying %s substance.",
X  			Hallucination ? hcolor() : green);
X  	    else
X! 		pline("It contains spinach.");
X  
X+ 	    pline("Eat it? ");
X+ 	    if (yn() == 'n') {
X+ 		if (!Hallucination && !tin.tin->cursed)
X+ 		    tin.tin->dknown = tin.tin->known = TRUE;
X+ 		if (flags.verbose)
X+ 		    You("discard the open tin.");
X+ 		goto use_me;
X+ 	    }
X+ 	    if (!tin.tin->cursed)
X+ 		pline("This makes you feel like %s!",
X+ 		      Hallucination ? "Swee'pea" : "Popeye");
X  	    lesshungry(600);
X  	    gainstr(tin.tin, 0);
X  	}
X  	tin.tin->dknown = tin.tin->known = TRUE;
X! use_me:
X! 	if (carried(tin.tin)) useup(tin.tin);
X! 	else useupf(tin.tin);
X  	return(0);
X  }
X  
X***************
X*** 538,544 ****
X  				obj = splitobj(otmp, 1);
X  				if(otmp == uwep) setuwep(obj);
X  			}
X! 			dropx(otmp);
X  			return;
X  		}
X  		tmp = 10 + rn2(1 + 500/((int)(ACURR(A_DEX) + ACURR(A_STR))));
X--- 606,613 ----
X  				obj = splitobj(otmp, 1);
X  				if(otmp == uwep) setuwep(obj);
X  			}
X! 			if (carried(otmp)) dropx(otmp);
X! 			else stackobj(otmp);
X  			return;
X  		}
X  		tmp = 10 + rn2(1 + 500/((int)(ACURR(A_DEX) + ACURR(A_STR))));
X***************
X*** 586,602 ****
X  	register struct obj *otmp;
X  {
X  	register char *cname = mons[otmp->corpsenm].mname;
X! 	register int tp, rotted;
X  
X  	tp = 0;
X! #ifdef LINT	/* problem if more than 320K moves before try to eat */
X! 	rotted = 0;
X! #else
X! 	rotted = (monstermoves - otmp->age)/((long)(10 + rn2(20)));
X  #endif
X  
X! 	if(otmp->cursed) rotted += 2;
X! 	else if (otmp->blessed) rotted -= 2;
X  
X  	if(otmp->corpsenm != PM_ACID_BLOB && (rotted > 5)) {
X  		tp++;
X--- 655,672 ----
X  	register struct obj *otmp;
X  {
X  	register char *cname = mons[otmp->corpsenm].mname;
X! 	register int tp, rotted = 0;
X  
X  	tp = 0;
X! 
X! 	if(otmp->corpsenm != PM_LIZARD) {
X! #ifndef LINT	/* problem if more than 320K moves before try to eat */
X! 		rotted = (monstermoves - otmp->age)/((long)(10 + rn2(20)));
X  #endif
X  
X! 		if(otmp->cursed) rotted += 2;
X! 		else if (otmp->blessed) rotted -= 2;
X! 	}
X  
X  	if(otmp->corpsenm != PM_ACID_BLOB && (rotted > 5)) {
X  		tp++;
X***************
X*** 615,621 ****
X  #ifdef POLYSELF
X  		}
X  #endif
X! 		useup(otmp);
X  		return(1);
X  	} else if(poisonous(&mons[otmp->corpsenm]) && rn2(5)){
X  		tp++;
X--- 685,692 ----
X  #ifdef POLYSELF
X  		}
X  #endif
X! 		if (carried(otmp)) useup(otmp);
X! 		else useupf(otmp);
X  		return(1);
X  	} else if(poisonous(&mons[otmp->corpsenm]) && rn2(5)){
X  		tp++;
X***************
X*** 634,646 ****
X  		You("feel%s sick.", (Sick) ? " very" : "");
X  		losehp(rnd(8), "cadaver");
X  	}
X! 	if(!tp && !rn2(7)) {
X  
X  	    if(rottenfood()) {
X  		(void)touchfood(otmp);
X  		return(1);
X  	    }
X! 	    victual.nutrit = (int)mons[otmp->corpsenm].cnutrit >> 2;
X  	} else {
X  #ifdef POLYSELF
X  	    pline("That %s corpse %s!", cname,
X--- 705,718 ----
X  		You("feel%s sick.", (Sick) ? " very" : "");
X  		losehp(rnd(8), "cadaver");
X  	}
X! 	if(!tp && otmp->corpsenm != PM_LIZARD && (otmp->orotten || !rn2(7))) {
X  
X  	    if(rottenfood()) {
X+ 		otmp->orotten = TRUE;
X  		(void)touchfood(otmp);
X  		return(1);
X  	    }
X! 	    otmp->oeaten >>= 2;
X  	} else {
X  #ifdef POLYSELF
X  	    pline("That %s corpse %s!", cname,
X***************
X*** 648,657 ****
X  #else
X  	    pline("That %s corpse tasted terrible!", cname);
X  #endif
X- 	    victual.nutrit = (int)mons[otmp->corpsenm].cnutrit;
X  	}
X  
X! 	/* delay is weight dependant */
X  	victual.reqtime = 3 + (mons[otmp->corpsenm].cwt >> 2);
X  	return(0);
X  }
X--- 720,728 ----
X  #else
X  	    pline("That %s corpse tasted terrible!", cname);
X  #endif
X  	}
X  
X! 	/* delay is weight dependent */
X  	victual.reqtime = 3 + (mons[otmp->corpsenm].cwt >> 2);
X  	return(0);
X  }
X***************
X*** 661,670 ****
X  	register struct obj *otmp;
X  {
X  #ifdef DEBUG
X! 	pline("start_eating: %x (victual = %x)", otmp, victual.piece);
X! 	pline("reqtime = %d", victual.reqtime);
X! 	pline("nutrit = %d", victual.nutrit);
X! 	pline("nmod = %d", victual.nmod);
X  #endif
X  	victual.fullwarn = victual.doreset = FALSE;
X  	victual.canchoke = (u.uhs == SATIATED);
X--- 732,742 ----
X  	register struct obj *otmp;
X  {
X  #ifdef DEBUG
X! 	debug("start_eating: %lx (victual = %lx)", otmp, victual.piece);
X! 	debug("reqtime = %d", victual.reqtime);
X! 	debug("(original reqtime = %d)", objects[otmp->otyp].oc_delay);
X! 	debug("nmod = %d", victual.nmod);
X! 	debug("oeaten = %d", otmp->oeaten);
X  #endif
X  	victual.fullwarn = victual.doreset = FALSE;
X  	victual.canchoke = (u.uhs == SATIATED);
X***************
X*** 673,679 ****
X  	if (otmp->otyp == CORPSE)
X  	    cprefx(victual.piece->corpsenm);
X  
X! 	Sprintf(msgbuf, "eating the %s", singular(otmp));
X  	set_occupation(eatfood, msgbuf, 0);
X  }
X  
X--- 745,751 ----
X  	if (otmp->otyp == CORPSE)
X  	    cprefx(victual.piece->corpsenm);
X  
X! 	Sprintf(msgbuf, "eating the %s", singular(otmp, xname));
X  	set_occupation(eatfood, msgbuf, 0);
X  }
X  
X***************
X*** 711,723 ****
X  			make_vomiting((long)rn1(victual.reqtime, 10), FALSE);
X  		}
X  		break;
X- 	    case DEAD_LIZARD:
X- 		/* Relief from cockatrices -dgk */
X- 		if (Stoned) {
X- 			Stoned = 0;
X- 			You("feel limber!");
X- 		}
X- 		break;
X  #ifdef POLYSELF
X  	    case CLOVE_OF_GARLIC:
X  		if (is_undead(uasmon)) {
X--- 783,788 ----
X***************
X*** 764,770 ****
X  	}
X  }
X  
X! static int
X  fpostfx(otmp)		/* called after consuming (non-corpse) food */
X  
X  	register struct obj *otmp;
X--- 829,835 ----
X  	}
X  }
X  
X! static void
X  fpostfx(otmp)		/* called after consuming (non-corpse) food */
X  
X  	register struct obj *otmp;
X***************
X*** 780,789 ****
X  		}
X  		break;
X  #endif
X- 	    case DEAD_LIZARD:
X- 		if (HStun > 2)  make_stunned(2L,FALSE);
X- 		if (HConfusion > 2)  make_confused(2L,FALSE);
X- 		break;
X  	    case CARROT:
X  		make_blinded(0L,TRUE);
X  		break;
X--- 845,850 ----
X***************
X*** 816,837 ****
X  		}
X  		break;
X  	}
X! 	return(0);	/* must do this for sync with cpostfx() */
X  }
X  
X  int
X  doeat() {		/* generic "eat" command funtion (see cmd.c) */
X  	register struct obj *otmp;
X  
X! 	if(victual.piece &&
X! 	   (carried(victual.piece) ||
X! 	    (victual.piece->ox == u.ux && victual.piece->oy == u.uy))) {
X  
X  	    You("resume your meal.");
X  	    if(!carried(victual.piece)) {
X  		if(victual.piece->quan != 1)
X  			(void) splitobj(victual.piece, 1);
X- 		victual.piece = pick_obj(victual.piece);
X  	    }
X  	    start_eating(victual.piece);
X  	    return(1);
X--- 877,897 ----
X  		}
X  		break;
X  	}
X! 	return;
X  }
X  
X  int
X  doeat() {		/* generic "eat" command funtion (see cmd.c) */
X  	register struct obj *otmp;
X+ 	int basenutrit; 		/* nutrition of full item */
X  
X! 	if (!(otmp = floorfood("eat", 0))) return 0;
X  
X+ 	if(otmp == victual.piece) {
X  	    You("resume your meal.");
X  	    if(!carried(victual.piece)) {
X  		if(victual.piece->quan != 1)
X  			(void) splitobj(victual.piece, 1);
X  	    }
X  	    start_eating(victual.piece);
X  	    return(1);
X***************
X*** 838,845 ****
X  	}
X  
X  	/* nothing in progress - so try to find something. */
X- 	if (!(otmp = floorfood("eat", 0))) return 0;
X- 
X  	/* tins are a special case */
X  	if(otmp->otyp == TIN) {
X  	    start_tin(otmp);
X--- 898,903 ----
X***************
X*** 846,851 ****
X--- 904,912 ----
X  	    return(1);
X  	}
X  
X+ 	victual.piece = otmp = touchfood(otmp);
X+ 	victual.usedtime = 0;
X+ 
X  	/* Now we need to calculate delay and nutritional info.
X  	 * The base nutrition calculated here and in eatcorpse() accounts
X  	 * for normal vs. rotten food.  The reqtime and nutrit values are
X***************
X*** 853,888 ****
X  	 */
X  	if(otmp->otyp == CORPSE) {
X  	    if(eatcorpse(otmp)) return(1);
X! 	    /* else eatcorpse sets up reqtime and nutrit */
X  	} else {
X  	    victual.reqtime = objects[otmp->otyp].oc_delay;
X! 	    victual.nutrit = objects[otmp->otyp].nutrition;
X! 	    if (otmp->otyp != FORTUNE_COOKIE && otmp->otyp != DEAD_LIZARD &&
X  		(otmp->cursed ||
X  		 ((monstermoves - otmp->age) > otmp->blessed ? 50 : 30)) &&
X! 		!rn2(7)) {
X  
X  		if(rottenfood()) {
X! 		    (void)touchfood(otmp);
X  		    return(1);
X  		}
X! 		victual.nutrit /= 2;
X  	    } else fprefx(otmp);
X  	}
X  
X! 	victual.piece = otmp;
X! 	victual.usedtime = 0;
X! 
X! 	/* re-calc the nutrition (already set) to account for weight */
X! 	if(otmp->oeaten) {
X! 	    int baseweight = weight(otmp);	/* weight of full item */
X! 
X! 	    victual.reqtime = 
X! 		rounddiv((int)(victual.reqtime * otmp->owt), baseweight);
X! 	    victual.nutrit = 
X! 		rounddiv((int)(victual.nutrit * otmp->owt), baseweight);
X! 	}
X  
X  	/* calculate the modulo value (nutrit. units per round eating)
X  	 * note: this isn't exact - you actually lose a little nutrition
X  	 *	 due to this method.
X--- 914,948 ----
X  	 */
X  	if(otmp->otyp == CORPSE) {
X  	    if(eatcorpse(otmp)) return(1);
X! 	    /* else eatcorpse sets up reqtime and oeaten */
X  	} else {
X  	    victual.reqtime = objects[otmp->otyp].oc_delay;
X! 	    if (otmp->otyp != FORTUNE_COOKIE &&
X  		(otmp->cursed ||
X  		 ((monstermoves - otmp->age) > otmp->blessed ? 50 : 30)) &&
X! 		(otmp->orotten || !rn2(7))) {
X  
X  		if(rottenfood()) {
X! 		    otmp->orotten = TRUE;
X  		    return(1);
X  		}
X! 		otmp->oeaten /= 2;
X  	    } else fprefx(otmp);
X  	}
X  
X! 	/* re-calc the nutrition */
X! 	if (otmp->otyp == CORPSE) basenutrit = mons[otmp->corpsenm].cnutrit;
X! 	else basenutrit = objects[otmp->otyp].nutrition;
X  
X+ #ifdef DEBUG
X+ 	debug("before rounddiv: victual.reqtime == %d", victual.reqtime);
X+ 	debug("oeaten == %d, basenutrit == %d", otmp->oeaten, basenutrit);
X+ #endif
X+ 	victual.reqtime = (basenutrit == 0 ? 0 :
X+ 	  (int)rounddiv(victual.reqtime * (long)otmp->oeaten,(long)basenutrit));
X+ #ifdef DEBUG
X+ 	debug("after rounddiv: victual.reqtime == %d", victual.reqtime);
X+ #endif
X  	/* calculate the modulo value (nutrit. units per round eating)
X  	 * note: this isn't exact - you actually lose a little nutrition
X  	 *	 due to this method.
X***************
X*** 889,901 ****
X  	 * TODO: add in a "remainder" value to be given at the end of the
X  	 *	 meal.
X  	 */
X! 	if(victual.nutrit == 0 || victual.reqtime == 0)
X  	    /* possible if most has been eaten before */
X  	    victual.nmod = 0;
X! 	else if(victual.nutrit > victual.reqtime)
X! 	    victual.nmod = -(victual.nutrit / victual.reqtime);
X  	else
X! 	    victual.nmod = victual.reqtime % victual.nutrit;
X  
X  	start_eating(otmp);
X  	return(1);
X--- 949,961 ----
X  	 * TODO: add in a "remainder" value to be given at the end of the
X  	 *	 meal.
X  	 */
X! 	if(victual.reqtime == 0)
X  	    /* possible if most has been eaten before */
X  	    victual.nmod = 0;
X! 	else if (otmp->oeaten > victual.reqtime)
X! 	    victual.nmod = -(otmp->oeaten / victual.reqtime);
X  	else
X! 	    victual.nmod = victual.reqtime % otmp->oeaten;
X  
X  	start_eating(otmp);
X  	return(1);
X***************
X*** 938,949 ****
X  register int num;
X  {
X  #ifdef DEBUG
X! 	pline("lesshungry(%d)", num);
X  #endif
X  	u.uhunger += num;
X  	if(u.uhunger >= 2000) {
X! 	    if (!victual.eating || victual.canchoke)
X  		choke((struct obj *) 0);
X  	} else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X--- 998,1011 ----
X  register int num;
X  {
X  #ifdef DEBUG
X! 	debug("lesshungry(%d)", num);
X  #endif
X  	u.uhunger += num;
X  	if(u.uhunger >= 2000) {
X! 	    if (!victual.eating || victual.canchoke) {
X  		choke((struct obj *) 0);
X+ 		reset_eat(); /* stop eating if they were lifesaved */
X+ 	    }
X  	} else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X***************
X*** 957,963 ****
X  		else {
X  		    victual.fullwarn = TRUE;
X  		    if (victual.canchoke) {
X! 			pline("Stop eating?");
X  			if(yn() == 'y') reset_eat();
X  		    }
X  		}
X--- 1019,1025 ----
X  		else {
X  		    victual.fullwarn = TRUE;
X  		    if (victual.canchoke) {
X! 			pline("Stop eating? ");
X  			if(yn() == 'y') reset_eat();
X  		    }
X  		}
X***************
X*** 967,973 ****
X  	newuhs(FALSE);
X  }
X  
X! static int
X  unfaint() {
X  	(void) Hear_again();
X  	u.uhs = FAINTING;
X--- 1029,1038 ----
X  	newuhs(FALSE);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  unfaint() {
X  	(void) Hear_again();
X  	u.uhs = FAINTING;
X***************
X*** 1045,1050 ****
X--- 1110,1118 ----
X  	}
X  }
X  
X+ /* Returns an object representing food.  Object may be either on floor or
X+  * in inventory.
X+  */
X  struct obj *
X  floorfood(verb,corpseonly)	/* get food from floor or pack */
X  	char *verb;
X***************
X*** 1060,1070 ****
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X  				(otmp->quan == 1) ? "it" : "one");
X! 			if(yn() == 'y') {
X! 				if(otmp->quan != 1)
X! 					(void) splitobj(otmp, 1);
X! 				return(pick_obj(otmp));
X! 			}
X  		}
X  	    }
X  	}
X--- 1128,1135 ----
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X  				(otmp->quan == 1) ? "it" : "one");
X! 			if(yn() == 'y')
X! 				return(otmp);
X  		}
X  	    }
X  	}
X***************
X*** 1078,1081 ****
X--- 1143,1158 ----
X  vomit() {		/* A good idea from David Neves */
X  	make_sick(0L,TRUE);
X  	nomul(-2);
X+ }
X+ 
X+ int
X+ eaten_stat(base, obj)
X+ register int base;
X+ register struct obj *obj;
X+ {
X+ 	base *= obj->oeaten;
X+ 
X+ 	if (obj->otyp == CORPSE) base /= mons[obj->corpsenm].cnutrit;
X+ 	else base /= objects[obj->otyp].nutrition;
X+ 	return (base < 1) ? 1 : base;
X  }
X*** src/Old/end.c	Sun Nov 19 12:39:59 1989
X--- src/end.c	Sun Nov  5 16:15:57 1989
X***************
X*** 15,21 ****
X  
X  void end_box_display();
X  
X! static const char *deaths[] = { 	/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X  	"burning", "crushed", "turned to stone", "genocided",
X  	"panic", "trickery",
X--- 15,21 ----
X  
X  void end_box_display();
X  
X! static const char *deaths[] = {		/* the array of death */
X  	"died", "choked", "poisoned", "starvation", "drowning",
X  	"burning", "crushed", "turned to stone", "genocided",
X  	"panic", "trickery",
X***************
X*** 44,50 ****
X  		return 0;
X  	}
X  	return done2();
X! } 
X  
X  int
X  done2()
X--- 44,50 ----
X  		return 0;
X  	}
X  	return done2();
X! }
X  
X  int
X  done2()
X***************
X*** 198,204 ****
X  	Vprintf(str,VA_ARGS);
X  	more();				/* contains a fflush() */
X  #if defined(WIZARD) && (defined(UNIX) || defined(VMS))
X! 	if (wizard)	
X  # ifdef SYSV
X  		(void)
X  # endif
X--- 198,204 ----
X  	Vprintf(str,VA_ARGS);
X  	more();				/* contains a fflush() */
X  #if defined(WIZARD) && (defined(UNIX) || defined(VMS))
X! 	if (wizard)
X  # ifdef SYSV
X  		(void)
X  # endif
X***************
X*** 243,254 ****
X  		      !Blind ? "begins to glow" : "feels warm");
X  		You("feel much better!");
X  		pline("The medallion crumbles to dust!");
X! 		if (uamul)	/* Huss:  Check if amulet really is worn */
X! 			useup(uamul);
X! 		else if (uwep && uwep->otyp == AMULET_OF_LIFE_SAVING)
X! 			useup(uwep);	/* Oops, he must be wielding it. */
X! 		else
X! 			impossible("Using an amulet without having it?");
X  		if (u.uhunger < 500) u.uhunger = 500;
X  		nomovemsg = "You survived that attempt on your life.";
X  		curs_on_u();
X--- 243,249 ----
X  		      !Blind ? "begins to glow" : "feels warm");
X  		You("feel much better!");
X  		pline("The medallion crumbles to dust!");
X! 		useup(uamul);
X  		if (u.uhunger < 500) u.uhunger = 500;
X  		nomovemsg = "You survived that attempt on your life.";
X  		curs_on_u();
X***************
X*** 367,373 ****
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   how != ASCENDED ? pl_character : 
X  		   flags.female ? "Demigoddess" : "Demigod");
X  #else
X  		   pl_character);
X--- 362,368 ----
X  	if(!done_stopprint)
X  	    Printf("Goodbye %s the %s...\n\n", buf2,
X  #ifdef ENDGAME
X! 		   how != ASCENDED ? pl_character :
X  		   flags.female ? "Demigoddess" : "Demigod");
X  #else
X  		   pl_character);
X***************
X*** 441,447 ****
X  				    doname(otmp), i);
X  			} else if(otmp->olet == AMULET_SYM) {
X  				otmp->known = 1;
X! 				i = (otmp->spe < 0) ? 2 : 
X  					otmp->otyp == AMULET_OF_YENDOR ?
X  							5000 : 500;
X  				u.urexp += i;
X--- 436,442 ----
X  				    doname(otmp), i);
X  			} else if(otmp->olet == AMULET_SYM) {
X  				otmp->known = 1;
X! 				i = (otmp->spe < 0) ? 2 :
X  					otmp->otyp == AMULET_OF_YENDOR ?
X  							5000 : 500;
X  				u.urexp += i;
X***************
X*** 459,465 ****
X  		    if (how != ASCENDED) {
X  			if(dlevel == ENDLEVEL)
X  			     Printf("in the endgame ");
X! 		    	else Printf("on dungeon level %d ", dlevel);
X  		    }
X  #else
X  		    Printf("on dungeon level %d ", dlevel);
X--- 454,460 ----
X  		    if (how != ASCENDED) {
X  			if(dlevel == ENDLEVEL)
X  			     Printf("in the endgame ");
X! 			else Printf("on dungeon level %d ", dlevel);
X  		    }
X  #else
X  		    Printf("on dungeon level %d ", dlevel);
X***************
X*** 498,505 ****
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! # if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS)) || defined(VMS) \
X! 							|| defined(MACOS)
X  	register int x;
X  #  if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X--- 493,499 ----
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! # if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS)) || defined(VMS) || defined(MACOS)
X  	register int x;
X  #  if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X***************
X*** 528,534 ****
X  end_box_display()
X  {
X  	register struct obj *box, *obj;
X- 	int boxcnt = 0;
X  	char buf[BUFSZ];
X  
X  	for(box=invent; box; box=box->nobj) {
X--- 522,527 ----
X***************
X*** 539,548 ****
X  		    if (obj->cobj == box) {
X  			if (!cnt) {
X  			    Sprintf(buf, "Contents of the %s:",xname(box));
X! 			    if (!boxcnt)
X! 				cornline(0, buf);
X! 			    else
X! 				cornline(1, buf);
X  			}
X  			makeknown(obj->otyp);
X  			obj->known = obj->bknown = obj->dknown = 1;
X--- 532,538 ----
X  		    if (obj->cobj == box) {
X  			if (!cnt) {
X  			    Sprintf(buf, "Contents of the %s:",xname(box));
X! 			    cornline(0, buf);
X  			}
X  			makeknown(obj->otyp);
X  			obj->known = obj->bknown = obj->dknown = 1;
X***************
X*** 551,565 ****
X  		    }
X  		}
X  		if (!cnt) {
X! 		    Sprintf(buf, "The %s is empty.", xname(box));
X! 		    if (!boxcnt)
X! 			cornline(0, buf);
X! 		    else
X! 			cornline(1, buf);
X! 		} else
X! 		    cornline(1," ");
X! 		boxcnt++;
X  	    }
X  	}
X- 	if (boxcnt) cornline(2,"");
X  }
X--- 541,549 ----
X  		    }
X  		}
X  		if (!cnt) {
X! 		    pline("The %s is empty.", xname(box));
X! 		    more();
X! 		} else cornline(2,"");
X  	    }
X  	}
X  }
X*** src/Old/engrave.c	Sun Nov 19 12:40:26 1989
X--- src/engrave.c	Fri Nov 17 19:31:37 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)engrave.c	3.0	89/06/12
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)engrave.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 11,24 ****
X  	unsigned engr_lth;	/* for save & restore; not length of text */
X  	long engr_time;	/* moment engraving was (will be) finished */
X  	xchar engr_type;
X! #define	DUST	1
X! #define	ENGRAVE	2
X! #define	BURN	3
X  #define MARK	4
X  #define POLY	5	/* temporary type - for polymorphing engraving */
X  } *head_engr;
X  
X! static void del_engr P((struct engr *));
X  
X  /* random engravings */
X  const char *random_engr[] =
X--- 11,24 ----
X  	unsigned engr_lth;	/* for save & restore; not length of text */
X  	long engr_time;	/* moment engraving was (will be) finished */
X  	xchar engr_type;
X! #define DUST	1
X! #define ENGRAVE	2
X! #define BURN	3
X  #define MARK	4
X  #define POLY	5	/* temporary type - for polymorphing engraving */
X  } *head_engr;
X  
X! static void FDECL(del_engr, (struct engr *));
X  
X  /* random engravings */
X  const char *random_engr[] =
END_OF_FILE
if test 55539 -ne `wc -c <'patches06f'`; then
    echo shar: \"'patches06f'\" unpacked with wrong size!
fi
# end of 'patches06f'
fi
echo shar: End of archive 3 \(of 15\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
