Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i068:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6o
Message-ID: <4857@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:57:01 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2398
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 68
Archive-name: NetHack3/Patch6o
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 15)."
# Contents:  include/extern.h src/dbridge.c
# Wrapped by billr@saab on Wed Nov 22 10:50:23 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'include/extern.h' -a "${1}" != "-c" ; then 
  echo shar: clobbering existing file \"'include/extern.h'\"
fi
echo shar: Extracting \"'include/extern.h'\" \(37999 characters\)
sed "s/^X//" >'include/extern.h' <<'END_OF_FILE'
X/*	SCCS Id: @(#)extern.h	3.0	88/10/18 */
X/* 	Copyright (c)   Steve Creps, 1988. 		 */
X/* NetHack may be freely redistributed.  See license for details. */
X
X#ifndef EXTERN_H
X#define EXTERN_H
X
X#if defined(MSDOS) && defined(MSC)
X/* MSC include files do not contain "extern" keyword */
X#define E
X#else
X#define E extern
X#endif
X
X/* ### allmain.c ### */
X
XE int (*occupation)();
XE int (*afternmv)();
XE void moveloop();
XE void stop_occupation();
XE void newgame();
X
X/* ### alloc.c ### */
X
X#ifndef __TURBOC__
XE long *FDECL(alloc, (unsigned int));
X#endif
X
X#if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
X
X/* ### apply.c ### */
X
X#ifdef OVERLAY
XE int dig();
X#endif
XE int doapply();
XE int holetime();
XE void dighole();
XE int dorub();
XE int dojump();
X#ifdef WALKIES
XE int number_leashed();
XE void FDECL(o_unleash, (struct obj *));
XE void FDECL(m_unleash, (struct monst *));
XE void unleash_all();
XE boolean next_to_u();
XE struct obj *FDECL(get_mleash, (struct monst *));
XE void FDECL(check_leash, (XCHAR_P,XCHAR_P));
X#endif
XE boolean FDECL(um_dist, (XCHAR_P,XCHAR_P,XCHAR_P));
XE int FDECL(use_unicorn_horn, (struct obj *));
X
X/* ### artifact.c ### */
X
X#ifdef NAMED_ITEMS
XE void FDECL(mkartifact, (struct obj **));
XE boolean FDECL(is_artifact, (struct obj *));
XE boolean FDECL(spec_ability, (struct obj *,unsigned));
XE int FDECL(restr_name, (struct obj *,char *));
X# if defined(THEOLOGY) && defined(ALTARS)
XE struct obj *FDECL(mk_aligned_artifact, (unsigned));
X# endif
XE int FDECL(defends, (int,struct obj *));
XE int FDECL(spec_abon, (struct obj *,struct permonst *));
XE int FDECL(spec_dbon, (struct obj *,struct permonst *,int));
X#endif
X
X/* ### attrib.c ### */
X
XE void FDECL(adjattrib, (int,int,BOOLEAN_P));
XE void FDECL(change_luck, (SCHAR_P));
XE int FDECL(stone_luck, (BOOLEAN_P));
XE void FDECL(gainstr, (struct obj *,int));
XE void FDECL(losestr, (int));
XE void restore_attrib();
XE void FDECL(init_attr, (int));
XE void redist_attr();
XE void FDECL(adjabil, (int));
XE int newhp();
XE schar acurr();
XE void FDECL(adjalign, (int));
X
X/* ### bones.c ### */
X
XE void savebones();
XE int getbones();
XE void FDECL(name_file, (char *,int));
X
X/* ### cmd.c ### */
X
X#ifdef OVERLAY
XE int doextcmd();
X#ifdef POLYSELF
XE int domonability();
X#endif /* POLYSELF */
XE int timed_occupation();
X#if defined(WIZARD) || defined(EXPLORE_MODE)
XE int wiz_attributes();
X#endif /* WIZARD */
X#ifdef WIZARD
XE int wiz_detect();
XE int wiz_genesis();
XE int wiz_identify();
XE int wiz_level_tele();
XE int wiz_map();
XE int wiz_where();
XE int wiz_wish();
X#endif /* WIZARD */
X#endif /* OVERLAY */
XE void reset_occupations();
XE void FDECL(set_occupation, (int(*)(),char *,int));
X#ifdef REDO
XE char pgetchar();
XE void FDECL(pushch, (CHAR_P));
XE void FDECL(savech, (CHAR_P));
X#endif
XE void FDECL(rhack, (char *));
XE char FDECL(lowc, (CHAR_P));
XE void enlightenment();
XE int FDECL(xytod, (SCHAR_P,SCHAR_P));
XE void FDECL(dtoxy, (coord *,int));
XE int FDECL(movecmd, (CHAR_P));
XE int FDECL(getdir, (BOOLEAN_P));
XE void confdir();
XE int FDECL(isok, (int,int));
XE int doextlist();
X
X/* ### dbridge.c ### */
X
XE boolean FDECL(is_pool, (int,int));
X#ifdef STRONGHOLD
XE void FDECL(initsym, (int,int));
XE int FDECL(is_drawbridge_wall, (int, int));
XE boolean FDECL(is_db_wall, (int, int));
XE boolean FDECL(find_drawbridge, (int *, int*));
XE boolean FDECL(create_drawbridge, (int, int, int, BOOLEAN_P));
XE void FDECL(open_drawbridge, (int, int));
XE void FDECL(close_drawbridge, (int, int));
XE void FDECL(destroy_drawbridge, (int, int));
X#endif	/* STRONGHOLD /**/
X
X/* ### decl.c ### */
X
X/* ### demon.c ### */
X
XE void FDECL(dsummon, (struct permonst *));
XE int FDECL(demon_talk, (struct monst *));
XE long FDECL(bribe, (struct monst *));
XE int dprince();
XE int dlord();
XE int ndemon();
X
X/* ### do.c ### */
X
X#ifdef OVERLAY
XE int FDECL(drop, (struct obj *));
XE int wipeoff();
X#endif
XE int dodrop();
XE boolean FDECL(flooreffects, (struct obj *,int,int));
XE void FDECL(doaltarobj, (struct obj *));
XE boolean FDECL(canletgo, (struct obj *,char *));
XE void FDECL(dropx, (struct obj *));
XE void FDECL(dropy, (struct obj *));
XE int doddrop();
XE int dodown();
XE int doup();
XE void FDECL(goto_level, (int,BOOLEAN_P,BOOLEAN_P));
XE int donull();
XE int dowipe();
XE struct obj *FDECL(splitobj, (struct obj *,int));
XE void FDECL(set_wounded_legs, (long,int));
XE void heal_legs();
X
X/* ### do_name.c ### */
X
XE void FDECL(getpos, (coord *,int,char *));
XE int do_mname();
XE struct obj *FDECL(oname, (struct obj *,char *,int));
XE int ddocall();
XE void FDECL(docall, (struct obj *));
XE char *FDECL(x_monnam, (struct monst *,int));
XE char *FDECL(lmonnam, (struct monst *));
XE char *FDECL(mon_nam, (struct monst *));
XE char *FDECL(Monnam, (struct monst *));
XE char *FDECL(a_monnam, (struct monst *,char *));
XE char *FDECL(a2_monnam, (struct monst *,char *));
XE char *FDECL(Amonnam, (struct monst *,char *));
XE char *FDECL(Xmonnam, (struct monst *));
XE char *FDECL(defmonnam, (struct monst *));
XE char *rndmonnam();
X#ifdef REINCARNATION
XE char *roguename();
X#endif
X
X/* ### do_wear.c ### */
X
X#ifdef OVERLAY
XE int Armor_on();
XE int Boots_on();
XE int Gloves_on();
XE int Helmet_on();
XE int FDECL(select_off, (struct obj *otmp));
XE int take_off();
X#endif
XE void FDECL(off_msg, (struct obj *));
XE boolean FDECL(is_helmet, (struct obj *));
XE boolean FDECL(is_gloves, (struct obj *));
XE boolean FDECL(is_boots, (struct obj *));
XE boolean FDECL(is_cloak, (struct obj *));
XE boolean FDECL(is_shield, (struct obj *));
XE void set_wear();
XE boolean FDECL(donning, (struct obj *));
XE int Armor_off();
XE int Armor_gone();
XE int Helmet_off();
XE int Gloves_off();
XE int Boots_off();
XE int Cloak_off();
XE int Shield_off();
XE void Amulet_off();
XE void FDECL(Ring_on, (struct obj *));
XE void FDECL(Ring_off, (struct obj *));
XE void FDECL(Ring_gone, (struct obj *));
XE void FDECL(Blindf_on, (struct obj *));
XE void FDECL(Blindf_off, (struct obj *));
XE int dotakeoff();
XE int doremring();
XE int FDECL(cursed, (struct obj *));
XE int FDECL(armoroff, (struct obj *));
XE int dowear();
XE int doputon();
XE void find_ac();
XE void glibr();
XE struct obj *some_armor();
XE void corrode_armor();
XE void reset_remarm();
XE int doddoremarm();
XE int FDECL(destroy_arm, (struct obj *));
XE void FDECL(adj_abon, (struct obj *,SCHAR_P));
X
X/* ### dog.c ### */
X
XE void FDECL(initedog, (struct monst *));
XE void FDECL(make_familiar, (struct obj *));
XE struct monst *makedog();
XE void losedogs();
XE void keepdogs();
XE void FDECL(fall_down, (struct monst *,int));
XE int FDECL(dogfood, (struct monst *,struct obj *));
XE int FDECL(inroom, (XCHAR_P,XCHAR_P));
XE int FDECL(tamedog, (struct monst *,struct obj *));
X
X/* ### dogmove.c ### */
X
XE int FDECL(dog_move, (struct monst *,int));
X
X/* ### dokick.c ### */
X
XE boolean FDECL(ghitm, (struct monst *,long));
XE boolean FDECL(bad_kick_throw_pos, (XCHAR_P,XCHAR_P));
XE struct monst *FDECL(ghit, (int,int,int));
XE int dokick();
X
X/* ### dothrow.c ### */
X
XE int dothrow();
XE int FDECL(throwit, (struct obj *));
XE int FDECL(thitmonst, (struct monst *,struct obj *));
XE int FDECL(breaks, (struct obj *,BOOLEAN_P));
X
X/* ### eat.c ### */
X
X#ifdef OVERLAY
XE int Meatdone();
XE int eatfood();
XE int opentin();
XE int unfaint();
X#endif
XE void init_uhunger();
XE int Hear_again();
XE void reset_eat();
XE int doeat();
XE void gethungry();
XE void FDECL(morehungry, (int));
XE void FDECL(lesshungry, (int));
XE void FDECL(newuhs, (BOOLEAN_P));
XE struct obj *FDECL(floorfood, (char *,BOOLEAN_P));
XE void vomit();
XE int FDECL(eaten_stat, (int, struct obj *));
X
X/* ### end.c ### */
X
XE int done1();
XE int done2();
XE void FDECL(done_in_by, (struct monst *));
XE void VDECL(panic, (char *,...));
XE void FDECL(done, (int));
XE void clearlocks();
X#ifdef NOSAVEONHANGUP
XE void hangup();
X#endif
X
X/* ### engrave.c ### */
X
X#ifdef ELBERETH
XE int FDECL(sengr_at, (char *,XCHAR_P,XCHAR_P));
X#endif
XE void FDECL(u_wipe_engr, (int));
XE void FDECL(wipe_engr_at, (XCHAR_P,XCHAR_P,XCHAR_P));
XE void FDECL(read_engr_at, (int,int));
XE void FDECL(make_engr_at, (int,int,char *));
XE int freehand();
XE int doengrave();
XE void FDECL(save_engravings, (int));
XE void FDECL(rest_engravings, (int));
X
X/* ### exper.c ### */
X
XE long FDECL(newuexp, (unsigned));
XE int FDECL(experience, (struct monst *,int));
XE void FDECL(more_experienced, (int,int));
XE void losexp();
XE void newexplevel();
XE void pluslvl();
XE long rndexp();
X
X/* ### extralev.c ### */
X
X#ifdef REINCARNATION
XE void makeroguerooms();
XE void FDECL(corr, (int,int));
XE void makerogueghost();
X#endif
X
X/* ### fountain.c ### */
X
X#ifdef FOUNTAINS
XE void dryup();
XE void drinkfountain();
XE void FDECL(dipfountain, (struct obj *));
X#endif /* FOUNTAINS */
X#ifdef SINKS
XE void drinksink();
X#endif
X
X/* ### getline.c ### */
X
XE void FDECL(getlin, (char *));
XE void getret();
XE void FDECL(cgetret, (char *));
XE void FDECL(xwaitforspace, (char *));
XE char *parse();
XE char readchar();
X#ifdef COM_COMPL
XE void FDECL(get_ext_cmd, (char *));
X#endif /* COM_COMPL */
X
X/* ### hack.c ### */
X
XE void unsee();
XE void FDECL(seeoff, (int));
XE void FDECL(movobj, (struct obj *,XCHAR_P,XCHAR_P));
XE boolean FDECL(may_dig, (XCHAR_P,XCHAR_P));
XE void domove();
XE void spoteffects();
XE int dopickup();
XE void lookaround();
XE int monster_nearby();
XE int FDECL(cansee, (XCHAR_P,XCHAR_P));
XE int FDECL(sgn, (int));
XE void FDECL(getcorners, (xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *,xchar *));
XE void setsee();
XE void FDECL(nomul, (int));
XE void FDECL(losehp, (int,const char *));
XE int weight_cap();
XE int inv_weight();
XE int inv_cnt();
XE int FDECL(identify, (struct obj *));
X#ifdef STUPID_CPP	/* otherwise these functions are macros in hack.h */
XE char yn();
XE char ynq();
XE char ynaq();
XE char nyaq();
XE char *FDECL(plur, (long));
XE void FDECL(makeknown, (unsigned));
X#endif
X
X/* ### invent.c ### */
X
X#ifdef OVERLAY
XE int FDECL(ckunpaid, (struct obj *));
X#endif
XE struct obj *FDECL(addinv, (struct obj *));
XE void FDECL(useup, (struct obj *));
XE void FDECL(freeinv, (struct obj *));
XE void FDECL(delobj, (struct obj *));
XE void FDECL(freeobj, (struct obj *));
XE void FDECL(freegold, (struct gold *));
XE struct obj *FDECL(sobj_at, (int,int,int));
XE int FDECL(carried, (struct obj *));
XE struct obj *FDECL(carrying, (int));
XE boolean have_lizard();
XE struct obj *FDECL(o_on, (unsigned int,struct obj *));
XE boolean FDECL(obj_here, (struct obj *,int,int));
XE struct gold *FDECL(g_at, (int,int));
XE struct obj *FDECL(getobj, (const char *,const char *));
XE int FDECL(ggetobj, (char *,int(*)(),int));
XE int FDECL(askchain, (struct obj *,int,char *,int,int(*)(),int(*)(),int,char *));
XE void FDECL(prinv, (struct obj *));
XE int ddoinv();
XE void FDECL(doinv, (char *));
XE int dotypeinv();
XE int dolook();
XE void FDECL(stackobj, (struct obj *));
XE int doprgold();
XE int doprwep();
XE int doprarm();
XE int doprring();
XE int dopramulet();
XE int doprtool();
XE int FDECL(digit, (CHAR_P));
XE void FDECL(useupf, (struct obj *));
XE char *FDECL(let_to_name, (CHAR_P));
XE void reassign();
X
X/* ### ioctl.c ### */
X
X#ifdef UNIX
XE void getioctls();
XE void setioctls();
X# ifdef SUSPEND
XE int dosuspend();
X# endif /* SUSPEND */
X#endif /* UNIX */
X
X/* ### lock.c ### */
X
X#ifdef OVERLAY
XE int forcelock();
XE int picklock();
X#endif
XE void reset_pick();
XE int FDECL(pick_lock, (struct obj *));
XE int doforce();
XE int FDECL(boxlock, (struct obj *,struct obj *));
XE int FDECL(doorlock, (struct obj *,int,int));
XE int doopen();
XE int doclose();
X
X/* ### mac.c ### */
X#ifdef MACOS
XE int tgetch();
XE void gethdate();
XE int uptodate();
X# ifndef THINKC4
XE char *getenv();
XE int memcmp();
X# else
XE int kbhit();
X# endif
XE int mcurs();
XE int mputc();
XE int mputs();
XE int mprintf();
XE int about();
X#endif  /* MACOS */
X
X/* ### macfile.c ### */
X#ifdef MACOS
XE short findNamedFile();
XE FILE *openFile();
X#endif	/* MACOS */
X
X/* ### macinit.c ### */
X#ifdef MACOS
XE int initterm();
XE int freeterm();
X#ifdef SMALLDATA
XE void init_decl();
XE void free_decl();
X#endif  /* SMALLDATA */
X#endif	/* MACOS */
X
X/* ### mail.c ### */
X
X#ifdef MAIL
X# ifdef UNIX
XE void getmailstatus();
X# endif
XE void ckmailstatus();
XE void readmail();
X#endif /* MAIL */
X
X/* ### makemon.c ### */
X
XE struct monst *FDECL(makemon, (struct permonst *,int,int));
XE void FDECL(enexto, (coord *,XCHAR_P,XCHAR_P,struct permonst *));
XE int FDECL(goodpos, (int,int, struct permonst *));
XE void FDECL(rloc, (struct monst *));
XE void FDECL(vloc, (struct monst *));
XE void init_monstr();
XE struct permonst *rndmonst();
XE struct permonst *FDECL(mkclass, (CHAR_P));
XE int FDECL(adj_lev, (struct permonst *));
XE struct permonst *FDECL(grow_up, (struct monst *));
XE int FDECL(mongets, (struct monst *,int));
X#ifdef REINCARNATION
XE struct permonst *roguemon();
X#endif
X#ifdef GOLEMS
XE int FDECL(golemhp, (int));
X#endif /* GOLEMS */
XE boolean FDECL(peace_minded, (struct permonst *));
XE void FDECL(set_malign, (struct monst *));
XE void FDECL(set_mimic_sym, (struct monst *));
X
X/* ### mcastu.c ### */
X
XE int FDECL(castmu, (struct monst *,struct attack *));
XE int FDECL(buzzmu, (struct monst *,struct attack *));
X
X/* ### mhitm.c ### */
X
XE int FDECL(fightm, (struct monst *));
XE int FDECL(mattackm, (struct monst *,struct monst *));
XE int FDECL(noattacks, (struct permonst *));
X
X/* ### mhitu.c ### */
X
X#ifdef POLYSELF
XE struct monst *cloneu();
X#endif
XE void FDECL(regurgitates, (struct monst *));
XE int FDECL(mattacku, (struct monst *));
XE void FDECL(mdamageu, (struct monst *,int));
XE int FDECL(could_seduce, (struct monst *,struct monst *,struct attack *));
X#ifdef SEDUCE
XE int FDECL(doseduce, (struct monst *));
X#endif
X
X/* ### mklev.c ### */
X
XE int FDECL(somex, (struct mkroom *));
XE int FDECL(somey, (struct mkroom *));
X#ifdef ORACLE
XE boolean FDECL(place_oracle, (struct mkroom *,int *,int *,int *));
X#endif
XE void mklev();
XE int FDECL(okdoor, (XCHAR_P,XCHAR_P));
XE void FDECL(dodoor, (int,int,struct mkroom *));
XE void FDECL(mktrap, (int,int,struct mkroom *));
XE void FDECL(mkfount, (int,struct mkroom *));
X
X/* ### mkmaze.c ### */
X
X#if defined(WALLIFIED_MAZE) || defined(STRONGHOLD)
XE void FDECL(wallification, (int,int,int,int,BOOLEAN_P));
X#endif
XE void FDECL(walkfrom, (int,int));
XE void makemaz();
XE void FDECL(move, (int *,int *,int));
XE void FDECL(mazexy, (coord *));
XE void bound_digging();
X
X/* ### mkobj.c ### */
X
XE struct obj *FDECL(mkobj_at, (CHAR_P,int,int));
XE struct obj *FDECL(mksobj_at, (int,int,int));
XE struct obj *FDECL(mkobj, (CHAR_P,BOOLEAN_P));
XE int rndmonnum();
XE struct obj *FDECL(mksobj, (int,BOOLEAN_P));
XE int FDECL(letter, (int));
XE int FDECL(weight, (struct obj *));
XE void FDECL(mkgold, (long,int,int));
XE struct obj *FDECL(mkcorpstat, (int,struct permonst *,int,int));
XE struct obj *FDECL(mk_tt_object, (int,int,int));
XE struct obj *FDECL(mk_named_object, (int,struct permonst *,int,int,char *,int));
XE void FDECL(bless, (struct obj *));
XE void FDECL(curse, (struct obj *));
XE void FDECL(blessorcurse, (struct obj *,int));
X#ifdef STUPID_CPP
XE boolean FDECL(is_flammable, (struct obj *));
XE boolean FDECL(is_rustprone, (struct obj *));
XE boolean FDECL(is_corrodeable, (struct obj *));
XE boolean FDECL(OBJ_AT, (int, int));
X#endif
XE void FDECL(place_object, (struct obj *,int,int));
XE void FDECL(move_object, (struct obj *,int,int));
XE void FDECL(remove_object, (struct obj *));
X
X/* ### mkroom.c ### */
X
XE void FDECL(mkroom, (int));
XE void FDECL(shrine_pos, (int *, int*, struct mkroom *));
XE boolean FDECL(nexttodoor, (int,int));
XE boolean FDECL(has_dnstairs, (struct mkroom *));
XE boolean FDECL(has_upstairs, (struct mkroom *));
XE int FDECL(dist2, (int,int,int,int));
XE struct permonst *courtmon();
XE int FDECL(bcsign, (struct obj *));
X
X/* ### mon.c ### */
X
XE void movemon();
XE void FDECL(meatgold, (struct monst *));
XE void FDECL(meatobj, (struct monst *));
XE void FDECL(mpickgold, (struct monst *));
XE void FDECL(mpickgems, (struct monst *));
XE int FDECL(curr_mon_load, (struct monst *));
XE int FDECL(max_mon_load, (struct monst *));
XE boolean FDECL(can_carry, (struct monst *,struct obj *));
XE void FDECL(mpickstuff, (struct monst *,char *));
XE int FDECL(mfndpos, (struct monst *,coord *,long *,long));
XE int FDECL(dist, (int,int));
XE boolean FDECL(monnear, (struct monst *,int,int));
XE void FDECL(poisontell, (int));
XE void FDECL(poisoned, (char *,int,char *));
XE void FDECL(mondead, (struct monst *));
XE void FDECL(replmon, (struct monst *,struct monst *));
XE void FDECL(relmon, (struct monst *));
XE void FDECL(monfree, (struct monst *));
XE void FDECL(unstuck, (struct monst *));
XE void FDECL(killed, (struct monst *));
XE void FDECL(xkilled, (struct monst *,int));
XE void rescham();
XE void restartcham();
XE int FDECL(newcham, (struct monst *,struct permonst *));
XE void FDECL(mnexto, (struct monst *));
XE void FDECL(mnearto, (struct monst *, XCHAR_P, XCHAR_P, BOOLEAN_P));
XE void FDECL(setmangry, (struct monst *));
XE int FDECL(disturb, (struct monst *));
XE void FDECL(mondied, (struct monst *));
XE void FDECL(mongone, (struct monst *));
XE void FDECL(monstone, (struct monst *));
X#ifdef GOLEMS
XE void FDECL(golemeffects, (struct monst *, int, int));
X#endif /* GOLEMS */
X
X/* ### mondata.c ### */
X
XE boolean FDECL(attacktype, (struct permonst *,int));
XE boolean FDECL(resists_ston, (struct permonst *));
XE boolean FDECL(resists_drli, (struct permonst *));
XE boolean FDECL(ranged_attk, (struct permonst *));
XE boolean FDECL(can_track, (struct permonst *));
X#ifdef POLYSELF
XE boolean FDECL(breakarm, (struct permonst *));
XE boolean FDECL(sliparm, (struct permonst *));
X#endif
XE boolean FDECL(sticks, (struct permonst *));
XE boolean FDECL(canseemon, (struct monst *));
XE boolean FDECL(dmgtype, (struct permonst *,int));
XE int FDECL(monsndx, (struct permonst *));
XE int FDECL(name_to_mon, (char *));
X#ifdef POLYSELF
XE boolean FDECL(webmaker, (struct permonst *));
X#endif
XE boolean FDECL(is_female, (struct monst *));
XE int FDECL(gender, (struct monst *));
XE boolean FDECL(levl_follower, (struct monst *));
XE struct permonst *player_mon();
XE int FDECL(little_to_big, (int));
XE int FDECL(big_to_little, (int));     
X
X/* ### monmove.c ### */
X
XE boolean FDECL(mb_trapped, (struct monst *));
XE int FDECL(dochugw, (struct monst *));
XE boolean FDECL(onscary, (int,int,struct monst *));
XE int FDECL(dochug, (struct monst *));
XE int FDECL(m_move, (struct monst *,int));
XE void FDECL(set_apparxy, (struct monst *));
XE boolean FDECL(mdig_tunnel, (struct monst *));
X#ifdef STUPID_CPP
XE boolean FDECL(MON_AT, (int, int));
XE void FDECL(place_monster, (struct monst *, int, int));
XE void FDECL(place_worm_seg, (struct monst *, int, int));
XE void FDECL(remove_monster, (int, int));
XE struct monst *FDECL(m_at, (int, int));
X#endif
X
X/* ### monst.c ### */
X
X/* ### msdos.c ### */
X
X#ifdef MSDOS
XE void flushout();
XE int tgetch();
XE int dosh();
X# ifdef DGK
XE long FDECL(freediskspace, (char *));
XE long FDECL(filesize, (char *));
XE void FDECL(eraseall, (const char *,const char *));
XE void FDECL(copybones, (int));
XE void playwoRAMdisk();
XE int FDECL(saveDiskPrompt, (int));
XE void gameDiskPrompt();
X# endif
XE void read_config_file();
XE void set_lock_and_bones();
XE void FDECL(append_slash, (char *));
XE void FDECL(getreturn, (const char *));
XE void VDECL(msmsg, (const char *,...));
XE void FDECL(chdrive, (char *));
X# ifndef TOS
XE void disable_ctrlP();
XE void enable_ctrlP();
X# endif
X# ifdef DGK
XE FILE *FDECL(fopenp, (char *,char *));
X# endif
XE void FDECL(msexit, (int));
X# ifdef DGK
XE void get_scr_size();
X# endif
X#endif /* MSDOS */
X#ifdef TOS
XE int FDECL(_copyfile, (char *, char *));
XE int kbhit();
XE void restore_colors();
XE void set_colors();
X#endif /* TOS */
X
X/* ### mthrowu.c ### */
X
XE int FDECL(thitu, (int,int,struct obj *,char *));
XE int FDECL(thrwmu, (struct monst *));
XE int FDECL(spitmu, (struct monst *));
XE int FDECL(breamu, (struct monst *,struct attack *));
XE boolean FDECL(linedup, (XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
XE boolean FDECL(lined_up, (struct monst *));
XE struct obj *FDECL(m_carrying, (struct monst *,int));
XE void FDECL(m_useup, (struct monst *,struct obj *));
X
X/* ### music.c ### */
X
X#ifdef MUSIC
XE int FDECL(do_play_instrument, (struct obj *));
X#endif /* MUSIC /**/
X
X/* ### o_init.c ### */
X
XE int FDECL(letindex, (CHAR_P));
XE void init_objects();
XE void oinit();
XE void FDECL(savenames, (int));
XE void FDECL(restnames, (int));
XE int dodiscovered();
X
X/* ### objnam.c ### */
X
XE char *FDECL(typename, (int));
XE char *FDECL(distant_name, (struct obj *, char *(*)(struct obj *)));
XE char *FDECL(xname, (struct obj *));
XE char *FDECL(doname, (struct obj *));
XE char *FDECL(singular, (struct obj *, char *(*)(struct obj *)));
XE char *FDECL(an, (char *));
XE char *FDECL(An, (char *));
XE char *FDECL(aobjnam, (struct obj *,char *));
XE char *FDECL(Doname2, (struct obj *));
XE void FDECL(lcase, (char *));
XE char *FDECL(makeplural, (char *));
XE struct obj *FDECL(readobjnam, (char *));
X
X/* ### options.c ### */
X
XE void initoptions();
XE void FDECL(assign_graphics, (unsigned int *, int));
XE void FDECL(parseoptions, (char *,BOOLEAN_P));
XE int doset();
XE int dotogglepickup();
XE void option_help();
X#ifdef TUTTI_FRUTTI
XE int FDECL(fruitadd, (char *));
X#endif
X
X/* ### pager.c ### */
X
XE int dowhatis();
XE int dowhatdoes();
XE void set_whole_screen();
X#ifdef NEWS
XE int readnews();
X#endif /* NEWS */
XE void FDECL(set_pager, (int));
XE int FDECL(page_line, (char *));
XE void FDECL(cornline, (int,char *));
XE int dohelp();
XE int dohistory();
XE int FDECL(page_file, (char *,BOOLEAN_P));
X#ifdef UNIX
X# ifdef SHELL
XE int dosh();
X# endif /* SHELL */
X# if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
XE int FDECL(child, (int));
X# endif
X#endif /* UNIX */
X
X/* ### pcmain.c ### */
X
X#if defined(MSDOS) || defined(MACOS)
XE void askname();
X# ifdef CHDIR
XE void FDECL(chdirx, (char *,BOOLEAN_P));
X# endif /* CHDIR */
X#endif /* MSDOS || MACOS */
X
X/* ### pctty.c ### */
X
X#if defined(MSDOS) || defined(MACOS)
XE void gettty();
XE void FDECL(settty, (char *));
XE void VDECL(error, (char *,...));
X#endif /* MSDOS || MACOS  */
X
X/* ### pcunix.c ### */
X
X#if defined(MSDOS) || defined(MACOS)
X# ifndef OLD_TOS
XE void setrandom();
XE int getyear();
XE char *getdate();
XE int phase_of_the_moon();
XE int night();
XE int midnight();
XE void FDECL(gethdate, (char *));
XE int FDECL(uptodate, (int));
X# endif /* TOS */
XE void FDECL(regularize, (char *));
X#endif /* MSDOS */
X
X/* ### pickup.c ### */
X
X#ifdef OVERLAY
XE int ck_bag();
XE int FDECL(ck_container, (struct obj *));
XE int FDECL(in_container, (struct obj *));
XE int FDECL(out_container, (struct obj *));
X#endif
XE void FDECL(pickup, (int));
XE struct obj *FDECL(pick_obj, (struct obj *));
XE int doloot();
XE void get_all_from_box();
XE void FDECL(use_container, (struct obj *, int));
XE void FDECL(inc_cwt, (struct obj *, struct obj *));
XE void FDECL(delete_contents, (struct obj *));
XE void FDECL(dec_cwt, (struct obj *, struct obj *));
X
X/* ### polyself.c ### */
X
XE void newman();
X#ifdef POLYSELF
XE void polyself();
XE int FDECL(polymon, (int));
XE void rehumanize();
XE int dobreathe();
XE int dospit();
XE int doremove();
XE int dospinweb();
XE int dosummon();
XE int doconfuse();
XE int dohide();
X#endif
XE char *FDECL(body_part, (int));
XE int poly_gender();
X#ifdef POLYSELF
X# ifdef GOLEMS
XE void FDECL(ugolemeffects, (int, int));
X# endif /* GOLEMS */
X#endif
X
X/* ### potion.c ### */
X
XE void FDECL(make_confused, (long,BOOLEAN_P));
XE void FDECL(make_stunned, (long,BOOLEAN_P));
XE void FDECL(make_blinded, (long,BOOLEAN_P));
XE void FDECL(make_sick, (long,BOOLEAN_P));
XE void FDECL(make_vomiting, (long,BOOLEAN_P));
XE void FDECL(make_hallucinated, (long,BOOLEAN_P));
XE int dodrink();
XE int FDECL(dopotion, (struct obj *));
XE int FDECL(peffects, (struct obj *));
XE void FDECL(healup, (int,int,BOOLEAN_P,BOOLEAN_P));
XE void FDECL(strange_feeling, (struct obj *,char *));
XE void FDECL(potionhit, (struct monst *,struct obj *));
XE void FDECL(potionbreathe, (struct obj *));
XE boolean FDECL(get_wet, (struct obj *));
XE int dodip();
XE void FDECL(djinni_from_bottle, (struct obj *));
XE int FDECL(monster_detect, (struct obj *));
XE int FDECL(object_detect, (struct obj *));
XE int FDECL(trap_detect, (struct obj *));
X
X/* ### pray.c ### */
X
X# ifdef THEOLOGY
XE int dosacrifice();
XE int dopray();
XE char *u_gname();
X#endif /* THEOLOGY */
XE int doturn();
X#ifdef ALTARS
XE char *a_gname();
XE char *FDECL(a_gname_at, (XCHAR_P,XCHAR_P));
X# ifdef THEOLOGY
XE void FDECL(altar_wrath, (int,int));
X# endif
X#endif
X
X/* ### pri.c ### */
X
XE void swallowed();
XE void setclipped();
X#ifdef CLIPPING
XE void FDECL(cliparound, (int, int));
X#endif
XE boolean FDECL(showmon, (struct monst *));
XE void FDECL(at, (XCHAR_P,XCHAR_P,UCHAR_P,UCHAR_P));
XE void prme();
XE void FDECL(shieldeff, (XCHAR_P,XCHAR_P));
XE int doredraw();
XE void docrt();
XE void FDECL(docorner, (int,int));
XE void seeglds();
XE void seeobjs();
XE void seemons();
XE void FDECL(pmon, (struct monst *));
XE void FDECL(unpmon, (struct monst *));
XE void nscr();
XE void bot();
XE void FDECL(mstatusline, (struct monst *));
XE void ustatusline();
XE void cls();
XE void max_rank_sz();
XE char rndmonsym();
XE char rndobjsym();
XE const char *hcolor();
X
X/* ### priest.c ### */
X
XE int FDECL(move_special, (struct monst *,SCHAR_P,SCHAR_P,BOOLEAN_P,BOOLEAN_P,
X			XCHAR_P,XCHAR_P,XCHAR_P,XCHAR_P));
X#if defined(ALTARS) && defined(THEOLOGY)
XE struct mkroom *FDECL(in_temple, (int,int));
XE int FDECL(pri_move, (struct monst *));
XE void FDECL(priestini, (int,int,int,int));
XE char *FDECL(priestname, (struct monst *));
XE boolean FDECL(p_coaligned, (struct monst *));
XE void intemple();
XE void FDECL(priest_talk, (struct monst *));
XE boolean FDECL(u_in_sanctuary, (struct mkroom *));
XE void ghod_hitsu();
XE void angry_priest();
X#endif
X
X/* ### prisym.c ### */
X
XE void FDECL(atl, (int,int,CHAR_P));
XE void FDECL(on_scr, (int,int));
XE void FDECL(tmp_at, (int,int));
XE void FDECL(Tmp_at2, (int,int));
XE void curs_on_u();
XE void pru();
XE void FDECL(prl, (int,int));
XE uchar FDECL(news0, (XCHAR_P,XCHAR_P));
XE void FDECL(newsym, (int,int));
XE void FDECL(mnewsym, (int,int));
XE void FDECL(nosee, (int,int));
XE void FDECL(prl1, (int,int));
XE void FDECL(nose1, (int,int));
XE int FDECL(vism_at, (int,int));
X#ifdef NEWSCR
XE void FDECL(pobj, (struct obj *));
X#endif /* NEWSCR */
XE void FDECL(unpobj, (struct obj *));
X#ifdef STUPID_CPP	/* otherwise these functions are macros in rm.h */
XE boolean FDECL(IS_WALL, (unsigned));
XE boolean FDECL(IS_STWALL, (unsigned));
XE boolean FDECL(IS_ROCK, (unsigned));
XE boolean FDECL(IS_DOOR, (unsigned));
XE boolean FDECL(IS_FLOOR, (unsigned));
XE boolean FDECL(ACCESSIBLE, (unsigned));
XE boolean FDECL(IS_ROOM, (unsigned));
XE boolean FDECL(ZAP_POS, (unsigned));
XE boolean FDECL(SPACE_POS, (unsigned));
XE boolean FDECL(IS_POOL, (unsigned));
XE boolean FDECL(IS_THRONE, (unsigned));
XE boolean FDECL(IS_FOUNTAIN, (unsigned));
XE boolean FDECL(IS_SINK, (unsigned));
XE boolean FDECL(IS_ALTAR, (unsigned));
XE boolean FDECL(IS_DRAWBRIDGE, (unsigned));
XE boolean FDECL(IS_FURNITURE, (unsigned));
X#endif /* STUPID_CPP */
X
X/* ### read.c ### */
X
XE int doread();
XE int FDECL(seffects, (struct obj *));
XE void FDECL(litroom, (BOOLEAN_P));
XE void FDECL(do_genocide, (int));
XE void do_mapping();
XE void do_vicinity_map();
XE int FDECL(gold_detect, (struct obj *));
XE int FDECL(food_detect, (struct obj *));
XE void FDECL(punish, (struct obj *));
XE void unpunish();
XE boolean FDECL(cant_create, (int *));
X#if defined(WIZARD) || defined(EXPLORE_MODE)
XE boolean create_particular();
X#endif
X
X/* ### restore.c ### */
X
XE int FDECL(dorecover, (int));
XE void FDECL(getlev, (int,int,XCHAR_P,BOOLEAN_P));
X#ifdef ZEROCOMP
XE void minit();
XE int FDECL(mread, (int,genericptr_t,unsigned int));
X#else
XE void FDECL(mread, (int,genericptr_t,unsigned int));
X#endif
X
X/* ### rip.c ### */
X
XE void outrip();
X
X/* ### rnd.c ### */
X
XE int FDECL(rn1, (int,int));
XE int FDECL(rn2, (int));
XE int FDECL(rnl, (int));
XE int FDECL(rnd, (int));
XE int FDECL(d, (int,int));
XE int FDECL(rne, (int));
X#ifdef THEOLOGY
XE int FDECL(rnz, (int));
X#endif
X
X/* ### rumors.c ### */
X
XE void FDECL(outrumor, (int,BOOLEAN_P));
X#ifdef ORACLE
XE int FDECL(doconsult, (struct monst *));
X#endif
X
X/* ### save.c ### */
X
XE int dosave();
X#ifndef NOSAVEONHANGUP
XE int hangup();
X#endif /* NOSAVEONHANGUP */
XE int dosave0();
X#if defined(DGK) && !defined(OLD_TOS)
XE boolean FDECL(savelev, (int,XCHAR_P,int));
XE boolean FDECL(swapin_file, (int));
X#else /* DGK && !OLD_TOS */
XE void FDECL(savelev, (int, XCHAR_P));
X#endif /* DGK && !OLD_TOS */
X#ifdef ZEROCOMP
XE void FDECL(bflush, (int));
X#endif
XE void FDECL(bwrite, (int,genericptr_t,unsigned int));
X#ifdef TUTTI_FRUTTI
XE void FDECL(savefruitchn, (int));
X#endif
X
X/* ### search.c ### */
X
XE int findit();
XE int dosearch();
XE int FDECL(dosearch0, (int));
XE int doidtrap();
XE void FDECL(wakeup, (struct monst *));
XE void FDECL(seemimic, (struct monst *));
X
X/* ### shk.c ### */
X
XE char *FDECL(shkname, (struct monst *));
XE void FDECL(shkdead, (struct monst *));
XE void FDECL(replshk, (struct monst *,struct monst *));
XE int inshop();
XE int FDECL(inhishop, (struct monst *));
XE boolean FDECL(tended_shop, (struct mkroom *));
XE void FDECL(obfree, (struct obj *,struct obj *));
XE int dopay();
XE void FDECL(home_shk, (struct monst *));
XE void FDECL(make_happy_shk, (struct monst *));
XE boolean paybill();
XE void FDECL(pay_for_door, (int,int,char *));
XE void FDECL(addtobill, (struct obj *,BOOLEAN_P));
XE void FDECL(splitbill, (struct obj *,struct obj *));
XE void FDECL(sellobj, (struct obj *));
XE int FDECL(doinvbill, (int));
XE int FDECL(shkcatch, (struct obj *));
XE int FDECL(shk_move, (struct monst *));
XE int FDECL(online, (XCHAR_P,XCHAR_P));
XE boolean FDECL(is_fshk, (struct monst *));
XE void FDECL(shopdig, (int));
XE boolean FDECL(in_shop, (int,int));
XE boolean FDECL(costly_spot, (int,int));
XE void FDECL(check_unpaid, (struct obj *));
X
X/* ### shknam.c ### */
X
XE void FDECL(stock_room, (struct shclass *,struct mkroom *));
XE int FDECL(saleable, (int,struct obj *));
XE int FDECL(get_shop_item, (int));
X
X/* ### sit.c ### */
X
X#if defined(THRONES) || defined(SPELLS)
XE void take_gold();
X#endif
XE int dosit();
XE void rndcurse();
XE void attrcurse();
X
X/* ### sounds.c ### */
X
XE void FDECL(verbalize, (char *));
X#ifdef SOUNDS
XE void dosounds();
XE void FDECL(growl, (struct monst *));
XE void FDECL(yelp, (struct monst *));
XE void FDECL(whimper, (struct monst *));
X#endif
XE int dotalk();
X
X/* ### sp_lev.c ### */
X
X#ifdef STRONGHOLD
XE boolean FDECL(load_special, (char *));
X#endif /* STRONGHOLD /**/
X
X/* ### spell.c ### */
X#ifdef SPELLS
X#ifdef OVERLAY
XE int learn();
X#endif
XE int FDECL(study_book, (struct obj *));
XE int docast();
XE int FDECL(spelleffects, (int, BOOLEAN_P));
XE void losespells();
XE int dovspell();
X#endif /* SPELLS */
X
X/* ### steal.c ### */
X
X#ifdef OVERLAY
XE int stealarm();
X#endif
XE long somegold();
XE void FDECL(stealgold, (struct monst *));
XE int FDECL(steal, (struct monst *));
XE void FDECL(mpickobj, (struct monst *,struct obj *));
XE void FDECL(stealamulet, (struct monst *));
XE void FDECL(relobj, (struct monst *,int));
X
X/* ### termcap.c ### */
X
XE void startup();
XE void start_screen();
XE void end_screen();
X#ifdef CLIPPING
XE boolean FDECL(win_curs, (int,int));
X#endif
XE void FDECL(curs, (int,int));
XE void FDECL(cmov, (int,int));
XE void FDECL(xputc, (CHAR_P));
XE void FDECL(xputs, (char *));
XE void cl_end();
XE void clear_screen();
XE void home();
XE void standoutbeg();
XE void standoutend();
XE void revbeg();
X#if 0
XE void boldbeg();
XE void blinkbeg();
XE void dimbeg();
X#endif
XE void m_end();
XE void backsp();
XE void bell();
XE void graph_on();
XE void graph_off();
XE void delay_output();
XE void cl_eos();
X
X/* ### timeout.c ### */
X
XE void timeout();
XE void hatch_eggs();
X
X/* ### topl.c ### */
X
XE int doredotopl();
XE void remember_topl();
XE void FDECL(addtopl, (char *));
XE void more();
XE void FDECL(cmore, (char *));
XE void clrlin();
X#ifdef NEED_VARARGS
X# if defined(USE_STDARG) || defined(USE_VARARGS)
XE void FDECL(vpline, (const char *, va_list));
X# endif
X#endif
XE void VDECL(pline, (const char *,...));
XE void VDECL(Norep, (const char *,...));
XE void VDECL(You, (const char *,...));
XE void VDECL(Your, (const char *,...));
XE void VDECL(kludge, (char *,char *,...));
XE void FDECL(putsym, (CHAR_P));
XE void FDECL(putstr, (const char *));
XE char FDECL(yn_function, (const char *,CHAR_P));
XE void VDECL(impossible, (char *,...));
X
X/* ### topten.c ### */
X
XE void topten();
XE char *FDECL(eos, (char *));
XE void FDECL(prscore, (int,char **));
XE struct obj *FDECL(tt_oname, (struct obj *));
X
X/* ### track.c ### */
X
XE void initrack();
XE void settrack();
XE coord *FDECL(gettrack, (int,int));
X
X/* ### trap.c ### */
X
XE boolean FDECL(rust_dmg, (struct obj *,char *,int,BOOLEAN_P));
XE struct trap *FDECL(maketrap, (int,int,int));
XE int FDECL(teleok, (int,int));
XE void FDECL(dotrap, (struct trap *));
XE int FDECL(mintrap, (struct monst *));
XE void FDECL(selftouch, (char *));
XE void float_up();
XE int float_down();
XE void tele();
XE void FDECL(teleds, (int,int));
XE int dotele();
XE void FDECL(placebc, (int));
XE void unplacebc();
XE void level_tele();
XE void drown();
X#ifdef SPELLS
XE void FDECL(drain_en, (int));
X#endif
XE int dountrap();
XE void FDECL(chest_trap, (struct obj *,int));
XE void wake_nearby();
XE void FDECL(deltrap, (struct trap *));
XE struct trap *FDECL(t_at, (int,int));
XE void b_trapped();
XE boolean unconscious();
X
X/* ### u_init.c ### */
X
XE void u_init();
XE void plnamesuffix();
X
X/* ### uhitm.c ### */
X
XE struct monst *FDECL(clone_mon, (struct monst *));
XE boolean FDECL(special_case, (struct monst *));
XE schar FDECL(find_roll_to_hit, (struct monst *));
XE boolean FDECL(attack, (struct monst *));
XE boolean FDECL(hmon, (struct monst *,struct obj *,int));
XE int FDECL(damageum, (struct monst *, struct attack *));
XE void FDECL(missum, (struct monst *, struct attack *));
XE int FDECL(passive, (struct monst *,BOOLEAN_P,int,BOOLEAN_P));
XE void FDECL(stumble_onto_mimic, (struct monst *));
X
X/* ### unixmain.c ### */
X
X#ifdef UNIX
XE void FDECL(glo, (int));
XE void askname();
X#endif /* UNIX */
X
X/* ### unixtty.c ### */
X
X#ifdef UNIX
XE void gettty();
XE void FDECL(settty, (char *));
XE void setftty();
XE void intron();
XE void introff();
XE void VDECL(error, (char *,...));
X#endif /* UNIX */
X
X/* ### unixunix.c ### */
X
X#ifdef UNIX
XE void setrandom();
XE int getyear();
XE char *getdate();
XE int phase_of_the_moon();
XE int night();
XE int midnight();
XE void FDECL(gethdate, (char *));
XE int FDECL(uptodate, (int));
XE void getlock();
XE void FDECL(regularize, (char *));
X#endif /* UNIX */
X
X/* ### vault.c ### */
X
XE void setgd();
XE void invault();
XE int gd_move();
XE void gddead();
XE void FDECL(replgd, (struct monst *,struct monst *));
XE void paygd();
X
X/* ### version.c ### */
X
XE int doversion();
X
X/* ### vmsmain.c ### */
X
X#ifdef VMS
X# ifdef CHDIR
XE void FDECL(chdirx, (char *,char));
X# endif /* CHDIR */
XE void FDECL(glo, (int));
XE void askname();
X#endif /* VMS */
X
X/* ### vmsmisc.c ### */
X
X#ifdef VMS
XE void vms_abort();
XE void vms_exit();
X#endif /* VMS */
X
X/* ### vmstty.c ### */
X
X#ifdef VMS
XE void gettty();
XE void FDECL(settty, (char *));
XE void setftty();
XE void intron();
XE void introff();
XE void VDECL(error, (char *,...));
X#endif /* VMS */
X
X/* ### vmsunix.c ### */
X
X#ifdef VMS
XE void setrandom();
XE int getyear();
XE char *getdate();
XE int phase_of_the_moon();
XE int night();
XE int midnight();
XE void FDECL(gethdate, (char *));
XE int FDECL(uptodate, (int));
XE void getlock();
XE void FDECL(regularize, (char *));
XE int FDECL(vms_creat, (char *,unsigned int));
XE int vms_getuid();
XE void privoff();
XE void privon();
X# ifdef SHELL
XE int dosh();
X# endif
X#endif /* VMS */
X
X/* ### weapon.c ### */
X
XE int FDECL(hitval, (struct obj *,struct permonst *));
XE int FDECL(dmgval, (struct obj *,struct permonst *));
XE void set_uasmon();
XE struct obj *FDECL(select_rwep, (struct monst *));
XE struct obj *FDECL(select_hwep, (struct monst *));
XE int abon();
XE int dbon();
X
X/* ### were.c ### */
X
XE void FDECL(were_change, (struct monst *));
XE void FDECL(new_were, (struct monst *));
XE boolean FDECL(were_summon, (struct permonst *,BOOLEAN_P));
X#ifdef POLYSELF
XE void you_were();
X#endif /* POLYSELF */
X
X/* ### wield.c ### */
X
XE void FDECL(setuwep, (struct obj *));
XE void uwepgone();
XE int dowield();
XE void corrode_weapon();
XE int FDECL(chwepon, (struct obj *,int));
XE int FDECL(welded, (struct obj *));
XE void FDECL(weldmsg, (struct obj *,BOOLEAN_P));
X
X/* ### wizard.c ### */
X
XE void amulet();
XE int FDECL(mon_has_amulet, (struct monst *));
XE int FDECL(wiz_get_amulet, (struct monst *));
XE void aggravate();
XE void clonewiz();
X#ifdef HARD
XE void nasty();
XE void resurrect();
XE void intervene();
XE void FDECL(wizdead, (struct monst *));
X#endif /* HARD */
XE void FDECL(cuss, (struct monst *));
X
X/* ### worm.c ### */
X
X#ifdef WORM
XE int FDECL(getwn, (struct monst *));
XE void FDECL(initworm, (struct monst *));
XE void FDECL(worm_move, (struct monst *));
XE void FDECL(worm_nomove, (struct monst *));
XE void FDECL(wormdead, (struct monst *));
XE void FDECL(wormhit, (struct monst *));
XE void FDECL(wormsee, (unsigned int));
XE void FDECL(cutworm, (struct monst *,XCHAR_P,XCHAR_P,unsigned));
X#endif /* WORM */
X
X/* ### worn.c ### */
X
XE void FDECL(setworn, (struct obj *,long));
XE void FDECL(setnotworn, (struct obj *));
X
X/* ### write.c ### */
X
XE void FDECL(dowrite, (struct obj *));
X
X/* ### zap.c ### */
X
X#ifdef OVERLAY
XE int FDECL(bhito, (struct obj *, struct obj *));
XE int FDECL(bhitm, (struct monst *, struct obj *));
X#endif
XE struct monst *FDECL(revive, (struct obj *,BOOLEAN_P));
XE int FDECL(zappable, (struct obj *));
XE void FDECL(zapnodir, (struct obj *));
XE int dozap();
XE int FDECL(zapyourself, (struct obj *));
XE void FDECL(weffects, (struct obj *));
XE char *FDECL(exclam, (int));
XE void FDECL(hit, (const char *,struct monst *,const char *));
XE void FDECL(miss, (const char *,struct monst *));
XE struct monst *FDECL(bhit, (int,int,int,CHAR_P,int(*)(),int(*)(),struct obj *));
XE struct monst *FDECL(boomhit, (int,int));
XE void FDECL(buzz, (int,int,XCHAR_P,XCHAR_P,int,int));
XE void FDECL(rlocgold, (struct gold *));
XE void FDECL(rloco, (struct obj *));
XE void FDECL(fracture_rock, (struct obj *));
XE boolean FDECL(break_statue, (struct obj *));
XE void FDECL(destroy_item, (int,int));
XE int FDECL(destroy_mitem, (struct monst *,int,int));
XE int FDECL(resist, (struct monst *,CHAR_P,int,int));
XE void makewish();
X
X#endif /* !MAKEDEFS_C && !LEV_LEX_C */
X
X#undef E
X
X#endif /* EXTERN_H /**/
END_OF_FILE
if test 37999 -ne `wc -c <'include/extern.h'`; then
    echo shar: \"'include/extern.h'\" unpacked with wrong size!
fi
# end of 'include/extern.h'
if test -f 'src/dbridge.c' -a "${1}" != "-c" ; then 
  echo shar: clobbering existing file \"'src/dbridge.c'\"
fi
echo shar: Extracting \"'src/dbridge.c'\" \(19606 characters\)
sed "s/^X//" >'src/dbridge.c' <<'END_OF_FILE'
X/*     SCCS Id: @(#)dbridge.c  3.0     88/18/12
X/*     Copyright (c) 1989 by Jean-Christophe Collet */
X/* NetHack may be freely redistributed.  See license for details. */
X
X/*
X * This file contains the drawbridge manipulation (create, open, close,
X * destroy).
X *
X * Added comprehensive monster-handling, and the "entity" structure to 
X * deal with players as well. - 11/89
X */
X
X#include "hack.h"
X
Xboolean
Xis_pool(x,y)
Xint x,y;
X{
X       if(levl[x][y].typ == POOL || levl[x][y].typ == MOAT) return TRUE;
X#ifdef STRONGHOLD
X       if(levl[x][y].typ == DRAWBRIDGE_UP &&
X               (levl[x][y].drawbridgemask & DB_UNDER) == DB_MOAT) return TRUE;
X#endif
X       return FALSE;
X}
X
X#ifdef STRONGHOLD
Xvoid
Xinitsym(x,y)
Xint x,y;
X{
X	char oldseen;
X	struct rm *crm = &levl[x][y];
X
X	oldseen = crm->seen;
X	crm->seen = 1;
X	crm->scrsym = news0(x,y);
X	crm->seen = oldseen;
X}
X
Xstatic void
Xredosym(x,y)
Xint x,y;
X{
X	if(cansee(x,y)) {
X		levl[x][y].seen = 0;            /* force prl */
X		prl(x, y);
X	} else {
X		initsym(x,y);
X		levl[x][y].seen = 0;
X	}
X}
X
X/* 
X * We want to know whether a wall (or a door) is the portcullis (passageway)
X * of an eventual drawbridge.
X *
X * Return value:  the direction of the drawbridge.
X */
X
Xint
Xis_drawbridge_wall(x,y)
Xint x,y;
X{
X	struct rm *lev;
X
X	lev = &levl[x][y];
X	if (lev->typ != DOOR && !(lev->diggable & W_GATEWAY))
X		return (-1);
X	switch (lev->typ) {
X	case DOOR:
X	case VWALL:
X		if (IS_DRAWBRIDGE(levl[x+1][y].typ) &&
X	 	    (levl[x+1][y].drawbridgemask & DB_DIR) == DB_WEST)
X			return (DB_WEST);
X		if (IS_DRAWBRIDGE(levl[x-1][y].typ) && 
X		    (levl[x-1][y].drawbridgemask & DB_DIR) == DB_EAST)
X			return (DB_EAST);
X		if (lev->typ == VWALL) break;
X	case HWALL:
X		if (IS_DRAWBRIDGE(levl[x][y-1].typ) && 
X		    (levl[x][y-1].drawbridgemask & DB_DIR) == DB_SOUTH)
X			return (DB_SOUTH);
X		if (IS_DRAWBRIDGE(levl[x][y+1].typ) && 
X		    (levl[x][y+1].drawbridgemask & DB_DIR) == DB_NORTH)
X			return (DB_NORTH);
X	}
X	return (-1);
X}
X
X/*
X * Use is_db_wall where you want to verify that a
X * drawbridge "wall" is UP in the location x, y
X * (instead of UP or DOWN, as with is_drawbridge_wall). 
X */ 
Xboolean
Xis_db_wall(x,y)
Xint x,y;
X{
X	return( (levl[x][y].typ == VWALL || levl[x][y].typ == HWALL) &&
X		levl[x][y].diggable & W_GATEWAY);
X}
X
X/*
X * Return true with x,y pointing to the drawbridge if x,y initially indicate
X * a drawbridge or drawbridge wall.
X */
Xboolean
Xfind_drawbridge(x,y)
Xint *x,*y;
X{
X	int dir;
X
X	if (IS_DRAWBRIDGE(levl[*x][*y].typ))
X		return TRUE;
X	dir = is_drawbridge_wall(*x,*y);
X	if (dir >= 0) {
X		switch(dir) {
X			case DB_NORTH: (*y)++; break;
X			case DB_SOUTH: (*y)--; break;
X			case DB_EAST:  (*x)--; break;
X			case DB_WEST:  (*x)++; break;
X		}
X		return TRUE;
X	}
X	return FALSE;
X}
X
X/* 
X * Find the drawbridge wall associated with a drawbridge.
X */
Xstatic void
Xget_wall_for_db(x,y)
Xint *x,*y;
X{
X	switch (levl[*x][*y].drawbridgemask & DB_DIR) {
X		case DB_NORTH: (*y)--; break;
X		case DB_SOUTH: (*y)++; break;
X		case DB_EAST:  (*x)++; break;
X		case DB_WEST:  (*x)--; break;
X	}
X}
X
X/*
X * Creation of a drawbridge at pos x,y.
X *     dir is the direction.
X *     flag must be put to TRUE if we want the drawbridge to be opened.
X */
X
Xboolean
Xcreate_drawbridge(x,y,dir,flag)
Xint x,y,dir;
Xboolean flag;
X{
X	int x2,y2;
X	uchar wall;
X
X	x2 = x; y2 = y;
X	switch(dir) {
X		case DB_NORTH:
X			wall = HWALL;
X			y2--;
X			break;
X		case DB_SOUTH:
X			wall = HWALL;
X			y2++;
X			break;
X		case DB_EAST:
X			wall = VWALL;
X			x2++;
X			break;
X		case DB_WEST:
X			wall = VWALL;
X			x2--;
X			break;
X	}
X	if (!IS_WALL(levl[x2][y2].typ))
X		return(FALSE);
X	if (flag) {             /* We want the bridge open */
X		levl[x][y].typ = DRAWBRIDGE_DOWN;
X		levl[x2][y2].typ = DOOR;
X		levl[x2][y2].doormask = D_NODOOR;
X	} else {
X		levl[x][y].typ = DRAWBRIDGE_UP;
X		levl[x2][y2].typ = wall;
X		/* Beware, drawbridges are non-diggable. */
X		levl[x2][y2].diggable = (W_NONDIGGABLE | W_GATEWAY);
X	}
X	levl[x][y].drawbridgemask = dir;        /* always have DB_MOAT */
X	initsym(x,y);
X	initsym(x2,y2);
X	return(TRUE);           
X}
X
Xstruct entity {
X	struct monst *emon;	   /* youmonst for the player */
X	struct permonst *edata;    /* must be non-zero for record to be valid */
X	int ex, ey;
X};
X
X#define ENTITIES 2
X
Xstatic struct entity occupants[ENTITIES];
X
Xstatic
Xstruct entity *
Xe_at(x, y)
Xint x, y;
X{
X	int entitycnt;
X	
X	for (entitycnt = 0; entitycnt < ENTITIES; entitycnt++)
X		if ((occupants[entitycnt].edata) && 
X		    (occupants[entitycnt].ex == x) &&
X		    (occupants[entitycnt].ey == y))
X			break;
X#ifdef D_DEBUG
X	pline("entitycnt = %d", entitycnt);
X	fflush(stdout);
X#endif
X	return((entitycnt == ENTITIES)? 
X	       (struct entity *)0 : &(occupants[entitycnt]));
X}
X
Xstatic void
Xm_to_e(mtmp, etmp)
Xstruct monst *mtmp;
Xstruct entity *etmp;
X{
X	etmp->emon = mtmp;
X	if (mtmp) {
X		etmp->ex = mtmp->mx;
X		etmp->ey = mtmp->my;
X		etmp->edata = mtmp->data;
X	} else
X		etmp->edata = (struct permonst *)0;
X}
X
Xstatic void
Xu_to_e(etmp)
Xstruct entity *etmp;
X{
X	etmp->emon = &youmonst;
X	etmp->ex = u.ux;
X	etmp->ey = u.uy;
X	etmp->edata = uasmon;
X}
X
Xstatic void
Xset_entity(x, y, etmp)
Xint x, y;
Xstruct entity *etmp;
X{
X	if ((x == u.ux) && (y == u.uy))
X		u_to_e(etmp);
X	else
X		if (MON_AT(x, y))
X			m_to_e(m_at(x, y), etmp);
X		else
X			etmp->edata = (struct permonst *)0;
X}
X
X#ifdef POLYSELF
X#define is_u(etmp) (etmp->emon == &youmonst)
X#else
X#define is_u(x) FALSE
X#endif
X
X/* 
X * WARNING! THE FOLLOWING IS ONLY USEFUL FOR CANSEEMON, OR OTHER FUNCS WHICH 
X * ALWAYS RETURN TRUE FOR U.
X */
X
X#define e_boolean(etmp, func) (is_u(etmp)? (boolean)TRUE : func(etmp->emon)) 
X
X/*
X * e_strg is a utility routine which is not actually in use anywhere, since 
X * the specialized routines below suffice for all current purposes. 
X */
X
X/* #define e_strg(etmp, func) (is_u(etmp)? (char *)0 : func(etmp->emon)) */
X
Xstatic char *
Xe_nam(etmp)
Xstruct entity *etmp;
X{
X	return(is_u(etmp)? "you" : mon_nam(etmp->emon));
X}
X
X/*
X * Enam is another unused utility routine:  E_phrase is preferable.
X */
X
X/*
Xstatic char *
XEnam(etmp)
Xstruct entity *etmp;
X{
X	return(is_u(etmp)? "You" : Monnam(etmp->emon));
X}
X*/
X
X/*
X * Generates capitalized entity name, makes 2nd -> 3rd person conversion on 
X * verb, where necessary.
X */
X
Xstatic char *
XE_phrase(etmp, verb)
Xstruct entity *etmp;
Xchar *verb;
X{
X	char wholebuf[80], verbbuf[30];
X
X	if (is_u(etmp)) 
X		Strcpy(wholebuf, "You");
X	else
X		Strcpy(wholebuf, Monnam(etmp->emon));
X	if (!*verb)
X		return(wholebuf);
X	Strcat(wholebuf, " ");
X	verbbuf[0] = '\0';
X	if (is_u(etmp)) 
X		Strcpy(verbbuf, verb);
X	else {
X		if (!strcmp(verb, "are"))
X			Strcpy(verbbuf, "is");
X		if (!strcmp(verb, "have"))
X			Strcpy(verbbuf, "has");
X		if (!verbbuf[0]) {
X			Strcpy(verbbuf, verb);
X			switch (verbbuf[strlen(verbbuf) - 1]) {
X				case 'y':
X					verbbuf[strlen(verbbuf) - 1] = '\0';
X					Strcat(verbbuf, "ies");
X					break;
X				case 'h':
X				case 'o':
X				case 's':
X					Strcat(verbbuf, "es");
X					break;
X				default:
X					Strcat(verbbuf, "s");
X					break;
X			}
X		}
X	}
X	Strcat(wholebuf, verbbuf);
X	return(wholebuf);
X}
X
X/*
X * Simple-minded "can it be here?" routine
X */
X
Xstatic boolean
Xe_survives_at(etmp, x, y)
Xstruct entity *etmp;
Xint x, y;
X{
X	if (noncorporeal(etmp->edata))
X		return(TRUE);
X	if (is_pool(x, y))
X		return((is_u(etmp) && (Wwalking || Levitation)) ||
X		       is_swimmer(etmp->edata) || is_flyer(etmp->edata) ||
X		       is_floater(etmp->edata));
X	if (is_db_wall(x, y))
X		return(passes_walls(etmp->edata));
X	return(TRUE);
X}
X
Xstatic void
Xe_died(etmp, dest, how)
Xstruct entity *etmp;
Xint dest, how;
X{
X	if (is_u(etmp)) {
X		if (how == DROWNING)
X			drown();
X		else {
X			coord xy;
X
X			done(how);
X			/* So, you didn't die */
X			if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X				pline("A %s force teleports you away...",
X		      		      Hallucination ? "normal" : "strange");
X				enexto(&xy, etmp->ex, etmp->ey, etmp->edata);
X				teleds(xy.x, xy.y);
X			}
X		}
X	} else {
X		xkilled(etmp->emon, dest);
X		etmp->edata = (struct permonst *)0;	
X	}
X}
X
X
X/*
X * These are never directly affected by a bridge or portcullis.
X */
X
Xstatic boolean
Xautomiss(etmp)
Xstruct entity *etmp;
X{
X	return(passes_walls(etmp->edata) || noncorporeal(etmp->edata));
X}
X
X/*
X * Does falling drawbridge or portcullis miss etmp?
X */
X
Xstatic boolean
Xe_missed(etmp, chunks)
Xstruct entity *etmp;
Xboolean chunks;
X{
X	int misses;
X
X#ifdef D_DEBUG
X	if (chunks)
X		pline("Do chunks miss?");
X#endif
X	if (automiss(etmp))
X		return(TRUE);	
X
X	if (is_flyer(etmp->edata) && 
X	    (is_u(etmp)? !Sleeping : 
X	     (!etmp->emon->mfroz && !etmp->emon->msleep)))
X						  /* flying requires mobility */
X		misses = 5;	/* out of 8 */	
X	else
X		if (is_floater(etmp->edata) ||
X		    (is_u(etmp) && Levitation))	  /* doesn't require mobility */
X			misses = 3;
X		else
X			if (chunks && is_pool(etmp->ex, etmp->ey))
X				misses = 2; 		     /* sitting ducks */
X			else
X				misses = 0;	  
X
X	if (is_db_wall(etmp->ex, etmp->ey))
X		misses -= 3;				     /* less airspace */
X
X#ifdef D_DEBUG
X	pline("Miss chance = %d (out of 8)", misses);
X#endif
X
X	return((misses >= rnd(8))? TRUE : FALSE);
X}
X
X/*
X * Can etmp jump from death?
X */ 
X
Xstatic boolean
Xe_jumps(etmp)
Xstruct entity *etmp;
X{
X	int tmp = 4; 		/* out of 10 */
X
X	if (is_u(etmp)? (Sleeping || Fumbling) : 
X		        (etmp->emon->mfroz || etmp->emon->msleep || 
X			 !etmp->edata->mmove))
X		return(FALSE);
X
X	if (is_u(etmp)? Confusion : etmp->emon->mconf)
X		tmp -= 2;
X
X	if (is_u(etmp)? Stunned : etmp->emon->mstun)
X		tmp -= 3;
X
X	if (is_db_wall(etmp->ex, etmp->ey))
X		tmp -= 2;			     /* less room to maneuver */
X	
X#ifdef D_DEBUG
X	pline("%s to jump (%d chances in 10)", E_phrase(etmp, "try"), tmp);
X#endif
X	return((tmp >= rnd(10))? TRUE : FALSE);
X}
X
Xstatic void
Xdo_entity(etmp)
Xstruct entity *etmp;
X{
X	int newx, newy, at_portcullis, oldx, oldy;
X	boolean must_jump = FALSE, relocates = FALSE, e_inview;
X	struct rm *crm;
X
X	if (!etmp->edata)
X		return;
X
X	e_inview = e_boolean(etmp, canseemon);
X
X	oldx = etmp->ex;
X	oldy = etmp->ey;
X
X	at_portcullis = is_db_wall(oldx, oldy);
X
X	crm = &levl[oldx][oldy];
X
X	if (automiss(etmp) && e_survives_at(etmp, oldx, oldy)) {
X		char edifice[20];
X
X		if (e_inview) {
X			*edifice = '\0';
X			if ((crm->typ == DRAWBRIDGE_DOWN) ||
X		    	    (crm->typ == DRAWBRIDGE_UP))
X				Strcpy(edifice, "drawbridge");
X			else
X     				if (at_portcullis) 
X					Strcpy(edifice, "portcullis");
X			if (*edifice)
X				pline("The %s passes through %s!", edifice, 
X			      	      e_nam(etmp));			
X		}
X		return;
X	}
X	if (e_missed(etmp, FALSE)) { 
X		if (at_portcullis)
X			pline("The portcullis misses %s!",
X			      e_nam(etmp));
X#ifdef D_DEBUG
X		else
X			pline("The drawbridge misses %s!", 
X			      e_nam(etmp));
X#endif
X		if (e_survives_at(etmp, oldx, oldy)) 
X			return;
X		else {
X#ifdef D_DEBUG
X			pline("Mon can't survive here");
X#endif
X			if (at_portcullis)
X				must_jump = TRUE;
X			else
X				relocates = TRUE;  /* just ride drawbridge in */
X		}
X	} else {
X		if (crm->typ == DRAWBRIDGE_DOWN) {
X			pline("%s crushed underneath the drawbridge.",
X		      	      E_phrase(etmp, "are"));	   	   /* no jump */
X			e_died(etmp, e_inview? 2 : 3, CRUSHING); /* no corpse */
X			return;   /* Note: Beyond this point, we know we're   */
X		}                 /* not at an opened drawbridge, since all   */
X		must_jump = TRUE; /* *missable* creatures survive on the      */
X	}			  /* square, and all the unmissed ones die.   */
X	if (must_jump) 
X		if (at_portcullis) {
X			if (e_jumps(etmp)) {
X				relocates = TRUE;
X#ifdef D_DEBUG
X				pline("Jump succeeds!");
X#endif
X			} else {
X				if (e_inview)
X			       pline("%s crushed by the falling portcullis!",
X	      	      		     E_phrase(etmp, "are"));
X				else
X					if (flags.soundok)
X						You("hear a crushing sound.");
X				e_died(etmp, e_inview? 1 : 0, CRUSHING);
X								    /* corpse */
X				return;
X			}
X		} else {       /* tries to jump off bridge to original square */
X			relocates = !e_jumps(etmp); 
X#ifdef D_DEBUG
X			pline("Jump %s!", (relocates)? "fails" : "succeeds");
X#endif
X		}
X
X/*
X * Here's where we try to do relocation.  Assumes that etmp is not arriving
X * at the portcullis square while the drawbridge is falling, since this square
X * would be inaccessible (i.e. etmp started on drawbridge square) or 
X * unnecessary (i.e. etmp started here) in such a situation.
X */
X#ifdef D_DEBUG
X	pline("Doing relocation");
X#endif
X	newx = oldx;
X	newy = oldy;
X	(void)find_drawbridge(&newx, &newy);
X	if ((newx == oldx) && (newy == oldy))
X		get_wall_for_db(&newx, &newy);
X#ifdef D_DEBUG
X	pline("Checking new square for occupancy");
X#endif
X	if (relocates && (e_at(newx, newy))) { 
X
X/* 
X * Standoff problem:  one or both entities must die, and/or both switch 
X * places.  Avoid infinite recursion by checking first whether the other 
X * entity is staying put.  Clean up if we happen to move/die in recursion.
X */
X		struct entity *other;
X
X		other = e_at(newx, newy);
X#ifdef D_DEBUG
X		pline("New square is occupied by %s", e_nam(other));
X#endif
X		if (e_survives_at(other, newx, newy) && automiss(other)) {
X			relocates = FALSE;     	       /* "other" won't budge */
X#ifdef D_DEBUG
X			pline("%s suicide.", E_phrase(etmp, "commit"));
X#endif
X		} else {
X
X#ifdef D_DEBUG
X			pline("Handling %s", e_nam(other));
X#endif
X			while ((e_at(newx, newy)) && 
X			       (e_at(newx, newy) != etmp))
X		       		do_entity(other);
X#ifdef D_DEBUG
X			pline("Checking existence of %s", 
X			      e_nam(etmp));
X			fflush(stdout);
X#endif
X			if (e_at(oldx, oldy) != etmp) {
X#ifdef D_DEBUG
X			        pline("%s moved or died in recursion somewhere",
X				      E_phrase(etmp, "have"));
X				fflush(stdout);
X#endif
X				return;
X			}
X		}
X	}
X	if (relocates) {
X#ifdef D_DEBUG
X		pline("Moving %s", e_nam(etmp));
X#endif
X		if (!is_u(etmp)) {
X			remove_monster(etmp->ex, etmp->ey);
X			place_monster(etmp->emon, newx, newy);
X		} else {
X			u.ux = newx;
X			u.uy = newy;
X		}
X		etmp->ex = newx;
X		etmp->ey = newy;
X		e_inview = e_boolean(etmp, canseemon);
X	}
X#ifdef D_DEBUG
X	pline("Final disposition of %s", e_nam(etmp));
X	fflush(stdout);
X#endif
X	if (is_db_wall(etmp->ex, etmp->ey)) {
X#ifdef D_DEBUG
X		pline("%s in portcullis chamber", E_phrase(etmp, "are"));
X		fflush(stdout);
X#endif
X		if (e_inview)
X			if (is_u(etmp)) {
X				You("tumble towards the closed portcullis!"); 
X				if (automiss(etmp))
X					You("pass through it!");
X				else
X					pline("The drawbridge closes in...");
X			} else
X				pline("%s behind the drawbridge.",
X		      	      	      E_phrase(etmp, "disappear"));
X		if (!e_survives_at(etmp, etmp->ex, etmp->ey)) {
X			killer = "closing drawbridge";
X			e_died(etmp, 0, CRUSHING); 		/* no message */
X			return;
X		}
X#ifdef D_DEBUG
X		pline("%s in here", E_phrase(etmp, "survive"));
X#endif
X	} else {
X#ifdef D_DEBUG
X		pline("%s on drawbridge square", E_phrase(etmp, "are"));
X#endif
X		if (is_pool(etmp->ex, etmp->ey) && !e_inview)
X			if (flags.soundok)
X				You("hear a splash.");
X		if (e_survives_at(etmp, etmp->ex, etmp->ey)) {
X			if (e_inview && !is_flyer(etmp->edata) &&
X			    !is_floater(etmp->edata))
X				pline("%s from the bridge.",
X		      	      	      E_phrase(etmp, "fall"));	
X			return;	
X		}
X#ifdef D_DEBUG
X		pline("%s cannot survive on the drawbridge square", Enam(etmp));
X#endif
X		if (is_pool(etmp->ex, etmp->ey))
X			if (e_inview && 
X			    !is_u(etmp))  /* drown() will supply msgs if nec. */
X				if (Hallucination)
X				      pline("%s the moat and disappears.",
X					    E_phrase(etmp, "drink"));
X				else
X				      pline("%s into the moat.",
X			      	            E_phrase(etmp, "fall"));
X		killer = "fall from a drawbridge";
X		e_died(etmp, e_inview? 1 : 0,        /* CRUSHING is arbitrary */
X		       (is_pool(etmp->ex, etmp->ey))? DROWNING : CRUSHING);
X		       						    /* corpse */
X		return;
X	}
X}
X
X/*
X * Close the drawbridge located at x,y
X */
X
Xvoid
Xclose_drawbridge(x,y)
Xint x,y;
X{
X	register struct rm *lev1, *lev2;
X	struct obj *otmp, *otmp2;
X	int x2, y2;
X
X	lev1 = &levl[x][y];
X	if (lev1->typ != DRAWBRIDGE_DOWN) return;
X	x2 = x; y2 = y;
X	get_wall_for_db(&x2,&y2);
X	if (cansee(x,y))   /* change msgs if you are a w-walker at portcullis */
X		You("see a drawbridge %s up!", 
X		    ((u.ux == x2) && (u.uy == y2))? "coming" : "going");
X	lev1->typ = DRAWBRIDGE_UP;
X	lev2 = &levl[x2][y2];
X	switch (lev1->drawbridgemask & DB_DIR) {
X		case DB_NORTH:
X		case DB_SOUTH:
X			lev2->typ = HWALL;
X			break;
X		case DB_WEST:
X		case DB_EAST:
X			lev2->typ = VWALL;
X			break;
X	}
X	lev2->diggable = (W_NONDIGGABLE | W_GATEWAY);
X	set_entity(x, y, &(occupants[0]));
X	set_entity(x2, y2, &(occupants[1]));
X	do_entity(&(occupants[0]));
X	do_entity(&(occupants[1]));
X	redosym(x, y);
X	for (otmp = level.objects[x][y]; otmp; otmp = otmp2) {
X		otmp2 = otmp->nexthere;
X		delobj(otmp);
X	}
X	for (otmp = level.objects[x2][y2]; otmp; otmp = otmp2) {
X		otmp2 = otmp->nexthere;
X		delobj(otmp);
X	}
X	redosym(x2, y2);
X}
X
X/* 
X * Open the drawbridge located at x,y
X */
X
Xvoid
Xopen_drawbridge(x,y)
Xint x,y;
X{
X	register struct rm *lev1, *lev2;
X	int x2, y2;
X
X	lev1 = &levl[x][y];
X	if (lev1->typ != DRAWBRIDGE_UP) return;
X	x2 = x; y2 = y;
X	get_wall_for_db(&x2,&y2);
X	if (cansee(x,y))   /* change msgs if you are a w-walker at portcullis */
X		You("see a drawbridge %s down!",
X		    ((x2 == u.ux) && (y2 == u.uy))? "going" : "coming");
X	lev1->typ = DRAWBRIDGE_DOWN;
X	lev2 = &levl[x2][y2];
X	lev2->typ = DOOR;
X	lev2->doormask = D_NODOOR;
X	set_entity(x, y, &(occupants[0]));
X	set_entity(x2, y2, &(occupants[1]));
X	do_entity(&(occupants[0]));
X	do_entity(&(occupants[1]));
X	redosym(x, y);
X	redosym(x2, y2);
X}
X
X/*
X * Let's destroy the drawbridge located at x,y
X */
X
Xvoid
Xdestroy_drawbridge(x,y)
Xint x,y;
X{
X	register struct rm *lev1, *lev2;
X	int x2, y2;
X	boolean e_inview;
X	struct entity *etmp1 = &(occupants[0]), *etmp2 = &(occupants[1]);
X
X	lev1 = &levl[x][y];
X	if (!IS_DRAWBRIDGE(lev1->typ))
X		return;
X	x2 = x; y2 = y;
X	get_wall_for_db(&x2,&y2);
X	lev2 = &levl[x2][y2];
X	if ((lev1->drawbridgemask & DB_UNDER) == DB_MOAT) {
X		if (lev1->typ == DRAWBRIDGE_UP) {
X			if (cansee(x2,y2))
X		pline("The portcullis of the drawbridge falls into the moat!");
X			else if (flags.soundok)
X				You("hear a loud *SPLASH*!");
X		} else {
X			if (cansee(x,y))
X			    pline("The drawbridge collapses into the moat!");
X			else if (flags.soundok)
X				You("hear a loud *SPLASH*!");
X		}
X		lev1->typ = MOAT;
X		lev1->drawbridgemask = 0;
X	} else {
X		if (cansee(x,y))
X			pline("The drawbridge disintegrates!");
X		else
X			You("hear a loud *CRASH*!");
X		lev1->typ = ROOM;
X		lev1->icedpool =
X			((lev1->drawbridgemask & DB_ICE) ? ICED_MOAT : 0);
X	}
X	set_entity(x2, y2, etmp2); /* currently, only automissers can be here */
X	if (etmp2->edata) {
X		e_inview = e_boolean(etmp2, canseemon);
X		if (!automiss(etmp2)) {			   /* i.e. no-one yet */
X			if (e_inview)
X				pline("%s blown apart by flying debris",
X			      	      E_phrase(etmp2, "are"));
X			killer = "exploding drawbridge";
X			e_died(etmp2, e_inview? 2 : 3, CRUSHING);/* no corpse */
X		}	      /* nothing which is vulnerable can survive this */
X	}
X	lev2->typ = DOOR;
X	lev2->doormask = D_NODOOR;
X	set_entity(x, y, etmp1);
X	e_inview = e_boolean(etmp1, canseemon);
X	if (etmp1->edata) {
X		if (e_missed(etmp1, TRUE)) {
X#ifdef D_DEBUG
X			pline("%s spared!", E_phrase(etmp1, "are"));
X#endif
X		} else {
X			if (e_inview) 
X				if (!is_u(etmp1) && Hallucination)
X					pline("%s into some heavy metal",
X					      E_phrase(etmp1, "get"));
X				else
X				    pline("%s hit by a huge chunk of metal!",
X			      	          E_phrase(etmp1, "are"));
X			else 
X				if (flags.soundok && !is_u(etmp1) && 
X				    !is_pool(x, y))
X					You("hear a crushing sound");
X#ifdef D_DEBUG
X				else
X					pline("%s from shrapnel", 
X					      E_phrase(etmp1, "die"));
X#endif
X			killer = "collapsing drawbridge";
X			e_died(etmp1, e_inview? 0 : 1, CRUSHING);   /* corpse */
X		}
X	}
X	redosym(x,y);
X	redosym(x2,y2);
X}
X
X#endif /* STRONGHOLD /**/
END_OF_FILE
if test 19606 -ne `wc -c <'src/dbridge.c'`; then
    echo shar: \"'src/dbridge.c'\" unpacked with wrong size!
fi
# end of 'src/dbridge.c'
echo shar: End of archive 15 \(of 15\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
