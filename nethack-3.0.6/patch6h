Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i061:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6h
Message-ID: <4850@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:52:21 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2240
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 61
Archive-name: NetHack3/Patch6h
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 15)."
# Contents:  patches06e
# Wrapped by billr@saab on Wed Nov 22 10:50:14 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches06e' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06e'\"
else
echo shar: Extracting \"'patches06e'\" \(53756 characters\)
sed "s/^X//" >'patches06e' <<'END_OF_FILE'
X*** src/Old/Makefile.src	Sun Nov 19 12:30:37 1989
X--- src/Makefile.src	Thu Nov  9 18:09:45 1989
X***************
X*** 47,58 ****
X  CFLAGS = -O -I../include
X  LFLAGS =
X  
X- # object files for makedefs
X- MAKEOBJS = makedefs.o monst.o objects.o panic.o
X- 
X- # object files for special levels compiler
X- SPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X- 
X  # on some systems the termcap library is in -ltermcap or -lcurses
X  # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
X  # Sysatt uses shared library in lieu of this option
X--- 47,52 ----
X***************
X*** 105,115 ****
X  
X  HACKINCL = amiconf.h artifact.h attrib.h color.h config.h coord.h decl.h\
X  	   def_os2.h edog.h epri.h eshk.h extern.h flag.h func_tab.h global.h\
X! 	   gold.h hack.h lev.h mfndpos.h mkroom.h monattk.h mondata.h monflag.h\
X! 	   monst.h monsym.h msdos.h obj.h objclass.h patchlevel.h pcconf.h\
X! 	   permonst.h prop.h rm.h sp_lev.h spell.h system.h tosconf.h\
X! 	   tradstdc.h trapname.h unixconf.h vault.h vmsconf.h wseg.h you.h\
X! 	   youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X--- 99,109 ----
X  
X  HACKINCL = amiconf.h artifact.h attrib.h color.h config.h coord.h decl.h\
X  	   def_os2.h edog.h epri.h eshk.h extern.h flag.h func_tab.h global.h\
X! 	   gold.h hack.h lev.h macconf.h mfndpos.h mkroom.h monattk.h mondata.h\
X! 	   monflag.h monst.h monsym.h msdos.h obj.h objclass.h patchlevel.h\
X! 	   pcconf.h permonst.h prop.h rm.h sp_lev.h spell.h system.h termcap.h\
X! 	   tosconf.h tradstdc.h trapname.h unixconf.h vault.h vmsconf.h wseg.h\
X! 	   you.h youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X***************
X*** 119,124 ****
X--- 113,124 ----
X  
X  SOURCES = $(CSOURCES) $(HSOURCES)
X  
X+ # object files for makedefs
X+ MAKEOBJS = makedefs.o monst.o objects.o panic.o
X+ 
X+ # object files for special levels compiler
X+ SPLEVOBJS = lev_comp.o lev_lex.o lev_main.o alloc.o monst.o objects.o panic.o
X+ 
X  HOBJ = allmain.o alloc.o apply.o artifact.o attrib.o bones.o cmd.o dbridge.o\
X  	decl.o demon.o do.o do_name.o do_wear.o dog.o dogmove.o dokick.o\
X  	dothrow.o eat.o end.o engrave.o exper.o extralev.o fountain.o getline.o\
X***************
X*** 387,393 ****
X  polyself.o:  ../include/hack.h
X  potion.o:  ../include/hack.h
X  pray.o:  ../include/hack.h
X! pri.o:  ../include/hack.h ../include/epri.h
X  priest.o:  ../include/hack.h ../include/mfndpos.h ../include/eshk.h ../include/epri.h
X  prisym.o:  ../include/hack.h ../include/wseg.h ../include/lev.h
X  read.o:  ../include/hack.h
X--- 387,393 ----
X  polyself.o:  ../include/hack.h
X  potion.o:  ../include/hack.h
X  pray.o:  ../include/hack.h
X! pri.o:  ../include/hack.h ../include/epri.h ../include/termcap.h
X  priest.o:  ../include/hack.h ../include/mfndpos.h ../include/eshk.h ../include/epri.h
X  prisym.o:  ../include/hack.h ../include/wseg.h ../include/lev.h
X  read.o:  ../include/hack.h
X***************
X*** 404,410 ****
X  sp_lev.o:  ../include/hack.h ../include/sp_lev.h
X  spell.o:  ../include/hack.h
X  steal.o:  ../include/hack.h
X! termcap.o:  ../include/hack.h
X  timeout.o:  ../include/hack.h
X  topl.o:  ../include/hack.h
X  topten.o:  ../include/hack.h
X--- 404,410 ----
X  sp_lev.o:  ../include/hack.h ../include/sp_lev.h
X  spell.o:  ../include/hack.h
X  steal.o:  ../include/hack.h
X! termcap.o:  ../include/hack.h ../include/termcap.h
X  timeout.o:  ../include/hack.h
X  topl.o:  ../include/hack.h
X  topten.o:  ../include/hack.h
X***************
X*** 428,437 ****
X  			touch ../include/config.h
X  ../include/decl.h:  ../include/spell.h ../include/color.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X  			touch ../include/decl.h
X! ../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h
X  			touch ../include/global.h
X  ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h 
X  			touch ../include/hack.h
X  ../include/pcconf.h:  ../include/msdos.h ../include/system.h
X  			touch ../include/pcconf.h
X  ../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X--- 428,439 ----
X  			touch ../include/config.h
X  ../include/decl.h:  ../include/spell.h ../include/color.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X  			touch ../include/decl.h
X! ../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h ../include/macconf.h
X  			touch ../include/global.h
X  ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h 
X  			touch ../include/hack.h
X+ ../include/macconf.h:  ../include/msdos.h ../include/system.h 
X+ 			touch ../include/macconf.h
X  ../include/pcconf.h:  ../include/msdos.h ../include/system.h
X  			touch ../include/pcconf.h
X  ../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X*** src/Old/allmain.c	Sun Nov 19 12:31:13 1989
X--- src/allmain.c	Sat Nov  4 13:40:17 1989
X***************
X*** 42,47 ****
X--- 42,50 ----
X  		UnloadSeg(savebones);
X  	}
X  #endif
X+ #ifdef CLIPPING
X+ 		cliparound(u.ux, u.uy);
X+ #endif
X  		if(flags.move) {	/* actual time passed */
X  
X  #ifdef SOUNDS
X***************
X*** 262,267 ****
X--- 265,273 ----
X  	 */
X  	if(MON_AT(u.ux, u.uy)) mnexto(m_at(u.ux, u.uy));
X  
X+ #ifdef CLIPPING
X+ 	cliparound(u.ux, u.uy);
X+ #endif
X  	(void) makedog();
X  	seemons();
X  #ifdef NEWS
X*** src/Old/alloc.c	Sun Nov 19 12:31:27 1989
X--- src/alloc.c	Fri Nov 17 19:31:23 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)alloc.c	3.0	88/07/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)alloc.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 23,29 ****
X  
X  #else
X  #ifndef __TURBOC__
X! extern void panic P((char *,...));
X  
X  long *
X  alloc(lth)
X--- 23,29 ----
X  
X  #else
X  #ifndef __TURBOC__
X! extern void VDECL(panic, (char *,...));
X  
X  long *
X  alloc(lth)
X*** src/Old/apply.c	Sun Nov 19 12:31:42 1989
X--- src/apply.c	Sat Nov 18 21:17:21 1989
X***************
X*** 95,102 ****
X  				mtmp->mflee = 1;
X  				if(rn2(4)) mtmp->mfleetim = rnd(100);
X  			}
X! 			if(tmp < 3) mtmp->mcansee  = mtmp->mblinded = 0;
X! 			else {
X  				tmp2 = mtmp->mblinded;
X  				tmp2 += rnd(1 + 50/tmp);
X  				if(tmp2 > 127) tmp2 = 127;
X--- 95,104 ----
X  				mtmp->mflee = 1;
X  				if(rn2(4)) mtmp->mfleetim = rnd(100);
X  			}
X! 			if(tmp < 3) {
X! 				mtmp->mcansee  = 0;
X! 				mtmp->mblinded = 0;
X! 			} else {
X  				tmp2 = mtmp->mblinded;
X  				tmp2 += rnd(1 + 50/tmp);
X  				if(tmp2 > 127) tmp2 = 127;
X***************
X*** 415,422 ****
X  }
X  #endif /* WALKIES */
X  
X! 
X! static int
X  dig() {
X  	register struct rm *lev;
X  	register int dpx = dig_pos.x, dpy = dig_pos.y;
X--- 417,426 ----
X  }
X  #endif /* WALKIES */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  dig() {
X  	register struct rm *lev;
X  	register int dpx = dig_pos.x, dpy = dig_pos.y;
X***************
X*** 524,529 ****
X--- 528,535 ----
X  		if(IS_DOOR(lev->typ) && (lev->doormask & D_TRAPPED)) {
X  			b_trapped("door");
X  			lev->doormask = D_NODOOR;
X+ 			mnewsym(dpx, dpy);
X+ 			prl(dpx, dpy);
X  		}
X  		dig_level = -1;
X  		return(0);
X***************
X*** 642,648 ****
X  struct obj *obj;
X  {
X  	char dirsyms[12];
X! 	register char *dsp = dirsyms, *sdp = flags.num_pad ? ndir : sdir;
X  	register struct rm *lev;
X  	register int rx, ry, res = 0;
X  	register boolean isclosedoor = FALSE;
X--- 648,655 ----
X  struct obj *obj;
X  {
X  	char dirsyms[12];
X! 	register char *dsp = dirsyms;
X! 	register const char *sdp = flags.num_pad ? ndir : sdir;
X  	register struct rm *lev;
X  	register int rx, ry, res = 0;
X  	register boolean isclosedoor = FALSE;
X***************
X*** 779,795 ****
X  #endif
X  			   if (Hallucination) You("look %s.", hcolor());
X  		    else if (Sick)
X! 			You("look peakish.");
X  		    else if (u.uhs >= WEAK)
X  			You("look undernourished.");
X  #ifdef POLYSELF
X  		    else if (u.usym == S_NYMPH
X! #ifdef HARD
X  			     || u.umonnum==PM_SUCCUBUS
X  #endif
X  			     )
X  			You("look beautiful in the mirror.");
X! #ifdef HARD
X  		    else if (u.umonnum == PM_INCUBUS)
X  			You("look handsome in the mirror.");
X  #endif
X--- 786,802 ----
X  #endif
X  			   if (Hallucination) You("look %s.", hcolor());
X  		    else if (Sick)
X! 			You("look peaked.");
X  		    else if (u.uhs >= WEAK)
X  			You("look undernourished.");
X  #ifdef POLYSELF
X  		    else if (u.usym == S_NYMPH
X! #ifdef INFERNO
X  			     || u.umonnum==PM_SUCCUBUS
X  #endif
X  			     )
X  			You("look beautiful in the mirror.");
X! #ifdef INFERNO
X  		    else if (u.umonnum == PM_INCUBUS)
X  			You("look handsome in the mirror.");
X  #endif
X***************
X*** 883,889 ****
X  			pline ("%s has confused itself!", Monnam(mtmp));
X  	    	mtmp->mconf = 1;
X  	} else if(!mtmp->mcan && !mtmp->minvis && (mlet == S_NYMPH
X! #ifdef HARD
X  			  || mtmp->data==&mons[PM_SUCCUBUS]
X  #endif
X  			  )) {
X--- 890,896 ----
X  			pline ("%s has confused itself!", Monnam(mtmp));
X  	    	mtmp->mconf = 1;
X  	} else if(!mtmp->mcan && !mtmp->minvis && (mlet == S_NYMPH
X! #ifdef INFERNO
X  			  || mtmp->data==&mons[PM_SUCCUBUS]
X  #endif
X  			  )) {
X***************
X*** 1135,1141 ****
X  	can->blessed = obj->blessed;
X  	can = addinv(can);
X  	You("now have %s.", doname(can));
X! 	useup(corpse);
X  }
X  
X  int
X--- 1142,1223 ----
X  	can->blessed = obj->blessed;
X  	can = addinv(can);
X  	You("now have %s.", doname(can));
X! 	if (carried(corpse)) useup(corpse);
X! 	else useupf(corpse);
X! }
X! 
X! int
X! use_unicorn_horn(obj)
X! struct obj *obj;
X! {
X! 	boolean cursed = (obj && obj->cursed);
X! 	boolean blessed = (obj && obj->blessed);
X! 	boolean did_something = FALSE;
X! 
X! 	if (cursed) {
X! 		switch (rn2(6)) {
X! 		    static char buf[BUFSZ];
X! 		    case 0: make_sick(Sick ? 1L : (long)(20 + rn2(20)), TRUE);
X! 			    Strcpy(buf, xname(obj));
X! 			    u.usick_cause = buf;
X! 			    break;
X! 		    case 1: make_blinded(Blinded + (long) rnd(100), TRUE);
X! 			    break;
X! 		    case 2: if (!Confusion)
X! 				You("suddenly feel %s.",
X! 					Hallucination ? "trippy" : "confused");
X! 			    make_confused(HConfusion + (long) rnd(100), TRUE);
X! 			    break;
X! 		    case 3: make_stunned(HStun + (long) rnd(100), TRUE);
X! 			    break;
X! 		    case 4: adjattrib(rn2(6), -1, FALSE);
X! 			    break;
X! 		    case 5: make_hallucinated(Hallucination + (long) rnd(100),
X! 				TRUE);
X! 			    break;
X! 		}
X! 		return 1;
X! 	}
X! 		
X! 	if (Sick) {
X! 		make_sick(0L, TRUE);
X! 		did_something++;
X! 	}
X! 	if (Blinded && (!did_something || blessed)) {
X! 		make_blinded(0L, TRUE);
X! 		did_something++;
X! 	}
X! 	if (Hallucination && (!did_something || blessed)) {
X! 		make_hallucinated(0L, TRUE);
X! 		did_something++;
X! 	}
X! 	if (HConfusion && (!did_something || blessed)) {
X! 		make_confused(0L, TRUE);
X! 		did_something++;
X! 	}
X! 	if (HStun && (!did_something || blessed)) {
X! 		make_stunned(0L, TRUE);
X! 		did_something++;
X! 	}
X! 	if (!did_something || blessed) {
X! 		register int j;
X! 		int did_stat = 0;
X! 		int i = rn2(A_MAX);
X! 		for(j=0; j<A_MAX; j++) {
X! 			if ((blessed || j==i) && ABASE(i) < AMAX(i)) {
X! 				did_something++;
X! 				/* They may have to use it several times... */
X! 				if (!did_stat) {
X! 					did_stat++;
X! 					pline("This makes you feel good!");
X! 				}
X! 				ABASE(i)++;
X! 				flags.botl = 1;
X! 			}
X! 		}
X! 	}
X! 	if (!did_something) pline(nothing_happens);
X! 	return !!did_something;
X  }
X  
X  int
X***************
X*** 1244,1249 ****
X--- 1326,1334 ----
X  		} 
X  		else if (!ublindf) Blindf_on(obj);
X  		else You("are already wearing a blindfold!");
X+ 		break;
X+ 	case UNICORN_HORN:
X+ 		res = use_unicorn_horn(obj);
X  		break;
X  	default:
X  		pline("Sorry, I don't know how to use that.");
X*** src/Old/artifact.c	Sun Nov 19 12:32:35 1989
X--- src/artifact.c	Sun Oct 22 11:45:42 1989
X***************
X*** 101,107 ****
X  mkartifact(otmp1)
X  struct obj **otmp1;
X  {
X! 	register struct artifact *artif;
X  	register struct obj *otmp = *otmp1;
X  	register int n = 0;
X  
X--- 101,107 ----
X  mkartifact(otmp1)
X  struct obj **otmp1;
X  {
X! 	register const struct artifact *artif;
X  	register struct obj *otmp = *otmp1;
X  	register int n = 0;
X  
X***************
X*** 123,135 ****
X  get_artifact(otmp)
X  struct obj *otmp;
X  {
X! 	register struct artifact *artif;
X  
X  	if(otmp)
X  	    if(strlen(ONAME(otmp)))
X  		for(artif = artilist; artif->otyp; artif++)
X  		    if(artif->otyp == otmp->otyp &&
X! 		       !strcmp(ONAME(otmp), artif->name)) return(artif);
X  	return((struct artifact *)0);
X  }
X  
X--- 123,136 ----
X  get_artifact(otmp)
X  struct obj *otmp;
X  {
X! 	register const struct artifact *artif;
X  
X  	if(otmp)
X  	    if(strlen(ONAME(otmp)))
X  		for(artif = artilist; artif->otyp; artif++)
X  		    if(artif->otyp == otmp->otyp &&
X! 		       !strcmp(ONAME(otmp), artif->name))
X! 			    return((struct artifact *)artif);
X  	return((struct artifact *)0);
X  }
X  
X***************
X*** 155,161 ****
X  register struct obj *otmp;
X  register char	*name;
X  {
X! 	register struct artifact *artif;
X  
X  	if(!strlen(name)) return(0);
X  
X--- 156,162 ----
X  register struct obj *otmp;
X  register char	*name;
X  {
X! 	register const struct artifact *artif;
X  
X  	if(!strlen(name)) return(0);
X  
X***************
X*** 172,178 ****
X  mk_aligned_artifact(align)
X  unsigned align;
X  {
X! 	register struct artifact *artif;
X  	register struct obj *otmp;
X  	register int n = 0;
X  
X--- 173,179 ----
X  mk_aligned_artifact(align)
X  unsigned align;
X  {
X! 	register const struct artifact *artif;
X  	register struct obj *otmp;
X  	register int n = 0;
X  
X*** src/Old/attrib.c	Sun Nov 19 12:32:55 1989
X--- src/attrib.c	Wed Nov  8 21:19:20 1989
X***************
X*** 95,110 ****
X   * a minimum strength of 6 since without one you can't teleport or cast
X   * spells. --KAA
X   */
X! 	struct	innate *abil;
X! }	a_attr = { {	 6,  9,  9,  6,  6,  6 },  /* Archeologist */
X  		   {	20, 20, 20, 10, 20, 10 },
X  		    10,  1, 13, 10, 14,  2, a_abil },
X  
X! 	b_attr = { {	15,  6,  6, 14, 15,  5 },  /* Barbarian */
X  		   {	30,  6,  7, 20, 30,  7 },
X  		    10, -1, 16, 12, 10,  3, b_abil },
X  
X! 	c_attr = { {	 9,  6,  6,  6,  7,  5 },  /* Caveman (fighter) */
X  		   {	30,  6,  7, 20, 30,  7 },
X  		     0,  1, 16, 10, 10,  3, c_abil },
X  
X--- 95,110 ----
X   * a minimum strength of 6 since without one you can't teleport or cast
X   * spells. --KAA
X   */
X! 	const struct	innate *abil;
X! }	a_attr = { {	 7, 10, 10,  7,  7,  7 },  /* Archeologist */
X  		   {	20, 20, 20, 10, 20, 10 },
X  		    10,  1, 13, 10, 14,  2, a_abil },
X  
X! 	b_attr = { {	16,  7,  7, 15, 16,  6 },  /* Barbarian */
X  		   {	30,  6,  7, 20, 30,  7 },
X  		    10, -1, 16, 12, 10,  3, b_abil },
X  
X! 	c_attr = { {	10,  7,  7,  7,  8,  6 },  /* Caveman (fighter) */
X  		   {	30,  6,  7, 20, 30,  7 },
X  		     0,  1, 16, 10, 10,  3, c_abil },
X  
X***************
X*** 111,149 ****
X  /*
X  	e_attr = { {	13, 13, 14,  6, 14,  6 },
X   */
X! 	e_attr = { {	12, 12, 12,  8, 12,  6 },  /* Elf (ranger) */
X  		   {	30, 10, 10, 20, 20, 10 },
X  		    10,  1, 15, 10, 11,  2, e_abil },
X  
X! 	h_attr = { {	 6,  6, 12,  6, 10, 15 },  /* Healer (druid) */
X  		   {	15, 20, 20, 15, 25, 10 },
X  		    10,  1, 13, 10, 20,  2, h_abil },
X  
X! 	k_attr = { {	12,  6, 13,  6,  9, 17 },  /* Knight (paladin) */
X  		   {	20, 15, 15, 10, 20, 10 },
X  		    10,  1, 16, 10, 10,  3, k_abil },
X  
X! 	p_attr = { {	 6,  6,  9,  6,  6,  6 },  /* Priest (cleric) */
X  		   {	15, 10, 30, 15, 20, 10 },
X  		     0,  0, 14, 10, 10,  2, p_abil },
X  
X! 	r_attr = { {	 6,  6,  6,  9,  6,  5 },  /* Rogue (thief) */
X  		   {	20, 10, 10, 30, 20, 10 },
X  		    10, -1, 12, 10, 11,  2, r_abil },
X  
X! 	s_attr = { {	 9,  6,  6,  9, 17,  5 },  /* Samurai (fighter/thief) */
X  		   {	30, 10, 10, 30, 14, 10 },
X  		    10,  1, 15, 10, 11,  2, s_abil },
X  
X! 	t_attr = { {	 6,  9,  5,  6,  6,  9 },  /* Tourist */
X  		   {	15, 10, 10, 15, 30, 20 },
X  		     0,  0, 10, 10, 14,  1, t_abil },
X  
X! 	v_attr = { {	 9,  6,  6,  6,  9,  6 },  /* Valkyrie (fighter) */
X  		   {	30,  6,  7, 20, 30,  7 },
X  		     0, -1, 16, 10, 10,  3, v_abil },
X  
X! 	w_attr = { {	 6,  9,  6,  6,  6,  6 },  /* Wizard (magic-user) */
X  		   {	10, 30, 10, 20, 20, 10 },
X  		     0,  0, 12, 10, 12,  1, w_abil },
X  
X--- 111,149 ----
X  /*
X  	e_attr = { {	13, 13, 14,  6, 14,  6 },
X   */
X! 	e_attr = { {	13, 13, 13,  9, 13,  7 },  /* Elf (ranger) */
X  		   {	30, 10, 10, 20, 20, 10 },
X  		    10,  1, 15, 10, 11,  2, e_abil },
X  
X! 	h_attr = { {	 7,  7, 13,  7, 11, 16 },  /* Healer (druid) */
X  		   {	15, 20, 20, 15, 25, 10 },
X  		    10,  1, 13, 10, 20,  2, h_abil },
X  
X! 	k_attr = { {	13,  7, 14,  8, 10, 17 },  /* Knight (paladin) */
X  		   {	20, 15, 15, 10, 20, 10 },
X  		    10,  1, 16, 10, 10,  3, k_abil },
X  
X! 	p_attr = { {	 7,  7, 10,  7,  7,  7 },  /* Priest (cleric) */
X  		   {	15, 10, 30, 15, 20, 10 },
X  		     0,  0, 14, 10, 10,  2, p_abil },
X  
X! 	r_attr = { {	 7,  7,  7, 10,  7,  6 },  /* Rogue (thief) */
X  		   {	20, 10, 10, 30, 20, 10 },
X  		    10, -1, 12, 10, 11,  2, r_abil },
X  
X! 	s_attr = { {	10,  8,  7, 10, 17,  6 },  /* Samurai (fighter/thief) */
X  		   {	30, 10, 10, 30, 14, 10 },
X  		    10,  1, 15, 10, 11,  2, s_abil },
X  
X! 	t_attr = { {	 7, 10,  6,  7,  7, 10 },  /* Tourist */
X  		   {	15, 10, 10, 15, 30, 20 },
X  		     0,  0, 10, 10, 14,  1, t_abil },
X  
X! 	v_attr = { {	10,  7,  7,  7, 10,  7 },  /* Valkyrie (fighter) */
X  		   {	30,  6,  7, 20, 30,  7 },
X  		     0, -1, 16, 10, 10,  3, v_abil },
X  
X! 	w_attr = { {	 7, 10,  7,  7,  7,  7 },  /* Wizard (magic-user) */
X  		   {	10, 30, 10, 20, 20, 10 },
X  		     0,  0, 12, 10, 12,  1, w_abil },
X  
X***************
X*** 277,286 ****
X  	}
X  }
X  
X! static struct	clattr *
X  clx()  {
X  
X! 	register struct	clattr	*attr;
X  
X  	switch	(pl_character[0]) {
X  
X--- 277,286 ----
X  	}
X  }
X  
X! static const struct	clattr *
X  clx()  {
X  
X! 	register const struct	clattr	*attr;
X  
X  	switch	(pl_character[0]) {
X  
X***************
X*** 318,324 ****
X  static void
X  init_align() {	/* called from newhp if u.ulevel is 0 */
X  
X! 	register struct	clattr	*attr = clx();
X  
X  	u.ualign = (int)attr->align;
X  	u.ualigntyp = attr->aligntyp;
X--- 318,324 ----
X  static void
X  init_align() {	/* called from newhp if u.ulevel is 0 */
X  
X! 	register const struct	clattr	*attr = clx();
X  
X  	u.ualign = (int)attr->align;
X  	u.ualigntyp = attr->aligntyp;
X***************
X*** 329,335 ****
X  	register int	np;
X  {
X  	register int	i, x, tryct;
X! 	register struct	clattr	*attr = clx();
X  
X  	for(i = 0; i < A_MAX; i++) {
X  
X--- 329,335 ----
X  	register int	np;
X  {
X  	register int	i, x, tryct;
X! 	register const struct	clattr	*attr = clx();
X  
X  	for(i = 0; i < A_MAX; i++) {
X  
X***************
X*** 398,405 ****
X  
X  	int	flag;		/* +ve/-ve  = gain/lose */
X  {
X! 	register struct	clattr	*attr = clx();
X! 	register struct innate	*abil = attr->abil;
X  
X  	if(abil) {
X  
X--- 398,405 ----
X  
X  	int	flag;		/* +ve/-ve  = gain/lose */
X  {
X! 	register const struct clattr	*attr = clx();
X! 	register const struct innate	*abil = attr->abil;
X  
X  	if(abil) {
X  
X***************
X*** 428,434 ****
X  
X  int
X  newhp() {
X! 	register struct	clattr	*attr = clx();
X  	int	hp, conplus;
X  
X  	if(u.ulevel == 0) {
X--- 428,434 ----
X  
X  int
X  newhp() {
X! 	register const struct clattr	*attr = clx();
X  	int	hp, conplus;
X  
X  	if(u.ulevel == 0) {
X*** src/Old/bones.c	Sun Nov 19 12:33:21 1989
X--- src/bones.c	Tue Oct 31 11:04:23 1989
X***************
X*** 71,76 ****
X--- 71,112 ----
X  }
X  #endif
X  
X+ void
X+ resetobjs(ochain)
X+ struct obj *ochain;
X+ {
X+ 	struct obj *otmp;
X+ 
X+ 	for (otmp = ochain; otmp; otmp = otmp->nobj) {
X+ 		otmp->o_id = 0;
X+ 		if (((otmp->otyp != CORPSE && otmp->otyp != STATUE)
X+        			|| otmp->corpsenm < PM_ARCHEOLOGIST)
X+ #ifdef NAMED_ITEMS
X+ 			&& !is_artifact(otmp)
X+ #endif
X+ 		)
X+ 		otmp->onamelth = 0;
X+ 		if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X+ #ifdef TUTTI_FRUTTI
X+ 		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X+ #endif
X+ 		otmp->dknown = otmp->bknown = 0;
X+ 		otmp->invlet = 0;
X+ #ifdef MAIL
X+ 		if (otmp->otyp == SCR_MAIL)
X+ 			otmp->spe = 1;
X+ #endif
X+ #ifdef POLYSELF
X+ 		if (otmp->otyp == EGG)
X+ 			otmp->spe = 0;
X+ #endif
X+ 		if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X+ 			otmp->spe = -1;      /* no longer the actual amulet */
X+ 			curse(otmp);
X+ 		}
X+ 	}			
X+ }
X+ 
X  /* save bones and possessions of a deceased adventurer */
X  void
X  savebones(){
X***************
X*** 166,174 ****
X  		Strcpy(NAME(mtmp), plname);
X  		mtmp->mnamelth = strlen(plname);
X  		atl(u.ux, u.uy, mtmp->data->mlet);
X! 		Your("body rises from the dead as a%s %s...",
X! 			index(vowels, *(mons[u.ugrave_arise].mname)) ? "n" : "",
X! 			mons[u.ugrave_arise].mname);
X  	}
X  	mtmp->m_lev = (u.ulevel ? u.ulevel : 1);
X  	mtmp->mhp = mtmp->mhpmax = u.uhpmax;
X--- 202,209 ----
X  		Strcpy(NAME(mtmp), plname);
X  		mtmp->mnamelth = strlen(plname);
X  		atl(u.ux, u.uy, mtmp->data->mlet);
X! 		Your("body rises from the dead as %s...",
X! 			an(mons[u.ugrave_arise].mname));
X  	}
X  	mtmp->m_lev = (u.ulevel ? u.ulevel : 1);
X  	mtmp->mhp = mtmp->mhpmax = u.uhpmax;
X***************
X*** 175,191 ****
X  	mtmp->msleep = 1;
X  	if(u.ugold) mkgold(u.ugold, u.ux, u.uy);
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X! 		for(otmp = mtmp->minvent; otmp; otmp = otmp->nobj) {
X! 		    otmp->dknown = otmp->bknown = 0;
X! #ifdef TUTTI_FRUTTI
X! 		    if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X! #endif
X! 		    if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X! 		    if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X! 			otmp->spe = -1;  /* no longer the actual amulet */
X! 			curse(otmp);
X! 		    }
X! 		}
X  		mtmp->m_id = 0;
X  		mtmp->mlstmv = 0L;
X  		if(mtmp->mtame) mtmp->mtame = mtmp->mpeaceful = 0;
X--- 210,216 ----
X  	mtmp->msleep = 1;
X  	if(u.ugold) mkgold(u.ugold, u.ux, u.uy);
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon){
X! 		resetobjs(mtmp->minvent);
X  		mtmp->m_id = 0;
X  		mtmp->mlstmv = 0L;
X  		if(mtmp->mtame) mtmp->mtame = mtmp->mpeaceful = 0;
X***************
X*** 194,228 ****
X  	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X  		ttmp->tseen = 0;
X  
X! 	for(otmp = fobj; otmp; otmp = otmp->nobj)  {
X! 
X! 		otmp->o_id = 0;
X! 		if (((otmp->otyp != CORPSE && otmp->otyp != STATUE)
X! 				|| otmp->corpsenm < PM_ARCHEOLOGIST)
X! #ifdef NAMED_ITEMS
X! 				&& !is_artifact(otmp)
X! #endif
X! 		   )
X! 			otmp->onamelth = 0;
X! 		if(objects[otmp->otyp].oc_uses_known) otmp->known = 0;
X! #ifdef TUTTI_FRUTTI
X! 		if(otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
X! #endif
X! 		otmp->dknown = otmp->bknown = 0;
X! 		otmp->invlet = 0;
X! #ifdef MAIL
X! 		if (otmp->otyp == SCR_MAIL)
X! 			otmp->spe = 1;
X! #endif
X! #ifdef POLYSELF
X! 		if (otmp->otyp == EGG)
X! 			otmp->spe = 0;
X! #endif
X! 		if(otmp->otyp == AMULET_OF_YENDOR && !otmp->spe) {
X! 			otmp->spe = -1;      /* no longer the actual amulet */
X! 			curse(otmp);
X! 		}
X! 	}
X  
X  	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++)
X  		levl[x][y].seen = levl[x][y].new = levl[x][y].scrsym = 0;
X--- 219,226 ----
X  	for(ttmp = ftrap; ttmp; ttmp = ttmp->ntrap)
X  		ttmp->tseen = 0;
X  
X! 	resetobjs(fobj);
X! 	resetobjs(fcobj);   /* let's (not) forget about these - KCD, 10/21/89 */
X  
X  	for(x=0; x<COLNO; x++) for(y=0; y<ROWNO; y++)
X  		levl[x][y].seen = levl[x][y].new = levl[x][y].scrsym = 0;
X***************
X*** 242,248 ****
X  		(void)GetVol(&fileName,&oldvolume);
X  		(void)SetVol(0L, t->system.sysVRefNum);
X  		fileName[0] = (uchar)strlen(bones);
X! 		(void)strcpy((char *)&fileName[1],bones);
X  		
X  		if (er = Create(&fileName,0,CREATOR,BONES_TYPE))
X  			SysBeep(1);
X--- 240,246 ----
X  		(void)GetVol(&fileName,&oldvolume);
X  		(void)SetVol(0L, t->system.sysVRefNum);
X  		fileName[0] = (uchar)strlen(bones);
X! 		Strcpy((char *)&fileName[1],bones);
X  		
X  		if (er = Create(&fileName,0,CREATOR,BONES_TYPE))
X  			SysBeep(1);
X*** src/Old/cmd.c	Sun Nov 19 12:33:50 1989
X--- src/cmd.c	Fri Nov 17 19:31:26 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)cmd.c	3.0	88/10/24
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)cmd.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 61,67 ****
X  extern int dosave(); /**/
X  extern int dosave0(); /**/
X  extern int dosearch(); /**/
X! extern int dosearch0 P((int)); /**/
X  extern int doidtrap(); /**/
X  extern int dopay(); /**/
X  extern int dosit(); /**/
X--- 61,67 ----
X  extern int dosave(); /**/
X  extern int dosave0(); /**/
X  extern int dosearch(); /**/
X! extern int FDECL(dosearch0, (int)); /**/
X  extern int doidtrap(); /**/
X  extern int dopay(); /**/
X  extern int dosit(); /**/
X***************
X*** 76,88 ****
X  extern int dozap(); /**/
X  #endif /* DUMB */
X  
X! static int (*timed_occ_fn)();
X  #ifdef POLYSELF
X! static int domonability();
X  #endif
X  
X  /* Count down by decrementing multi */
X! static int
X  timed_occupation() {
X  	(*timed_occ_fn)();
X  	if (multi > 0)
X--- 76,97 ----
X  extern int dozap(); /**/
X  #endif /* DUMB */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int (*timed_occ_fn)();
X  #ifdef POLYSELF
X! #ifndef OVERLAY
X! static 
X! #endif
X! int domonability();
X  #endif
X  
X  /* Count down by decrementing multi */
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  timed_occupation() {
X  	(*timed_occ_fn)();
X  	if (multi > 0)
X***************
X*** 173,179 ****
X  	return;
X  }
X  
X! /* A ch == 0 resets the saveq.  Only save keystrokes when not
X   * replaying a previous command.
X   */
X  void
X--- 182,188 ----
X  	return;
X  }
X  
X! /* A ch == 0 resets the saveq.	Only save keystrokes when not
X   * replaying a previous command.
X   */
X  void
X***************
X*** 190,200 ****
X  }
X  #endif /* REDO */
X  
X! static int
X  doextcmd()	/* here after # - now read a full-word command */
X  {
X  	char buf[BUFSZ];
X! 	register struct ext_func_tab *efp = extcmdlist;
X  again:
X  	pline("# ");
X  #ifdef COM_COMPL
X--- 199,212 ----
X  }
X  #endif /* REDO */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  doextcmd()	/* here after # - now read a full-word command */
X  {
X  	char buf[BUFSZ];
X! 	register const struct ext_func_tab *efp = extcmdlist;
X  again:
X  	pline("# ");
X  #ifdef COM_COMPL
X***************
X*** 221,228 ****
X  int
X  doextlist()	/* here after #? - now list all full-word commands */
X  {
X! 	register struct ext_func_tab *efp = extcmdlist;
X! 	char     buf[BUFSZ];
X  
X  	set_pager(0);
X  	if(page_line("") ||
X--- 233,240 ----
X  int
X  doextlist()	/* here after #? - now list all full-word commands */
X  {
X! 	register const struct ext_func_tab *efp = extcmdlist;
X! 	char	 buf[BUFSZ];
X  
X  	set_pager(0);
X  	if(page_line("") ||
X***************
X*** 229,235 ****
X  	   page_line("            Extended Commands List") ||
X  	   page_line("") ||
X  	   page_line("    Press '#', then type (first letter only):") ||
X! 	   page_line(""))					 goto quit;
X  
X  	while(efp->ef_txt) {
X  
X--- 241,247 ----
X  	   page_line("            Extended Commands List") ||
X  	   page_line("") ||
X  	   page_line("    Press '#', then type (first letter only):") ||
X! 	   page_line(""))                                        goto quit;
X  
X  	while(efp->ef_txt) {
X  
X***************
X*** 245,251 ****
X  }
X  
X  #ifdef POLYSELF
X! static int
X  domonability()
X  {
X  	if (can_breathe(uasmon)) return dobreathe();
X--- 257,266 ----
X  }
X  
X  #ifdef POLYSELF
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  domonability()
X  {
X  	if (can_breathe(uasmon)) return dobreathe();
X***************
X*** 255,260 ****
X--- 270,276 ----
X  	else if (is_were(uasmon)) return dosummon();
X  	else if (webmaker(uasmon)) return dospinweb();
X  	else if (is_hider(uasmon)) return dohide();
X+ 	else if (u.usym == S_UNICORN) return use_unicorn_horn((struct obj *)0);
X  	else if (u.umonnum >= 0)
X  		pline("Any special ability you may have is purely reflexive.");
X  	else You("don't have a special ability!");
X***************
X*** 263,269 ****
X  #endif
X  
X  #ifdef WIZARD
X! static int
X  wiz_wish()	/* Unlimited wishes for wizard mode by Paul Polderman */
X  {
X  	if (wizard)	makewish();
X--- 279,288 ----
X  #endif
X  
X  #ifdef WIZARD
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_wish()	/* Unlimited wishes for wizard mode by Paul Polderman */
X  {
X  	if (wizard)	makewish();
X***************
X*** 271,277 ****
X  	return 0;
X  }
X  
X! static int
X  wiz_identify()
X  {
X  	struct obj *obj;
X--- 290,299 ----
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_identify()
X  {
X  	struct obj *obj;
X***************
X*** 287,293 ****
X  	return 0;
X  }
X  
X! static int
X  wiz_map()
X  {
X  	if (wizard)	do_mapping();
X--- 309,318 ----
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_map()
X  {
X  	if (wizard)	do_mapping();
X***************
X*** 295,301 ****
X  	return 0;
X  }
X  
X! static int
X  wiz_genesis()
X  {
X  	if (wizard)	(void) create_particular();
X--- 320,329 ----
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_genesis()
X  {
X  	if (wizard)	(void) create_particular();
X***************
X*** 303,309 ****
X  	return 0;
X  }
X  
X! static int
X  wiz_where()
X  {
X  	if (wizard) {
X--- 331,340 ----
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_where()
X  {
X  	if (wizard) {
X***************
X*** 310,316 ****
X  		pline("Medusa:%d  Wiz:%d  Big:%d", medusa_level, wiz_level, bigroom_level);
X  #ifdef STRONGHOLD
X  #  ifdef MUSIC
X! 		pline("Castle:%d (tune %s)  Tower:%d-%d", 
X  		      stronghold_level, tune, tower_level, tower_level+2);
X  #  else
X  		pline("Castle:%d  Tower:%d-%d",
X--- 341,347 ----
X  		pline("Medusa:%d  Wiz:%d  Big:%d", medusa_level, wiz_level, bigroom_level);
X  #ifdef STRONGHOLD
X  #  ifdef MUSIC
X! 		pline("Castle:%d (tune %s)  Tower:%d-%d",
X  		      stronghold_level, tune, tower_level, tower_level+2);
X  #  else
X  		pline("Castle:%d  Tower:%d-%d",
X***************
X*** 328,334 ****
X  	return 0;
X  }
X  
X! static int
X  wiz_detect()
X  {
X  	if(wizard)  (void) findit();
X--- 359,368 ----
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_detect()
X  {
X  	if(wizard)  (void) findit();
X***************
X*** 336,342 ****
X  	return 0;
X  }
X  
X! static int
X  wiz_level_tele()
X  {
X  	if (wizard)	level_tele();
X--- 370,379 ----
X  	return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_level_tele()
X  {
X  	if (wizard)	level_tele();
X***************
X*** 435,441 ****
X  }
X  
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! static int
X  wiz_attributes()
X  {
X  	if (wizard || discover)
X--- 472,481 ----
X  }
X  
X  #if defined(WIZARD) || defined(EXPLORE_MODE)
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  wiz_attributes()
X  {
X  	if (wizard || discover)
X***************
X*** 446,453 ****
X--- 486,497 ----
X  }
X  #endif /* WIZARD || EXPLORE_MODE */
X  
X+ #ifndef M
X  #define M(c)		(0x80 | (c))
X+ #endif
X+ #ifndef C
X  #define C(c)		(0x1f & (c))
X+ #endif
X  const struct func_tab cmdlist[]={
X  	{C('d'), dokick},	/* "D" is for door!...? */
X  #ifdef WIZARD
X***************
X*** 616,622 ****
X  rhack(cmd)
X  register char *cmd;
X  {
X! 	register struct func_tab *tlist = cmdlist;
X  	boolean firsttime = FALSE;
X  	register int res;
X  
X--- 660,666 ----
X  rhack(cmd)
X  register char *cmd;
X  {
X! 	register const struct func_tab *tlist = cmdlist;
X  	boolean firsttime = FALSE;
X  	register int res;
X  
X***************
X*** 766,772 ****
X  movecmd(sym)	/* also sets u.dz, but returns false for <> */
X  char sym;
X  {
X! 	register char *dp, *sdp = flags.num_pad ? ndir : sdir;
X  
X  	u.dz = 0;
X  	if(!(dp = index(sdp, sym))) return 0;
X--- 810,817 ----
X  movecmd(sym)	/* also sets u.dz, but returns false for <> */
X  char sym;
X  {
X! 	register char *dp;
X! 	register const char *sdp = flags.num_pad ? ndir : sdir;
X  
X  	u.dz = 0;
X  	if(!(dp = index(sdp, sym))) return 0;
X***************
X*** 773,778 ****
X--- 818,829 ----
X  	u.dx = xdir[dp-sdp];
X  	u.dy = ydir[dp-sdp];
X  	u.dz = zdir[dp-sdp];
X+ #ifdef POLYSELF
X+ 	if (u.dx && u.dy && u.umonnum == PM_GRID_BUG) {
X+ 		u.dx = u.dy = 0;
X+ 		return 0;
X+ 	}
X+ #endif
X  	return !u.dz;
X  }
X  
X***************
X*** 804,810 ****
X  void
X  confdir()
X  {
X! 	register int x = rn2(8);
X  	u.dx = xdir[x];
X  	u.dy = ydir[x];
X  	return;
X--- 855,865 ----
X  void
X  confdir()
X  {
X! 	register int x = 
X! #ifdef POLYSELF
X! 		(u.umonnum == PM_GRID_BUG) ? 2*rn2(4) :
X! #endif
X! 							rn2(8);
X  	u.dx = xdir[x];
X  	u.dy = ydir[x];
X  	return;
X*** src/Old/decl.c	Sun Nov 19 12:35:05 1989
X--- src/decl.c	Sat Nov  4 13:40:18 1989
X***************
X*** 81,86 ****
X--- 81,91 ----
X  #endif
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X+ #ifdef CLIPPING
X+ boolean clipping;	/* clipping on? */
X+ int clipx, clipy, clipxmax, clipymax;
X+ #endif
X+ 
X  #ifdef TEXTCOLOR
X  char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X  #endif
X***************
X*** 155,161 ****
X  	*uarmc = 0, *uarmh = 0, *uarms = 0, *uarmg = 0, *uarmf = 0, *uamul = 0,
X  	*uright = 0, *uleft = 0, *ublindf = 0, *uchain = 0, *uball = 0;
X  
X! const struct symbols defsyms = {
X      ' ', /* stone */
X      '|', /* vwall */
X      '-', /* hwall */
X--- 160,166 ----
X  	*uarmc = 0, *uarmh = 0, *uarms = 0, *uarmg = 0, *uarmf = 0, *uamul = 0,
X  	*uright = 0, *uleft = 0, *ublindf = 0, *uchain = 0, *uball = 0;
X  
X! symbol_array defsyms = {
X      ' ', /* stone */
X      '|', /* vwall */
X      '-', /* hwall */
X***************
X*** 172,178 ****
X      '-', /* hbeam */
X      '\\', /* lslant */
X      '/', /* rslant */
X!     '+', /* door */
X      '.', /* room */
X      '#', /* corr */
X      '<', /* upstair */
X--- 177,186 ----
X      '-', /* hbeam */
X      '\\', /* lslant */
X      '/', /* rslant */
X!     '.', /* ndoor */
X!     '-', /* vodoor */
X!     '|', /* hodoor */
X!     '+', /* cdoor */
X      '.', /* room */
X      '#', /* corr */
X      '<', /* upstair */
X***************
X*** 189,198 ****
X      '#', /* dbvwall */	/* used ifdef STRONGHOLD */
X      '#', /* dbhwall */	/* used ifdef STRONGHOLD */
X  };
X! struct symbols showsyms = DUMMY; /* will contain the symbols actually used */
X  #ifdef REINCARNATION
X! struct symbols savesyms = DUMMY;
X  #endif
X  
X  #ifdef SPELLS
X  struct spell spl_book[MAXSPELL + 1] = DUMMY;
X--- 197,243 ----
X      '#', /* dbvwall */	/* used ifdef STRONGHOLD */
X      '#', /* dbhwall */	/* used ifdef STRONGHOLD */
X  };
X! symbol_array showsyms = DUMMY; /* will contain the symbols actually used */
X  #ifdef REINCARNATION
X! symbol_array savesyms = DUMMY;
X! #endif
X! 
X! char *explainsyms[MAXPCHARS] = {
X! 	"a dark part of a room", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a wall", "a wall",
X! 	"a wall", "a doorway", "an open door",
X! 	"an open door", "a closed door", "the floor of a room",
X! 	"a corridor", "a staircase up", "a staircase down",
X! 	"a trap", "a web", "a water filled area",
X! #ifdef FOUNTAINS
X! 	"a fountain",
X! #else
X! 	"",
X! #endif
X! #ifdef SINKS
X! 	"a sink",
X! #else
X! 	"",
X! #endif
X! #ifdef THRONES
X! 	"an opulent throne",
X! #else
X! 	"",
X! #endif
X! #ifdef ALTARS
X! 	"an altar",
X! #else
X! 	"",
X! #endif
X! #ifdef STRONGHOLD
X! 	"a ladder up", "a ladder down", "a drawbridge", "a drawbridge"
X! #else
X! 	"", "", "", ""
X  #endif
X+ };
X  
X  #ifdef SPELLS
X  struct spell spl_book[MAXSPELL + 1] = DUMMY;
X*** src/Old/demon.c	Sun Nov 19 12:35:29 1989
X--- src/demon.c	Tue Oct 31 19:26:49 1989
X***************
X*** 8,16 ****
X  dsummon(ptr)		/* summon demon */
X  	register struct permonst *ptr;
X  {
X  	register int dtype, cnt = 0;
X  
X- #ifdef HARD
X  	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X  
X  	    dtype = (!rn2(20)) ? dprince() : (!rn2(4)) ? dlord() : ndemon();
X--- 8,16 ----
X  dsummon(ptr)		/* summon demon */
X  	register struct permonst *ptr;
X  {
X+ #ifdef INFERNO
X  	register int dtype, cnt = 0;
X  
X  	if(is_dprince(ptr) || (ptr == &mons[PM_WIZARD_OF_YENDOR])) {
X  
X  	    dtype = (!rn2(20)) ? dprince() : (!rn2(4)) ? dlord() : ndemon();
X***************
X*** 23,37 ****
X  
X  	} else if(is_ndemon(ptr)) {
X  
X! 	    dtype = (!rn2(20)) ? dlord() : ndemon();
X  	    cnt = 1;
X  	}
X  
X  	if(!dtype) return;
X- #else
X- 	dtype = PM_DEMON;
X- 	cnt = 1;
X- #endif
X  
X  	while(cnt > 0) {
X  
X--- 23,33 ----
X  
X  	} else if(is_ndemon(ptr)) {
X  
X! 	    dtype = (!rn2(20)) ? dlord() : (!rn2(6)) ? ndemon() : monsndx(ptr);
X  	    cnt = 1;
X  	}
X  
X  	if(!dtype) return;
X  
X  	while(cnt > 0) {
X  
X***************
X*** 38,47 ****
X  	    (void)makemon(&mons[dtype], u.ux, u.uy);
X  	    cnt--;
X  	}
X  	return;
X  }
X  
X! #ifdef HARD
X  #define	Athome	(Inhell && !mtmp->cham)
X  
X  int
X--- 34,46 ----
X  	    (void)makemon(&mons[dtype], u.ux, u.uy);
X  	    cnt--;
X  	}
X+ #else
X+ 	(void)makemon(&mons[PM_DEMON], u.ux, u.uy);
X+ #endif
X  	return;
X  }
X  
X! #ifdef INFERNO
X  #define	Athome	(Inhell && !mtmp->cham)
X  
X  int
X***************
X*** 105,111 ****
X  }
X  #endif
X  
X! #if defined(HARD) || (defined(ALTARS) && defined(THEOLOGY))
X  long
X  bribe(mtmp)
X  struct monst *mtmp;
X--- 104,110 ----
X  }
X  #endif
X  
X! #if defined(INFERNO) || (defined(ALTARS) && defined(THEOLOGY))
X  long
X  bribe(mtmp)
X  struct monst *mtmp;
X***************
X*** 137,143 ****
X  
X  int
X  dprince() {
X! #ifdef HARD
X  	int	tryct, pm;
X  
X  	for(tryct = 0; tryct < 20; tryct++) {
X--- 136,142 ----
X  
X  int
X  dprince() {
X! #ifdef INFERNO
X  	int	tryct, pm;
X  
X  	for(tryct = 0; tryct < 20; tryct++) {
X***************
X*** 153,159 ****
X  
X  int
X  dlord() {
X! #ifdef HARD
X  	int	tryct, pm;
X  
X  	for(tryct = 0; tryct < 20; tryct++) {
X--- 152,158 ----
X  
X  int
X  dlord() {
X! #ifdef INFERNO
X  	int	tryct, pm;
X  
X  	for(tryct = 0; tryct < 20; tryct++) {
X***************
X*** 169,175 ****
X  
X  int
X  ndemon() {
X! #ifdef HARD
X  	int	tryct;
X  	struct	permonst *ptr;
X  
X--- 168,174 ----
X  
X  int
X  ndemon() {
X! #ifdef INFERNO
X  	int	tryct;
X  	struct	permonst *ptr;
X  
X*** src/Old/do.c	Sun Nov 19 12:35:45 1989
X--- src/do.c	Fri Nov 17 19:31:29 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do.c	3.0	89/06/12
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 12,18 ****
X  extern boolean level_exists[];
X  #endif
X  
X! static int drop P((struct obj *));
X  
X  static const char drop_types[] = { '0', GOLD_SYM, '#', 0 };
X  
X--- 12,20 ----
X  extern boolean level_exists[];
X  #endif
X  
X! #ifndef OVERLAY
X! static int FDECL(drop, (struct obj *));
X! #endif
X  
X  static const char drop_types[] = { '0', GOLD_SYM, '#', 0 };
X  
X***************
X*** 31,37 ****
X  int x,y;
X  {
X  	struct trap *t = t_at(x,y);
X! 	boolean pool = IS_POOL(levl[x][y].typ);
X  
X  	if(obj->otyp == BOULDER && (pool ||
X  	  (t && (t->ttyp==PIT || t->ttyp==SPIKED_PIT || t->ttyp==TRAPDOOR)))) {
X--- 33,39 ----
X  int x,y;
X  {
X  	struct trap *t = t_at(x,y);
X! 	boolean pool = is_pool(x,y);
X  
X  	if(obj->otyp == BOULDER && (pool ||
X  	  (t && (t->ttyp==PIT || t->ttyp==SPIKED_PIT || t->ttyp==TRAPDOOR)))) {
X***************
X*** 86,97 ****
X  {
X  	if (Blind) return;
X  	if (obj->blessed || obj->cursed) {
X! 		register const char *fcolor = Hallucination ? hcolor() :
X! 					obj->blessed ? amber : black;
X! 
X! 		pline("There is %s %s flash as %s hit%s the altar.",
X! 		      index(vowels, *fcolor) ? "an" : "a",
X! 		      fcolor,
X  		      doname(obj),
X  		      (obj->quan==1) ? "s" : "");
X  		if (!Hallucination) obj->bknown = 1;
X--- 88,96 ----
X  {
X  	if (Blind) return;
X  	if (obj->blessed || obj->cursed) {
X! 		pline("There is %s flash as %s hit%s the altar.",
X! 		      an(Hallucination ? hcolor() :
X! 			 obj->blessed ? amber : black),
X  		      doname(obj),
X  		      (obj->quan==1) ? "s" : "");
X  		if (!Hallucination) obj->bknown = 1;
X***************
X*** 125,131 ****
X  	You("drop %s down the drain.", doname(obj));
X  	switch(obj->otyp) {	/* effects that can be noticed without eyes */
X  	    case RIN_SEARCHING:
X! 	You("thought your %s got lost in the sink, but there it is!",
X  			xname(obj));
X  		dropx(obj);
X  		trycall(obj);
X--- 124,130 ----
X  	You("drop %s down the drain.", doname(obj));
X  	switch(obj->otyp) {	/* effects that can be noticed without eyes */
X  	    case RIN_SEARCHING:
X! 		You("thought your %s got lost in the sink, but there it is!",
X  			xname(obj));
X  		dropx(obj);
X  		trycall(obj);
X***************
X*** 181,192 ****
X  		    break;
X  		case RIN_HUNGER:
X  		    ideed = FALSE;
X! 		    for(otmp=fobj; otmp; otmp=otmp2) {
X! 			otmp2 = otmp->nobj;
X! 			if(otmp->ox == u.ux && otmp->oy == u.uy)
X! 			    if(otmp != uball && otmp != uchain) {
X! 				pline("Suddenly, %s vanishes from the sink!",
X! 							    doname(otmp));
X  			    delobj(otmp);
X  			    ideed = TRUE;
X  			}
X--- 180,190 ----
X  		    break;
X  		case RIN_HUNGER:
X  		    ideed = FALSE;
X! 		    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp2) {
X! 			otmp2 = otmp->nexthere;
X! 			if(otmp != uball && otmp != uchain) {
X! 			    pline("Suddenly, %s vanishes from the sink!",
X! 							doname(otmp));
X  			    delobj(otmp);
X  			    ideed = TRUE;
X  			}
X***************
X*** 269,275 ****
X  	return(TRUE);
X  }
X  
X! static int
X  drop(obj) register struct obj *obj; {
X  	if(!obj) return(0);
X  	if(obj->olet == GOLD_SYM) {		/* pseudo object */
X--- 267,276 ----
X  	return(TRUE);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  drop(obj) register struct obj *obj; {
X  	if(!obj) return(0);
X  	if(obj->olet == GOLD_SYM) {		/* pseudo object */
X***************
X*** 501,508 ****
X  			if (otmp == uwep)
X  				setuwep((struct obj *)0);
X  			if ((otmp != uwep) && (canletgo(otmp, ""))) {
X! 				Your("%s left behind on the stairs.",
X! 				     aobjnam(otmp, "get"));
X  				dropx(otmp);
X  			}
X  		}
X--- 502,509 ----
X  			if (otmp == uwep)
X  				setuwep((struct obj *)0);
X  			if ((otmp != uwep) && (canletgo(otmp, ""))) {
X! 				Your("%s you down the stairs.",
X! 				     aobjnam(otmp, "follow"));
X  				dropx(otmp);
X  			}
X  		}
X***************
X*** 561,569 ****
X  {
X  	register int fd;
X  	register boolean up = (newlevel < dlevel);
X- 	boolean stair_fall = (at_stairs && !up && ((inv_weight() + 5 > 0) || 
X- 						  Punished || Fumbling));
X- 	boolean stair_drag = FALSE;
X  
X  #ifdef ENDGAME
X  	if(dlevel == ENDLEVEL) return;	/* To be on the safe side.. */
X--- 562,567 ----
X***************
X*** 689,702 ****
X  	}
X  #endif
X  	if(Punished) unplacebc();
X- 	if (stair_fall) {
X- #ifdef STRONGHOLD
X- 			You("fall down the %s.",
X- 			    !at_ladder ? "stairs" : "ladder");
X- #else
X- 		You("fall down the stairs.");
X- #endif
X- 	}
X  	u.utrap = 0;				/* needed in level_tele */
X  	u.ustuck = 0;				/* idem */
X  	keepdogs();
X--- 687,692 ----
X***************
X*** 723,733 ****
X  	if (newlevel == rogue_level || dlevel == rogue_level) {
X  		/* No graphics characters on Rogue levels */
X  		if (dlevel != rogue_level) {
X! 			savesyms = showsyms;
X! 			showsyms = defsyms;
X  		}
X  		if (newlevel != rogue_level)
X! 			showsyms = savesyms;
X  	}
X  #endif
X  	dlevel = newlevel;
X--- 713,728 ----
X  	if (newlevel == rogue_level || dlevel == rogue_level) {
X  		/* No graphics characters on Rogue levels */
X  		if (dlevel != rogue_level) {
X! 			(void) memcpy((genericptr_t)savesyms,
X! 				      (genericptr_t)showsyms, sizeof savesyms);
X! 			(void) memcpy((genericptr_t)showsyms,
X! 				      (genericptr_t)defsyms, sizeof showsyms);
X! 			showsyms[S_vodoor] = showsyms[S_hodoor] = 
X! 			    showsyms[S_ndoor] = '+';
X  		}
X  		if (newlevel != rogue_level)
X! 			(void) memcpy((genericptr_t)showsyms,
X! 				      (genericptr_t)savesyms, sizeof showsyms);
X  	}
X  #endif
X  	dlevel = newlevel;
X***************
X*** 806,814 ****
X  		    u.uy = yupladder;
X  		}
X  #endif
X! 		if(stair_fall) {
X  			if (Punished) {
X! 				if (stair_drag)
X  					litter();
X  				if (carried(uball)) {
X  					if (uwep == uball)
X--- 801,816 ----
X  		    u.uy = yupladder;
X  		}
X  #endif
X! 		if(at_stairs && !up && ((inv_weight() + 5 > 0) || 
X! 					Punished || Fumbling)) {
X! #ifdef STRONGHOLD
X! 			You("fall down the %s.",
X! 			    !at_ladder ? "stairs" : "ladder");
X! #else
X! 			You("fall down the stairs.");
X! #endif
X  			if (Punished) {
X! 				if (drag_down())
X  					litter();
X  				if (carried(uball)) {
X  					if (uwep == uball)
X***************
X*** 904,910 ****
X--- 906,914 ----
X  	return(1);	/* Do nothing, but let other things happen */
X  }
X  
X+ #ifndef OVERLAY
X  static
X+ #endif
X  int
X  wipeoff() {
X  	if(u.ucreamed < 4)	u.ucreamed = 0;
X*** src/Old/do_name.c	Sun Nov 19 12:36:26 1989
X--- src/do_name.c	Wed Nov  8 22:56:28 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)do_name.c	3.0	88/11/24
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)do_name.c	3.0	89/11/08
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 32,42 ****
X  int force; char *goal;
X  {
X  	register int cx, cy, i, c;
X! 	char *sdp = flags.num_pad ? ndir : sdir;
X  	if(flags.verbose) pline("(For instructions type a ?)");
X  	cx = cc->x;
X  	cy = cc->y;
X  	curs(cx,cy+2);
X  	while((c = readchar()) != '.'){
X  		for(i=0; i<8; i++) if(sdp[i] == c){
X  			if(1 <= cx + xdir[i] && cx + xdir[i] <= COLNO)
X--- 32,47 ----
X  int force; char *goal;
X  {
X  	register int cx, cy, i, c;
X! 	const char *sdp = flags.num_pad ? ndir : sdir;
X  	if(flags.verbose) pline("(For instructions type a ?)");
X  	cx = cc->x;
X  	cy = cc->y;
X+ #ifdef CLIPPING
X+ 	cliparound(cx, cy);
X+ 	(void) win_curs(cx, cy);
X+ #else
X  	curs(cx,cy+2);
X+ #endif
X  	while((c = readchar()) != '.'){
X  		for(i=0; i<8; i++) if(sdp[i] == c){
X  			if(1 <= cx + xdir[i] && cx + xdir[i] <= COLNO)
X***************
X*** 63,69 ****
X--- 68,79 ----
X  			return;
X  		}
X  	nxtc:	;
X+ #ifdef CLIPPING
X+ 		cliparound(cx, cy);
X+ 		(void) win_curs(cx, cy);
X+ #else
X  		curs(cx,cy+2);
X+ #endif
X  	}
X  	cc->x = cx;
X  	cc->y = cy;
X***************
X*** 112,118 ****
X   	    if(!mtmp->mtame) {
X   		pline("%s gets %sangry!", Monnam(mtmp),
X   		      mtmp->mpeaceful ? "" : "very ");
X!  		mtmp->mpeaceful = mtmp->msleep = 0;
X   	    }
X   	    return(0);
X   	}
X--- 122,129 ----
X   	    if(!mtmp->mtame) {
X   		pline("%s gets %sangry!", Monnam(mtmp),
X   		      mtmp->mpeaceful ? "" : "very ");
X!  		mtmp->mpeaceful = 0;
X! 		mtmp->msleep = 0;
X   	    }
X   	    return(0);
X   	}
X***************
X*** 132,140 ****
X  }
X  
X  /*
X!  * This routine changes the address of  obj . Be careful not to call it
X   * when there might be pointers around in unknown places. For now: only
X!  * when  obj  is in the inventory.
X   */
X  static
X  void
X--- 143,151 ----
X  }
X  
X  /*
X!  * This routine changes the address of obj. Be careful not to call it
X   * when there might be pointers around in unknown places. For now: only
X!  * when obj is in the inventory.
X   */
X  static
X  void
X***************
X*** 168,174 ****
X  char	*buf;
X  register int ininv;
X  {
X! 	register struct obj *otmp, *otmp2;
X  	register int	lth;
X  
X  	lth = *buf ? strlen(buf)+1 : 0;
X--- 179,185 ----
X  char	*buf;
X  register int ininv;
X  {
X! 	register struct obj *otmp, *otmp2, *contents;
X  	register int	lth;
X  
X  	lth = *buf ? strlen(buf)+1 : 0;
X***************
X*** 210,215 ****
X--- 221,230 ----
X  			}
X  		}
X  	}
X+ 	if (Is_container(obj)) {
X+ 		for(contents=fcobj; contents; contents=contents->nobj)
X+ 			if(contents->cobj==obj) contents->cobj = otmp2;
X+ 	}
X  	/* obfree(obj, otmp2);	/* now unnecessary: no pointers on bill */
X  	free((genericptr_t) obj);	/* let us hope nobody else saved a pointer */
X  	return otmp2;
X***************
X*** 272,281 ****
X  	if (otemp.corpsenm) { /* kludge, meaning it's sink water */
X  		pline("Call a stream of %s fluid: ",
X  				objects[otemp.otyp].oc_descr);
X! 	} else {
X! 		str = xname(&otemp);
X! 		pline("Call %s %s: ", index(vowels,*str) ? "an" : "a", str);
X! 	}
X  	getlin(buf);
X  	clrlin();
X  	if(!*buf || *buf == '\033')
X--- 287,294 ----
X  	if (otemp.corpsenm) { /* kludge, meaning it's sink water */
X  		pline("Call a stream of %s fluid: ",
X  				objects[otemp.otyp].oc_descr);
X! 	} else
X! 		pline("Call %s: ", an(xname(&otemp)));
X  	getlin(buf);
X  	clrlin();
X  	if(!*buf || *buf == '\033')
X***************
X*** 345,356 ****
X  
X  	switch(mtmp->data->mlet) {
X  	    case S_GHOST:
X! 		{ register char *gn = (char *) mtmp->mextra;
X  		  if(!*gn) {		/* might also look in scorefile */
X  		    gn = ghostnames[rn2(SIZE(ghostnames))];
X  			Strcpy((char *) mtmp->mextra, !rn2(5) ? plname : gn);
X  		  }
X! 		  Sprintf(buf, "%s's ghost", gn);
X  		}
X  		break;
X  	    default:
X--- 358,369 ----
X  
X  	switch(mtmp->data->mlet) {
X  	    case S_GHOST:
X! 		{ register const char *gn = (const char *) mtmp->mextra;
X  		  if(!*gn) {		/* might also look in scorefile */
X  		    gn = ghostnames[rn2(SIZE(ghostnames))];
X  			Strcpy((char *) mtmp->mextra, !rn2(5) ? plname : gn);
X  		  }
X! 		  Sprintf(buf, "%s's ghost", (char *) mtmp->mextra);
X  		}
X  		break;
X  	    default:
X***************
X*** 472,479 ****
X  	int name;
X  
X  	do {
X! 		name = rn2(PM_CHAMELEON);
X! 		/* chameleon: last monster before player classes */
X  	} while(type_is_pname(&mons[name]) || (mons[name].geno & G_NOGEN));
X  	return(mons[name].mname);
X  }
X--- 485,492 ----
X  	int name;
X  
X  	do {
X! 		name = rn2(PM_ARCHEOLOGIST);
X! 		/* archeologist: first player class */
X  	} while(type_is_pname(&mons[name]) || (mons[name].geno & G_NOGEN));
X  	return(mons[name].mname);
X  }
X*** src/Old/do_wear.c	Sun Nov 19 12:36:52 1989
X--- src/do_wear.c	Sat Nov 11 17:29:31 1989
X***************
X*** 24,35 ****
X  /* for items that involve no delay */
X  static void
X  on_msg(otmp) register struct obj *otmp; {
X- 	register char *bp = xname(otmp);
X- 	char buf[BUFSZ];
X- 
X- 	setan(bp, buf);
X  	if(flags.verbose)
X! 	    You("are now wearing %s.", buf);
X  }
X  
X  boolean
X--- 24,31 ----
X  /* for items that involve no delay */
X  static void
X  on_msg(otmp) register struct obj *otmp; {
X  	if(flags.verbose)
X! 	    You("are now wearing %s.", an(xname(otmp)));
X  }
X  
X  boolean
X***************
X*** 72,78 ****
X   * The Type_off() functions call setworn() themselves.
X   */
X  
X! static int
X  Boots_on() {
X      long oldprop =
X  		u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~(WORN_BOOTS | TIMEOUT);
X--- 68,77 ----
X   * The Type_off() functions call setworn() themselves.
X   */
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  Boots_on() {
X      long oldprop =
X  		u.uprops[objects[uarmf->otyp].oc_oprop].p_flgs & ~(WORN_BOOTS | TIMEOUT);
X***************
X*** 220,226 ****
X      return 0;
X  }
X  
X! static int
X  Helmet_on() {
X      switch(uarmh->otyp) {
X  	case FEDORA:
X--- 219,228 ----
X      return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  Helmet_on() {
X      switch(uarmh->otyp) {
X  	case FEDORA:
X***************
X*** 288,294 ****
X      return 0;
X  }
X  
X! static int
X  Gloves_on() {
X      long oldprop =
X  	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X--- 290,299 ----
X      return 0;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  Gloves_on() {
X      long oldprop =
X  	u.uprops[objects[uarmg->otyp].oc_oprop].p_flgs & ~(WORN_GLOVES | TIMEOUT);
X***************
X*** 338,343 ****
X--- 343,356 ----
X  	default: impossible("Unknown type of gloves (%d)", uarmg->otyp);
X      }
X      setworn((struct obj *)0, W_ARMG);
X+     if (uwep && uwep->otyp == CORPSE && uwep->corpsenm == PM_COCKATRICE) {
X+ 	/* Prevent wielding cockatrice when not wearing gloves */
X+ 	You("wield the cockatrice corpse in your bare %s.",
X+ 	    makeplural(body_part(HAND)));
X+ 	You("turn to stone...");
X+ 	killer = "cockatrice corpse";
X+ 	done(STONING);
X+     }
X      return 0;
X  }
X  
X***************
X*** 385,391 ****
X  /* This must be done in worn.c, because one of the possible intrinsics conferred
X   * is fire resistance, and we have to immediately set HFire_resistance in worn.c
X   * since worn.c will check it before returning.
X! static int
X  Armor_on()
X  {
X      return 0;
X--- 398,407 ----
X  /* This must be done in worn.c, because one of the possible intrinsics conferred
X   * is fire resistance, and we have to immediately set HFire_resistance in worn.c
X   * since worn.c will check it before returning.
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  Armor_on()
X  {
X      return 0;
X***************
X*** 691,696 ****
X--- 707,722 ----
X  /*	if (uarms) (void) Shield_on(); */
X  }
X  
X+ boolean
X+ donning(otmp)
X+ register struct obj *otmp;
X+ {
X+     return (otmp == uarmf && afternmv == Boots_on)
X+ 	|| (otmp == uarmh && afternmv == Helmet_on)
X+ 	|| (otmp == uarmg && afternmv == Gloves_on)
X+ /*	|| (otmp == uarm && afternmv == Armor_on)*/;
X+ }
X+ 
X  static const char clothes[] = {ARMOR_SYM, 0};
X  static const char accessories[] = {RING_SYM, AMULET_SYM, TOOL_SYM, 0};
X  
X***************
X*** 1118,1123 ****
X--- 1144,1151 ----
X  	return(1);
X  }
X  
X+ #define ARM_BONUS(obj)	((10 - objects[obj->otyp].a_ac) + obj->spe)
X+ 
X  void
X  find_ac() {
X  	register int uac = 10;
X***************
X*** 1227,1233 ****
X  	}
X  }
X  
X! static int
X  select_off(otmp)
X  register struct obj *otmp;
X  {
X--- 1255,1264 ----
X  	}
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  select_off(otmp)
X  register struct obj *otmp;
X  {
X***************
X*** 1332,1338 ****
X  	return(otmp);
X  }
X  
X! static int
X  take_off() {
X  
X  	register int i;
X--- 1363,1372 ----
X  	return(otmp);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  take_off() {
X  
X  	register int i;
END_OF_FILE
if test 53756 -ne `wc -c <'patches06e'`; then
    echo shar: \"'patches06e'\" unpacked with wrong size!
fi
# end of 'patches06e'
fi
echo shar: End of archive 8 \(of 15\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
