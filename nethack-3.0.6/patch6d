Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i057:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6d
Message-ID: <4846@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:47:48 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2278
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 57
Archive-name: NetHack3/Patch6d
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 15)."
# Contents:  patches06j
# Wrapped by billr@saab on Wed Nov 22 10:50:08 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches06j' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06j'\"
else
echo shar: Extracting \"'patches06j'\" \(55338 characters\)
sed "s/^X//" >'patches06j' <<'END_OF_FILE'
X*** src/Old/pager.c	Sun Nov 19 13:04:16 1989
X--- src/pager.c	Fri Nov 17 19:32:03 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pager.c	3.0	88/10/25 */
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pager.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,14 ****
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X! #include	 "hack.h"
X  
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X--- 8,14 ----
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X! #include	"hack.h"
X  
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X***************
X*** 23,38 ****
X  
X  static char hc = 0;
X  
X! static void page_more();
X! static boolean clear_help P((CHAR_P));
X! static boolean valid_help P((CHAR_P));
X  
X  int
X  dowhatis()
X  {
X  	FILE *fp;
X  	char bufr[BUFSZ+6];
X! 	register char *buf = &bufr[6], *ep, q;
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X  
X--- 23,70 ----
X  
X  static char hc = 0;
X  
X! static void FDECL(page_more, (FILE *,int));
X! static boolean FDECL(clear_help, (CHAR_P));
X! static boolean FDECL(valid_help, (CHAR_P));
X  
X+ /*
X+  * print out another possibility for dowhatis. "new" is the possible new
X+  * string; "out_flag" indicates whether we really want output, and if
X+  * so what kind of output: 0 == no output, 1 == "(or %s)" output. 
X+  * Returns TRUE if this new string wasn't the last string printed.
X+  */
X+ 
X+ static boolean
X+ outspec(new, out_flag)
X+ char *new;
X+ int out_flag;
X+ {
X+ 	static char old[50];
X+ 
X+ 	if (!strcmp(old, new))
X+ 		return FALSE;		/* don't print the same thing twice */
X+ 
X+ 	if (out_flag)
X+ 		pline("(or %s)", new);
X+ 
X+ 	Strcpy(old, new);
X+ 	return 1;
X+ }
X+ 
X  int
X  dowhatis()
X  {
X  	FILE *fp;
X  	char bufr[BUFSZ+6];
X! 	register char *buf = &bufr[6], *ep;
X! 	uchar q, typ;
X! 	register int i;
X! 	coord	cc;
X! 	boolean oldverb = flags.verbose;
X! 	boolean found_in_file = FALSE;
X! 	int	found = 0;
X! 	register struct monst *mtmp;
X! 
X  #ifdef OS2_CODEVIEW
X  	char tmp[PATHLEN];
X  
X***************
X*** 43,247 ****
X  #else
X  	fp = fopen(DATAFILE, "r");
X  #endif
X! 	if(!fp)
X  #ifdef MACOS
X! 		fp = openFile(DATAFILE);
X! 	if (!fp)
X  #endif
X  		pline("Cannot open data file!");
X! 	else {
X! 		coord	cc;
X! 		uchar	r;
X! 		boolean oldverb = flags.verbose;
X  
X! 		pline ("Specify unknown object by cursor? ");
X! 		q = ynq();
X! 		if (q == 'q') {
X! 			(void) fclose(fp);
X! 			return 0;
X! 		} else if (q == 'n') {
X! 			cc.x = cc.y = -1;
X! 			pline("Specify what? ");
X! 			r = readchar();
X! 		} else {
X! 		    cc.x = u.ux;
X! 		    cc.y = u.uy;
X! 	selobj:
X! 		    if(flags.verbose)
X  			pline("Please move the cursor to an unknown object.");
X! 		    else
X  			pline("Pick an object.");
X! 		    getpos(&cc, FALSE, "an unknown object");
X! 		    if (cc.x < 0) {
X  			    (void) fclose(fp); /* sweet@scubed */
X  			    flags.verbose = oldverb;
X  			    return 0;
X- 		    }
X- 		    flags.verbose = FALSE;
X- 		    r = levl[cc.x][cc.y].scrsym;
X- 		    if (!r || !levl[cc.x][cc.y].seen) r = ' ';
X  		}
X  
X! #define conv_sym(x)	if(r == showsyms.x) q = defsyms.x
X! 		conv_sym(stone);
X! 		else conv_sym(vwall);
X! 		else conv_sym(hwall);
X! 		else conv_sym(tlcorn);
X! 		else conv_sym(trcorn);
X! 		else conv_sym(blcorn);
X! 		else conv_sym(brcorn);
X! 		else conv_sym(crwall);
X! 		else conv_sym(tuwall);
X! 		else conv_sym(tdwall);
X! 		else conv_sym(tlwall);
X! 		else conv_sym(trwall);
X! 		else conv_sym(door);
X! 		else conv_sym(room);
X! 		else conv_sym(corr);
X! 		else conv_sym(upstair);
X! 		else conv_sym(dnstair);
X! 		else conv_sym(trap);
X! 		else conv_sym(web); 
X! 		else conv_sym(pool);
X! #ifdef FOUNTAINS
X! 		else conv_sym(fountain);
X! #endif
X! #ifdef SINKS
X! 		else conv_sym(sink);
X! #endif
X! #ifdef THRONES
X! 		else conv_sym(throne);
X! #endif
X! #ifdef ALTARS
X! 		else conv_sym(altar);
X! #endif
X! #ifdef STRONGHOLD
X! 		else conv_sym(upladder);
X! 		else conv_sym(dnladder);
X! 		else conv_sym(dbvwall);
X! 		else conv_sym(dbhwall);
X! #endif
X! #undef conv_sym
X! 		else {
X! 			q = r;
X! 			if (index(quitchars, q)) {
X! 				(void) fclose(fp); /* sweet@scubed */
X! 				flags.verbose = oldverb;
X! 				return 0;
X! 			}
X! 		}
X  
X! 		if(q != '\t')
X! 		while(fgets(buf,BUFSZ,fp))
X! 		    if(*buf == q) {
X  			ep = index(buf, '\n');
X  			if(ep) *ep = 0;
X  			/* else: bad data file */
X  			/* Expand tab 'by hand' */
X! 			if(buf[1] == '\t'){
X  				buf = bufr;
X! 				buf[0] = r;
X  				(void) strncpy(buf+1, "       ", 7);
X  			}
X! 			/* use %s so '%' won't be interpreted as a format */
X! 			pline("%s", buf);
X! 			if(cc.x != -1) {
X! 			    register struct monst *mtmp;
X  
X! 			    if(MON_AT(cc.x,cc.y))
X! 				mtmp = m_at(cc.x,cc.y);
X! 			    else
X! 				mtmp = (struct monst *) 0;
X! #ifdef ALTARS
X! 			    if (r == showsyms.altar && q == defsyms.altar &&
X! 				(IS_ALTAR(levl[cc.x][cc.y].typ) ||
X! 				 (mtmp && mtmp->mimic))
X! 			       ) {
X! 				    int type = levl[cc.x][cc.y].altarmask &
X! 						~A_SHRINE;
X! 				    pline((type == A_CHAOS) ? "(chaotic)" :
X! 					  (type == A_NEUTRAL) ? "(neutral)" :
X! 					  "(lawful)");
X! 			    } else
X! #endif
X! 			    if (q == CHAIN_SYM && OBJ_AT(cc.x, cc.y))
X! 				    pline("(chain)");
X! 			    else if (r == showsyms.door && q == defsyms.door &&
X! 				(IS_DOOR(levl[cc.x][cc.y].typ) ||
X! 				 (mtmp && mtmp->mimic))) {
X! 				/* Note: this will say mimics in walls are
X! 				 *	 closed doors, which we want.
X! 				 */
X! 				switch(levl[cc.x][cc.y].doormask & ~D_TRAPPED) {
X! 				    case D_NODOOR: pline("(doorway)"); break;
X! 				    case D_BROKEN: pline("(broken door)"); break;
X! 				    case D_ISOPEN: pline("(open door)"); break;
X! 				    default:	   pline("(closed door)"); break;
X! 						   /* locked or not */
X! 				}
X! 			    }
X! #ifdef SPELLS
X! 			    else if (q == SPBOOK_SYM && OBJ_AT(cc.x, cc.y))
X! 				    pline("(spellbook)");
X! #endif
X! #ifdef STRONGHOLD
X! 			    else
X! 			    if (((r == showsyms.dbvwall && q == defsyms.dbvwall) ||
X! 				 (r == showsyms.dbvwall && q == defsyms.dbvwall)) &&
X! 				is_db_wall(cc.x,cc.y))
X! 				    pline("(raised drawbridge)");
X! #endif
X! #ifdef SINKS
X! 			    else if (r == showsyms.sink && q == defsyms.sink &&
X! 				IS_SINK(levl[cc.x][cc.y].typ))
X! 				    pline("(sink)");
X! #endif
X! 			    if (!Invisible 
X  #ifdef POLYSELF
X  				&& !u.uundetected
X  #endif
X! 					&& u.ux==cc.x && u.uy==cc.y) {
X! 				pline("(%s named %s)",
X  #ifdef POLYSELF
X! 				    u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X! 				    pl_character, plname);
X! 			    /* Note: the blind/telepathy check is necessary.
X! 			     * Otherwise a ghost sitting on a blank square
X! 			     * gets identified even while blind because the
X! 			     * symbol is "correct".
X! 			     */
X! 			    } else if (mtmp && (!Blind || Telepat)) {
X! 				if (q == mtmp->data->mlet)
X! 				    pline("(%s%s)",
X! 					mtmp->mtame ? "tame " :
X! 					  mtmp->mpeaceful ? "peaceful " : "",
X! 					strncmp(lmonnam(mtmp), "the ", 4)
X! 					  ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X! 			    }
X! 			}
X! 			if(ep[-1] == ';') {
X! 				pline("More info? ");
X! 				if(yn() == 'y') {
X! 					page_more(fp,1); /* does fclose() */
X! 					flags.verbose = oldverb;
X! 					return 0;
X! 				}
X! 			}
X! 			if(cc.x != -1) {
X! 				buf = &bufr[6];
X! 				more();
X! 				rewind(fp);
X! 				goto selobj;
X  			}
X! 			(void) fclose(fp); 	/* kopper@psuvax1 */
X  			flags.verbose = oldverb;
X  			return 0;
X! 		    }
X! 		pline("I've never heard of such things.");
X! 		(void) fclose(fp);
X! 		flags.verbose = oldverb;
X  	}
X  	return 0;
X  }
X  
X--- 75,264 ----
X  #else
X  	fp = fopen(DATAFILE, "r");
X  #endif
X! 	if(!fp) {
X  #ifdef MACOS
X! 		fp = openFile(DATAFILE, "r");
X! 	}
X! 	if (!fp) {
X  #endif
X  		pline("Cannot open data file!");
X! 		return 0;
X! 	}
X  
X! 	pline ("Specify unknown object by cursor? ");
X! 	q = ynq();
X! 	if (q == 'q') {
X! 		(void) fclose(fp);
X! 		return 0;
X! 	} else if (q == 'n') {
X! 		cc.x = cc.y = -1;
X! 		pline("Specify what? ");
X! 		q = readchar();
X! 	} else {
X! 		cc.x = u.ux;
X! 		cc.y = u.uy;
X! selobj:
X! 		found_in_file = FALSE;
X! 		found = 0;
X! 		(void) outspec("", 0);		/* reset output */
X! 		if(flags.verbose)
X  			pline("Please move the cursor to an unknown object.");
X! 		else
X  			pline("Pick an object.");
X! 		getpos(&cc, FALSE, "an unknown object");
X! 		if (cc.x < 0) {
X  			    (void) fclose(fp); /* sweet@scubed */
X  			    flags.verbose = oldverb;
X  			    return 0;
X  		}
X+ 		flags.verbose = FALSE;
X+ 		q = levl[cc.x][cc.y].scrsym;
X+ 		if (!q || (!levl[cc.x][cc.y].seen && !MON_AT(cc.x,cc.y)))
X+ 			q = ' ';
X+ 	}
X  
X! 	if (index(quitchars, (char)q)) {
X! 		(void) fclose(fp); /* sweet@scubed */
X! 		flags.verbose = oldverb;
X! 		return 0;
X! 	}
X  
X! /* now check for symbols defined in the data file */
X! 	if(q != '\t')
X! 	while(fgets(buf,BUFSZ,fp)) {
X! 		if(*buf == q) {
X  			ep = index(buf, '\n');
X  			if(ep) *ep = 0;
X  			/* else: bad data file */
X  			/* Expand tab 'by hand' */
X! 			if (buf[1] == '\t') {
X  				buf = bufr;
X! 				buf[0] = q;
X  				(void) strncpy(buf+1, "       ", 7);
X  			}
X! 			pline("%s", buf);	/* watch out for % in output */
X! 			(void) outspec("", 0);
X! 			found++;
X! 			found_in_file = TRUE;
X! 			break;
X! 		}
X! 	}
X! 
X! /* Now check for graphics symbols */
X! 	for (i = 0; i < MAXPCHARS; i++) {
X! 		if ( q == showsyms[i] && (*explainsyms[i])) {
X! 			if (!found) {
X! 				pline("%c       %s",q,explainsyms[i]);
X! 				(void) outspec(explainsyms[i], 0);
X! 				found++;
X! 			}
X! 			else if (outspec(explainsyms[i], 1))
X! 				found++;
X! 		}
X! 	}
X  
X! 	if (!found)
X! 		pline("I've never heard of such things.");
X! 
X! /* now check for specific things at a given location */
X! 	if(cc.x != -1 && found) {
X! 		if(MON_AT(cc.x,cc.y)) {
X! 			mtmp = m_at(cc.x,cc.y);
X! 			if (!showmon(mtmp) || Hallucination)
X! 				mtmp = (struct monst *)0;
X! 		} else
X! 			mtmp = (struct monst *) 0;
X! 		typ = levl[cc.x][cc.y].typ;
X! 		if (!Invisible 
X  #ifdef POLYSELF
X  				&& !u.uundetected
X  #endif
X! 				&& u.ux==cc.x && u.uy==cc.y) {
X! 			pline("(%s named %s)",
X  #ifdef POLYSELF
X! 				u.mtimedone ? mons[u.umonnum].mname :
X  #endif
X! 				pl_character, plname);
X! 		} else if (mtmp && !mtmp->mimic)
X! 			pline("(%s%s)",
X! 			   mtmp->mtame ? "tame " :
X! 			   mtmp->mpeaceful ? "peaceful " : "",
X! 			   strncmp(lmonnam(mtmp), "the ", 4)
X! 				  ? lmonnam(mtmp) : lmonnam(mtmp)+4);
X! /* Only worry about the rest of the cases if the symbol could represent
X!    more than one thing */
X! 		else if (found <= 1)
X! 			/* do nothing */ ;
X! 		else if (!levl[cc.x][cc.y].seen)
X! 			pline("(a dark part of a room)");
X! #ifdef ALTARS
X! 		else if (q == showsyms[S_altar] && 
X! 			 (IS_ALTAR(typ) || (mtmp && mtmp->mimic))) {
X! 			int kind = levl[cc.x][cc.y].altarmask & ~A_SHRINE;
X! 			pline( "(%s altar)",
X! 				(kind == A_CHAOS) ? "chaotic" :
X! 				(kind == A_NEUTRAL) ? "neutral" :
X! 				 "lawful" );
X! 		}
X! #endif
X! 		else if ((q==showsyms[S_ndoor] ||
X! 			  q==showsyms[S_vodoor] ||
X! 			  q==showsyms[S_hodoor] ||
X! 			  q==showsyms[S_cdoor]) &&
X! 			(IS_DOOR(typ) ||
X! 				(IS_WALL(typ) && mtmp && mtmp->mimic))) {
X! 			/* Note: this will say mimics in walls are
X! 			 *	 closed doors, which we want.
X! 			 */
X! 			switch(levl[cc.x][cc.y].doormask & ~D_TRAPPED) {
X! 				case D_NODOOR: pline("(doorway)"); break;
X! 				case D_BROKEN: pline("(broken door)"); break;
X! 				case D_ISOPEN: pline("(open door)"); break;
X! 				default:       pline("(closed door)"); break;
X! 						   /* locked or not */
X  			}
X! 		}
X! #ifdef STRONGHOLD
X! 		else if ((q == showsyms[S_dbvwall] ||
X! 			  q == showsyms[S_dbhwall]) &&
X! 			  is_db_wall(cc.x,cc.y))
X! 				pline("(raised drawbridge)");
X! #endif
X! #ifdef SINKS
X! 		else if (q == showsyms[S_sink] && IS_SINK(levl[cc.x][cc.y].typ))
X! 			pline("(sink)");
X! #endif
X! 		else if (IS_ROOM(typ) && q == showsyms[S_room])
X! 			pline("(floor of a room)");
X! 		else if (q == showsyms[S_corr] && SPACE_POS(typ))
X! 			pline("(corridor)");
X! 		else if (!ACCESSIBLE(typ)) {
X! 			if (q == showsyms[S_stone] || q == ' ')
X! 				pline("(dark part of a room)");
X! 			else
X! 				pline("(wall)");
X! 		}
X! 	}
X! 
X! /* now check for "more info" */
X! 	if(found_in_file && ep[-1] == ';') {
X! 		pline("More info? ");
X! 		if(yn() == 'y') {
X! 			page_more(fp,1); /* does fclose() */
X  			flags.verbose = oldverb;
X  			return 0;
X! 		}
X! 	}
X! 
X! /* if specified by cursor, keep going */
X! 	if(cc.x != -1) {
X! 		buf = &bufr[6];
X! 		more();
X! 		rewind(fp);
X! 		goto selobj;
X  	}
X+ 	(void) fclose(fp); 	/* kopper@psuvax1 */
X+ 	flags.verbose = oldverb;
X  	return 0;
X  }
X  
X***************
X*** 261,267 ****
X  #else
X  # ifdef MACOS
X  	if(!(fp = fopen(CMDHELPFILE, "r")))
X! 		fp = openFile(CMDHELPFILE);
X  	if (!fp) {
X  # else
X  	if(!(fp = fopen(CMDHELPFILE, "r"))) {
X--- 278,284 ----
X  #else
X  # ifdef MACOS
X  	if(!(fp = fopen(CMDHELPFILE, "r")))
X! 		fp = openFile(CMDHELPFILE, "r");
X  	if (!fp) {
X  # else
X  	if(!(fp = fopen(CMDHELPFILE, "r"))) {
X***************
X*** 659,666 ****
X--- 676,700 ----
X  	 * help menu, we end up restoring the part of the maze underneath the
X  	 * help menu when the last page of a long help file is displayed with
X  	 * an external pager.
X+ 	 *
X+ 	 * When whole_screen is FALSE and the internal pager is used, the
X+ 	 * screen is big enough so that the maze is left in place during paging
X+ 	 * and the paging occurs in the lower part of the screen.  In this case
X+ 	 * the pager clears out the part it wrote over when it exits but it
X+ 	 * doesn't redraw the whole screen.  So all characters require that
X+ 	 * the help menu be cleared.
X+ 	 *
X+ 	 * When an external pager is used, the screen is always cleared.
X+ 	 * However, the "f" and "h" help options always use the internal
X+ 	 * pager even if DEF_PAGER is defined.
X+ 	 *                        - Bob Wilber  wilber@homxb.att.com  10/20/89
X  	 */
X  	return(index(quitchars,c) || c == 'd' || c == 'e'
X+ #ifdef DEF_PAGER
X+ 	        || (!whole_screen && (c == 'f' || c == 'h'))
X+ #else
X+ 	        || !whole_screen
X+ #endif
X  #ifdef WIZARD
X  		|| c == 'j'
X  #endif
X***************
X*** 763,769 ****
X  #else
X  # ifdef MACOS
X  	if ((f = fopen (fnam, "r")) == (FILE *) 0)
X! 		f = openFile(fnam);
X  	/* refresh screen kluge */
X  	if (!f) {
X  		cls();
X--- 797,803 ----
X  #else
X  # ifdef MACOS
X  	if ((f = fopen (fnam, "r")) == (FILE *) 0)
X! 		f = openFile(fnam, "r");
X  	/* refresh screen kluge */
X  	if (!f) {
X  		cls();
X*** src/Old/panic.c	Sun Nov 19 13:04:49 1989
X--- src/panic.c	Fri Nov 17 19:32:04 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)panic.c	3.0	88/05/03
X   * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
X   *
X   *	This code was adapted from the code in end.c to run in a standalone
X--- 1,4 ----
X! /*	SCCS Id: @(#)panic.c	3.0	89/11/15
X   * Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985.
X   *
X   *	This code was adapted from the code in end.c to run in a standalone
X***************
X*** 12,18 ****
X  
X  #ifdef MSDOS
X  #undef exit
X! extern void exit P((int));
X  #endif
X  #ifdef AZTEC
X  #define abort() exit()
X--- 12,18 ----
X  
X  #ifdef MSDOS
X  #undef exit
X! extern void FDECL(exit, (int));
X  #endif
X  #ifdef AZTEC
X  #define abort() exit()
X***************
X*** 44,47 ****
X  	exit(1);		/* redundant */
X  	return;
X  }
X- 
X--- 44,46 ----
X*** src/Old/pickup.c	Sun Nov 19 13:05:04 1989
X--- src/pickup.c	Tue Nov 14 21:24:39 1989
X***************
X*** 33,49 ****
X  	dummygold.cobj = 0;
X  
X  	if(Levitation) {
X! 		if (all && !flags.pickup) read_engr_at(u.ux,u.uy);
X  		return;
X  	}
X! 	if (all && !flags.pickup) {
X  		int ct = 0;
X  
X! 		for (obj = fobj; obj; obj = obj->nobj)
X! 			if(obj->ox == u.ux && obj->oy == u.uy)
X! 			    if(!obj->cobj)
X! 				if (obj != uchain)
X! 					ct++;
X  
X  		/* Stop on a zorkmid */
X  		if (gold) ct++;
X--- 33,47 ----
X  	dummygold.cobj = 0;
X  
X  	if(Levitation) {
X! 		if (multi || (all && !flags.pickup)) read_engr_at(u.ux,u.uy);
X  		return;
X  	}
X! 	if (multi || (all && !flags.pickup)) {
X  		int ct = 0;
X  
X! 		for (obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X! 			if(!obj->cobj && obj != uchain)
X! 				ct++;
X  
X  		/* Stop on a zorkmid */
X  		if (gold) ct++;
X***************
X*** 209,215 ****
X  		  if(obj->blessed) obj->blessed = 0;
X  		  else if(!obj->spe && !obj->cursed) obj->spe = 1;
X  		  else {
X! 		    pline("The scroll turns to dust as you pick it up.");
X  			if(!(objects[SCR_SCARE_MONSTER].oc_name_known) &&
X  			   !(objects[SCR_SCARE_MONSTER].oc_uname))
X  				docall(obj);
X--- 207,215 ----
X  		  if(obj->blessed) obj->blessed = 0;
X  		  else if(!obj->spe && !obj->cursed) obj->spe = 1;
X  		  else {
X! 		    pline("The scroll%s turn%s to dust as you pick %s up.",
X! 				plur((long)obj->quan), (obj->quan==1) ? "s":"",
X! 				(obj->quan==1) ? "it" : "them");
X  			if(!(objects[SCR_SCARE_MONSTER].oc_name_known) &&
X  			   !(objects[SCR_SCARE_MONSTER].oc_uname))
X  				docall(obj);
X***************
X*** 310,319 ****
X  		pline("You cannot reach the floor.");
X  		return(0);
X  	}
X! 	if(OBJ_AT(u.ux, u.uy))
X! 	for(cobj = fobj; cobj; cobj = cobj->nobj) {
X! 
X! 	    if(cobj->ox == u.ux && cobj->oy == u.uy)
X  		if(Is_container(cobj)) {
X  
X  		    pline("There is %s here, loot it? ", doname(cobj));
X--- 310,316 ----
X  		pline("You cannot reach the floor.");
X  		return(0);
X  	}
X! 	for(cobj = level.objects[u.ux][u.uy]; cobj; cobj = cobj->nexthere) {
X  		if(Is_container(cobj)) {
X  
X  		    pline("There is %s here, loot it? ", doname(cobj));
X***************
X*** 355,365 ****
X  register struct obj *cobj, *obj;
X  {
X  	if (cobj->otyp == BAG_OF_HOLDING)
X! 		cobj->owt += (obj->owt/2 + 1);
X  	else	cobj->owt += obj->owt;
X  }
X  
X! static int
X  in_container(obj)
X  register struct obj *obj;
X  {
X--- 352,365 ----
X  register struct obj *cobj, *obj;
X  {
X  	if (cobj->otyp == BAG_OF_HOLDING)
X! 		cobj->owt += (obj->cursed?(obj->owt*2):(obj->owt/(obj->blessed?4:2)) + 1);
X  	else	cobj->owt += obj->owt;
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  in_container(obj)
X  register struct obj *obj;
X  {
X***************
X*** 431,437 ****
X  	return(1);
X  }
X  
X! static int
X  ck_container(obj)
X  register struct obj *obj;
X  {
X--- 431,440 ----
X  	return(1);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  ck_container(obj)
X  register struct obj *obj;
X  {
X***************
X*** 438,450 ****
X  	return(obj->cobj == current_container);
X  }
X  
X! static int
X  ck_bag()
X  {
X  	return(!baggone);
X  }
X  
X! static int
X  out_container(obj)
X  register struct obj *obj;
X  {
X--- 441,459 ----
X  	return(obj->cobj == current_container);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  ck_bag()
X  {
X  	return(!baggone);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  out_container(obj)
X  register struct obj *obj;
X  {
X*** src/Old/polyself.c	Sun Nov 19 13:05:28 1989
X--- src/polyself.c	Sun Nov 19 09:25:32 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)polyself.c	3.0	88/10/22
X  /* Polymorph self routine.  Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)polyself.c 3.0	89/11/19
X  /* Polymorph self routine.  Copyright (C) 1987, 1988, 1989 by Ken Arromdee */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 185,192 ****
X  	if (mntmp < 0) {
X  		tries = 0;
X  		do {
X! 			mntmp = rn2(PM_CHAMELEON);
X! 			/* All valid monsters are from 0 to PM_CHAMELEON-1 */
X  		} while(!polyok(&mons[mntmp]) && tries++ < 200);
X  	}
X  
X--- 185,192 ----
X  	if (mntmp < 0) {
X  		tries = 0;
X  		do {
X! 			mntmp = rn2(PM_ARCHEOLOGIST);
X! 			/* All valid monsters are from 0 to PM_ARCHEOLOGIST-1 */
X  		} while(!polyok(&mons[mntmp]) && tries++ < 200);
X  	}
X  
X***************
X*** 234,242 ****
X  	u.usym = mons[mntmp].mlet;
X  
X  	if (tmp != mntmp)
X! 		You("turn into a%s %s!",
X! 			index(vowels, *(mons[mntmp].mname)) ? "n" : "",
X! 			mons[mntmp].mname);
X  	else
X  		You("feel like a new %s!", mons[mntmp].mname);
X  
X--- 234,240 ----
X  	u.usym = mons[mntmp].mlet;
X  
X  	if (tmp != mntmp)
X! 		You("turn into %s!", an(mons[mntmp].mname));
X  	else
X  		You("feel like a new %s!", mons[mntmp].mname);
X  
X***************
X*** 300,305 ****
X--- 298,305 ----
X  		pline("Use the command #monster to summon help.");
X  	if (webmaker(uasmon))
X  		pline("Use the command #monster to spin a web.");
X+ 	if (u.usym == S_UNICORN)
X+ 		pline("Use the command #monster to use your horn.");
X  	if (lays_eggs(uasmon) || u.umonnum == PM_QUEEN_BEE)
X  		pline("Use the command #sit to lay an egg.");
X  	find_ac();
X***************
X*** 366,372 ****
X  	  }
X  	  if (otmp = uarmf) {
X  	       Your("boots %s off your feet!",
X! 			verysmall(uasmon) ? "slide" : "get pushed");
X  	       (void) Boots_off();
X  	       dropx(otmp);
X  	  }
X--- 366,372 ----
X  	  }
X  	  if (otmp = uarmf) {
X  	       Your("boots %s off your feet!",
X! 			verysmall(uasmon) ? "slide" : "are pushed");
X  	       (void) Boots_off();
X  	       dropx(otmp);
X  	  }
X***************
X*** 638,643 ****
X--- 638,644 ----
X  
X  char *
X  body_part(part)
X+ int part;
X  {
X  	/* Note: it is assumed these will never be >22 characters long,
X  	 * plus the trailing null, after pluralizing (since sometimes a
X***************
X*** 669,675 ****
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X  		"edge" },
X! 	*snake_parts[] = { "vestigal limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X  		"head", "rear region", "light headed", "neck", "rear scale" };
X  	
X--- 670,676 ----
X  		"minor current", "lower current", "swirl", "swirled",
X  		"central core", "lower current", "addled", "center",
X  		"edge" },
X! 	*snake_parts[] = { "vestigial limb", "eye", "face", "large scale",
X  		"large scale tip", "rear region", "scale gap", "scale gapped",
X  		"head", "rear region", "light headed", "neck", "rear scale" };
X  	
X***************
X*** 709,715 ****
X   */
X  #ifdef POLYSELF
X  	if (uasmon->mflags1 & M1_FEM) return 1;
X! #ifdef HARD
X  	if (u.umonnum==PM_INCUBUS) return 0;
X  #endif
X  	if (!humanoid(uasmon)) return 2;
X--- 710,716 ----
X   */
X  #ifdef POLYSELF
X  	if (uasmon->mflags1 & M1_FEM) return 1;
X! #ifdef INFERNO
X  	if (u.umonnum==PM_INCUBUS) return 0;
X  #endif
X  	if (!humanoid(uasmon)) return 2;
X***************
X*** 721,727 ****
X  #ifdef GOLEMS
X  void
X  ugolemeffects(damtype, dam)
X! int damtype;
X  {
X  	int heal = 0;
X  	/* We won't bother with "slow"/"haste" since players do not
X--- 722,728 ----
X  #ifdef GOLEMS
X  void
X  ugolemeffects(damtype, dam)
X! int damtype, dam;
X  {
X  	int heal = 0;
X  	/* We won't bother with "slow"/"haste" since players do not
X*** src/Old/potion.c	Sun Nov 19 13:05:59 1989
X--- src/potion.c	Sat Nov 18 21:17:43 1989
X***************
X*** 127,133 ****
X  	if (!xtime && old ) {
X  		if (!Blind && talk) pline("Everything looks SO boring now.");
X  		for (mtmp=fmon; mtmp; mtmp=mtmp->nmon)
X! 		  if ((Blind && Telepat) || canseemon(mtmp))
X  		    atl(mtmp->mx, mtmp->my, (!mtmp->mappearance ||
X  					     Protection_from_shape_changers)
X  			? mtmp->data->mlet : mtmp->mappearance);
X--- 127,133 ----
X  	if (!xtime && old ) {
X  		if (!Blind && talk) pline("Everything looks SO boring now.");
X  		for (mtmp=fmon; mtmp; mtmp=mtmp->nmon)
X! 		  if (showmon(mtmp))
X  		    atl(mtmp->mx, mtmp->my, (!mtmp->mappearance ||
X  					     Protection_from_shape_changers)
X  			? mtmp->data->mlet : mtmp->mappearance);
X***************
X*** 182,188 ****
X--- 182,190 ----
X  
X  	otmp = getobj(beverages, "drink");
X  	if(!otmp) return(0);
X+ #ifndef NO_SIGNAL
X  	otmp->in_use = TRUE;		/* you've opened the stopper */
X+ #endif
X  	if(objects[otmp->otyp].oc_descr && !strcmp(objects[otmp->otyp].oc_descr, "smoky") && !rn2(13)) {
X  		ghost_from_bottle();
X  		useup(otmp);
X***************
X*** 259,267 ****
X  	case POT_WATER:
X  		if(!otmp->blessed && !otmp->cursed) {
X  			pline("This tastes like %swater.",
X! 			      otmp->spe == -1 ? "impure " :
X! 			      !otmp->rustfree ? "" : "mineral "
X! 			     );
X  			lesshungry(rnd(otmp->spe == -1 ? 3 : 10));
X  			break;
X  		}
X--- 261,267 ----
X  	case POT_WATER:
X  		if(!otmp->blessed && !otmp->cursed) {
X  			pline("This tastes like %swater.",
X! 			      otmp->spe == -1 ? "impure " : "");
X  			lesshungry(rnd(otmp->spe == -1 ? 3 : 10));
X  			break;
X  		}
X***************
X*** 317,323 ****
X  			unkn++;
X  			You("have an uneasy feeling...");
X  		} else {
X! 			You("feel self-knowledgable...");
X  			if (otmp->blessed) {
X  				adjattrib(A_INT, 1, FALSE);
X  				adjattrib(A_WIS, 1, FALSE);
X--- 317,323 ----
X  			unkn++;
X  			You("have an uneasy feeling...");
X  		} else {
X! 			You("feel self-knowledgeable...");
X  			if (otmp->blessed) {
X  				adjattrib(A_INT, 1, FALSE);
X  				adjattrib(A_WIS, 1, FALSE);
X***************
X*** 786,792 ****
X  	/* note: no obfree() */
X  }
X  
X! static int
X  neutralizes(o1, o2)
X  register struct obj *o1, *o2;
X  {
X--- 786,792 ----
X  	/* note: no obfree() */
X  }
X  
X! static boolean
X  neutralizes(o1, o2)
X  register struct obj *o1, *o2;
X  {
X***************
X*** 797,813 ****
X  		case POT_CONFUSION:
X  			if (o2->otyp == POT_HEALING ||
X  			    o2->otyp == POT_EXTRA_HEALING)
X! 				return 1;
X  		case POT_HEALING:
X  		case POT_EXTRA_HEALING:
X  			if (o2->otyp == POT_SICKNESS ||
X  			    o2->otyp == POT_HALLUCINATION ||
X  			    o2->otyp == POT_BLINDNESS ||
X  			    o2->otyp == POT_CONFUSION)
X! 				return 1;
X  	}
X  
X! 	return 0;
X  }
X  
X  int
X--- 797,856 ----
X  		case POT_CONFUSION:
X  			if (o2->otyp == POT_HEALING ||
X  			    o2->otyp == POT_EXTRA_HEALING)
X! 				return TRUE;
X  		case POT_HEALING:
X  		case POT_EXTRA_HEALING:
X+ 		case UNICORN_HORN:
X  			if (o2->otyp == POT_SICKNESS ||
X  			    o2->otyp == POT_HALLUCINATION ||
X  			    o2->otyp == POT_BLINDNESS ||
X  			    o2->otyp == POT_CONFUSION)
X! 				return TRUE;
X  	}
X  
X! 	return FALSE;
X! }
X! 
X! boolean
X! get_wet(obj)
X! register struct obj *obj;
X! /* returns TRUE if something happened (potion should be used up) */
X! {
X! 	switch (obj->olet) {
X! 	    case WEAPON_SYM:
X! 		if (!obj->rustfree &&
X! 		    objects[obj->otyp].oc_material == METAL &&
X! 		    obj->spe > -6 && !rn2(10)) {
X! 			Your("%s somewhat.", aobjnam(obj,"rust"));
X! 			obj->spe--;
X! 			return TRUE;
X! 		} else break;
X! 	    case POTION_SYM:
X! 		if (obj->otyp == POT_WATER) return FALSE;
X! 		Your("%s.", aobjnam(obj,"dilute"));
X! 		if (obj->spe == -1) {
X! 			obj->spe = 0;
X! 			obj->blessed = obj->cursed = 0;
X! 			obj->otyp = POT_WATER;
X! 		} else obj->spe--;
X! 		return TRUE;
X! 	    case SCROLL_SYM:
X! 		if (obj->otyp != SCR_BLANK_PAPER
X! #ifdef MAIL
X! 		    && obj->otyp != SCR_MAIL
X! #endif
X! 		    ) {
X! 			if (!Blind) {
X! 				if (obj->quan == 1)
X! 					pline("The scroll fades.");
X! 				else pline("The scrolls fade.");
X! 			}
X! 			obj->otyp = SCR_BLANK_PAPER;
X! 			return TRUE;
X! 		}
X! 	}
X! 	Your("%s wet.", aobjnam(obj,"get"));
X! 	return FALSE;
X  }
X  
X  int
X***************
X*** 815,826 ****
X  {
X  	register struct obj *potion, *obj;
X  	char *tmp;
X  
X  	if(!(obj = getobj("#", "dip")))
X  		return(0);
X  #ifdef FOUNTAINS
X  	/* Is there a fountain to dip into here? */
X! 	if (IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X  		pline("Dip it into the fountain? ");
X  		if(yn() == 'y') {
X  			dipfountain(obj);
X--- 858,872 ----
X  {
X  	register struct obj *potion, *obj;
X  	char *tmp;
X+ 	uchar here;
X  
X  	if(!(obj = getobj("#", "dip")))
X  		return(0);
X+ 
X+ 	here = levl[u.ux][u.uy].typ;
X  #ifdef FOUNTAINS
X  	/* Is there a fountain to dip into here? */
X! 	if (IS_FOUNTAIN(here)) {
X  		pline("Dip it into the fountain? ");
X  		if(yn() == 'y') {
X  			dipfountain(obj);
X***************
X*** 828,833 ****
X--- 874,888 ----
X  		}
X  	}
X  #endif
X+         if (is_pool(u.ux,u.uy)) {
X+ 		pline("Dip it into the %s? ",
X+ 		      here == POOL ? "pool" : "moat");
X+ 		if(yn() == 'y') {
X+ 			(void) get_wet(obj);
X+ 			return(1);
X+ 		}
X+ 	}
X+ 
X  	if(!(potion = getobj(beverages, "dip into")))
X  		return(0);
X  	if (potion==obj && potion->quan==1) {
X***************
X*** 879,914 ****
X  				obj->bknown=1;
X  				goto poof;
X  			}
X! 		} else if (obj->otyp != POT_WATER) {
X! 			if (obj->olet == WEAPON_SYM && !obj->rustfree &&
X! 			    objects[obj->otyp].oc_material == METAL &&
X! 			    obj->spe > -6 && !rn2(10)) {
X! 				Your("%s somewhat.", aobjnam(obj,"rust"));
X! 				obj->spe--;
X! 				goto poof;
X! 			} else if (obj->olet == POTION_SYM) {
X! 				Your("%s.", aobjnam(obj,"dilute"));
X! 				if (obj->spe == -1) {
X! 					obj->spe = 0;
X! 					obj->blessed = obj->cursed = 0;
X! 					obj->otyp = POT_WATER;
X! 				} else obj->spe--;
X! 				goto poof;
X! 			} else if (obj->olet == SCROLL_SYM &&
X! #ifdef MAIL
X! 				   obj->otyp != SCR_MAIL &&
X! #endif
X! 				   obj->otyp != SCR_BLANK_PAPER) {
X! 				if (!Blind) {
X! 					if (obj->quan == 1)
X! 						pline("The scroll fades.");
X! 					else pline("The scrolls fade.");
X! 				}
X! 				obj->otyp = SCR_BLANK_PAPER;
X! 				goto poof;
X! 			} else
X! 				Your("%s wet.", aobjnam(obj,"get"));
X! 		}
X  	}
X  	else if(obj->olet == POTION_SYM && obj->otyp != potion->otyp) {
X  		/* Mixing potions is dangerous... */
X--- 934,942 ----
X  				obj->bknown=1;
X  				goto poof;
X  			}
X! 		} else
X! 			if (get_wet(obj))
X! 			    goto poof;
X  	}
X  	else if(obj->olet == POTION_SYM && obj->otyp != potion->otyp) {
X  		/* Mixing potions is dangerous... */
X***************
X*** 926,933 ****
X  		obj->blessed = obj->cursed = obj->bknown = 0;
X  		if (Blind) obj->dknown = 0;
X  
X! 		switch (neutralizes(obj, potion) || obj->spe == -1 ?
X! 			1 : rnd(8)) {
X  			case 1:
X  				obj->otyp = POT_WATER;
X  				obj->blessed = obj->cursed = 0;
X--- 954,961 ----
X  		obj->blessed = obj->cursed = obj->bknown = 0;
X  		if (Blind) obj->dknown = 0;
X  
X! 		switch (neutralizes(obj, potion) ||
X! 			obj->spe == -1 /* diluted */ ? 1 : rnd(8)) {
X  			case 1:
X  				obj->otyp = POT_WATER;
X  				obj->blessed = obj->cursed = 0;
X***************
X*** 982,987 ****
X--- 1010,1023 ----
X  		goto poof;
X  	    }
X  	}
X+ 
X+ 	if(obj->otyp == UNICORN_HORN && neutralizes(obj, potion)) {
X+ 		pline("The potion clears.");
X+ 		potion->otyp = POT_WATER;
X+ 		potion->blessed = potion->cursed = 0;
X+ 		return(1);
X+ 	}
X+ 
X  	pline("Interesting...");
X  	return(1);
X  }
X*** src/Old/pray.c	Sun Nov 19 13:06:43 1989
X--- src/pray.c	Sat Nov 11 16:11:29 1989
X***************
X*** 184,192 ****
X  		    break;
X  	    case TROUBLE_HIT:
X  		    if (!Blind) {
X! 			const char *tmp = Hallucination ? hcolor() : golden;
X! 			pline("A%s %s glow surrounds you.",
X! 			      index(vowels,*tmp) ? "n" : "", tmp);
X  		    } else You("feel much better.");
X  		    u.uhp = u.uhpmax += 5;
X  		    flags.botl = 1;
X--- 184,191 ----
X  		    break;
X  	    case TROUBLE_HIT:
X  		    if (!Blind) {
X! 			pline("%s glow surrounds you.",
X! 			      An(Hallucination ? hcolor() : golden));
X  		    } else You("feel much better.");
X  		    u.uhp = u.uhpmax += 5;
X  		    flags.botl = 1;
X***************
X*** 312,319 ****
X  
X  	    case 0:
X  	    case 1:	if (Hallucination)
X! 			    You("feel %sholy dread.",
X! 				  u.ualigntyp == U_CHAOTIC ? "an un" : "a ");
X  			else You("feel that %s is %s.",
X  #  ifdef ALTARS
X  				   on_altar() ? a_gname() : u_gname(),
X--- 311,318 ----
X  
X  	    case 0:
X  	    case 1:	if (Hallucination)
X! 			    You("feel a%sholy dread.",
X! 				  u.ualigntyp == U_CHAOTIC ? "n un" : " ");
X  			else You("feel that %s is %s.",
X  #  ifdef ALTARS
X  				   on_altar() ? a_gname() : u_gname(),
X***************
X*** 350,360 ****
X  			    break;
X  			} /* else fall thru */
X  	    case 4:
X! 	    case 5:	if (!Blind) {
X! 			    const char *temp = Hallucination ? hcolor() : black;
X! 			    pline("A%s %s glow surrounds you.",
X! 				  index(vowels,*temp) ? "n" : "", temp);
X! 			}
X  			rndcurse();
X  			break;
X  	    case 7:
X--- 349,357 ----
X  			    break;
X  			} /* else fall thru */
X  	    case 4:
X! 	    case 5:	if (!Blind)
X! 			    pline("%s glow surrounds you.",
X! 				  An(Hallucination ? hcolor() : black));
X  			rndcurse();
X  			break;
X  	    case 7:
X***************
X*** 407,413 ****
X  
X  static void
X  pleased() {
X- 	char	*tmp;
X  	int trouble = in_trouble ();	/* what's your worst difficulty? */
X  	int pat_on_head = 0;
X  
X--- 404,409 ----
X***************
X*** 481,490 ****
X  			    } else if(uwep->otyp < BOW) {
X  				uwep->blessed = uwep->bknown = 1;
X  				if (!Blind) {
X! 				    tmp = Hallucination ? hcolor() : light_blue;
X! 				    Your("%s with a%s %s aura.",
X  					  aobjnam(uwep, "softly glow"),
X! 					  index(vowels,*tmp) ? "n" : "", tmp);
X  				}
X  			    }
X  			}
X--- 477,485 ----
X  			    } else if(uwep->otyp < BOW) {
X  				uwep->blessed = uwep->bknown = 1;
X  				if (!Blind) {
X! 				    Your("%s with %s aura.",
X  					  aobjnam(uwep, "softly glow"),
X! 					  an(Hallucination ? hcolor() : light_blue));
X  				}
X  			    }
X  			}
X***************
X*** 507,517 ****
X  			}
X  			/* Otherwise, falls into next case */
X  #endif
X! 	    case 2:	if (!Blind) {
X! 			    tmp = Hallucination ? hcolor() : golden;
X! 			    You("are surrounded by a%s %s glow.",
X! 				  index(vowels,*tmp) ? "n" : "", tmp);
X! 			}
X  			u.uhp = u.uhpmax += 5;
X  			ABASE(A_STR) = AMAX(A_STR);
X  			if (u.uhunger < 900)	init_uhunger();
X--- 502,510 ----
X  			}
X  			/* Otherwise, falls into next case */
X  #endif
X! 	    case 2:	if (!Blind)
X! 			    You("are surrounded by %s glow.",
X! 				an(Hallucination ? hcolor() : golden));
X  			u.uhp = u.uhpmax += 5;
X  			ABASE(A_STR) = AMAX(A_STR);
X  			if (u.uhunger < 900)	init_uhunger();
X***************
X*** 522,532 ****
X  	    case 4:
X  		{	register struct obj *otmp;
X  
X- 			tmp = Hallucination ? hcolor() : light_blue;
X  			if (Blind)
X  				You("feel the power of %s.", u_gname());
X! 			else You("are surrounded by a%s %s aura.",
X! 					index(vowels,*tmp) ? "n" : "", tmp);
X  			for(otmp=invent; otmp; otmp=otmp->nobj) {
X  				if (otmp->cursed) {
X  				    otmp->cursed = 0;
X--- 515,524 ----
X  	    case 4:
X  		{	register struct obj *otmp;
X  
X  			if (Blind)
X  				You("feel the power of %s.", u_gname());
X! 			else You("are surrounded by %s aura.",
X! 				 an(Hallucination ? hcolor() : light_blue));
X  			for(otmp=invent; otmp; otmp=otmp->nobj) {
X  				if (otmp->cursed) {
X  				    otmp->cursed = 0;
X***************
X*** 598,605 ****
X  				    pline("Something appears at your %s.",
X  					makeplural(body_part(FOOT)));
X  				else
X! 				    pline("A %s sword appears at your %s!",
X! 					Hallucination ? hcolor() : "black",
X  					makeplural(body_part(FOOT)));
X  				obj = mksobj(BROADSWORD, FALSE);
X  				obj = oname(obj, "Stormbringer", 0);
X--- 590,597 ----
X  				    pline("Something appears at your %s.",
X  					makeplural(body_part(FOOT)));
X  				else
X! 				    pline("%s sword appears at your %s!",
X! 					An(Hallucination ? hcolor() : black),
X  					makeplural(body_part(FOOT)));
X  				obj = mksobj(BROADSWORD, FALSE);
X  				obj = oname(obj, "Stormbringer", 0);
X***************
X*** 678,684 ****
X  		pline("Your sacrifice disappears!");
X  	else pline ("Your sacrifice is consumed in a %s!",
X  		    u.ualigntyp == U_LAWFUL ? "flash of light" : "burst of flame");
X! 	useup(otmp);
X  }
X  
X  int
X--- 670,677 ----
X  		pline("Your sacrifice disappears!");
X  	else pline ("Your sacrifice is consumed in a %s!",
X  		    u.ualigntyp == U_LAWFUL ? "flash of light" : "burst of flame");
X! 	if (carried(otmp)) useup(otmp);
X! 	else useupf(otmp);
X  }
X  
X  int
X***************
X*** 713,719 ****
X     a pet corpse was tame, so you can still sacrifice it.)
X   */
X  
X! #define MAXVALUE 33	/* Highest corpse value (approx.) */
X  
X  	if (otmp->otyp == CORPSE) {
X  	    register struct permonst *mtmp = &mons[otmp->corpsenm];
X--- 706,712 ----
X     a pet corpse was tame, so you can still sacrifice it.)
X   */
X  
X! #define MAXVALUE 24	/* Highest corpse value (besides Wiz) */
X  
X  	if (otmp->otyp == CORPSE) {
X  	    register struct permonst *mtmp = &mons[otmp->corpsenm];
X***************
X*** 722,729 ****
X  	    if (otmp->corpsenm == PM_ACID_BLOB || (monstermoves <= otmp->age + 50))
X  		value = monstr[otmp->corpsenm] + 1;
X  	    if (otmp->oeaten)
X! 		value =
X! 		    value * otmp->owt / mons[otmp->corpsenm].cwt / otmp->quan;
X  
X  	    if (is_human(mtmp)) { /* Human sacrifice! */
X  #ifdef POLYSELF
X--- 715,721 ----
X  	    if (otmp->corpsenm == PM_ACID_BLOB || (monstermoves <= otmp->age + 50))
X  		value = monstr[otmp->corpsenm] + 1;
X  	    if (otmp->oeaten)
X! 		value = eaten_stat(value, otmp);
X  
X  	    if (is_human(mtmp)) { /* Human sacrifice! */
X  #ifdef POLYSELF
X***************
X*** 741,747 ****
X  			angry_priest();
X  		} else {
X  			register struct monst *dmon;
X- 			const char *color = Hallucination ? hcolor() : black;
X      /* Human sacrifice on a chaotic altar is equivalent to demon summoning */
X  #ifdef THEOLOGY
X  			if (levl[u.ux][u.uy].altarmask & A_SHRINE)
X--- 733,738 ----
X***************
X*** 748,756 ****
X  				pline("The blood covers the altar!");
X  			else {
X  #endif
X!     pline("The blood floods over the altar, which vanishes in a%s %s cloud!",
X! 				  index(vowels, *color) ? "n" : "", color);
X  				levl[u.ux][u.uy].typ = ROOM;
X  #ifdef THEOLOGY
X  			}
X  #endif
X--- 739,748 ----
X  				pline("The blood covers the altar!");
X  			else {
X  #endif
X!     pline("The blood floods over the altar, which vanishes in %s cloud!",
X! 				  an(Hallucination ? hcolor() : black));
X  				levl[u.ux][u.uy].typ = ROOM;
X+ 				levl[u.ux][u.uy].altarmask = 0;
X  #ifdef THEOLOGY
X  			}
X  #endif
X***************
X*** 772,778 ****
X  			if (!Inhell) angrygods();
X  			change_luck(-5);
X  		} else adjalign(5);
X! 		useup(otmp);
X  		return(1);
X  	    } else if (is_undead(mtmp)) { /* Not demons--no demon corpses */
X  		if (u.ualigntyp != U_CHAOTIC)
X--- 764,771 ----
X  			if (!Inhell) angrygods();
X  			change_luck(-5);
X  		} else adjalign(5);
X! 		if (carried(otmp)) useup(otmp);
X! 		else useupf(otmp);
X  		return(1);
X  	    } else if (is_undead(mtmp)) { /* Not demons--no demon corpses */
X  		if (u.ualigntyp != U_CHAOTIC)
X***************
X*** 828,834 ****
X  		else {
X  		    /* The final Test.	Did you win? */
X  		    if(uamul == otmp) Amulet_off();
X! 		    useup(otmp);    /* well, it's gone now */
X  		    You("offer the Amulet to %s...", a_gname());
X  		    if (u.ualigntyp !=
X  			    (levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1) {
X--- 821,828 ----
X  		else {
X  		    /* The final Test.	Did you win? */
X  		    if(uamul == otmp) Amulet_off();
X! 		    if(carried(otmp)) useup(otmp);    /* well, it's gone now */
X! 		    else useupf(otmp);
X  		    You("offer the Amulet to %s...", a_gname());
X  		    if (u.ualigntyp !=
X  			    (levl[u.ux][u.uy].altarmask & ~A_SHRINE) - 1) {
X***************
X*** 1094,1099 ****
X--- 1088,1106 ----
X  
X  	if((pl_character[0] != 'P') &&
X  	   (pl_character[0] != 'K')) {
X+ #ifdef SPELLS
X+ 		/* Try to use turn undead spell. */
X+ 		if (objects[SPE_TURN_UNDEAD].oc_name_known) {
X+ 		    register int sp_no;
X+ 		    for (sp_no = 0; sp_no < MAXSPELL &&
X+ 				spl_book[sp_no].sp_id != NO_SPELL &&
X+ 				spl_book[sp_no].sp_id != SPE_TURN_UNDEAD; sp_no++);
X+ 
X+ 		    if (sp_no < MAXSPELL &&
X+ 			spl_book[sp_no].sp_id == SPE_TURN_UNDEAD)
X+ 			    return spelleffects(++sp_no, TRUE);
X+ 		}
X+ #endif
X  
X  		You("don't know how to turn undead!");
X  		return(0);
X*** src/Old/pri.c	Sun Nov 19 13:07:30 1989
X--- src/pri.c	Fri Nov 17 20:44:47 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)pri.c	3.0	89/06/16
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)pri.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 9,31 ****
X  #if defined(ALTARS) && defined(THEOLOGY)
X  #include "epri.h"
X  #endif
X  
X! static void hilite P((int,int,UCHAR_P, UCHAR_P));
X! static void cornbot P((int));
X! static boolean ismnst P((CHAR_P));
X  #ifdef TEXTCOLOR
X! static uchar mimic_color P((UCHAR_P));
X  #endif
X  
X! #if defined(MSDOS) && !defined(TERMLIB) && !defined(DECRAINBOW)
X! #  define g_putch  (void) putchar
X! #endif
X! 
X! /* This is the same logic used for "#define IBMXASCII" in file "termcap.c" */
X! #if !defined(AMIGA)
X! # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X! #  define g_putch  (void) putchar
X! # endif
X  #endif
X  
X  #ifndef g_putch
X--- 9,25 ----
X  #if defined(ALTARS) && defined(THEOLOGY)
X  #include "epri.h"
X  #endif
X+ #include "termcap.h"
X  
X! static void FDECL(hilite, (int,int,UCHAR_P, UCHAR_P));
X! static void FDECL(cornbot, (int));
X! static boolean FDECL(ismnst, (CHAR_P));
X  #ifdef TEXTCOLOR
X! static uchar FDECL(mimic_color, (UCHAR_P));
X  #endif
X  
X! #ifndef ASCIIGRAPH
X! # define g_putch  (void) putchar
X  #endif
X  
X  #ifndef g_putch
X***************
X*** 39,44 ****
X--- 33,42 ----
X  static const char *dispst = "*0#@#0#*0#@#0#*0#@#0#*0#@#0#*0#@#0#*";
X  static int mrank_sz = 0;  /* loaded by max_rank_sz (called in u_init) */
X  
X+ #ifdef CLIPPING
X+ #define curs(x, y) win_curs((x), (y)-2)
X+ #endif
X+ 
X  void
X  swallowed(first)
X  register int first;
X***************
X*** 90,102 ****
X--- 88,144 ----
X  	u.udisx = u.ux;
X  	u.udisy = u.uy;
X  }
X+ #ifdef CLIPPING
X+ #undef curs
X+ #endif
X  
X  void
X  setclipped()
X  {
X+ #ifndef CLIPPING
X  	error("NetHack needs a screen of size at least %d by %d.\n",
X  		ROWNO+3, COLNO);
X+ #else
X+ 	clipping = TRUE;
X+ 	clipx = clipy = 0;
X+ 	clipxmax = CO;
X+ 	clipymax = LI - 3;
X+ #endif
X+ }
X+ 
X+ #ifdef CLIPPING
X+ void
X+ cliparound(x, y)
X+ int x, y;
X+ {
X+ 	int oldx = clipx, oldy = clipy;
X+ 
X+ 	if (!clipping) return;
X+ 	if (x < clipx + 5) {
X+ 		clipx = max(0, x - 20);
X+ 		clipxmax = clipx + CO;
X+ 	}
X+ 	else if (x > clipxmax - 5) {
X+ 		clipxmax = min(COLNO, clipxmax + 20);
X+ 		clipx = clipxmax - CO;
X+ 	}
X+ 	if (y < clipy + 2) {
X+ 		clipy = max(0, y - 10);
X+ 		clipymax = clipy + (LI - 3);
X+ 	}
X+ 	else if (y > clipymax - 2) {
X+ 		clipymax = min(ROWNO, clipymax + 10);
X+ 		clipy = clipxmax - (LI - 3);
X+ 	}
X+ 	if (clipx != oldx || clipy != oldy) {
X+ 		if (u.udispl) {
X+ 			u.udispl = 0;
X+ 			levl[u.udisx][u.udisy].scrsym = news0(u.udisx, u.udisy);
X+ 		}
X+ 		doredraw();
X+ 	}
X  }
X+ #endif /* CLIPPING */
X  
X  /*
X   *  Allow for a different implementation than this...
X***************
X*** 108,114 ****
X  g_putch(ch)
X  uchar ch;
X  {
X! 	if (ch & 0x80) {
X  		if (!GFlag) {
X  			graph_on();
X  			GFlag = TRUE;
X--- 150,158 ----
X  g_putch(ch)
X  uchar ch;
X  {
X! 	if (IBMgraphics)    /* IBM-compatible displays don't need other stuff */
X! 		(void) putchar(ch);
X! 	else if (ch & 0x80) {
X  		if (!GFlag) {
X  			graph_on();
X  			GFlag = TRUE;
X***************
X*** 125,131 ****
X  
X  #endif
X  
X! static boolean
X  showmon(mon)
X  register struct monst *mon;
X  {
X--- 169,175 ----
X  
X  #endif
X  
X! boolean
X  showmon(mon)
X  register struct monst *mon;
X  {
X***************
X*** 168,178 ****
X  		    (!OBJ_AT(x, y) && !levl[x][y].gmask || is_pool(x,y)))
X  		    typ = AT_MAP;
X  
X! 	y += 2;
X! 	curs(x,y);
X! 
X! 	hilite(x, y-2, ch, typ);
X  	curx++;
X  }
X  
X  void
X--- 212,227 ----
X  		    (!OBJ_AT(x, y) && !levl[x][y].gmask || is_pool(x,y)))
X  		    typ = AT_MAP;
X  
X! #ifdef CLIPPING
X! 	if (win_curs(x, y)) {
X! #else
X! 	curs(x,y+2);
X! #endif
X! 	hilite(x, y, ch, typ);
X  	curx++;
X+ #ifdef CLIPPING
X+ 	}
X+ #endif
X  }
X  
X  void
X***************
X*** 269,275 ****
X  		mtmp->mdispl = 0;
X  	seemons();	/* force new positions to be shown */
X  
X! #if (defined(DGK) && !defined(TEXTCOLOR)) || defined(MACOS)
X  # ifdef MACOS
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	if (!t->inColor)
X--- 318,324 ----
X  		mtmp->mdispl = 0;
X  	seemons();	/* force new positions to be shown */
X  
X! #if ((defined(DGK) && !defined(TEXTCOLOR)) || defined(MACOS)) & !defined(CLIPPING)
X  # ifdef MACOS
X  	t = (term_info *)GetWRefCon(HackWindow);
X  	if (!t->inColor)
X***************
X*** 328,334 ****
X  				at(x,y,room->scrsym,AT_APP);
X  			} else if(room->seen)
X  				at(x,y,room->scrsym,AT_APP);
X! #endif /* DGK && !TEXTCOLOR */
X  #ifndef g_putch
X  	if (GFlag) {
X  		graph_off();
X--- 377,383 ----
X  				at(x,y,room->scrsym,AT_APP);
X  			} else if(room->seen)
X  				at(x,y,room->scrsym,AT_APP);
X! #endif /* DGK && !TEXTCOLOR && !CLIPPING */
X  #ifndef g_putch
X  	if (GFlag) {
X  		graph_off();
X***************
X*** 364,369 ****
X--- 413,421 ----
X  		return;
X  	}
X  
X+ #ifdef CLIPPING
X+ 	xmin += clipx; ymax += clipy;
X+ #endif
X  	seemons();	/* reset old positions */
X  	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X  	    if(mtmp->mx >= xmin && mtmp->my < ymax)
X***************
X*** 370,378 ****
X--- 422,436 ----
X  		mtmp->mdispl = 0;
X  	seemons();	/* force new positions to be shown */
X  
X+ #ifdef CLIPPING
X+ 	for(y = clipy; y < ymax; y++) {
X+ 		if(clipping && y > clipymax && CD) break;
X+ 		curs(xmin - clipx, (y - clipy)+2);
X+ #else
X  	for(y = 0; y < ymax; y++) {
X  		if(y > ROWNO+1 && CD) break;
X  		curs(xmin,y+2);
X+ #endif
X  		cl_end();
X  		if(y < ROWNO) {
X  		    for(x = xmin; x < COLNO; x++) {
X***************
X*** 444,451 ****
X  			struct monst *mtmp = revive(obj, FALSE);
X  
X  			if (mtmp && visible)
X! 				pline("%s rises from the dead!", Monnam(mtmp));
X! 		} else if (obj->age + 250 < monstermoves) delobj(obj);
X  	    }
X  	}
X  
X--- 502,513 ----
X  			struct monst *mtmp = revive(obj, FALSE);
X  
X  			if (mtmp && visible)
X! 				pline("%s rises from the dead!",
X! 					(mtmp->mhp==mtmp->mhpmax) ? Monnam(mtmp)
X! 					: Amonnam(mtmp, "bite-covered"));
X! 		} else if (obj->corpsenm != PM_LIZARD &&
X! 						obj->age + 250 < monstermoves)
X! 			delobj(obj);
X  	    }
X  	}
X  
X***************
X*** 458,468 ****
X  		    struct monst *mtmp = revive(obj, TRUE);
X  
X  		    if (mtmp && wielded)
X! 			pline("The %s %s writhes out of your grasp!",
X  				mtmp->data->mname, xname(obj));
X  		    else if (mtmp)
X  			You("feel squirming in your backpack!");
X! 		} else if (obj->age + 250 < monstermoves) useup(obj);
X  	    }
X  	}
X  }
X--- 520,533 ----
X  		    struct monst *mtmp = revive(obj, TRUE);
X  
X  		    if (mtmp && wielded)
X! 			pline("The %s%s %s writhes out of your grasp!",
X! 				(mtmp->mhp < mtmp->mhpmax) ? "bite-covered ":"",
X  				mtmp->data->mname, xname(obj));
X  		    else if (mtmp)
X  			You("feel squirming in your backpack!");
X! 		} else if (obj->corpsenm != PM_LIZARD &&
X! 						obj->age + 250 < monstermoves)
X! 		    useup(obj);
X  	    }
X  	}
X  }
X***************
X*** 499,506 ****
X  	    if (Hallucination)
X  	    atl(mon->mx,mon->my,
X  		(char) ((!mon->mimic || Protection_from_shape_changers) ?
X! 		rndmonsym() : (mon->mappearance == DOOR_SYM) ?
X! 		DOOR_SYM : rndobjsym()));
X  	    else
X  
X  		atl(mon->mx,mon->my,
X--- 564,571 ----
X  	    if (Hallucination)
X  	    atl(mon->mx,mon->my,
X  		(char) ((!mon->mimic || Protection_from_shape_changers) ?
X! 		rndmonsym() : (mon->mappearance == CLOSED_DOOR_SYM) ?
X! 		CLOSED_DOOR_SYM : rndobjsym()));
X  	    else
X  
X  		atl(mon->mx,mon->my,
X***************
X*** 879,885 ****
X--- 944,954 ----
X  		register char *bp0 = newbot, *bp1 = newbot;
X  
X  		do {
X+ #ifdef CLIPPING
X+ 			if(*bp0 != ' ' || bp0[1] != ' ')
X+ #else
X  			if(*bp0 != ' ' || bp0[1] != ' ' || bp0[2] != ' ')
X+ #endif
X  				*bp1++ = *bp0;
X  		} while(*bp0++);
X  	}
X***************
X*** 910,915 ****
X--- 979,987 ----
X  {
X  	register int i,j;
X  
X+ #ifdef CLIPPING
X+ 	if (CO > 59) {
X+ #endif
X  	Strcpy(newbot1, plname);
X  	if('a' <= newbot1[0] && newbot1[0] <= 'z') newbot1[0] += 'A'-'a';
X  	newbot1[10] = 0;
X***************
X*** 939,944 ****
X--- 1011,1021 ----
X  	      do { Sprintf(eos(newbot1)," "); /* pad with spaces */
X  		   i--;
X  	      } while((i - j) > 0);
X+ #ifdef CLIPPING
X+ 	}
X+ 	else
X+ 		*newbot1 = 0;
X+ #endif
X  	if(ACURR(A_STR)>18) {
X  		if(ACURR(A_STR)>118)
X  		    Sprintf(eos(newbot1),"St:%2d ",ACURR(A_STR)-100);
X***************
X*** 959,965 ****
X--- 1036,1046 ----
X  	    + u.urexp + (50 * maxdlevel)
X  	    + (maxdlevel > 20? 1000*((maxdlevel > 30) ? 10 : maxdlevel - 20) :0));
X  #endif
X+ #ifdef CLIPPING
X+ 	fillbot(min(LI-1, ROWNO+2), oldbot1, newbot1);
X+ #else
X  	fillbot(ROWNO+2, oldbot1, newbot1);
X+ #endif
X  }
X  
X  static void
X***************
X*** 1016,1022 ****
X--- 1097,1107 ----
X  	if(Blinded)	   Sprintf(eos(newbot2), " Blind");
X  	if(Stunned)	   Sprintf(eos(newbot2), " Stun");
X  	if(Hallucination)  Sprintf(eos(newbot2), " Hallu");
X+ #ifdef CLIPPING
X+ 	fillbot(min(LI, ROWNO+3), oldbot2, newbot2);
X+ #else
X  	fillbot(ROWNO+3, oldbot2, newbot2);
X+ #endif
X  }
X  
X  void
X***************
X*** 1130,1136 ****
X  int x, y;
X  uchar let, typ;
X  {
X- 
X  	if (let == ' '
X  #if !defined(MSDOS) && !defined(MACOS)
X  	    || !flags.standout
X--- 1215,1220 ----
X***************
X*** 1164,1181 ****
X  		        default:
X  			    if (u.ux == x && u.uy == y)
X  				typ = uasmon->mcolor;
X! 			    else
X  			        typ = level.monsters[x][y]->data->mcolor;
X  		    }
X! 		break;
X  		case AT_OBJ:
X  		    if (let == GOLD_SYM)
X  			typ = HI_GOLD;
X! 		    else if (level.objects[x][y] && 
X! 			   let == objects[level.objects[x][y]->otyp].oc_olet)
X! 			typ = objects[level.objects[x][y]->otyp].oc_color;
X  		    else
X  			typ = mimic_color(let);
X  		    break;
X  		case AT_MAP:
X  		    if ( ((let == POOL_SYM && IS_POOL(levl[x][y].typ))
X--- 1248,1275 ----
X  		        default:
X  			    if (u.ux == x && u.uy == y)
X  				typ = uasmon->mcolor;
X! 			    else if (level.monsters[x][y])
X  			        typ = level.monsters[x][y]->data->mcolor;
X+ 			    else
X+ 				typ = 0;
X  		    }
X! 		    break;
X  		case AT_OBJ:
X+ 		    { struct obj *otmp;
X+ 
X  		    if (let == GOLD_SYM)
X  			typ = HI_GOLD;
X! 		    else if ((otmp = level.objects[x][y]) && 
X! 			   let == objects[otmp->otyp].oc_olet) {
X! 			if (otmp->otyp == CORPSE ||
X! 				otmp->otyp == DRAGON_SCALE_MAIL)
X! 			    typ = mons[otmp->corpsenm].mcolor;
X! 			else
X! 			    typ = objects[level.objects[x][y]->otyp].oc_color;
X! 		    }
X  		    else
X  			typ = mimic_color(let);
X+ 		    }
X  		    break;
X  		case AT_MAP:
X  		    if ( ((let == POOL_SYM && IS_POOL(levl[x][y].typ))
X***************
X*** 1190,1195 ****
X--- 1284,1292 ----
X  				&& hilites[HI_GOLD] != HI)
X  			typ = HI_GOLD;
X  #endif
X+ 		    else if (levl[x][y].typ == ROOM && levl[x][y].icedpool
X+ 				&& hilites[CYAN] != HI)
X+ 			typ = CYAN;
X  		    else
X  			typ = 0;
X  		    break;
X*** src/Old/priest.c	Sun Nov 19 13:08:13 1989
X--- src/priest.c	Wed Nov  8 22:56:57 1989
X***************
X*** 147,153 ****
X  	gy += rn1(3,-1);
X  
X  	if(!priest->mpeaceful) {
X! 		if(dist(omx,omy) < 3) {
X  			if(Displaced)
X  				Your("displaced image doesn't fool %s!",
X  					mon_nam(priest));
X--- 147,153 ----
X  	gy += rn1(3,-1);
X  
X  	if(!priest->mpeaceful) {
X! 		if(monnear(priest, u.ux, u.uy)) {
X  			if(Displaced)
X  				Your("displaced image doesn't fool %s!",
X  					mon_nam(priest));
X*** src/Old/prisym.c	Sun Nov 19 13:08:35 1989
X--- src/prisym.c	Fri Nov 17 19:32:10 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)prisym.c	3.0	88/11/09
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)prisym.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 8,14 ****
X  #include "wseg.h"
X  #include "lev.h"
X  
X! static void pwseg P((struct wseg *));
X  #endif
X  
X  void
X--- 8,14 ----
X  #include "wseg.h"
X  #include "lev.h"
X  
X! static void FDECL(pwseg, (struct wseg *));
X  #endif
X  
X  void
X***************
X*** 164,170 ****
X--- 164,175 ----
X  void
X  curs_on_u()
X  {
X+ #ifdef CLIPPING
X+ 	cliparound(u.ux, u.uy);
X+ 	(void)win_curs(u.ux, u.uy);
X+ #else
X  	curs(u.ux, u.uy+2);
X+ #endif
X  }
X  
X  void
X***************
X*** 194,199 ****
X--- 199,205 ----
X  /* print a position that is visible for @ */
X  void
X  prl(x,y)
X+ int x, y;
X  {
X  	register struct rm *room;
X  	register struct monst *mtmp = (struct monst *)0;
X***************
X*** 278,284 ****
X  	else if(ttmp && ttmp->tseen) tmp = TRAP_SYM;
X  	else switch(room->typ) {
X  	case SCORR:
X! 		tmp = STONE_SYM;
X  		break;
X  	case SDOOR:
X  		croom = inroom(x,y);
X--- 284,290 ----
X  	else if(ttmp && ttmp->tseen) tmp = TRAP_SYM;
X  	else switch(room->typ) {
X  	case SCORR:
X! 		tmp = ' ';	/* _not_ STONE_SYM! */
X  		break;
X  	case SDOOR:
X  		croom = inroom(x,y);
X***************
X*** 323,329 ****
X  		tmp = BRCORN_SYM;
X  		break;
X  	case DOOR:
X! 		tmp = DOOR_SYM;
X  		break;
X  	case CORR:
X  		tmp = CORR_SYM;
X--- 329,355 ----
X  		tmp = BRCORN_SYM;
X  		break;
X  	case DOOR:
X! 		if (room->doormask == D_NODOOR || room->doormask & D_BROKEN)
X! 		    tmp = NO_DOOR_SYM;
X! 		else if (room->doormask & (D_CLOSED|D_LOCKED))
X! 		    tmp = CLOSED_DOOR_SYM;
X! 		/* We know door is open. */
X! 		else {
X! 		    croom=inroom(x,y);
X! 		    if(croom == -1) {
X! #ifdef STRONGHOLD
X! 			if(IS_WALL(levl[x-1][y].typ)||IS_WALL(levl[x+1][y].typ))
X! 			    tmp = H_OPEN_DOOR_SYM;
X! 			else
X! 			    tmp = V_OPEN_DOOR_SYM;
X! #else
X! 			impossible("door %d %d not in room",x,y);
X! #endif
X! 		    } else if(rooms[croom].ly<=y && y<=rooms[croom].hy)
X! 			tmp = V_OPEN_DOOR_SYM;
X! 		    else
X! 			tmp = H_OPEN_DOOR_SYM;
X! 		}
X  		break;
X  	case CORR:
X  		tmp = CORR_SYM;
X***************
X*** 424,430 ****
X  
X  	if(!isok(x,y)) return;
X  	room = &levl[x][y];
X! 	if(room->scrsym == ROOM_SYM && !room->lit && !Blind) {
X  		room->scrsym = STONE_SYM;	/* was ' ' -- OIS */
X  		room->new = 1;
X  		on_scr(x,y);
X--- 450,457 ----
X  
X  	if(!isok(x,y)) return;
X  	room = &levl[x][y];
X! 	if(IS_FLOOR(levl[x][y].typ)
X! 	   && !room->lit && !Blind) {
X  		room->scrsym = STONE_SYM;	/* was ' ' -- OIS */
X  		room->new = 1;
X  		on_scr(x,y);
X***************
X*** 484,493 ****
X  	if(x == u.ux && y == u.uy && !Invisible) return(1);
X  
X  	if(MON_AT(x, y))
X! 		if (Blind && Telepat || canseemon(m_at(x,y)))
X! 		    return(1);
X! 		else return ((HTelepat & WORN_HELMET) &&
X! 			     (dist(x, y) <= (BOLT_LIM * BOLT_LIM)));
X  	return(0);
X  }
X  
X--- 511,517 ----
X  	if(x == u.ux && y == u.uy && !Invisible) return(1);
X  
X  	if(MON_AT(x, y))
X! 		return(showmon(m_at(x,y)));
X  	return(0);
X  }
X  
X***************
X*** 539,541 ****
X--- 563,664 ----
X  	}
X  }
X  #endif
X+ 
X+ 
X+ #ifdef STUPID_CPP	/* otherwise these functions are macros in rm.h */
X+ boolean IS_WALL(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ && typ <= TRWALL);
X+ }
X+ 
X+ boolean IS_STWALL(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ <= TRWALL);			/* STONE <= (typ) <= TRWALL */
X+ }
X+ 
X+ boolean IS_ROCK(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ < POOL);			/* absolutely nonaccessible */
X+ }
X+ 
X+ boolean IS_DOOR(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ == DOOR);
X+ }
X+ 
X+ boolean IS_FLOOR(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ == ROOM);
X+ }
X+ 
X+ boolean ACCESSIBLE(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ >= DOOR);			/* good position */
X+ }
X+ 
X+ boolean IS_ROOM(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ >= ROOM);			/* ROOM, STAIRS, furniture.. */
X+ }
X+ 
X+ boolean ZAP_POS(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ >= POOL);
X+ }
X+ 
X+ boolean SPACE_POS(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ > DOOR);
X+ }
X+ 
X+ boolean IS_POOL(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ >= POOL && typ <= DRAWBRIDGE_UP);
X+ }
X+ 
X+ boolean IS_THRONE(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ == THRONE);
X+ }
X+ 
X+ boolean IS_FOUNTAIN(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ == FOUNTAIN);
X+ }
X+ 
X+ boolean IS_SINK(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ == SINK);
X+ }
X+ 
X+ boolean IS_ALTAR(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ == ALTAR);
X+ }
X+ 
X+ boolean IS_DRAWBRIDGE(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ == DRAWBRIDGE_UP || typ == DRAWBRIDGE_DOWN);
X+ }
X+ 
X+ boolean IS_FURNITURE(typ)
X+ unsigned typ;
X+ {
X+ 	return(typ >= STAIRS && typ <= ALTAR);
X+ }
X+ #endif /* STUPID_CPP */
END_OF_FILE
if test 55338 -ne `wc -c <'patches06j'`; then
    echo shar: \"'patches06j'\" unpacked with wrong size!
fi
# end of 'patches06j'
fi
echo shar: End of archive 4 \(of 15\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
