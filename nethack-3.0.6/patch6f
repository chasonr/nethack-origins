Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i059:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6f
Message-ID: <4848@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:49:25 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2137
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 59
Archive-name: NetHack3/Patch6f
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 15)."
# Contents:  patches06g
# Wrapped by billr@saab on Wed Nov 22 10:50:11 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches06g' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06g'\"
else
echo shar: Extracting \"'patches06g'\" \(54581 characters\)
sed "s/^X//" >'patches06g' <<'END_OF_FILE'
X*** src/Old/exper.c	Sun Nov 19 12:40:48 1989
X--- src/exper.c	Wed Nov  8 19:39:17 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)exper.c	3.0	89/04/21
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)exper.c	3.0	89/11/08
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 15,21 ****
X  	return(0L * lev);
X  #else
X  	if(lev < 10) return (10L*(1L << lev));
X! 	if(lev < 20) return (10000L*(1L << lev-10));
X  	return (10000000L*(lev-19));
X  #endif
X  }
X--- 15,21 ----
X  	return(0L * lev);
X  #else
X  	if(lev < 10) return (10L*(1L << lev));
X! 	if(lev < 20) return (10000L*(1L << (lev-10)));
X  	return (10000000L*(lev-19));
X  #endif
X  }
X*** src/Old/extralev.c	Sun Nov 19 12:41:04 1989
X--- src/extralev.c	Tue Oct 31 22:18:58 1989
X***************
X*** 29,36 ****
X--- 29,40 ----
X  int horiz;
X  {
X  	register int x,y,middle;
X+ #ifndef MAX
X  #define MAX(a,b) (((a) > (b)) ? (a) : (b))
X+ #endif
X+ #ifndef MIN
X  #define MIN(a,b) (((a) < (b)) ? (a) : (b))
X+ #endif
X  	if (horiz) {
X  		middle = x1 + rn2(x2-x1+1);
X  		for(x=MIN(x1,middle); x<=MAX(x1,middle); x++)
X***************
X*** 71,76 ****
X--- 75,81 ----
X  									fromy);
X  			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X  			levl[fromx][fromy].doormask = D_NODOOR;
X+ 			mnewsym(fromx,fromy);
X  			fromy++;
X  		}
X  		if(y >= 2) {
X***************
X*** 90,95 ****
X--- 95,101 ----
X  				impossible("up: no wall at %d,%d?",tox,toy);
X  			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X  			levl[tox][toy].doormask = D_NODOOR;
X+ 			mnewsym(tox,toy);
X  			toy--;
X  		}
X  		roguejoin(fromx, fromy, tox, toy, FALSE);
X***************
X*** 108,113 ****
X--- 114,120 ----
X  									fromy);
X  			dodoor(fromx, fromy, &rooms[r[x][y].nroom]);
X  			levl[fromx][fromy].doormask = D_NODOOR;
X+ 			mnewsym(fromx,fromy);
X  			fromx++;
X  		}
X  		if(x >= 2) {
X***************
X*** 127,132 ****
X--- 134,140 ----
X  				impossible("left: no wall at %d,%d?",tox,toy);
X  			dodoor(tox, toy, &rooms[r[x][y].nroom]);
X  			levl[tox][toy].doormask = D_NODOOR;
X+ 			mnewsym(tox,toy);
X  			tox--;
X  		}
X  		roguejoin(fromx, fromy, tox, toy, TRUE);
X***************
X*** 307,312 ****
X--- 315,321 ----
X  
X  void
X  corr(x,y)
X+ int x, y;
X  {
X  	if (rn2(50)) {
X  		levl[x][y].typ = CORR;
X***************
X*** 313,319 ****
X  		levl[x][y].scrsym = CORR_SYM;
X  	} else {
X  		levl[x][y].typ = SCORR;
X! 		levl[x][y].scrsym = STONE_SYM;
X  	}
X  }
X  
X--- 322,328 ----
X  		levl[x][y].scrsym = CORR_SYM;
X  	} else {
X  		levl[x][y].typ = SCORR;
X! 		levl[x][y].scrsym = ' ';	/* _not_ STONE_SYM */
X  	}
X  }
X  
X*** src/Old/fountain.c	Sun Nov 19 12:41:22 1989
X--- src/fountain.c	Sat Nov 18 21:17:32 1989
X***************
X*** 85,92 ****
X  		     
X  	    levl[mx][my].typ = POOL;
X  	    levl[mx][my].doormask = 0;
X! 	    if(!Blind) atl(mx,my,(char) POOL_SYM);
X! 	    else levl[mx][my].seen = 0;
X  	    madepool = 1;
X  	}
X  
X--- 85,93 ----
X  		     
X  	    levl[mx][my].typ = POOL;
X  	    levl[mx][my].doormask = 0;
X! 	    mnewsym(mx,my);
X! 	    if (cansee(mx, my))
X! 		prl(mx, my);
X  	    madepool = 1;
X  	}
X  
X***************
X*** 99,105 ****
X  
X  	if (!Blind) You("spot a gem in the sparkling waters!");
X  	(void) mkobj_at(GEM_SYM,u.ux,u.uy);
X! 	levl[u.ux][u.uy].doormask = T_LOOTED;
X  }
X  
X  void
X--- 100,106 ----
X  
X  	if (!Blind) You("spot a gem in the sparkling waters!");
X  	(void) mkobj_at(GEM_SYM,u.ux,u.uy);
X! 	levl[u.ux][u.uy].looted = T_LOOTED;
X  }
X  
X  void
X***************
X*** 107,113 ****
X  	if (!rn2(3) && IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X  		pline("The fountain dries up!");
X  		levl[u.ux][u.uy].typ = ROOM;
X! 		levl[u.ux][u.uy].doormask = 0;
X  		if(Invisible) newsym(u.ux, u.uy);
X  		fountsound--;
X  	}
X--- 108,114 ----
X  	if (!rn2(3) && IS_FOUNTAIN(levl[u.ux][u.uy].typ)) {
X  		pline("The fountain dries up!");
X  		levl[u.ux][u.uy].typ = ROOM;
X! 		levl[u.ux][u.uy].looted = 0;
X  		if(Invisible) newsym(u.ux, u.uy);
X  		fountsound--;
X  	}
X***************
X*** 131,137 ****
X  
X  		case 19: /* Self-knowledge */
X  
X! 			You("feel self-knowledgable...");
X  			more();
X  			enlightenment();
X  			pline("The feeling subsides.");
X--- 132,138 ----
X  
X  		case 19: /* Self-knowledge */
X  
X! 			You("feel self-knowledgeable...");
X  			more();
X  			enlightenment();
X  			pline("The feeling subsides.");
X***************
X*** 193,199 ****
X  
X  		case 27: /* Find a gem in the sparkling waters. */
X  
X! 			if (levl[u.ux][u.uy].doormask == 0) {
X  				dofindgem();
X  				break;
X  			}
X--- 194,200 ----
X  
X  		case 27: /* Find a gem in the sparkling waters. */
X  
X! 			if (!levl[u.ux][u.uy].looted) {
X  				dofindgem();
X  				break;
X  			}
X***************
X*** 230,274 ****
X  dipfountain(obj)
X  register struct obj *obj;
X  {
X! 	register int fate = rnd(30);
X  
X! 	if(Levitation)	You("are floating high above the fountain.");
X! 	else if(fate<10)
X! 		if(!obj->rustfree && is_sword(obj)) {
X! 			if(obj->spe > -6) {
X! 				Your("sword rusts somewhat.");
X! 				obj->spe--;
X! 			} else Your("sword looks quite rusted.");
X! 		} else pline("Well, it looks wet now.");
X! 	else if(fate<14)
X! 		if(obj->otyp == LONG_SWORD
X  #ifndef NAMED_ITEMS
X! 		   && !strcmp(ONAME(obj), "Excalibur")
X  #endif
X! 		   && u.ulevel >= 5
X! 		) {
X! 			/* The lady of the lake acts! - Eric Backus */
X! 			/* Be *REAL* nice to him */
X  	pline("A murky hand from the depths reaches up to bless the sword.");
X  	pline("As the hand retreats, the fountain disappears!");
X  
X  #ifndef NAMED_ITEMS
X! 			if(obj->spe < 5) obj->spe = 5;
X  #else
X! 			/* otherwise +rnd(10) / +5 "Super"sword */
X! 			obj = oname(obj, "Excalibur", 1);
X  #endif
X! 			bless(obj);
X! 			obj->rustfree = 1;
X! 			levl[u.ux][u.uy].typ = ROOM;
X! 			if(Invisible) newsym(u.ux, u.uy);
X! 			fountsound--;
X! 			return;
X! 		} else pline ("Well, it looks wet now.");
X! 	else {
X! 	    switch (fate) {
X  		case 16: /* Curse the item */
X- 			pline("Well, it looks wet now.");
X  			curse(obj);
X  			break;
X  		case 17:
X--- 231,268 ----
X  dipfountain(obj)
X  register struct obj *obj;
X  {
X! 	if (Levitation) {
X! 		You("are floating high above the fountain.");
X! 		return;
X! 	}
X  
X! 	if (obj->otyp == LONG_SWORD && u.ulevel >= 5 && !rn2(6)
X  #ifndef NAMED_ITEMS
X! 	    && !strcmp(ONAME(obj), "Excalibur")
X  #endif
X! 	   ) {
X! 		/* The lady of the lake acts! - Eric Backus */
X! 		/* Be *REAL* nice */
X  	pline("A murky hand from the depths reaches up to bless the sword.");
X  	pline("As the hand retreats, the fountain disappears!");
X  
X  #ifndef NAMED_ITEMS
X! 		if(obj->spe < 5) obj->spe = 5;
X  #else
X! 		/* otherwise +rnd(10) / +5 "Super"sword */
X! 		obj = oname(obj, "Excalibur", 1);
X  #endif
X! 		bless(obj);
X! 		obj->rustfree = 1;
X! 		levl[u.ux][u.uy].typ = ROOM;
X!                 levl[u.ux][u.uy].looted = 0;
X! 		if(Invisible) newsym(u.ux, u.uy);
X! 		fountsound--;
X! 		return;
X! 	} else (void) get_wet(obj);
X! 
X! 	switch (rnd(30)) {
X  		case 16: /* Curse the item */
X  			curse(obj);
X  			break;
X  		case 17:
X***************
X*** 289,295 ****
X  		case 22: /* Water Nymph */
X  			dowaternymph();
X  			break;
X! 		case 23: /* An Endless Stream Of Snakes */
X  			dowatersnakes();
X  			break;
X  		case 24: /* Find a gem */
X--- 283,289 ----
X  		case 22: /* Water Nymph */
X  			dowaternymph();
X  			break;
X! 		case 23: /* an Endless Stream of Snakes */
X  			dowatersnakes();
X  			break;
X  		case 24: /* Find a gem */
X***************
X*** 308,330 ****
X  		case 28: /* Strange feeling */
X  			pline("An urge to take a bath overwhelms you.");
X  			if (u.ugold > 10) {
X! 			     	u.ugold -= somegold()/10;
X! 			  You("lost some of your gold in the fountain!");
X! 			  levl[u.ux][u.uy].doormask = 0;
X! 	 		}
X  			break;
X  		case 29: /* You see coins */
X  
X  		/* We make fountains have more coins the closer you are to the
X  		 * surface.  After all, there will have been more people going
X! 		 * by.  Just like a shopping mall!  Chris Woodbury  */
X  
X! 			mkgold((long)(rnd((MAXLEVEL-dlevel)*2)+5),u.ux,u.uy);
X  		pline("Far below you, you see coins glistening in the water.");
X  			break;
X- 		default:
X- 			break;
X- 	    }
X  	}
X  	dryup();
X  	return;
X--- 302,321 ----
X  		case 28: /* Strange feeling */
X  			pline("An urge to take a bath overwhelms you.");
X  			if (u.ugold > 10) {
X! 			    u.ugold -= somegold() / 10;
X! 			    You("lost some of your gold in the fountain!");
X! 			    levl[u.ux][u.uy].looted = 0;
X! 			}
X  			break;
X  		case 29: /* You see coins */
X  
X  		/* We make fountains have more coins the closer you are to the
X  		 * surface.  After all, there will have been more people going
X! 		 * by.	Just like a shopping mall!  Chris Woodbury  */
X  
X! 			mkgold((long)(rnd((MAXLEVEL-dlevel)*2)+5), u.ux, u.uy);
X  		pline("Far below you, you see coins glistening in the water.");
X  			break;
X  	}
X  	dryup();
X  	return;
X***************
X*** 377,386 ****
X  			(void) dopotion(otmp);
X  			obfree(otmp, (struct obj *)0);
X  			break;
X! 		case 5: if (levl[u.ux][u.uy].doormask == 0) {
X  			    You("find a ring in the sink!");
X  			    (void) mkobj_at(RING_SYM, u.ux, u.uy);
X! 			    levl[u.ux][u.uy].doormask = T_LOOTED;
X  			} else pline("Some dirty water backs up in the drain.");
X  			break;
X  		case 6: pline("The pipes break!  Water spurts out!");
X--- 368,377 ----
X  			(void) dopotion(otmp);
X  			obfree(otmp, (struct obj *)0);
X  			break;
X! 		case 5: if (!levl[u.ux][u.uy].looted) {
X  			    You("find a ring in the sink!");
X  			    (void) mkobj_at(RING_SYM, u.ux, u.uy);
X! 			    levl[u.ux][u.uy].looted = T_LOOTED;
X  			} else pline("Some dirty water backs up in the drain.");
X  			break;
X  		case 6: pline("The pipes break!  Water spurts out!");
X*** src/Old/getline.c	Sun Nov 19 12:41:43 1989
X--- src/getline.c	Sun Nov  5 16:15:49 1989
X***************
X*** 165,171 ****
X  	}
X  	in_line[0] = foo;
X  	in_line[1] = 0;
X! 	if(foo == 'g' || foo == 'G'){
X  		in_line[1] = Getchar();
X  #ifdef REDO
X  		savech(in_line[1]);
X--- 165,171 ----
X  	}
X  	in_line[0] = foo;
X  	in_line[1] = 0;
X! 	if(foo == 'g' || foo == 'G' || (flags.num_pad && foo == '5')){
X  		in_line[1] = Getchar();
X  #ifdef REDO
X  		savech(in_line[1]);
X*** src/Old/hack.c	Sun Nov 19 12:42:00 1989
X--- src/hack.c	Wed Nov  8 22:56:43 1989
X***************
X*** 4,10 ****
X  #include "hack.h"
X  
X  #if defined(UNIX) && !defined(LINT)
X! static	const char	SCCS_Id[] = "@(#)hack.c	3.0\t88/10/25";
X  #endif
X  
X  /* called on movement:
X--- 4,10 ----
X  #include "hack.h"
X  
X  #if defined(UNIX) && !defined(LINT)
X! static	const char	SCCS_Id[] = "@(#)hack.c	3.0\t89/11/03";
X  #endif
X  
X  /* called on movement:
X***************
X*** 24,30 ****
X  	    for(y = u.uy-1; y < u.uy+2; y++) {
X  		if(!isok(x, y)) continue;
X  		lev = &levl[x][y];
X! 		if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			lev->scrsym = STONE_SYM;
X  			lev->new = 1;
X  			on_scr(x,y);
X--- 24,30 ----
X  	    for(y = u.uy-1; y < u.uy+2; y++) {
X  		if(!isok(x, y)) continue;
X  		lev = &levl[x][y];
X! 		if(!lev->lit && IS_FLOOR(lev->typ)){
X  			lev->scrsym = STONE_SYM;
X  			lev->new = 1;
X  			on_scr(x,y);
X***************
X*** 46,52 ****
X  	in trap.c:   seeoff(1)	- fall through trapdoor
X   */
X  void
X! seeoff(mode) {	/* 1 to redo @, 0 to leave them */
X  		/* 1 means misc movement, 0 means blindness */
X  	register xchar x,y;
X  	register struct rm *lev;
X--- 46,54 ----
X  	in trap.c:   seeoff(1)	- fall through trapdoor
X   */
X  void
X! seeoff(mode)
X! int mode;
X! {		/* 1 to redo @, 0 to leave them */
X  		/* 1 means misc movement, 0 means blindness */
X  	register xchar x,y;
X  	register struct rm *lev;
X***************
X*** 65,71 ****
X  			lev = &levl[x][y];
X  			if(MON_AT(x, y))
X  			    unpmon(m_at(x,y));
X! 			if(!lev->lit && lev->scrsym == ROOM_SYM) {
X  			    lev->seen = 0;
X  			    atl(x, y, (char)STONE_SYM);
X  			}
X--- 67,73 ----
X  			lev = &levl[x][y];
X  			if(MON_AT(x, y))
X  			    unpmon(m_at(x,y));
X! 			if(!lev->lit && IS_FLOOR(lev->typ)) {
X  			    lev->seen = 0;
X  			    atl(x, y, (char)STONE_SYM);
X  			}
X***************
X*** 94,100 ****
X  		}
X  #endif
X  		if(isok(rx,ry) && !IS_ROCK(levl[rx][ry].typ) &&
X! 		    (!IS_DOOR(levl[rx][ry].typ) || !(u.dx && u.dy)) &&
X  		    !sobj_at(BOULDER, rx, ry)) {
X  			if(MON_AT(rx, ry)) {
X  			    mtmp = m_at(rx,ry);
X--- 96,106 ----
X  		}
X  #endif
X  		if(isok(rx,ry) && !IS_ROCK(levl[rx][ry].typ) &&
X! 		    (!IS_DOOR(levl[rx][ry].typ) || !(u.dx && u.dy) || (
X! #ifdef REINCARNATION
X! 			dlevel != rogue_level &&
X! #endif
X! 		     (levl[rx][ry].doormask & ~D_BROKEN) == D_NODOOR)) &&
X  		    !sobj_at(BOULDER, rx, ry)) {
X  			if(MON_AT(rx, ry)) {
X  			    mtmp = m_at(rx,ry);
X***************
X*** 229,238 ****
X  # endif
X  		You("crash to the floor!");
X  		losehp((rn1(10, 20 - (int)ACURR(A_CON))),"fall onto a sink");
X! 		if(OBJ_AT(u.ux, u.uy))
X! 		for(obj=fobj; obj; obj=obj->nobj)
X! 		    if(obj->ox == u.ux && obj->oy == u.uy &&
X! 		       obj->olet == WEAPON_SYM) {
X  			You("fell on %s.",doname(obj));
X  			losehp(rn2(3),"fall onto a sink");
X  		    }
X--- 235,242 ----
X  # endif
X  		You("crash to the floor!");
X  		losehp((rn1(10, 20 - (int)ACURR(A_CON))),"fall onto a sink");
X! 		for(obj = level.objects[u.ux][u.uy]; obj; obj = obj->nexthere)
X! 		    if(obj->olet == WEAPON_SYM) {
X  			You("fell on %s.",doname(obj));
X  			losehp(rn2(3),"fall onto a sink");
X  		    }
X***************
X*** 451,459 ****
X  	if(bad_rock(x,y) ||
X  	   (u.dx && u.dy
X  #ifdef POLYSELF
X! 			&& !passes_walls(uasmon)
X  #endif
X- 			&& (IS_DOOR(tmpr->typ) || IS_DOOR(ust->typ)))){
X  		flags.move = 0;
X  		nomul(0);
X  		return;
X--- 455,471 ----
X  	if(bad_rock(x,y) ||
X  	   (u.dx && u.dy
X  #ifdef POLYSELF
X! 		    && !passes_walls(uasmon)
X! #endif
X! #ifdef REINCARNATION
X! 		    && (((IS_DOOR(tmpr->typ) && ((tmpr->doormask & ~D_BROKEN)
X! 				|| dlevel == rogue_level)) ||
X! 		        ((IS_DOOR(ust->typ) && ((ust->doormask & ~D_BROKEN)
X! 				|| dlevel == rogue_level))))))) {
X! #else
X! 		    && (((IS_DOOR(tmpr->typ) && (tmpr->doormask & ~D_BROKEN)) ||
X! 		      ((IS_DOOR(ust->typ) && (ust->doormask & ~D_BROKEN))))))){
X  #endif
X  		flags.move = 0;
X  		nomul(0);
X  		return;
X***************
X*** 521,527 ****
X  		} else {
X  			if (IS_WALL(tmpr->typ)) {
X  				digtxt = "You chew a hole in the wall.";
X! 				tmpr->typ = DOOR;
X  			} else if (tmpr->typ==SDOOR) {
X  				digtxt = "You chew through a secret door.";
X  				tmpr->typ = DOOR;
X--- 533,542 ----
X  		} else {
X  			if (IS_WALL(tmpr->typ)) {
X  				digtxt = "You chew a hole in the wall.";
X! 				if(!is_maze_lev)
X! 				  tmpr->typ = DOOR;
X! 				else
X! 				  tmpr->typ = ROOM;
X  			} else if (tmpr->typ==SDOOR) {
X  				digtxt = "You chew through a secret door.";
X  				tmpr->typ = DOOR;
X***************
X*** 537,542 ****
X--- 552,559 ----
X  			if(IS_DOOR(tmpr->typ) && (tmpr->doormask & D_TRAPPED)) {
X  				b_trapped("door");
X  				tmpr->doormask = D_NODOOR;
X+ 				mnewsym(x, y);
X+ 				prl(x, y);
X  			}
X  			dig_level = -1;
X  		}
X***************
X*** 696,701 ****
X--- 713,721 ----
X  #endif
X  	if(Blind || flags.run == 0) return;
X  	for(x = u.ux-1; x <= u.ux+1; x++) for(y = u.uy-1; y <= u.uy+1; y++) {
X+ #ifdef POLYSELF
X+ 		if(u.umonnum == PM_GRID_BUG && x != u.ux && y != u.uy) continue;
X+ #endif
X  		if(x == u.ux && y == u.uy) continue;
X  		if(MON_AT(x, y) && (mtmp = m_at(x,y)) && !mtmp->mimic &&
X  		    (!mtmp->minvis || See_invisible) && !mtmp->mundetected) {
X***************
X*** 707,714 ****
X  		{
X  		register uchar sym = levl[x][y].scrsym;
X  
X! 		if (IS_ROCK(levl[x][y].typ) || sym == ROOM_SYM) continue;
X! 		else if (sym == DOOR_SYM) {
X  			if(x != u.ux && y != u.uy) continue;
X  			if(flags.run != 1) goto stop;
X  			goto bcorr;
X--- 727,736 ----
X  		{
X  		register uchar sym = levl[x][y].scrsym;
X  
X! 		if (IS_ROCK(levl[x][y].typ) ||
X! 		   (sym == ROOM_SYM && !IS_DOOR(levl[x][y].typ)))
X! 		     continue;
X! 		else if (sym == CLOSED_DOOR_SYM) {
X  			if(x != u.ux && y != u.uy) continue;
X  			if(flags.run != 1) goto stop;
X  			goto bcorr;
X***************
X*** 927,933 ****
X  void
X  losehp(n, knam)
X  	register int n;
X! 	register char *knam;
X  {
X  #ifdef POLYSELF
X  	if (u.mtimedone) {
X--- 949,955 ----
X  void
X  losehp(n, knam)
X  	register int n;
X! 	register const char *knam;
X  {
X  #ifdef POLYSELF
X  	if (u.mtimedone) {
X***************
X*** 943,949 ****
X  		u.uhpmax = u.uhp;	/* perhaps n was negative */
X  	flags.botl = 1;
X  	if(u.uhp < 1) {
X! 		killer = knam;	/* the thing that killed you */
X  		You("die...");
X  		done(DIED);
X  	} else if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50 && n > 0){
X--- 965,971 ----
X  		u.uhpmax = u.uhp;	/* perhaps n was negative */
X  	flags.botl = 1;
X  	if(u.uhp < 1) {
X! 		killer = (char *)knam;	/* the thing that killed you */
X  		You("die...");
X  		done(DIED);
X  	} else if(u.uhp*10 < u.uhpmax && moves-wailmsg > 50 && n > 0){
X*** src/Old/invent.c	Sun Nov 19 12:42:44 1989
X--- src/invent.c	Tue Nov 14 21:24:36 1989
X***************
X*** 140,146 ****
X--- 140,148 ----
X  register struct obj *obj;
X  {
X  	if(obj->quan > 1){
X+ #ifndef NO_SIGNAL
X  		obj->in_use = FALSE;	/* no longer in use */
X+ #endif
X  		obj->quan--;
X  		obj->owt = weight(obj);
X  	} else {
X***************
X*** 252,259 ****
X  {
X  	register struct obj *otmp;
X  
X! 	if(OBJ_AT(x, y))
X! 	    for(otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X  		if(otmp->otyp == n)
X  		    return(otmp);
X  	return((struct obj *)0);
X--- 254,260 ----
X  {
X  	register struct obj *otmp;
X  
X! 	for(otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X  		if(otmp->otyp == n)
X  		    return(otmp);
X  	return((struct obj *)0);
X***************
X*** 282,287 ****
X--- 283,299 ----
X  	return((struct obj *) 0);
X  }
X  
X+ boolean
X+ have_lizard()
X+ {
X+ 	register struct obj *otmp;
X+ 
X+ 	for(otmp = invent; otmp; otmp = otmp->nobj)
X+ 		if(otmp->otyp == CORPSE && otmp->corpsenm == PM_LIZARD)
X+ 			return(TRUE);
X+ 	return(FALSE);
X+ }
X+ 
X  struct obj *
X  o_on(id, objchn)
X  unsigned int id;
X***************
X*** 294,299 ****
X--- 306,323 ----
X  	return((struct obj *) 0);
X  }
X  
X+ boolean
X+ obj_here(obj, x, y)
X+ register struct obj *obj;
X+ int x, y;
X+ {
X+ 	register struct obj *otmp;
X+ 
X+ 	for(otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X+ 		if(obj == otmp) return(TRUE);
X+ 	return(FALSE);
X+ }
X+ 
X  struct gold *
X  g_at(x,y)
X  register int x, y;
X***************
X*** 331,337 ****
X   */
X  struct obj *
X  getobj(let,word)
X! register char *let,*word;
X  {
X  	register struct obj *otmp;
X  	register char ilet,ilet1,ilet2;
X--- 355,361 ----
X   */
X  struct obj *
X  getobj(let,word)
X! register const char *let,*word;
X  {
X  	register struct obj *otmp;
X  	register char ilet,ilet1,ilet2;
X***************
X*** 395,400 ****
X--- 419,427 ----
X  		|| (!strcmp(word, "rub") &&
X  		    (otmp->olet == TOOL_SYM &&
X  		     otmp->otyp != LAMP && otmp->otyp != MAGIC_LAMP))
X+ 		|| (!strcmp(word, "wield") &&
X+ 		    (otmp->olet == TOOL_SYM &&
X+ 		     otmp->otyp != PICK_AXE && otmp->otyp != UNICORN_HORN))
X  		    )
X  			foo--;
X  	    }
X***************
X*** 540,546 ****
X  	return(otmp);
X  }
X  
X! static int
X  ckunpaid(otmp)
X  register struct obj *otmp;
X  {
X--- 567,576 ----
X  	return(otmp);
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X! int
X  ckunpaid(otmp)
X  register struct obj *otmp;
X  {
X***************
X*** 1033,1054 ****
X  
X      	cornline(0, "Things that are here:");
X      	for(otmp = otmp0; otmp; otmp = otmp->nexthere) {
X! 		if(otmp->ox == u.ux && otmp->oy == u.uy) {
X! 	    		ct++;
X! 	    		cornline(1, doname(otmp));
X  
X! 	    		if(Blind  && !uarmg &&
X  #ifdef POLYSELF
X! 			!resists_ston(uasmon) &&
X  #endif
X! 	       		(otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE)) {
X! 			    pline("Touching the dead cockatrice is a fatal mistake...");
X! 			    You("turn to stone...");
X! 			    killer = "cockatrice corpse";
X! 			    done(STONING);
X! 	    		}
X  		}
X!     	}
X  
X      	if(gold) {
X  		char gbuf[30];
X--- 1063,1082 ----
X  
X      	cornline(0, "Things that are here:");
X      	for(otmp = otmp0; otmp; otmp = otmp->nexthere) {
X! 		ct++;
X! 		cornline(1, doname(otmp));
X  
X! 		if(Blind  && !uarmg &&
X  #ifdef POLYSELF
X! 		    !resists_ston(uasmon) &&
X  #endif
X! 		    (otmp->otyp == CORPSE && otmp->corpsenm == PM_COCKATRICE)) {
X! 			pline("Touching the dead cockatrice is a fatal mistake...");
X! 			You("turn to stone...");
X! 			killer = "cockatrice corpse";
X! 			done(STONING);
X  		}
X! 	}
X  
X      	if(gold) {
X  		char gbuf[30];
X***************
X*** 1074,1084 ****
X  stackobj(obj)
X  register struct obj *obj;
X  {
X! 	register struct obj *otmp = fobj;
X! 	for(otmp = fobj; otmp; otmp = otmp->nobj) if(otmp != obj)
X! 		if(otmp->ox == obj->ox && otmp->oy == obj->oy &&
X! 			merged(obj,otmp,1))
X! 				break;
X  	return;
X  }
X  
X--- 1102,1112 ----
X  stackobj(obj)
X  register struct obj *obj;
X  {
X! 	register struct obj *otmp;
X! 
X! 	for(otmp = level.objects[obj->ox][obj->oy]; otmp; otmp = otmp->nexthere)
X! 		if(otmp != obj && merged(obj,otmp,1))
X! 			break;
X  	return;
X  }
X  
X***************
X*** 1097,1103 ****
X  	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X! 	else if(obj->olet == FOOD_SYM && obj->oeaten != otmp->oeaten)
X  		return(FALSE);
X  
X  	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X--- 1125,1132 ----
X  	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X! 	else if(obj->olet == FOOD_SYM && (obj->oeaten != otmp->oeaten ||
X! 		obj->orotten != otmp->orotten))
X  		return(FALSE);
X  
X  	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X***************
X*** 1205,1221 ****
X  }
X  
X  /*
X!  * useupf(obj)
X!  * uses up an object that's on the floor
X   */
X  void
X  useupf(obj)
X  register struct obj *obj;
X  {
X! 	if(obj->quan > 1)  {
X! 		obj->quan--;
X! 		obj->owt = weight(obj);
X! 	}  else delobj(obj);
X  }
X  
X  /*
X--- 1234,1255 ----
X  }
X  
X  /*
X!  * uses up an object that's on the floor, charging for it as necessary
X   */
X  void
X  useupf(obj)
X  register struct obj *obj;
X  {
X! 	register struct obj *otmp;
X! 
X! 	/* burn_floor_paper() keeps an object pointer that it tries to
X! 	 * useupf() multiple times, so obj must survive if plural */
X! 	if(obj->quan > 1)
X! 		otmp = splitobj(obj, (int)obj->quan - 1);
X! 	else
X! 		otmp = obj;
X! 	addtobill(otmp, FALSE);
X! 	delobj(otmp);
X  }
X  
X  /*
X***************
X*** 1241,1253 ****
X  let_to_name(let)
X  char let;
X  {
X! 	char *pos = index(obj_symbols, let);
X  	/* arbitrary buffer size by Tom May (tom@uw-warp) */
X  	static char *buf = NULL;
X  
X  	if (buf == NULL)
X! 	    buf = (char *) alloc ((unsigned)(strlen(HI)+strlen(HE)+15+1));
X! 
X  	if (pos == NULL) pos = obj_symbols;
X  	if (HI && HE)
X  	    Sprintf(buf, "%s%s%s", HI, names[pos - obj_symbols], HE);
X--- 1275,1292 ----
X  let_to_name(let)
X  char let;
X  {
X! 	const char *pos = index(obj_symbols, let);
X  	/* arbitrary buffer size by Tom May (tom@uw-warp) */
X  	static char *buf = NULL;
X  
X  	if (buf == NULL)
X! 	    buf = (char *) alloc ((unsigned)(strlen(HI)+17+strlen(HE)));
X! /* 
X!    THE ALLOC() *MUST* BE BIG ENOUGH TO ACCOMODATE THE LONGEST NAME PLUS A
X!    NULL BYTE: 
X! 			Boulders/Statues   +  '\0'
X! 			1234567890123456 = 16 + 1 = 17
X! */
X  	if (pos == NULL) pos = obj_symbols;
X  	if (HI && HE)
X  	    Sprintf(buf, "%s%s%s", HI, names[pos - obj_symbols], HE);
X*** src/Old/ioctl.c	Sun Nov 19 12:43:31 1989
X--- src/ioctl.c	Sun Nov 19 11:53:02 1989
X***************
X*** 13,19 ****
X  
X  #if defined(BSD) || defined(ULTRIX)
X  #include	<sgtty.h>
X! struct ltchars ltchars, ltchars0;
X  #else
X  #include	<termio.h>	/* also includes part of <sgtty.h> */
X  struct termio termio;
X--- 13,20 ----
X  
X  #if defined(BSD) || defined(ULTRIX)
X  #include	<sgtty.h>
X! struct ltchars ltchars;
X! struct ltchars ltchars0 = { -1, -1, -1, -1, -1, -1 }; /* turn all off */
X  #else
X  #include	<termio.h>	/* also includes part of <sgtty.h> */
X  struct termio termio;
X*** src/Old/lev_comp.l	Sun Nov 19 12:44:52 1989
X--- src/lev_comp.l	Mon Nov 13 21:23:17 1989
X***************
X*** 1,10 ****
X  %{
X! /*	SCCS Id: @(#)lev_lex.c	3.0	89/07/02
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #define LEV_LEX_C
X  
X  #include "hack.h"
X  #include "lev_comp.h"
X  #include "sp_lev.h"
X--- 1,14 ----
X  %{
X! /*	SCCS Id: @(#)lev_lex.c	3.0	89/11/08
X  /*	Copyright (c) 1989 by Jean-Christophe Collet */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #define LEV_LEX_C
X  
X+ /* block some unused #defines to avoid overloading some cpp's */
X+ #define MONDATA_H
X+ #define MONFLAG_H
X+ 
X  #include "hack.h"
X  #include "lev_comp.h"
X  #include "sp_lev.h"
X***************
X*** 13,18 ****
X--- 17,30 ----
X  #undef exit
X  #endif
X  
X+ #ifdef TOS
X+ extern YYSTYPE yylval;	/* this doesn't always get put in lev_comp.h */
X+ #endif
X+ 
X+ #ifdef MACOS
X+ #undef putchar
X+ #undef putc
X+ #endif
X  int line_number = 1;
X  
X  /* This is *** UGLY *** but I can't think a better way to do it
X***************
X*** 25,42 ****
X  %}
X  %s MAPC
X  %%
X- ^#.*\n		{ line_number++; }
X- MAZE		return MAZE_ID;
X- LEVEL		return LEVEL_ID;
X- GEOMETRY	return GEOMETRY_ID;
X- ^MAP\n		{ BEGIN MAPC; }
X  <MAPC>[-|}{+SK\\#. ]*\n	{ line_number++; yymore(); }	
X  <MAPC>ENDMAP\n	{ BEGIN 0;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X! 		  strcpy(yylval.map, yytext+1);
X  		  return MAP_ID;
X  		}
X  OBJECT		return OBJECT_ID;
X  MONSTER		return MONSTER_ID;
X  TRAP		return TRAP_ID;
X--- 37,55 ----
X  %}
X  %s MAPC
X  %%
X  <MAPC>[-|}{+SK\\#. ]*\n	{ line_number++; yymore(); }	
X  <MAPC>ENDMAP\n	{ BEGIN 0;
X+ 		  line_number++;
X  		  yytext[yyleng-7] = 0; /* Discard \nENDMAP */
X  		  yylval.map = (char *) alloc(strlen(yytext)+1);
X! 		  strcpy(yylval.map, yytext);
X  		  return MAP_ID;
X  		}
X+ ^#.*\n		{ line_number++; }
X+ MAZE		return MAZE_ID;
X+ LEVEL		return LEVEL_ID;
X+ GEOMETRY	return GEOMETRY_ID;
X+ ^MAP\n		{ BEGIN MAPC; line_number++; }
X  OBJECT		return OBJECT_ID;
X  MONSTER		return MONSTER_ID;
X  TRAP		return TRAP_ID;
X*** src/Old/lev_comp.y	Sun Nov 19 12:45:08 1989
X--- src/lev_comp.y	Tue Nov 14 20:32:34 1989
X***************
X*** 10,15 ****
X--- 10,17 ----
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONDATA_H
X+ #define MONFLAG_H
X+ 
X  #include "hack.h"
X  #include "sp_lev.h"
X  #ifndef O_WRONLY
X***************
X*** 33,38 ****
X--- 35,46 ----
X  # undef exit
X  #endif
X  
X+ #ifdef MACOS
X+ # undef printf
X+ # undef Printf
X+ # define Printf printf
X+ #endif
X+ 
X  #define MAX_REGISTERS	10
X  #define ERR		(-1)
X  
X***************
X*** 109,115 ****
X  static altar *tmpaltar[256];
X  #endif /* ALTARS /**/
X  static lad *tmplad[256];
X! static dig *tmpdig[256];
X  static char *tmpmap[ROWNO];
X  static region *tmpreg[16];
X  static door *tmpdoor[256];
X--- 117,123 ----
X  static altar *tmpaltar[256];
X  #endif /* ALTARS /**/
X  static lad *tmplad[256];
X! static digpos *tmpdig[256];
X  static char *tmpmap[ROWNO];
X  static region *tmpreg[16];
X  static door *tmpdoor[256];
X***************
X*** 153,163 ****
X  %token	<i> MAZE_ID LEVEL_ID GEOMETRY_ID
X  %token	<i> OBJECT_ID MONSTER_ID TRAP_ID DOOR_ID DRAWBRIDGE_ID MAZEWALK_ID
X  %token	<i> REGION_ID RANDOM_OBJECTS_ID RANDOM_MONSTERS_ID RANDOM_PLACES_ID
X! %token	<i> ALTAR_ID LADDER_ID NON_DIGGABLE_ID ROOM_ID 
X  %token	<i> DOOR_STATE LIGHT_STATE
X  %token	<i> DIRECTION RANDOM_TYPE O_REGISTER M_REGISTER P_REGISTER A_REGISTER
X  %token	<i> ALIGNMENT LEFT_OR_RIGHT CENTER TOP_OR_BOT ALTAR_TYPE UP_OR_DOWN
X! %token  <i> ',' ':' '(' ')' '[' ']'
X  %token	<map> STRING MAP_ID
X  %type	<map> string maze_def m_name o_name
X  %start	file
X--- 161,171 ----
X  %token	<i> MAZE_ID LEVEL_ID GEOMETRY_ID
X  %token	<i> OBJECT_ID MONSTER_ID TRAP_ID DOOR_ID DRAWBRIDGE_ID MAZEWALK_ID
X  %token	<i> REGION_ID RANDOM_OBJECTS_ID RANDOM_MONSTERS_ID RANDOM_PLACES_ID
X! %token	<i> ALTAR_ID LADDER_ID NON_DIGGABLE_ID ROOM_ID
X  %token	<i> DOOR_STATE LIGHT_STATE
X  %token	<i> DIRECTION RANDOM_TYPE O_REGISTER M_REGISTER P_REGISTER A_REGISTER
X  %token	<i> ALIGNMENT LEFT_OR_RIGHT CENTER TOP_OR_BOT ALTAR_TYPE UP_OR_DOWN
X! %token	<i> ',' ':' '(' ')' '[' ']'
X  %token	<map> STRING MAP_ID
X  %type	<map> string maze_def m_name o_name
X  %start	file
X***************
X*** 179,187 ****
X  				  fprintf(stderr,"%s : %d errors detected. No output created!\n", fname, fatal_error);
X  			  else {
X  				  fout = open($1, O_WRONLY | O_CREAT
X! #ifdef MSDOS
X  					      | O_BINARY
X! #endif /* MSDOS */
X  					      , 0644);
X  				  if (fout < 0) {
X  					  yyerror("Can't open output file!!");
X--- 187,195 ----
X  				  fprintf(stderr,"%s : %d errors detected. No output created!\n", fname, fatal_error);
X  			  else {
X  				  fout = open($1, O_WRONLY | O_CREAT
X! #if defined(MSDOS) || defined(MACOS)
X  					      | O_BINARY
X! #endif /* MSDOS || MACOS */
X  					      , 0644);
X  				  if (fout < 0) {
X  					  yyerror("Can't open output file!!");
X***************
X*** 202,211 ****
X  			  $$ = $3;
X  		  }
X  
X! regions		: aregion
X  		| regions aregion;
X  
X! aregion		: map_definition reg_init map_details
X  		  {
X  			store_part();
X  		  }
X--- 210,219 ----
X  			  $$ = $3;
X  		  }
X  
X! regions 	: aregion
X  		| regions aregion;
X  
X! aregion 	: map_definition reg_init map_details
X  		  {
X  			store_part();
X  		  }
X***************
X*** 341,347 ****
X  			  if (!$5)
X  			      tmpmonst[nmons]->id = -1;
X  			  else {
X! 				  token = get_monster_id($5, (char) $<i>3);  
X  				  if (token == ERR) {
X  				      yywarning("Illegal monster name!  Making random monster.");
X  				      tmpmonst[nmons]->id = -1;
X--- 349,355 ----
X  			  if (!$5)
X  			      tmpmonst[nmons]->id = -1;
X  			  else {
X! 				  token = get_monster_id($5, (char) $<i>3);
X  				  if (token == ERR) {
X  				      yywarning("Illegal monster name!  Making random monster.");
X  				      tmpmonst[nmons]->id = -1;
X***************
X*** 405,411 ****
X  			ndb++;
X  		   }
X  
X! mazewalk_detail	: MAZEWALK_ID ':' coordinate ',' DIRECTION
X  		  {
X  			tmpwalk[nwalk] = (walk *) alloc(sizeof(walk));
X  			tmpwalk[nwalk]->x = current_coord.x;
X--- 413,419 ----
X  			ndb++;
X  		   }
X  
X! mazewalk_detail : MAZEWALK_ID ':' coordinate ',' DIRECTION
X  		  {
X  			tmpwalk[nwalk] = (walk *) alloc(sizeof(walk));
X  			tmpwalk[nwalk]->x = current_coord.x;
X***************
X*** 423,431 ****
X  			nlad++;
X  		  }
X  
X! diggable_detail	: NON_DIGGABLE_ID ':' region
X  		  {
X! 			tmpdig[ndig] = (dig *) alloc(sizeof(dig));
X  			tmpdig[ndig]->x1 = current_region.x1;
X  			tmpdig[ndig]->y1 = current_region.y1;
X  			tmpdig[ndig]->x2 = current_region.x2;
X--- 431,439 ----
X  			nlad++;
X  		  }
X  
X! diggable_detail : NON_DIGGABLE_ID ':' region
X  		  {
X! 			tmpdig[ndig] = (digpos *) alloc(sizeof(digpos));
X  			tmpdig[ndig]->x1 = current_region.x1;
X  			tmpdig[ndig]->y1 = current_region.y1;
X  			tmpdig[ndig]->x2 = current_region.x2;
X***************
X*** 487,493 ****
X  
X  trap_name	: string
X  		  {
X! 		  	int token = get_trap_type($1);
X  			if (token == ERR)
X  				yyerror("unknown trap type!");
X  			$<i>$ = token;
X--- 495,501 ----
X  
X  trap_name	: string
X  		  {
X! 			int token = get_trap_type($1);
X  			if (token == ERR)
X  				yyerror("unknown trap type!");
X  			$<i>$ = token;
X***************
X*** 537,543 ****
X  			}
X  		  }
X  
X! o_register	: O_REGISTER '[' INTEGER ']' 
X  		  {
X  			if ( $3 >= MAX_REGISTERS ) {
X  				yyerror("Register Index overflow!");
X--- 545,551 ----
X  			}
X  		  }
X  
X! o_register	: O_REGISTER '[' INTEGER ']'
X  		  {
X  			if ( $3 >= MAX_REGISTERS ) {
X  				yyerror("Register Index overflow!");
X***************
X*** 566,572 ****
X  
X  place		: coord
X  
X! monster		: CHAR
X  		  {
X  			if (check_monster_char($1))
X  				$<i>$ = $1 ;
X--- 574,580 ----
X  
X  place		: coord
X  
X! monster 	: CHAR
X  		  {
X  			if (check_monster_char($1))
X  				$<i>$ = $1 ;
X***************
X*** 598,604 ****
X  
X  coord		: '(' INTEGER ',' INTEGER ')'
X  		  {
X! 		        if ($2 < 0 || $2 > max_x_map ||
X  			    $4 < 0 || $4 > max_y_map)
X  			    yyerror("Coordinates out of map range!");
X  			current_coord.x = $2;
X--- 606,612 ----
X  
X  coord		: '(' INTEGER ',' INTEGER ')'
X  		  {
X! 			if ($2 < 0 || $2 > max_x_map ||
X  			    $4 < 0 || $4 > max_y_map)
X  			    yyerror("Coordinates out of map range!");
X  			current_coord.x = $2;
X***************
X*** 607,613 ****
X  
X  region		: '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'
X  		  {
X! 		        if ($2 < 0 || $2 > max_x_map ||
X  			    $4 < 0 || $4 > max_y_map ||
X  			    $6 < 0 || $6 > max_x_map ||
X  			    $8 < 0 || $8 > max_y_map)
X--- 615,621 ----
X  
X  region		: '(' INTEGER ',' INTEGER ',' INTEGER ',' INTEGER ')'
X  		  {
X! 			if ($2 < 0 || $2 > max_x_map ||
X  			    $4 < 0 || $4 > max_y_map ||
X  			    $6 < 0 || $6 > max_x_map ||
X  			    $8 < 0 || $8 > max_y_map)
X***************
X*** 894,900 ****
X  	/* The non_diggable directives */
X  
X  	if(tmppart[npart]->ndig = ndig) {
X! 		tmppart[npart]->digs = (dig **) alloc(sizeof(dig*) * ndig);
X  		for(i=0;i<ndig;i++)
X  		    tmppart[npart]->digs[i] = tmpdig[i];
X  	}
X--- 902,908 ----
X  	/* The non_diggable directives */
X  
X  	if(tmppart[npart]->ndig = ndig) {
X! 		tmppart[npart]->digs = (digpos **) alloc(sizeof(digpos*) * ndig);
X  		for(i=0;i<ndig;i++)
X  		    tmppart[npart]->digs[i] = tmpdig[i];
X  	}
X***************
X*** 1039,1045 ****
X  	    /* The non_diggable directives */
X  	    (void) write(fd, &(pt->ndig), 1);
X  	    for(j=0;j<pt->ndig;j++) {
X! 		    (void) write(fd,(genericptr_t) pt->digs[j], sizeof(dig));
X  		    free(pt->digs[j]);
X  	    }
X  	    if (pt->ndig > 0)
X--- 1047,1053 ----
X  	    /* The non_diggable directives */
X  	    (void) write(fd, &(pt->ndig), 1);
X  	    for(j=0;j<pt->ndig;j++) {
X! 		    (void) write(fd,(genericptr_t) pt->digs[j], sizeof(digpos));
X  		    free(pt->digs[j]);
X  	    }
X  	    if (pt->ndig > 0)
X*** src/Old/lev_main.c	Sun Nov 19 12:46:16 1989
X--- src/lev_main.c	Sat Nov 11 17:29:56 1989
X***************
X*** 7,12 ****
X--- 7,13 ----
X   * and some useful functions needed by yacc
X   */
X  
X+ /* #include "hack.h"	/* uncomment for the Mac */
X  #include <stdio.h>
X  
X  #define MAX_ERRORS	25
X***************
X*** 21,26 ****
X--- 22,76 ----
X  {
X  	FILE *fin;
X  	int i;
X+ 
X+ #if defined(MACOS) && defined(SMALLDATA)
X+ # ifdef THINKC4
X+ #include <console.h>
X+ # endif
X+ #define YYLMAX	2048
X+ 	extern char	*yysbuf, *yytext, *yysptr;
X+ 	Handle temp;
X+ 	Str255 name;
X+ 	long	j;
X+ 	extern struct permonst *mons;
X+ 	extern struct objclass *objects;
X+ 
X+ 	/* sub in the Nethack resource filename */
X+ 	strcpy((char *)name, "\010NH3.rsrc");
X+ 	yysbuf = (char *)alloc(YYLMAX);
X+ 	yysptr = yysbuf;
X+ 	yytext = (char *)alloc(YYLMAX);
X+ 
X+ 	(void)OpenResFile(name);
X+ 	temp = GetResource(HACK_DATA, MONST_DATA);
X+ 	if (temp) {
X+ 		DetachResource(temp);
X+ 		MoveHHi(temp);
X+ 		HLock(temp);
X+ 		i = GetHandleSize(temp);
X+ 		mons = (struct permonst *)(*temp);
X+ 	} else {
X+ 		panic("Can't get MONST resource data.");
X+ 	}
X+ 	
X+ 	temp = GetResource(HACK_DATA, OBJECT_DATA);
X+ 	if (temp) {
X+ 		DetachResource(temp);
X+ 		MoveHHi(temp);
X+ 		HLock(temp);
X+ 		i = GetHandleSize(temp);
X+ 		objects = (struct objclass *)(*temp);
X+ 		for (j = 0; j< NROFOBJECTS+1; j++) {
X+ 			objects[j].oc_name = sm_obj[j].oc_name;
X+ 			objects[j].oc_descr = sm_obj[j].oc_descr;
X+ 		}
X+ 	} else {
X+ 		panic("Can't get OBJECT resource data.");
X+ 	}
X+ # ifdef THINKC4
X+ 	argc = ccommand(&argv);
X+ # endif
X+ #endif
X  
X  	if (argc == 1)		/* Read standard input */
X  	    yyparse();
X*** src/Old/lock.c	Sun Nov 19 12:46:30 1989
X--- src/lock.c	Sat Nov 11 17:29:37 1989
X***************
X*** 11,17 ****
X--- 11,19 ----
X  	int chance, usedtime;
X  } xlock;
X  
X+ #ifndef OVERLAY
X  static
X+ #endif
X  int
X  picklock() {	/* try to open/close a lock */
X  
X***************
X*** 59,64 ****
X--- 61,68 ----
X  	    if(xlock.door->doormask & D_TRAPPED) {
X  		    b_trapped("door");
X  		    xlock.door->doormask = D_NODOOR;
X+ 		    mnewsym(u.ux+u.dx, u.uy+u.dy);
X+ 		    prl(u.ux+u.dx, u.uy+u.dy);
X  	    } else if(xlock.door->doormask == D_LOCKED)
X  		xlock.door->doormask = D_CLOSED;
X  	    else xlock.door->doormask = D_LOCKED;
X***************
X*** 72,78 ****
X  	return((xlock.usedtime = 0));
X  }
X  
X! static
X  int
X  forcelock() {	/* try to force a locked chest */
X  
X--- 76,84 ----
X  	return((xlock.usedtime = 0));
X  }
X  
X! #ifndef OVERLAY
X! static 
X! #endif
X  int
X  forcelock() {	/* try to force a locked chest */
X  
X***************
X*** 182,227 ****
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) { /* pick the lock on a container */
X  	    c = 'n';			/* in case there are no boxes here */
X! 	    if(OBJ_AT(x, y))
X! 	    for(otmp = fobj; otmp; otmp = otmp->nobj)
X! 		if((otmp->ox == x) && (otmp->oy == y))
X! 		    if(Is_box(otmp) &&
X! 		       /* credit cards are only good for unlocking */
X! 		       (picktyp != CREDIT_CARD || otmp->olocked)) {
X! 			pline("There is %s here, %s the lock? ",
X! 			doname(otmp), (!otmp->olocked) ? "close" :
X! 			((picktyp == LOCK_PICK) ? "pick" : "open" ));
X! 
X! 			c = ynq();
X! 			if(c == 'q') return(0);
X! 			if(c == 'n') continue;
X! 
X! 			if(picktyp == KEY && otmp->spe != pick->spe) {
X! 				pline("The %s won't fit the lock.",xname(pick));
X! 				return(1);
X! 			}
X! 			switch(picktyp) {
X! 			    case CREDIT_CARD:
X! 				ch = ACURR(A_DEX)+(20*(pl_character[0] == 'R'));
X! 				break;
X! 			    case LOCK_PICK:
X! 				ch = 4*ACURR(A_DEX)+(25*(pl_character[0] == 'R'));
X! 				break;
X! 			    case SKELETON_KEY:
X! 				ch = 75 + ACURR(A_DEX);
X! 				break;
X! 			    case KEY:
X! 				ch = 1000;
X! 				break;
X! 			    default:	ch = 0;
X! 			}
X! 			if(otmp->cursed) ch /= 2;
X  
X! 			xlock.door_or_box = 0;
X! 			xlock.picktyp = picktyp;
X! 			xlock.box = otmp;
X! 			break;
X  		    }
X  	    if(c != 'y')
X  		return(0);		/* decided against all boxes */
X  	} else {			/* pick the lock in a door */
X--- 188,231 ----
X  	y = u.uy + u.dy;
X  	if((x == u.ux) && (y == u.uy)) { /* pick the lock on a container */
X  	    c = 'n';			/* in case there are no boxes here */
X! 	    for(otmp = level.objects[x][y]; otmp; otmp = otmp->nexthere)
X! 		if(Is_box(otmp) &&
X! 			       /* credit cards are only good for unlocking */
X! 			       (picktyp != CREDIT_CARD || otmp->olocked)) {
X! 		    pline("There is %s here, %s the lock? ",
X! 		    doname(otmp), (!otmp->olocked) ? "close" :
X! 		    ((picktyp == LOCK_PICK) ? "pick" : "open" ));
X! 
X! 		    c = ynq();
X! 		    if(c == 'q') return(0);
X! 		    if(c == 'n') continue;
X  
X! 		    if(picktyp == KEY && otmp->spe != pick->spe) {
X! 			    pline("The %s won't fit the lock.",xname(pick));
X! 			    return(1);
X! 		    }
X! 		    switch(picktyp) {
X! 			case CREDIT_CARD:
X! 			    ch = ACURR(A_DEX)+(20*(pl_character[0] == 'R'));
X! 			    break;
X! 			case LOCK_PICK:
X! 			    ch = 4*ACURR(A_DEX)+(25*(pl_character[0] == 'R'));
X! 			    break;
X! 			case SKELETON_KEY:
X! 			    ch = 75 + ACURR(A_DEX);
X! 			    break;
X! 			case KEY:
X! 			    ch = 1000;
X! 			    break;
X! 			default:	ch = 0;
X  		    }
X+ 		    if(otmp->cursed) ch /= 2;
X+ 
X+ 		    xlock.door_or_box = 0;
X+ 		    xlock.picktyp = picktyp;
X+ 		    xlock.box = otmp;
X+ 		    break;
X+ 		}
X  	    if(c != 'y')
X  		return(0);		/* decided against all boxes */
X  	} else {			/* pick the lock in a door */
X***************
X*** 329,360 ****
X  
X  	/* A lock is made only for the honest man, the thief will break it. */
X  	xlock.box = (struct obj *)0;
X! 	if(OBJ_AT(u.ux, u.uy))
X! 	for(otmp = fobj; otmp; otmp = otmp->nobj)
X! 	    if((otmp->ox == u.ux) && (otmp->oy == u.uy))
X! 		if(Is_box(otmp)) {
X! 		  if(otmp->olocked)
X  		    pline("There is %s here, force the lock? ", doname(otmp));
X! 		  else {
X  		    pline("There is a %s here, but it's already unlocked.",
X  			  xname(otmp));
X  		    continue;
X! 		  }
X  
X! 		  c = ynq();
X! 		  if(c == 'q') return(0);
X! 		  if(c == 'n') continue;
X  
X! 		  if(picktyp)
X  		    You("force your %s into a crack and pry.", xname(uwep));
X! 		  else
X  		    You("start bashing it with your %s.", xname(uwep));
X! 		  xlock.box = otmp;
X! 		  xlock.chance = objects[otmp->otyp].wldam * 2;
X! 		  xlock.picktyp = picktyp;
X! 		  xlock.usedtime = 0;
X! 		  break;
X! 		}
X  
X  	if(xlock.box)	set_occupation(forcelock, "forcing the lock", 0);
X  	else		You("decide not to force the issue.");
X--- 333,362 ----
X  
X  	/* A lock is made only for the honest man, the thief will break it. */
X  	xlock.box = (struct obj *)0;
X! 	for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere)
X! 	    if(Is_box(otmp)) {
X! 		if(otmp->olocked)
X  		    pline("There is %s here, force the lock? ", doname(otmp));
X! 		else {
X  		    pline("There is a %s here, but it's already unlocked.",
X  			  xname(otmp));
X  		    continue;
X! 		}
X  
X! 		c = ynq();
X! 		if(c == 'q') return(0);
X! 		if(c == 'n') continue;
X  
X! 		if(picktyp)
X  		    You("force your %s into a crack and pry.", xname(uwep));
X! 		else
X  		    You("start bashing it with your %s.", xname(uwep));
X! 		xlock.box = otmp;
X! 		xlock.chance = objects[otmp->otyp].wldam * 2;
X! 		xlock.picktyp = picktyp;
X! 		xlock.usedtime = 0;
X! 		break;
X! 	    }
X  
X  	if(xlock.box)	set_occupation(forcelock, "forcing the lock", 0);
X  	else		You("decide not to force the issue.");
X***************
X*** 374,380 ****
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X  	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X! 				mtmp->mappearance == DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X--- 376,382 ----
X  	if((x == u.ux) && (y == u.uy)) return(0);
X  
X  	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X! 				mtmp->mappearance == CLOSED_DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X***************
X*** 418,423 ****
X--- 420,427 ----
X  		door->doormask = D_NODOOR;
X  	    } else
X  		door->doormask = D_ISOPEN;
X+ 	    mnewsym(x,y);
X+ 	    prl(x,y);
X  	} else {
X  	    pline("The door resists!");
X  	}
X***************
X*** 460,466 ****
X  	}
X  
X  	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X! 				mtmp->mappearance == DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X--- 464,470 ----
X  	}
X  
X  	if(MON_AT(x, y) && (mtmp = m_at(x,y))->mimic && 
X! 				mtmp->mappearance == CLOSED_DOOR_SYM &&
X  				!Protection_from_shape_changers) {
X  		stumble_onto_mimic(mtmp);
X  		return(1);
X***************
X*** 506,511 ****
X--- 510,517 ----
X  	    if (rn2(25) < (ACURR(A_STR)+ACURR(A_DEX)+ACURR(A_CON))/3) {
X  		pline("The door closes.");
X  		door->doormask = D_CLOSED;
X+ 		mnewsym(x,y);
X+ 		prl(x,y);
X  	    }
X  	    else pline("The door resists!");
X  	}
X***************
X*** 561,570 ****
X  	      ) {
X  		door->typ = DOOR;
X  		door->doormask = D_CLOSED | (door->doormask & D_TRAPPED);
X! 		if(cansee(x,y)) {
X! 		    pline("A section of the wall opens up!");
X! 		    newsym(x,y);
X! 		}
X  		return(1);
X  	    } else
X  		return(0);
X--- 567,574 ----
X  	      ) {
X  		door->typ = DOOR;
X  		door->doormask = D_CLOSED | (door->doormask & D_TRAPPED);
X! 		if(cansee(x,y)) pline("A section of the wall opens up!");
X! 		mnewsym(x,y);
X  		return(1);
X  	    } else
X  		return(0);
X***************
X*** 608,613 ****
X--- 612,619 ----
X  			default: res = 0;
X  		}
X  		door->doormask = D_LOCKED | (door->doormask & D_TRAPPED);
X+ 		mnewsym(x,y);
X+ 		if(cansee(x,y)) prl(x,y);
X  		break;
X  	    case WAN_OPENING:
X  #ifdef SPELLS
X***************
X*** 632,637 ****
X--- 638,645 ----
X  			    else if (flags.soundok)
X  			       You("hear a distant explosion.");
X  			door->doormask = D_NODOOR;
X+ 			mnewsym(x,y);
X+ 			if (cansee(x,y)) prl(x,y);
X  			break;
X  		    }
X  		    door->doormask = D_BROKEN;
X***************
X*** 640,645 ****
X--- 648,655 ----
X  			    pline("The door crashes open!");
X  			else if (flags.soundok)
X  			    You("hear a crashing sound.");
X+ 		    mnewsym(x,y);
X+ 		    if (cansee(x,y)) prl(x,y);
X  		} else res = 0;
X  		break;
X  	    default:	impossible("magic (%d) attempted on door.", otmp->otyp);
X*** src/Old/makemon.c	Sun Nov 19 13:40:51 1989
X--- src/makemon.c	Fri Nov 17 19:31:44 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)makemon.c	3.0	88/04/11
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)makemon.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 5,16 ****
X  #include	"hack.h"
X  
X  struct monst zeromonst;
X! static int uncommon P((struct permonst *));
X  
X  int monstr[NUMMONS];
X  
X! #define m_initsgrp(mtmp, x, y) m_initgrp(mtmp, x, y, 3)
X! #define m_initlgrp(mtmp, x, y) m_initgrp(mtmp, x, y, 10)
X  #define toostrong(monindx, lev) (monstr[monindx] > lev)
X  #define tooweak(monindx, lev)	(monstr[monindx] < lev)
X  
X--- 5,16 ----
X  #include	"hack.h"
X  
X  struct monst zeromonst;
X! static int FDECL(uncommon, (struct permonst *));
X  
X  int monstr[NUMMONS];
X  
X! #define m_initsgrp(mtmp, x, y)	m_initgrp(mtmp, x, y, 3)
X! #define m_initlgrp(mtmp, x, y)	m_initgrp(mtmp, x, y, 10)
X  #define toostrong(monindx, lev) (monstr[monindx] > lev)
X  #define tooweak(monindx, lev)	(monstr[monindx] < lev)
X  
X***************
X*** 23,28 ****
X--- 23,35 ----
X  	register int cnt = rnd(n);
X  	struct monst *mon;
X  
X+ /*
X+  *	Temporary kludge to cut down on swarming at lower character levels
X+  *	till we can get this game a little more balanced. [mrs]
X+  */
X+ 	cnt /= (u.ulevel < 3) ? 4 : (u.ulevel < 5) ? 2 : 1;
X+ 	if(!cnt) cnt++;
X+ 
X  	mm.x = x;
X  	mm.y = y;
X  	while(cnt--) {
X***************
X*** 64,69 ****
X--- 71,77 ----
X  register struct monst *mtmp;
X  {
X  	register struct permonst *ptr = mtmp->data;
X+ 	register int mm = monsndx(ptr);
X  #ifdef REINCARNATION
X  	if (dlevel==rogue_level) return;
X  #endif
X***************
X*** 84,90 ****
X  		break;
X  	    case S_HUMAN:
X  		if(is_mercenary(ptr))
X! 		    switch(monsndx(ptr)) {
X  
X  #ifdef ARMY
X  			case PM_SOLDIER:
X--- 92,98 ----
X  		break;
X  	    case S_HUMAN:
X  		if(is_mercenary(ptr))
X! 		    switch (mm) {
X  
X  #ifdef ARMY
X  			case PM_SOLDIER:
X***************
X*** 108,114 ****
X  
X  	    case S_HUMANOID:
X  #ifdef TOLKIEN
X! 		if (monsndx(ptr) == PM_HOBBIT) {
X  		    switch (rn2(3)) {
X  		  	case 0:
X  			    (void)mongets(mtmp, DAGGER);
X--- 116,122 ----
X  
X  	    case S_HUMANOID:
X  #ifdef TOLKIEN
X! 		if (mm == PM_HOBBIT) {
X  		    switch (rn2(3)) {
X  		  	case 0:
X  			    (void)mongets(mtmp, DAGGER);
X***************
X*** 201,253 ****
X  		break;
X  #endif
X  	    case S_ORC:
X  #ifdef TOLKIEN
X! 		{ int mm = monsndx(ptr);
X! 		  if(rn2(2)) (void)mongets(mtmp, ORCISH_HELM);
X! 		  if (mm == PM_MORDOR_ORC ||
X! 		     (mm == PM_ORC_CAPTAIN && rn2(2))) {
X! 		      if(rn2(2)) (void)mongets(mtmp, SCIMITAR);
X! 		      if(rn2(2)) (void)mongets(mtmp, ORCISH_SHIELD);
X! 		      if(rn2(2)) (void)mongets(mtmp, KNIFE);
X! 		      if(rn2(2)) (void)mongets(mtmp, ORCISH_CHAIN_MAIL);
X! 		  } else if (mm == PM_URUK_HAI || mm == PM_ORC_CAPTAIN) {
X! 		      if(rn2(2)) (void)mongets(mtmp, ORCISH_CLOAK);
X! 		      if(rn2(2)) (void)mongets(mtmp, ORCISH_SHORT_SWORD);
X! 		      if(rn2(2)) (void)mongets(mtmp, IRON_SHOES);
X! 		      if(rn2(2)) {
X! 			  (void)mongets(mtmp, ORCISH_BOW);
X! 			  m_initthrow(mtmp, ORCISH_ARROW, 12);
X! 		      }
X! 		      if(rn2(2)) (void)mongets(mtmp, URUK_HAI_SHIELD);
X! 		  } else if (mm != PM_ORC_SHAMAN) {
X! 		      (void)mongets(mtmp, (mm == PM_GOBLIN || rn2(2) == 0) ?
X! 				    ORCISH_DAGGER : SCIMITAR);
X! 		  }
X! 		}
X  #else /* TOLKIEN */
X! 		{ int mm = monsndx(ptr);
X! 		  if(rn2(2)) (void)mongets(mtmp, ORCISH_HELM);
X! 		  if (mm == PM_ORC_CAPTAIN) {
X! 		      if(rn2(2)) {
X! 			  if(rn2(2)) (void)mongets(mtmp, SCIMITAR);
X! 			  if(rn2(2)) (void)mongets(mtmp, SMALL_SHIELD);
X! 			  if(rn2(2)) (void)mongets(mtmp, KNIFE);
X! 			  if(rn2(2)) (void)mongets(mtmp, CHAIN_MAIL);
X! 		      } else {
X! 			  if(rn2(2)) (void)mongets(mtmp, SHORT_SWORD);
X! 			  if(rn2(2)) (void)mongets(mtmp, IRON_SHOES);
X! 			  if(rn2(2)) {
X! 			      (void)mongets(mtmp, BOW);
X! 			      m_initthrow(mtmp, ARROW, 12);
X! 			  }
X! 			  if(rn2(2)) (void)mongets(mtmp, SMALL_SHIELD);
X! 		      }
X! 		  } else if (mm != PM_ORC_SHAMAN) {
X! 		      (void)mongets(mtmp, (mm == PM_GOBLIN || rn2(2) == 0) ?
X! 				    DAGGER : SCIMITAR);
X! 		  }
X! 		}
X  #endif /* TOLKIEN */
X  		break;
X  	    case S_KOBOLD:
X  		if (!rn2(4)) m_initthrow(mtmp, DART, 12);
X--- 209,261 ----
X  		break;
X  #endif
X  	    case S_ORC:
X+ 		if(rn2(2)) (void)mongets(mtmp, ORCISH_HELM);
X  #ifdef TOLKIEN
X! 		switch (mm != PM_ORC_CAPTAIN ? mm :
X! 			rn2(2) ? PM_MORDOR_ORC : PM_URUK_HAI) {
X! 		    case PM_MORDOR_ORC:
X! 			if(rn2(2)) (void)mongets(mtmp, SCIMITAR);
X! 			if(rn2(2)) (void)mongets(mtmp, ORCISH_SHIELD);
X! 			if(rn2(2)) (void)mongets(mtmp, KNIFE);
X! 			if(rn2(2)) (void)mongets(mtmp, ORCISH_CHAIN_MAIL);
X! 			break;
X! 		    case PM_URUK_HAI:
X! 			if(rn2(2)) (void)mongets(mtmp, ORCISH_CLOAK);
X! 			if(rn2(2)) (void)mongets(mtmp, ORCISH_SHORT_SWORD);
X! 			if(rn2(2)) (void)mongets(mtmp, IRON_SHOES);
X! 			if(rn2(2)) {
X! 			    (void)mongets(mtmp, ORCISH_BOW);
X! 			    m_initthrow(mtmp, ORCISH_ARROW, 12);
X! 			}
X! 			if(rn2(2)) (void)mongets(mtmp, URUK_HAI_SHIELD);
X! 			break;
X! 		    default:
X! 			if (mm != PM_ORC_SHAMAN)
X! 			  (void)mongets(mtmp, (mm == PM_GOBLIN || rn2(2) == 0) ?
X! 					      ORCISH_DAGGER : SCIMITAR);
X  #else /* TOLKIEN */
X! 		switch (mm) {
X! 		    case  PM_ORC_CAPTAIN:
X! 			if(rn2(2)) {
X! 			    if(rn2(2)) (void)mongets(mtmp, SCIMITAR);
X! 			    if(rn2(2)) (void)mongets(mtmp, SMALL_SHIELD);
X! 			    if(rn2(2)) (void)mongets(mtmp, KNIFE);
X! 			    if(rn2(2)) (void)mongets(mtmp, CHAIN_MAIL);
X! 			} else {
X! 			    if(rn2(2)) (void)mongets(mtmp, SHORT_SWORD);
X! 			    if(rn2(2)) (void)mongets(mtmp, IRON_SHOES);
X! 			    if(rn2(2)) {
X! 				(void)mongets(mtmp, BOW);
X! 				m_initthrow(mtmp, ARROW, 12);
X! 			    }
X! 			    if(rn2(2)) (void)mongets(mtmp, SMALL_SHIELD);
X! 			}
X! 		    default:
X! 			if (mm != PM_ORC_SHAMAN)
X! 			  (void)mongets(mtmp, (mm == PM_GOBLIN || rn2(2) == 0) ?
X! 					      DAGGER : SCIMITAR);
X  #endif /* TOLKIEN */
X+ 		}
X  		break;
X  	    case S_KOBOLD:
X  		if (!rn2(4)) m_initthrow(mtmp, DART, 12);
X***************
X*** 269,279 ****
X  		(void)mongets(mtmp, LONG_SWORD);
X  		break;
X  	    case S_DEMON:
X! #ifdef HARD
X! 		if (monsndx(ptr) == PM_BALROG) {
X! 		    (void)mongets(mtmp, BULLWHIP);
X! 		    (void)mongets(mtmp, BROADSWORD);
X! 		    break;
X  		}
X  #endif
X  		/* prevent djinnis and mail daemons from leaving objects when
X--- 277,306 ----
X  		(void)mongets(mtmp, LONG_SWORD);
X  		break;
X  	    case S_DEMON:
X! #ifdef INFERNO
X! 		switch (mm) {
X! 		    case PM_BALROG:
X! 			(void)mongets(mtmp, BULLWHIP);
X! 			(void)mongets(mtmp, BROADSWORD);
X! 			break;
X! 		    case PM_ORCUS:
X! 			(void)mongets(mtmp, WAN_DEATH); /* the Wand of Orcus */
X! 			break;
X! 		    case PM_HORNED_DEVIL:
X! 			(void)mongets(mtmp, rn2(4) ? TRIDENT : BULLWHIP);
X! 			break;
X! 		    case PM_ICE_DEVIL:
X! 			if (!rn2(4)) (void)mongets(mtmp, SPEAR);
X! 			break;
X! 		    case PM_ASMODEUS:
X! 			(void)mongets(mtmp, WAN_COLD);
X! 			break;
X! 		    case PM_DISPATER:
X! 			(void)mongets(mtmp, WAN_STRIKING);
X! 			break;
X! 		    case PM_YEENOGHU:
X! 			(void)mongets(mtmp, FLAIL);
X! 			break;
X  		}
X  #endif
X  		/* prevent djinnis and mail daemons from leaving objects when
X***************
X*** 504,520 ****
X  			if(OBJ_AT(x, y) || levl[x][y].gmask)
X  			    mtmp->mundetected = 1;
X  			break;
X- 		case S_CHAMELEON:
X- 			/* If you're protected with a ring, don't create
X- 			 * any shape-changing chameleons -dgk
X- 			 */
X- 			if (Protection_from_shape_changers)
X- 				mtmp->cham = 0;
X- 			else {
X- 				mtmp->cham = 1;
X- 				(void) newcham(mtmp, rndmonst());
X- 			}
X- 			break;
X  		case S_STALKER:
X  		case S_EEL:
X  			mtmp->minvis = 1;
X--- 531,536 ----
X***************
X*** 536,542 ****
X  				mtmp->mpeaceful = 1;
X  			break;
X  	}
X! 	if (ptr == &mons[PM_WIZARD_OF_YENDOR]) {
X  		mtmp->iswiz = 1;
X  		flags.no_of_wizards++;
X  	}
X--- 552,568 ----
X  				mtmp->mpeaceful = 1;
X  			break;
X  	}
X! 	if (ptr == &mons[PM_CHAMELEON]) {
X! 		/* If you're protected with a ring, don't create
X! 		 * any shape-changing chameleons -dgk
X! 		 */
X! 		if (Protection_from_shape_changers)
X! 			mtmp->cham = 0;
X! 		else {
X! 			mtmp->cham = 1;
X! 			(void) newcham(mtmp, rndmonst());
X! 		}
X! 	} else if (ptr == &mons[PM_WIZARD_OF_YENDOR]) {
X  		mtmp->iswiz = 1;
X  		flags.no_of_wizards++;
X  	}
X***************
X*** 559,565 ****
X  			}
X  		}
X  	}
X! #ifdef HARD
X  	if(is_dprince(ptr)) {
X  	    mtmp->mpeaceful = mtmp->minvis = 1;
X  # ifdef NAMED_ITEMS
X--- 585,591 ----
X  			}
X  		}
X  	}
X! #ifdef INFERNO
X  	if(is_dprince(ptr)) {
X  	    mtmp->mpeaceful = mtmp->minvis = 1;
X  # ifdef NAMED_ITEMS
X***************
X*** 629,635 ****
X  		range++;
X  	} while(tfoo == foo);
X  foofull:
X! 	i = rn2(tfoo - foo);
X  	cc->x = foo[i].x;
X  	cc->y = foo[i].y;
X  	return;
X--- 655,661 ----
X  		range++;
X  	} while(tfoo == foo);
X  foofull:
X! 	i = rn2((int)(tfoo - foo));
X  	cc->x = foo[i].x;
X  	cc->y = foo[i].y;
X  	return;
X***************
X*** 779,785 ****
X  					|| (tmp2 == AD_WERE)
X  #endif
X  								) n += 2;
X! 	    else n += (tmp2 != AD_PHYS);
X  	    n += ((ptr->mattk[i].damd * ptr->mattk[i].damn) > 23);
X  	}
X  
X--- 805,811 ----
X  					|| (tmp2 == AD_WERE)
X  #endif
X  								) n += 2;
X! 	    else if (ptr != &mons[PM_GRID_BUG]) n += (tmp2 != AD_PHYS);
X  	    n += ((ptr->mattk[i].damd * ptr->mattk[i].damn) > 23);
X  	}
X  
X***************
X*** 935,944 ****
X  	newtype = little_to_big(monsndx(ptr));
X  	if (++mtmp->m_lev >= mons[newtype].mlevel) {
X  		if (mons[newtype].geno & G_GENOD) {
X! 			pline("As %s grows up into a%s %s, %s dies!",
X  				mon_nam(mtmp),
X! 				index(vowels,*mons[newtype].mname) ? "n" : "",
X! 				mons[newtype].mname,
X  				mon_nam(mtmp));
X  			mondied(mtmp);
X  			return (struct permonst *)0;
X--- 961,969 ----
X  	newtype = little_to_big(monsndx(ptr));
X  	if (++mtmp->m_lev >= mons[newtype].mlevel) {
X  		if (mons[newtype].geno & G_GENOD) {
X! 			pline("As %s grows up into %s, %s dies!",
X  				mon_nam(mtmp),
X! 				an(mons[newtype].mname),
X  				mon_nam(mtmp));
X  			mondied(mtmp);
X  			return (struct permonst *)0;
X***************
X*** 1111,1118 ****
X  	else if (OBJ_AT(mtmp->mx, mtmp->my))
X  		sym = level.objects[mtmp->mx][mtmp->my]->olet;
X  	else if (IS_DOOR(levl[mtmp->mx][mtmp->my].typ) ||
X! 		 IS_WALL(levl[mtmp->mx][mtmp->my].typ))
X! 		sym = DOOR_SYM;
X  	else if (is_maze_lev)
X  		sym = rn2(2) ? ROCK_SYM : syms[rn2(sizeof syms)];
X  	else if (roomno < 0)
X--- 1136,1145 ----
X  	else if (OBJ_AT(mtmp->mx, mtmp->my))
X  		sym = level.objects[mtmp->mx][mtmp->my]->olet;
X  	else if (IS_DOOR(levl[mtmp->mx][mtmp->my].typ) ||
X! 		 IS_WALL(levl[mtmp->mx][mtmp->my].typ) ||
X! 		 levl[mtmp->mx][mtmp->my].typ == SDOOR ||
X! 		 levl[mtmp->mx][mtmp->my].typ == SCORR)
X! 		sym = CLOSED_DOOR_SYM;
X  	else if (is_maze_lev)
X  		sym = rn2(2) ? ROCK_SYM : syms[rn2(sizeof syms)];
X  	else if (roomno < 0)
END_OF_FILE
if test 54581 -ne `wc -c <'patches06g'`; then
    echo shar: \"'patches06g'\" unpacked with wrong size!
fi
# end of 'patches06g'
fi
echo shar: End of archive 6 \(of 15\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
