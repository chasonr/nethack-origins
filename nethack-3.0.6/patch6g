Path: utzoo!utgpu!jarvis.csri.toronto.edu!mailrus!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i060:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch6g
Message-ID: <4849@tekred.CNA.TEK.COM>
Date: 22 Nov 89 19:51:10 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2021
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 60
Archive-name: NetHack3/Patch6g
Patch-To: NetHack3: Volume 7, Issue 56-93



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 15)."
# Contents:  patches06h
# Wrapped by billr@saab on Wed Nov 22 10:50:13 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches06h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches06h'\"
else
echo shar: Extracting \"'patches06h'\" \(54198 characters\)
sed "s/^X//" >'patches06h' <<'END_OF_FILE'
X*** src/Old/makedefs.c	Sun Nov 19 13:40:22 1989
X--- src/makedefs.c	Fri Nov 17 19:31:40 1989
X***************
X*** 14,20 ****
X  #define NULL	((genericptr_t)0)
X  
X  #ifndef LINT
X! static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.0\t89/01/10";
X  #endif
X  
X  #ifdef MSDOS
X--- 14,20 ----
X  #define NULL	((genericptr_t)0)
X  
X  #ifndef LINT
X! static	const char	SCCS_Id[] = "@(#)makedefs.c\t3.0\t89/11/15";
X  #endif
X  
X  #ifdef MSDOS
X***************
X*** 22,28 ****
X  # define freopen _freopen
X  #endif
X  # undef	exit
X! extern void exit P((int));
X  # define RDMODE	"r"
X  # define WRMODE	"w"
X  #else
X--- 22,28 ----
X  # define freopen _freopen
X  #endif
X  # undef	exit
X! extern void FDECL(exit, (int));
X  # define RDMODE	"r"
X  # define WRMODE	"w"
X  #else
X***************
X*** 83,95 ****
X  
X  
X  char	in_line[256];
X! extern char *gets P((char *));
X  void do_objs(), do_traps(), do_data(), do_date(), do_permonst(), do_rumors();
X  #ifdef SMALLDATA
X  void do_monst(), save_resource();
X  #endif
X! char *limit P((char *,BOOLEAN_P));
X! FILE *_freopen();
X  
X  int
X  main(argc, argv)
X--- 83,95 ----
X  
X  
X  char	in_line[256];
X! extern char *FDECL(gets, (char *));
X  void do_objs(), do_traps(), do_data(), do_date(), do_permonst(), do_rumors();
X  #ifdef SMALLDATA
X  void do_monst(), save_resource();
X  #endif
X! char *FDECL(limit, (char *,BOOLEAN_P));
X! FILE *FDECL(_freopen, (char *,char *,FILE *));
X  
X  int
X  main(argc, argv)
X***************
X*** 211,217 ****
X--- 211,221 ----
X  	int	ntrap;
X  	char	tempfile[30];
X  
X+ #ifdef MACOS
X+ 	Sprintf(tempfile, ":include:makedefs.%d", getpid());
X+ #else
X  	Sprintf(tempfile, "makedefs.%d", getpid());
X+ #endif
X  	if(freopen(tempfile, WRMODE, stdout) == (FILE *)0) {
X  		perror(tempfile);
X  		exit(1);
X***************
X*** 245,251 ****
X  	Printf("\n#endif /* TRAP_H /**/\n");
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X! #ifdef MSDOS
X  	remove(TRAP_FILE);
X  #endif
X  	rename(tempfile, TRAP_FILE);
X--- 249,255 ----
X  	Printf("\n#endif /* TRAP_H /**/\n");
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X! #if defined(MSDOS) || defined(MACOS)
X  	remove(TRAP_FILE);
X  #endif
X  	rename(tempfile, TRAP_FILE);
X***************
X*** 256,262 ****
X  void
X  do_rumors(){
X  	char	infile[30];
X! 	FILE	*freopen();
X  	long	true_rumor_size;
X  
X  	if(freopen(RUMOR_FILE, WRMODE, stdout) == (FILE *)0) {
X--- 260,266 ----
X  void
X  do_rumors(){
X  	char	infile[30];
X! 	FILE	*FDECL(freopen, (char *,char *,FILE *));
X  	long	true_rumor_size;
X  
X  	if(freopen(RUMOR_FILE, WRMODE, stdout) == (FILE *)0) {
X***************
X*** 338,383 ****
X  	}
X  
X  	while(gets(in_line) != NULL) {
X! #ifdef  SINKS
X! 	    if(!strcmp(in_line, "#\ta corridor"))
X! 		Printf("#\ta corridor (or a kitchen sink)\n");
X! 	    else
X  #endif
X! #ifdef	ALTARS
X! 	    if(!strcmp(in_line, "_\tan iron chain"))
X! 		Printf("_\tan iron chain (or an altar)\n");
X  	    else
X  #endif
X! #ifdef	SPELLS
X! 	    if(!strcmp(in_line, "+\ta door"))
X! 		Printf("+\ta door (or a spell book)\n");
X  	    else
X  #endif
X! #ifdef	FOUNTAINS
X! 	    if(!strcmp(in_line, "}\twater filled area")) {
X! 		(void) puts(in_line);
X! 		Printf("{\ta fountain\n");
X! 	    } else
X! #endif
X! #ifdef	THRONES
X! 	    if(!strcmp(in_line, "^\ta trap")) {
X! 		(void) puts(in_line);
X! 		Printf("\\\tan opulent throne\n");
X! 	    } else
X  #endif
X- 	    if(!strcmp(in_line, ";\ta giant eel")) {
X  		(void) puts(in_line);
X- #ifdef	WORM
X- 		Printf("~\tthe tail of a long worm\n");
X- #endif
X- #ifdef	GOLEMS
X- Printf("'\ta golem\n");
X- Printf("\t\tThese creatures, not quite living but not  really  nonliving\n");
X- Printf("\t\teither,   are   created from inanimate materials by powerful\n");
X- Printf("\t\tmages or priests.\n");
X- #endif
X- 	    } else
X- 	      (void) puts(in_line);
X  	}
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X--- 342,368 ----
X  	}
X  
X  	while(gets(in_line) != NULL) {
X! #ifndef GOLEMS
X! 	    if(!strcmp(in_line, "'\ta golem;"))
X! 		while(gets(in_line) != NULL && in_line[0] == '\t')
X! 		    ; /* do nothing */
X  #endif
X! #ifndef	SPELLS
X! 	    if(!strcmp(in_line, "+\ta spell book"))
X! 		; /* do nothing */
X  	    else
X  #endif
X! #ifndef KOPS
X! 	    if(!strcmp(in_line, "K\ta Keystone Kop"))
X! 		; /* do nothing */
X  	    else
X  #endif
X! #ifndef WORM
X! 	    if(!strcmp(in_line, "~\tthe tail of a long worm"))
X! 		; /* do nothing */
X! 	    else
X  #endif
X  		(void) puts(in_line);
X  	}
X  	(void) fclose(stdin);
X  	(void) fclose(stdout);
X***************
X*** 550,562 ****
X  # endif
X  #endif /* MSDOS */
X  
X  #if defined(SMALLDATA) && defined(MACOS)
X  void
X  do_monst()
X  {
X! 	Handle	data;
X  	short i,j;
X  	pmstr	*pmMonst;
X  	
X  	for(i = 0; mons[i].mlet; i++) {
X  		;
X--- 535,553 ----
X  # endif
X  #endif /* MSDOS */
X  
X+ 
X  #if defined(SMALLDATA) && defined(MACOS)
X  void
X  do_monst()
X  {
X! 	Handle	monstData, objData;
X  	short i,j;
X  	pmstr	*pmMonst;
X+ 	SFReply	reply;
X+ 	short	refNum,error;
X+ 	Str255	name;
X+ 	short	findNamedFile();
X+ 	OSErr	write_resource();
X  	
X  	for(i = 0; mons[i].mlet; i++) {
X  		;
X***************
X*** 574,636 ****
X  				(long)sizeof(struct pmpart));
X  	}
X  	
X! 	PtrToHand((Ptr)pmMonst, &data, (long)(i * sizeof(struct pmstr)));
X! 	save_resource(data);
X! 	DisposHandle(data);
X! }
X! 
X! 
X! void
X! save_resource(data)
X! Handle	data;
X! {
X! 	SFReply	reply;
X! 	short	refNum,error;
X! 	Str255	name;
X! 	ResType	theType;
X! 	Handle	theRes;
X! 	short	findNamedFile();
X! #define MONST_DATA_ID	101
X  
X  	strcpy((char *)&name[0], "\014Nethack.rsrc");
X  	if (findNamedFile(&name[1], 0, &reply)) {
X! 	    strncpy((char *)&name[0],(char *)&reply.fName[1], reply.fName[0]);
X! 	    name[reply.fName[0]] = '\0';
X  	    if ((refNum = OpenResFile(name)) != -1) {
X  		if (ResError() == noErr) {
X- 		    theType = HACK_DATA;
X  		    strcpy((char *)&name[0], "\012MONST_DATA");
X! 		    error = CurResFile();
X! 		    if (theRes = GetResource(theType, MONST_DATA_ID)) {
X! 			RmveResource(theRes);
X! 			error = ResError();
X! 			if (error == noErr) {
X! 			    DisposHandle(theRes);
X! 			    UpdateResFile(refNum);
X! 			    error = ResError();
X! 			    if (error != noErr)
X! 				SysBeep(1);
X! 			} else {
X! 			    Printf("Couldn't remove old copy of data resource.");
X! 			    return;
X! 			}
X! 		    } else if (ResError() != resNotFound && ResError() != noErr) {
X! 			SysBeep(1);
X! 			Printf("Resource file is protected.");
X! 			return;
X  		    }
X! 		    AddResource(data, theType, MONST_DATA_ID, name);
X! 		    error = ResError();
X! 		    if (error != noErr) {
X! 			SysBeep(1);
X! 			Printf("Couldn't add data resource.");
X! 		    } else {
X! 			WriteResource(data);
X! 			error = ResError();
X! 			if (error != noErr) {
X! 			    SysBeep(1);
X! 			    Printf("Couldn't write data resource.");
X! 			}
X  		    }
X  		    CloseResFile(refNum);
X  		    if (ResError() != noErr) {
X--- 565,594 ----
X  				(long)sizeof(struct pmpart));
X  	}
X  	
X! 	PtrToHand((Ptr)pmMonst, &monstData, (long)(i * sizeof(struct pmstr)));
X! 	
X! 	/* store the object data, in Nethack the char * will be copied in */
X! 	for(i = 0; !i || objects[i].oc_olet != ILLOBJ_SYM; i++) {
X! 		;
X! 	}
X! 	PtrToHand((Ptr)objects, &objData, ((i+1)*sizeof(struct objclass)));
X  
X  	strcpy((char *)&name[0], "\014Nethack.rsrc");
X  	if (findNamedFile(&name[1], 0, &reply)) {
X! 	    strncpy((char *)&name[0],(char *)&reply.fName[0], reply.fName[0]+1);
X  	    if ((refNum = OpenResFile(name)) != -1) {
X  		if (ResError() == noErr) {
X  		    strcpy((char *)&name[0], "\012MONST_DATA");
X! 		    if (error = write_resource(monstData,
X! 						MONST_DATA, name, refNum)) {
X! 		    	SysBeep(1);
X! 		    	Printf("Couldn't add monster data resource.\n");
X  		    }
X! 		    strcpy((char *)&name[0], "\013OBJECT_DATA");
X! 		    if (error = write_resource(objData,
X! 						OBJECT_DATA, name, refNum)) {
X! 		    	SysBeep(1);
X! 		    	Printf("Couldn't add object data resource.\n");
X  		    }
X  		    CloseResFile(refNum);
X  		    if (ResError() != noErr) {
X***************
X*** 640,645 ****
X--- 598,642 ----
X  		}
X  	    }
X  	}
X+ 	
X+ 	DisposHandle(monstData);
X+ 	DisposHandle(objData);
X+ }
X+ 
X+ OSErr
X+ write_resource(data, resID, resName, refNum)
X+ Handle	data;
X+ short	resID;
X+ Str255	resName;
X+ short	refNum;
X+ {
X+ 	ResType	theType;
X+ 	short	error;
X+ 	Handle	theRes;
X+ 
X+     theType = HACK_DATA;
X+     error = CurResFile();
X+     if (theRes = GetResource(theType, resID)) {
X+ 		RmveResource(theRes);
X+ 		error = ResError();
X+ 		if (error == noErr) {
X+ 			DisposHandle(theRes);
X+ 			UpdateResFile(refNum);
X+ 			error = ResError();
X+ 		}
X+ 		if (error != noErr) {
X+     		return error;
X+     	}
X+ 	} else if (ResError() != resNotFound && ResError() != noErr) {
X+ 			return (ResError());
X+ 	}
X+ 	AddResource(data, theType, resID, resName);
X+ 	error = ResError();
X+ 	if (error == noErr) {
X+ 		WriteResource(data);
X+ 		error = ResError();
X+ 	}
X+     return error;
X  }
X  # if defined(AZTEC) || defined(THINKC4)
X  int
X*** src/Old/mcastu.c	Sun Nov 19 13:41:36 1989
X--- src/mcastu.c	Sun Oct 22 11:46:21 1989
X***************
X*** 72,78 ****
X  			dmg = 0;
X  		}
X  		break;
X! #ifdef HARD
X  	    case AD_MAGM:
X  		You("are hit by a shower of missiles!");
X  		if(Antimagic) {
X--- 72,78 ----
X  			dmg = 0;
X  		}
X  		break;
X! #ifdef INFERNO
X  	    case AD_MAGM:
X  		You("are hit by a shower of missiles!");
X  		if(Antimagic) {
X*** src/Old/mhitm.c	Sun Nov 19 13:41:53 1989
X--- src/mhitm.c	Fri Nov 17 19:31:46 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mhitm.c	3.0	88/11/10
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitm.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 11,23 ****
X  static long noisetime;
X  static struct obj *otmp;
X  
X! static void mrustm P((struct monst *, struct monst *, struct obj *));
X! static int hitmm P((struct monst *,struct monst *,struct attack *));
X! static int gazemm P((struct monst *,struct monst *,struct attack *));
X! static int gulpmm P((struct monst *,struct monst *,struct attack *));
X! static int explmm P((struct monst *,struct monst *,struct attack *));
X! static int mdamagem P((struct monst *,struct monst *,struct attack *));
X! static void mswingsm P((struct monst *, struct monst *, struct obj *));
X  
X  static void
X  noises(magr, mattk)
X--- 11,23 ----
X  static long noisetime;
X  static struct obj *otmp;
X  
X! static void FDECL(mrustm, (struct monst *, struct monst *, struct obj *));
X! static int FDECL(hitmm, (struct monst *,struct monst *,struct attack *));
X! static int FDECL(gazemm, (struct monst *,struct monst *,struct attack *));
X! static int FDECL(gulpmm, (struct monst *,struct monst *,struct attack *));
X! static int FDECL(explmm, (struct monst *,struct monst *,struct attack *));
X! static int FDECL(mdamagem, (struct monst *,struct monst *,struct attack *));
X! static void FDECL(mswingsm, (struct monst *, struct monst *, struct obj *));
X  
X  static void
X  noises(magr, mattk)
X***************
X*** 66,72 ****
X  	for(mon = fmon; mon; mon = mon->nmon)
X  	    if(mon != mtmp) {
X  		if(dist2(mon->mx,mon->my,mtmp->mx,mtmp->my) < 3)
X! 		    return(mattackm(mtmp,mon));
X  	    }
X  	return(-1);
X  }
X--- 66,75 ----
X  	for(mon = fmon; mon; mon = mon->nmon)
X  	    if(mon != mtmp) {
X  		if(dist2(mon->mx,mon->my,mtmp->mx,mtmp->my) < 3)
X! 		/* note: grid bug check needed here as well as in mattackm */
X! 		    if(mtmp->data != &mons[PM_GRID_BUG] || mtmp->mx==mon->mx
X! 				|| mtmp->my==mon->my)
X! 			return(mattackm(mtmp,mon));
X  	    }
X  	return(-1);
X  }
X***************
X*** 91,96 ****
X--- 94,102 ----
X  	if(!magr || !mdef) return(0);		/* mike@genat */
X  	pa = magr->data; pd = mdef->data;
X  	if(magr->mfroz) return(0);		/* riv05!a3 */
X+ 	if(pa==&mons[PM_GRID_BUG] && magr->mx != mdef->mx
X+ 						&& magr->my != mdef->my)
X+ 		return(0);
X  
X  /*	Calculate the armour class differential.	*/
X  
X*** src/Old/mhitu.c	Sun Nov 19 13:42:23 1989
X--- src/mhitu.c	Fri Nov 17 19:31:51 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: \@(#)mhitu.c	3.0	88/10/28
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mhitu.c	3.0	89/11/15
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 9,24 ****
X  
X  static struct obj *otmp;
X  #ifdef POLYSELF
X! static void urustm P((struct monst *, struct obj *));
X! static int passiveum P((struct permonst *, struct monst *));
X  #endif
X  #ifdef SEDUCE
X! static void mayberem P((struct obj *, char *));
X  #endif
X! static int hitmu P((struct monst *,struct attack *));
X! static int gulpmu P((struct monst *,struct attack *));
X! static int explmu P((struct monst *,struct attack *));
X! static int gazemu P((struct monst *,struct attack *));
X  
X  
X  static void
X--- 9,24 ----
X  
X  static struct obj *otmp;
X  #ifdef POLYSELF
X! static void FDECL(urustm, (struct monst *, struct obj *));
X! static int FDECL(passiveum, (struct permonst *, struct monst *));
X  #endif
X  #ifdef SEDUCE
X! static void FDECL(mayberem, (struct obj *, char *));
X  #endif
X! static int FDECL(hitmu, (struct monst *,struct attack *));
X! static int FDECL(gulpmu, (struct monst *,struct attack *));
X! static int FDECL(explmu, (struct monst *,struct attack *));
X! static int FDECL(gazemu, (struct monst *,struct attack *));
X  
X  
X  static void
X***************
X*** 152,158 ****
X  {
X  	unstuck(mtmp);
X  	mnexto(mtmp);
X! 	pru();
X  	spoteffects();
X  	/* to cover for a case where mtmp is not in a next square */
X  	if(um_dist(mtmp->mx,mtmp->my,1))
X--- 152,158 ----
X  {
X  	unstuck(mtmp);
X  	mnexto(mtmp);
X! 	prme();
X  	spoteffects();
X  	/* to cover for a case where mtmp is not in a next square */
X  	if(um_dist(mtmp->mx,mtmp->my,1))
X***************
X*** 177,183 ****
X  	struct	permonst *mdat = mtmp->data;
X  	boolean ranged = (dist(mtmp->mx, mtmp->my) > 3);
X  		/* Is it near you?  Affects your actions */
X! 	boolean range2 = (dist2(mtmp->mx, mtmp->my, mtmp->mux, mtmp->muy) > 3);
X  		/* Does it think it's near you?  Affects its actions */
X  	boolean foundyou = (mtmp->mux==u.ux && mtmp->muy==u.uy);
X  		/* Is it attacking you or your image? */
X--- 177,183 ----
X  	struct	permonst *mdat = mtmp->data;
X  	boolean ranged = (dist(mtmp->mx, mtmp->my) > 3);
X  		/* Is it near you?  Affects your actions */
X! 	boolean range2 = !monnear(mtmp, mtmp->mux, mtmp->muy);
X  		/* Does it think it's near you?  Affects its actions */
X  	boolean foundyou = (mtmp->mux==u.ux && mtmp->muy==u.uy);
X  		/* Is it attacking you or your image? */
X***************
X*** 280,286 ****
X  
X  /*	Special demon handling code */
X  	if(!mtmp->cham && is_demon(mdat) && !range2
X! #ifdef HARD
X  	   && mtmp->data != &mons[PM_BALROG]
X  	   && mtmp->data != &mons[PM_SUCCUBUS]
X  	   && mtmp->data != &mons[PM_INCUBUS]
X--- 280,286 ----
X  
X  /*	Special demon handling code */
X  	if(!mtmp->cham && is_demon(mdat) && !range2
X! #ifdef INFERNO
X  	   && mtmp->data != &mons[PM_BALROG]
X  	   && mtmp->data != &mons[PM_SUCCUBUS]
X  	   && mtmp->data != &mons[PM_INCUBUS]
X***************
X*** 437,442 ****
X--- 437,510 ----
X  }
X  
X  /*
X+  * helper function for some compilers that have trouble with hitmu
X+  */
X+ 
X+ static
X+ void
X+ hurtarmor(mdat, attack)
X+ struct permonst *mdat;
X+ int attack;
X+ {
X+ 	boolean getbronze, rusting;
X+ 	int	hurt;
X+ 
X+ 	rusting = (attack == AD_RUST);
X+ 	if (rusting) {
X+ 		hurt = 1;
X+ 		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X+ 			     uarm && is_corrodeable(uarm));
X+ 	}
X+ 	else {
X+ 		hurt=2;
X+ 		getbronze = FALSE;
X+ 	}
X+ 	/* What the following code does: it keeps looping until it
X+ 	 * finds a target for the rust monster.
X+ 	 * Head, feet, etc... not covered by metal, or covered by
X+ 	 * rusty metal, are not targets.  However, your body always
X+ 	 * is, no matter what covers it.
X+ 	 */
X+ 	while (1) {
X+ 	    switch(rn2(5)) {
X+ 	    case 0:
X+ 		if (!rust_dmg(uarmh, rusting ? "helmet" : "leather helmet",
X+ 					 hurt, FALSE))
X+ 			continue;
X+ 		break;
X+ 	    case 1:
X+ 		if (uarmc) break;
X+ 		/* Note the difference between break and continue;
X+ 		 * break means it was hit and didn't rust; continue
X+ 		 * means it wasn't a target and though it didn't rust
X+ 		 * something else did.
X+ 		 */
X+ 		if (getbronze)
X+ 		    (void)rust_dmg(uarm, "bronze armor", 3, TRUE);
X+ 		else if (uarm)
X+ 		    (void)rust_dmg(uarm, xname(uarm), hurt, TRUE);
X+ 		break;
X+ 	    case 2:
X+ 		if (!rust_dmg(uarms, rusting ? "shield" : "wooden shield",
X+ 					 hurt, FALSE))
X+ 			continue;
X+ 		break;
X+ 	    case 3:
X+ 		if (!rust_dmg(uarmg, rusting ? "metal gauntlets" : "gloves",
X+ 					 hurt, FALSE))
X+ 			continue;
X+ 		break;
X+ 	    case 4:
X+ 		if (!rust_dmg(uarmf, rusting ? "metal boots" : "boots",
X+ 					 hurt, FALSE))
X+ 			continue;
X+ 		break;
X+ 	    }
X+ 	    break; /* Out of while loop */
X+ 	}
X+ }
X+ 
X+ /*
X   * hitmu: monster hits you
X   *	  returns 2 if monster dies (e.g. "yellow light"), 1 otherwise
X   *	  3 if the monster lives but teleported, so it can't keep attacking you
X***************
X*** 449,455 ****
X  {
X  	register struct permonst *mdat = mtmp->data;
X  	register int dmg, ctmp, ptmp;
X- 	register boolean getbronze;
X  	char	 buf[BUFSZ];
X  #ifdef POLYSELF
X  	struct permonst *olduasmon = uasmon;
X--- 517,522 ----
X***************
X*** 567,573 ****
X  		    if(mtmp->m_lev > rn2(25))
X  			destroy_item(SPBOOK_SYM, AD_FIRE);
X  #endif
X! 		}
X  		break;
X  	    case AD_COLD:
X  		hitmsg(mtmp, mattk);
X--- 634,640 ----
X  		    if(mtmp->m_lev > rn2(25))
X  			destroy_item(SPBOOK_SYM, AD_FIRE);
X  #endif
X! 		} else dmg = 0;
X  		break;
X  	    case AD_COLD:
X  		hitmsg(mtmp, mattk);
X***************
X*** 579,585 ****
X  		    }
X  		    if(mtmp->m_lev > rn2(20))
X  			destroy_item(POTION_SYM, AD_COLD);
X! 		}
X  		break;
X  	    case AD_ELEC:
X  		hitmsg(mtmp, mattk);
X--- 646,652 ----
X  		    }
X  		    if(mtmp->m_lev > rn2(20))
X  			destroy_item(POTION_SYM, AD_COLD);
X! 		} else dmg = 0;
X  		break;
X  	    case AD_ELEC:
X  		hitmsg(mtmp, mattk);
X***************
X*** 593,599 ****
X  			destroy_item(WAND_SYM, AD_ELEC);
X  		    if(mtmp->m_lev > rn2(20))
X  			destroy_item(RING_SYM, AD_ELEC);
X! 		}
X  		break;
X  	    case AD_SLEE:
X  		hitmsg(mtmp, mattk);
X--- 660,666 ----
X  			destroy_item(WAND_SYM, AD_ELEC);
X  		    if(mtmp->m_lev > rn2(20))
X  			destroy_item(RING_SYM, AD_ELEC);
X! 		} else dmg = 0;
X  		break;
X  	    case AD_SLEE:
X  		hitmsg(mtmp, mattk);
X***************
X*** 671,678 ****
X  			    if (Blind) You("hear its hissing!");
X  			    else You("hear %s's hissing!", mon_nam(mtmp));
X  			if((!rn2(10) ||
X! 			    (flags.moonphase == NEW_MOON &&
X! 			     !carrying(DEAD_LIZARD)))
X  #ifdef POLYSELF
X  			    && !resists_ston(uasmon)
X  #endif
X--- 738,744 ----
X  			    if (Blind) You("hear its hissing!");
X  			    else You("hear %s's hissing!", mon_nam(mtmp));
X  			if((!rn2(10) ||
X! 			    (flags.moonphase == NEW_MOON && !have_lizard()))
X  #ifdef POLYSELF
X  			    && !resists_ston(uasmon)
X  #endif
X***************
X*** 766,775 ****
X  			rloc(mtmp);
X  			return 3;
X  		    }
X! 		} else if(steal(mtmp)) {
X  			rloc(mtmp);
X  			mtmp->mflee = 1;
X  			return 3;
X  		}
X  		break;
X  #ifdef SEDUCE
X--- 832,848 ----
X  			rloc(mtmp);
X  			return 3;
X  		    }
X! 		} else {
X! 		    switch (steal(mtmp)) {
X! 		      case -1:
X! 			return 2;
X! 		      case 0:
X! 			break;
X! 		      default:
X  			rloc(mtmp);
X  			mtmp->mflee = 1;
X  			return 3;
X+ 		    }
X  		}
X  		break;
X  #ifdef SEDUCE
X***************
X*** 807,850 ****
X  		}
X  #endif /* GOLEMS */
X  #endif
X! 		/* What the following code does: it keeps looping until it
X! 		 * finds a target for the rust monster.
X! 		 * Head, feet, etc... not covered by metal, or covered by
X! 		 * rusty metal, are not targets.  However, your body always
X! 		 * is, no matter what covers it.
X! 		 */
X! 		getbronze = (mdat == &mons[PM_BLACK_PUDDING] &&
X! 			     uarm && is_corrodeable(uarm));
X! 		while (1) {
X! 		    switch(rn2(5)) {
X! 		    case 0:
X! 			if (!rust_dmg(uarmh, "helmet", 1, FALSE)) continue;
X! 			break;
X! 		    case 1:
X! 			if (uarmc) break;
X! 			/* Note the difference between break and continue;
X! 			 * break means it was hit and didn't rust; continue
X! 			 * means it wasn't a target and though it didn't rust
X! 			 * something else did.
X! 			 */
X! 			if (getbronze)
X! 			    (void)rust_dmg(uarm, "bronze armor", 3, TRUE);
X! 			else
X! 			    (void)rust_dmg(uarm, "armor", 1, TRUE);
X! 			break;
X! 		    case 2:
X! 			if (!rust_dmg(uarms, "shield", 1, FALSE)) continue;
X! 			break;
X! 		    case 3:
X! 			if (!rust_dmg(uarmg, "metal gauntlets", 1, FALSE))
X! 			    continue;
X! 			break;
X! 		    case 4:
X! 			if (!rust_dmg(uarmf, "metal boots", 1, FALSE)) continue;
X! 			break;
X! 		    }
X! 		    break; /* Out of while loop */
X! 		}
X  		break;
X  	    case AD_DCAY:
X  		hitmsg(mtmp, mattk);
X--- 880,886 ----
X  		}
X  #endif /* GOLEMS */
X  #endif
X! 		hurtarmor(mdat, AD_RUST);
X  		break;
X  	    case AD_DCAY:
X  		hitmsg(mtmp, mattk);
X***************
X*** 859,887 ****
X  		}
X  #endif /* GOLEMS */
X  #endif
X! 		while (1) {
X! 		    switch(rn2(5)) {
X! 		    case 0:
X! 			if (!rust_dmg(uarmh, "leather helmet", 2, FALSE))
X! 				continue;
X! 			break;
X! 		    case 1:
X! 			if (uarmc) break;
X! 			if (uarm) (void)rust_dmg(uarm, xname(uarm), 2, TRUE);
X! 			break;
X! 		    case 2:
X! 			if (!rust_dmg(uarms, "wooden shield", 2, FALSE))
X! 				continue;
X! 			break;
X! 		    case 3:
X! 			if (!rust_dmg(uarmg, "gloves", 2, FALSE)) continue;
X! 			break;
X! 		    case 4:
X! 			if (!rust_dmg(uarmf, "boots", 2, FALSE)) continue;
X! 			break;
X! 		    }
X! 		    break; /* Out of while loop */
X! 		}
X  		break;
X  	    case AD_HEAL:
X  		if(!uwep
X--- 895,901 ----
X  		}
X  #endif /* GOLEMS */
X  #endif
X! 		hurtarmor(mdat, AD_DCAY);
X  		break;
X  	    case AD_HEAL:
X  		if(!uwep
X***************
X*** 889,895 ****
X  		   && !uarmu
X  #endif
X  		   && !uarm && !uarmh && !uarms && !uarmg && !uarmc && !uarmf) {
X! 		    kludge("%s hits! (I hope you don't mind.)", Monnam(mtmp));
X  #ifdef POLYSELF
X  			if (u.mtimedone) {
X  				u.mh += rnd(7);
X--- 903,909 ----
X  		   && !uarmu
X  #endif
X  		   && !uarm && !uarmh && !uarms && !uarmg && !uarmc && !uarmf) {
X! 		    kludge("%s hits!  (I hope you don't mind.)", Monnam(mtmp));
X  #ifdef POLYSELF
X  			if (u.mtimedone) {
X  				u.mh += rnd(7);
X***************
X*** 911,917 ****
X  		} else
X  		    if(pl_character[0] == 'H') {
X  			    if (flags.soundok && !(moves % 5))
X! 				pline("'Doc, I can't help you unless you cooperate.'");
X  			    dmg = 0;
X  		    } else hitmsg(mtmp, mattk);
X  		break;
X--- 925,931 ----
X  		} else
X  		    if(pl_character[0] == 'H') {
X  			    if (flags.soundok && !(moves % 5))
X! 				verbalize("Doc, I can't help you unless you cooperate.");
X  			    dmg = 0;
X  		    } else hitmsg(mtmp, mattk);
X  		break;
X***************
X*** 971,977 ****
X  		if(flags.soundok && !rn2(3)) cuss(mtmp);
X  		dmg = 0;
X  		break;
X! #ifdef HARD /* a non-gaze AD_CONF exists only for one of the demons */
X  	    case AD_CONF:
X  		hitmsg(mtmp, mattk);
X  		if(!mtmp->mcan && !rn2(4) && !mtmp->mspec_used) {
X--- 985,991 ----
X  		if(flags.soundok && !rn2(3)) cuss(mtmp);
X  		dmg = 0;
X  		break;
X! #ifdef INFERNO /* a non-gaze AD_CONF exists only for one of the demons */
X  	    case AD_CONF:
X  		hitmsg(mtmp, mattk);
X  		if(!mtmp->mcan && !rn2(4) && !mtmp->mspec_used) {
X***************
X*** 1026,1031 ****
X--- 1040,1049 ----
X  		u.ustuck = mtmp;
X  		pmon(mtmp);
X  		kludge("%s engulfs you!", Monnam(mtmp));
X+ 		if (u.utrap) {
X+ 			You("are released from the trap!");
X+ 			u.utrap = 0;
X+ 		}
X  #ifdef WALKIES
X  		if((i = number_leashed()) > 0) {
X  			pline("The leash%s snap%s loose...",
X***************
X*** 1074,1080 ****
X  		    } else
X  #endif
X  		    if (Hallucination) pline("Ouch!  You've been slimed!");
X! 		    else You("are covered in slime!  It burns!!!");
X  		    break;
X  		case AD_BLND:
X  		    if(!Blind) {
X--- 1092,1098 ----
X  		    } else
X  #endif
X  		    if (Hallucination) pline("Ouch!  You've been slimed!");
X! 		    else You("are covered in slime!  It burns!");
X  		    break;
X  		case AD_BLND:
X  		    if(!Blind) {
X***************
X*** 1120,1126 ****
X  			} else You("are burning to a crisp!");
X  		    } else tmp = 0;
X  		    break;
X! #ifdef HARD
X  		case AD_DISE:
X  		    if (!Sick) You("feel very sick.");
X  		    make_sick(Sick + (long)rn1(25-ACURR(A_CON),15),FALSE);
X--- 1138,1144 ----
X  			} else You("are burning to a crisp!");
X  		    } else tmp = 0;
X  		    break;
X! #ifdef INFERNO
X  		case AD_DISE:
X  		    if (!Sick) You("feel very sick.");
X  		    make_sick(Sick + (long)rn1(25-ACURR(A_CON),15),FALSE);
X***************
X*** 1246,1252 ****
X  		    make_confused(HConfusion + conf, FALSE);
X  		}
X  		break;
X! #ifdef HARD
X  	    case AD_STUN:
X  		if(!mtmp->mcan && canseemon(mtmp) && mtmp->mcansee &&
X  					!mtmp->mspec_used && rn2(5)) {
X--- 1264,1270 ----
X  		    make_confused(HConfusion + conf, FALSE);
X  		}
X  		break;
X! #ifdef INFERNO
X  	    case AD_STUN:
X  		if(!mtmp->mcan && canseemon(mtmp) && mtmp->mcansee &&
X  					!mtmp->mspec_used && rn2(5)) {
X***************
X*** 1351,1357 ****
X  		return 0;
X  
X  	if(pagr->mlet != S_NYMPH
X! #ifdef HARD
X  		&& ((pagr != &mons[PM_INCUBUS] && pagr != &mons[PM_SUCCUBUS])
X  # ifdef SEDUCE
X  		    || (mattk && mattk->adtyp != AD_SSEX)
X--- 1369,1375 ----
X  		return 0;
X  
X  	if(pagr->mlet != S_NYMPH
X! #ifdef INFERNO
X  		&& ((pagr != &mons[PM_INCUBUS] && pagr != &mons[PM_SUCCUBUS])
X  # ifdef SEDUCE
X  		    || (mattk && mattk->adtyp != AD_SSEX)
X***************
X*** 1606,1612 ****
X  			(obj == uarmu) ? "let me massage you" :
X  #endif
X  			/* obj == uarmh */
X! 			"so I can run my fingers through your hair");
X  
X  	if (obj == uarm)  (void) Armor_off();
X  	else if (obj == uarmc) (void) Cloak_off();
X--- 1624,1630 ----
X  			(obj == uarmu) ? "let me massage you" :
X  #endif
X  			/* obj == uarmh */
X! 			"let me run my fingers through your hair");
X  
X  	if (obj == uarm)  (void) Armor_off();
X  	else if (obj == uarmc) (void) Cloak_off();
X*** src/Old/mklev.c	Sun Nov 19 13:43:28 1989
X--- src/mklev.c	Thu Nov  9 20:27:10 1989
X***************
X*** 394,400 ****
X  				(void) mksobj_at(BOULDER, xx, yy);
X  		} else {
X  			crm->typ = SCORR;
X! 			crm->scrsym = STONE_SYM;
X  		}
X  	    } else
X  	    if(crm->typ != CORR && crm->typ != SCORR) {
X--- 394,400 ----
X  				(void) mksobj_at(BOULDER, xx, yy);
X  		} else {
X  			crm->typ = SCORR;
X! 			crm->scrsym = ' ';	/* _not_ STONE_SYM */
X  		}
X  	    } else
X  	    if(crm->typ != CORR && crm->typ != SCORR) {
X***************
X*** 498,504 ****
X  		type = DOOR;
X  	levl[x][y].typ = type;
X  	if(type == DOOR) {
X- 	    levl[x][y].scrsym = DOOR_SYM;
X  	    if(!rn2(3)) {      /* is it a locked door, closed, or a doorway? */
X  		if(!rn2(5))
X  		    levl[x][y].doormask = D_ISOPEN;
X--- 498,503 ----
X***************
X*** 509,518 ****
X  
X  		if (levl[x][y].doormask != D_ISOPEN && !shdoor && !rn2(25))
X  		    levl[x][y].doormask |= D_TRAPPED;
X! 	    } else {
X! 		if(shdoor)	levl[x][y].doormask = D_ISOPEN;
X! 		else		levl[x][y].doormask = D_NODOOR;
X! 	    }
X  	} else { /* SDOOR */
X  		if(shdoor || !rn2(5))	levl[x][y].doormask = D_LOCKED;
X  		else			levl[x][y].doormask = D_CLOSED;
X--- 508,516 ----
X  
X  		if (levl[x][y].doormask != D_ISOPEN && !shdoor && !rn2(25))
X  		    levl[x][y].doormask |= D_TRAPPED;
X! 	    } else
X! 		levl[x][y].doormask = (shdoor ? D_ISOPEN : D_NODOOR);
X! 	    levl[x][y].scrsym = news0(x,y);
X  	} else { /* SDOOR */
X  		if(shdoor || !rn2(5))	levl[x][y].doormask = D_LOCKED;
X  		else			levl[x][y].doormask = D_CLOSED;
X***************
X*** 599,605 ****
X  	    if(trap_type || !rn2(4)) {
X  
X  		rm->typ = SCORR;
X! 		rm->scrsym = STONE_SYM;
X  		if(trap_type) {
X  		    ttmp = maketrap(xx, yy+dy, trap_type);
X  		    ttmp->once = 1;
X--- 597,603 ----
X  	    if(trap_type || !rn2(4)) {
X  
X  		rm->typ = SCORR;
X! 		rm->scrsym = ' ';		/* _not_ STONE_SYM */
X  		if(trap_type) {
X  		    ttmp = maketrap(xx, yy+dy, trap_type);
X  		    ttmp->once = 1;
X***************
X*** 787,799 ****
X  #ifdef MEDUSA
X  	if (dlevel == medusa_level) {
X  		struct monst *mtmp;
X  
X  		if (mtmp = makemon(&mons[PM_MEDUSA], xdnstair, ydnstair))
X  			mtmp->msleep = 1;
X  		for (tryct = rn1(1,3); tryct; tryct--) {
X  			x = somex(croom); y = somey(croom);
X! 			if (goodpos(x,y,(struct permonst *)0))
X! 				(void) mk_tt_object(STATUE, x, y);
X  		}
X  	}
X  #endif
X--- 785,803 ----
X  #ifdef MEDUSA
X  	if (dlevel == medusa_level) {
X  		struct monst *mtmp;
X+ 		struct obj *otmp;
X  
X  		if (mtmp = makemon(&mons[PM_MEDUSA], xdnstair, ydnstair))
X  			mtmp->msleep = 1;
X  		for (tryct = rn1(1,3); tryct; tryct--) {
X  			x = somex(croom); y = somey(croom);
X! 			if (goodpos(x,y,(struct permonst *)0)) {
X! 				otmp = mk_tt_object(STATUE, x, y);
X! 				while(resists_ston(&mons[otmp->corpsenm])) {
X! 					otmp->corpsenm = rndmonnum();
X! 					otmp->owt = weight(otmp);
X! 				}
X! 			}
X  		}
X  	}
X  #endif
X***************
X*** 922,937 ****
X  		/* put statues inside */
X  #ifdef MEDUSA
X  		if(!rn2(dlevel == medusa_level ? 1 : 20)) {
X  			if (!rn2(dlevel == medusa_level ? 2 : 50))
X! 				(void) mk_tt_object(STATUE,
X  						somex(croom), somey(croom));
X  			else {
X! 				struct obj *otmp =
X! 					mkcorpstat(STATUE, (struct permonst *)0,
X  						somex(croom), somey(croom));
X! 				if (dlevel == medusa_level && otmp) 
X! 					otmp->spe = 0;
X  				/* Medusa statues don't contain books */
X  			}
X  		}
X  #else
X--- 926,947 ----
X  		/* put statues inside */
X  #ifdef MEDUSA
X  		if(!rn2(dlevel == medusa_level ? 1 : 20)) {
X+ 			struct obj *otmp;
X+ 
X  			if (!rn2(dlevel == medusa_level ? 2 : 50))
X! 				otmp = mk_tt_object(STATUE,
X  						somex(croom), somey(croom));
X  			else {
X! 				otmp = mkcorpstat(STATUE, (struct permonst *)0,
X  						somex(croom), somey(croom));
X! 			}
X! 			if (dlevel == medusa_level && otmp) {
X  				/* Medusa statues don't contain books */
X+ 				otmp->spe = 0;
X+ 				while(resists_ston(&mons[otmp->corpsenm])) {
X+ 					otmp->corpsenm = rndmonnum();
X+ 					otmp->owt = weight(otmp);
X+ 				}
X  			}
X  		}
X  #else
X***************
X*** 1117,1123 ****
X  
X  		if((mtmp = makemon(mkclass(S_MIMIC), mx, my))) {
X  		    mtmp->mimic = 1;
X! 		    mtmp->mappearance = DOOR_SYM;
X  		}
X  		return;
X  	}
X--- 1127,1133 ----
X  
X  		if((mtmp = makemon(mkclass(S_MIMIC), mx, my))) {
X  		    mtmp->mimic = 1;
X! 		    mtmp->mappearance = CLOSED_DOOR_SYM;
X  		}
X  		return;
X  	}
X*** src/Old/mkmaze.c	Sun Nov 19 13:44:08 1989
X--- src/mkmaze.c	Mon Oct 30 17:31:22 1989
X***************
X*** 26,32 ****
X  int x1, y1, x2, y2;
X  boolean see;
X  {
X! 	char type;
X  	short x,y;
X  	register struct rm *room;
X  
X--- 26,32 ----
X  int x1, y1, x2, y2;
X  boolean see;
X  {
X! 	uchar type;
X  	short x,y;
X  	register struct rm *room;
X  
X***************
X*** 43,144 ****
X  		room = &levl[x][y];
X  		type = room->typ;
X  		if (iswall(x,y)) {
X! 		    if (IS_DOOR(type)) {
X! 			room->scrsym = DOOR_SYM;
X! 			continue;
X! 		    } else
X  		    if (iswall(x,y-1))
X  			if (iswall(x,y+1))
X  			    if (iswall(x-1,y))
X! 				if (iswall(x+1,y)) {
X! 					room->scrsym = CRWALL_SYM; /* -+- */
X  					room->typ = CROSSWALL;
X! 				} else {
X! 					room->scrsym = TLWALL_SYM; /* -| */
X  					room->typ = TLWALL;
X- 				}
X  			    else
X! 				if (iswall(x+1,y)) {
X! 					room->scrsym = TRWALL_SYM; /* |- */
X  					room->typ = TRWALL;
X! 				} else {
X  					room->typ = VWALL;
X- #ifdef STRONGHOLD
X- 					if (is_drawbridge_wall(x,y) >= 0)
X- 					    room->scrsym = DB_VWALL_SYM;
X- 					else
X- #endif
X- 					    room->scrsym = VWALL_SYM; /* | */
X- 				}
X  			else
X  			    if (iswall(x-1,y))
X! 				if (iswall(x+1,y)) {		      
X! 					room->scrsym = TUWALL_SYM;  /*  |  */
X! 					room->typ = TUWALL;	    /* -+- */
X! 				} else {
X! 					room->scrsym = BRCORN_SYM;  /*	| */
X! 					room->typ = BRCORNER;	    /* -+ */
X! 				}
X  			    else
X! 				if (iswall(x+1,y)) {		    
X! 					room->scrsym = BLCORN_SYM;  /* |  */
X! 					room->typ = BLCORNER;	    /* +- */
X! 				} else {
X  					room->typ = VWALL;
X- #ifdef STRONGHOLD
X- 					if (is_drawbridge_wall(x,y) >= 0)
X- 					    room->scrsym = DB_VWALL_SYM;
X- 					else
X- #endif
X- 					    room->scrsym = VWALL_SYM; /* | */
X- 				}
X  		    else
X  			if (iswall(x,y+1))
X  			    if (iswall(x-1,y))
X! 				if (iswall(x+1,y)) {
X! 					room->scrsym = TDWALL_SYM;  /* -+- */
X! 					room->typ = TDWALL;	    /*	| */
X! 				} else {
X! 					room->scrsym = TRCORN_SYM;  /* -+ */
X! 					room->typ = TRCORNER;	    /*	| */
X! 				}
X  			    else
X! 				if (iswall(x+1,y)) {
X! 					room->scrsym = TLCORN_SYM;  /* +- */
X! 					room->typ = TLCORNER;	    /* |  */
X! 				} else {
X  					room->typ = VWALL;
X! #ifdef STRONGHOLD
X! 					if (is_drawbridge_wall(x,y) >= 0)
X! 					    room->scrsym = DB_VWALL_SYM;
X! 					else
X! #endif
X! 					    room->scrsym = VWALL_SYM; /* | */
X! 				}
X! 			else {
X  				room->typ = HWALL;
X- #ifdef STRONGHOLD
X- 				if (is_drawbridge_wall(x,y) >= 0)
X- 				    room->scrsym = DB_HWALL_SYM;
X- 				else
X- #endif
X- 				    room->scrsym = HWALL_SYM;
X- 			}
X  		    if (type == SDOOR) room->typ = type;
X- 		    if (see) room->seen = 0;
X- 		} else {
X- 		    switch(room->typ) {
X- 			case STONE:
X- 				room->scrsym = STONE_SYM;
X- 				break;
X- 			case CORR:
X- 				room->scrsym = CORR_SYM;
X- 				break;
X- 			case ROOM:
X- 				room->scrsym = ROOM_SYM;
X- 		    }
X- 		    if (see) room->seen = 0;
X  		}
X  	    }
X  }
X  #endif /* WALLIFIED_MAZE /**/
X--- 43,92 ----
X  		room = &levl[x][y];
X  		type = room->typ;
X  		if (iswall(x,y)) {
X! 		  if (IS_DOOR(type))
X! 		    continue;
X! 		  else
X  		    if (iswall(x,y-1))
X  			if (iswall(x,y+1))
X  			    if (iswall(x-1,y))
X! 				if (iswall(x+1,y))
X  					room->typ = CROSSWALL;
X! 				else
X  					room->typ = TLWALL;
X  			    else
X! 				if (iswall(x+1,y))
X  					room->typ = TRWALL;
X! 				else
X  					room->typ = VWALL;
X  			else
X  			    if (iswall(x-1,y))
X! 				if (iswall(x+1,y))
X! 					room->typ = TUWALL;
X! 				else
X! 					room->typ = BRCORNER;
X  			    else
X! 				if (iswall(x+1,y))
X! 					room->typ = BLCORNER;
X! 				else
X  					room->typ = VWALL;
X  		    else
X  			if (iswall(x,y+1))
X  			    if (iswall(x-1,y))
X! 				if (iswall(x+1,y))
X! 					room->typ = TDWALL;
X! 				else
X! 					room->typ = TRCORNER;
X  			    else
X! 				if (iswall(x+1,y))
X! 					room->typ = TLCORNER;
X! 				else
X  					room->typ = VWALL;
X! 			else
X  				room->typ = HWALL;
X  		    if (type == SDOOR) room->typ = type;
X  		}
X+ 		room->scrsym = news0(x,y);
X+ 		if (see) room->seen = 0;
X  	    }
X  }
X  #endif /* WALLIFIED_MAZE /**/
X***************
X*** 273,286 ****
X  	    if(mtmp = makemon(&mons[PM_HELL_HOUND], zx+1, zy))
X  		mtmp->msleep = 1;
X  	    (void) makemon(&mons[PM_KRAKEN], zx+2, zy+2);
X  	    if (dlevel == wiz_level) {
X  
X  		(void) mksobj_at(AMULET_OF_YENDOR, zx, zy);
X  		flags.made_amulet = 1;
X- #ifndef STRONGHOLD
X- 		if(mtmp = makemon(&mons[PM_VLAD_THE_IMPALER], zx-1, zy))
X- 			mtmp->msleep = 1;
X- #endif
X  		if(mtmp = makemon(&mons[PM_WIZARD_OF_YENDOR], zx, zy))
X  			mtmp->msleep = 1;
X  	    } else {
X--- 221,232 ----
X  	    if(mtmp = makemon(&mons[PM_HELL_HOUND], zx+1, zy))
X  		mtmp->msleep = 1;
X  	    (void) makemon(&mons[PM_KRAKEN], zx+2, zy+2);
X+ 	    if (mtmp = makemon(&mons[PM_VAMPIRE_LORD], zx-1, zy))
X+ 		mtmp->msleep = 1;
X  	    if (dlevel == wiz_level) {
X  
X  		(void) mksobj_at(AMULET_OF_YENDOR, zx, zy);
X  		flags.made_amulet = 1;
X  		if(mtmp = makemon(&mons[PM_WIZARD_OF_YENDOR], zx, zy))
X  			mtmp->msleep = 1;
X  	    } else {
X***************
X*** 288,297 ****
X  	    	/* make a cheap plastic imitation */
X  		if (ot = mksobj_at(AMULET_OF_YENDOR, zx, zy))
X  		    ot-> spe = -1;
X- #ifndef STRONGHOLD
X- 		if (mtmp = makemon(&mons[PM_VAMPIRE_LORD], zx-1, zy))
X- 		    mtmp->msleep = 1;
X- #endif
X  		(void) makemon(&mons[dprince()], zx, zy);
X  	    }
X  	    /* they should wake up when we intrude */
X--- 234,239 ----
X***************
X*** 317,353 ****
X  	wallification(2, 2, x_maze_max, y_maze_max, TRUE);
X  #else
X  	for(x = 2; x < x_maze_max; x++)
X! 		for(y = 2; y < y_maze_max; y++) {
X! 			switch(levl[x][y].typ) {
X! 			case STONE:
X! 				levl[x][y].scrsym = STONE_SYM;
X! 				break;
X! 			case CORR:
X! 				levl[x][y].scrsym = CORR_SYM;
X! 				break;
X! 			case ROOM:
X! 				levl[x][y].scrsym = ROOM_SYM;
X! 				break;
X! 			case HWALL:
X! 				levl[x][y].scrsym = HWALL_SYM;
X! 				break;
X! 			case VWALL:
X! 				levl[x][y].scrsym = VWALL_SYM;
X! 				break;
X! 			case TLCORNER:
X! 				levl[x][y].scrsym = TLCORN_SYM;
X! 				break;
X! 			case TRCORNER:
X! 				levl[x][y].scrsym = TRCORN_SYM;
X! 				break;
X! 			case BLCORNER:
X! 				levl[x][y].scrsym = BLCORN_SYM;
X! 				break;
X! 			case BRCORNER:
X! 				levl[x][y].scrsym = BRCORN_SYM;
X! 				break;
X! 			}
X! 		}
X  #endif
X  	mazexy(&mm);
X  	levl[(xupstair = mm.x)][(yupstair = mm.y)].scrsym = UP_SYM;
X--- 259,266 ----
X  	wallification(2, 2, x_maze_max, y_maze_max, TRUE);
X  #else
X  	for(x = 2; x < x_maze_max; x++)
X! 		for(y = 2; y < y_maze_max; y++)
X! 			levl[x][y].scrsym = news0(x,y);
X  #endif
X  	mazexy(&mm);
X  	levl[(xupstair = mm.x)][(yupstair = mm.y)].scrsym = UP_SYM;
X*** src/Old/mkobj.c	Sun Nov 19 13:44:30 1989
X--- src/mkobj.c	Thu Nov  9 20:27:13 1989
X***************
X*** 1,4 ****
X! /*	SCCS Id: @(#)mkobj.c	3.0	88/10/30
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X--- 1,4 ----
X! /*	SCCS Id: @(#)mkobj.c	3.0	89/11/08
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X***************
X*** 257,263 ****
X  			else		otmp->corpsenm = -1; /* empty */
X  		    } else		otmp->corpsenm = -1; /* empty */
X  		} else if(otmp->otyp == TIN) {
X! 		    if(!rn2(10)) {
X  			otmp->spe = 1;		/* spinach */
X  			otmp->corpsenm = -1;
X  		    } else do {
X--- 257,263 ----
X  			else		otmp->corpsenm = -1; /* empty */
X  		    } else		otmp->corpsenm = -1; /* empty */
X  		} else if(otmp->otyp == TIN) {
X! 		    if(!rn2(6)) {
X  			otmp->spe = 1;		/* spinach */
X  			otmp->corpsenm = -1;
X  		    } else do {
X***************
X*** 448,454 ****
X  }
X  
X  int
X! letter(c) {
X  	return(('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z'));
X  }
X  
X--- 448,456 ----
X  }
X  
X  int
X! letter(c)
X! int c;
X! {
X  	return(('@' <= c && c <= 'Z') || ('a' <= c && c <= 'z'));
X  }
X  
X***************
X*** 507,513 ****
X  	register struct obj *otmp;
X  
X  	if(objtype != CORPSE && objtype != STATUE)
X! 		impossible("making corpstate type %d", objtype);
X  	otmp = mksobj_at(objtype, x, y);
X  	if(otmp)  {
X  		if(ptr)	otmp->corpsenm = monsndx(ptr);
X--- 509,515 ----
X  	register struct obj *otmp;
X  
X  	if(objtype != CORPSE && objtype != STATUE)
X! 		impossible("making corpstat type %d", objtype);
X  	otmp = mksobj_at(objtype, x, y);
X  	if(otmp)  {
X  		if(ptr)	otmp->corpsenm = monsndx(ptr);
X*** src/Old/mon.c	Sun Nov 19 13:45:31 1989
X--- src/mon.c	Sun Nov 19 09:45:11 1989
X***************
X*** 1,16 ****
X! /*	SCCS Id: @(#)mon.c	3.0	88/10/31
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #ifdef MICROPORT_BUG
X  #define MKROOM_H
X  #endif
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X- #ifdef NAMED_ITEMS
X- #  include "artifact.h"
X- #endif
X  
X  #ifdef WORM
X  #  include "wseg.h"
X--- 1,13 ----
X! /*	SCCS Id: @(#)mon.c	3.0	89/11/19
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X! #if (defined(MICROPORT_BUG) || !defined(LINT)) && !defined(__STDC__)
X  #define MKROOM_H
X  #endif
X  
X  #include "hack.h"
X  #include "mfndpos.h"
X  
X  #ifdef WORM
X  #  include "wseg.h"
X***************
X*** 49,54 ****
X--- 46,52 ----
X  	    case PM_KOBOLD_ZOMBIE:
X  		obj = mksobj_at(CORPSE, x, y);
X  		obj->corpsenm = PM_KOBOLD;
X+ 		obj->age -= 50;			/* this is an *OLD* corpse */
X  		break;
X  	    case PM_GNOME_MUMMY:
X  		obj = mksobj_at(MUMMY_WRAPPING, x, y); /* and fall through */
X***************
X*** 55,60 ****
X--- 53,59 ----
X  	    case PM_GNOME_ZOMBIE:
X  		obj = mksobj_at(CORPSE, x, y);
X  		obj->corpsenm = PM_GNOME;
X+ 		obj->age -= 50;			/* this is an *OLD* corpse */
X  		break;
X  	    case PM_ORC_MUMMY:
X  		obj = mksobj_at(MUMMY_WRAPPING, x, y); /* and fall through */
X***************
X*** 61,66 ****
X--- 60,66 ----
X  	    case PM_ORC_ZOMBIE:
X  		obj = mksobj_at(CORPSE, x, y);
X  		obj->corpsenm = PM_ORC;
X+ 		obj->age -= 50;			/* this is an *OLD* corpse */
X  		break;
X  	    case PM_ELF_MUMMY:
X  		obj = mksobj_at(MUMMY_WRAPPING, x, y); /* and fall through */
X***************
X*** 67,72 ****
X--- 67,73 ----
X  	    case PM_ELF_ZOMBIE:
X  		obj = mksobj_at(CORPSE, x, y);
X  		obj->corpsenm = PM_ELF;
X+ 		obj->age -= 50;			/* this is an *OLD* corpse */
X  		break;
X  	    case PM_HUMAN_MUMMY:
X  		obj = mksobj_at(MUMMY_WRAPPING, x, y); /* and fall through */
X***************
X*** 73,78 ****
X--- 74,80 ----
X  	    case PM_HUMAN_ZOMBIE:
X  		obj = mksobj_at(CORPSE, x, y);
X  		obj->corpsenm = PM_HUMAN;
X+ 		obj->age -= 50;			/* this is an *OLD* corpse */
X  		break;
X  	    case PM_GIANT_MUMMY:
X  		obj = mksobj_at(MUMMY_WRAPPING, x, y); /* and fall through */
X***************
X*** 79,84 ****
X--- 81,87 ----
X  	    case PM_GIANT_ZOMBIE:
X  		obj = mksobj_at(CORPSE, x, y);
X  		obj->corpsenm = PM_GIANT;
X+ 		obj->age -= 50;			/* this is an *OLD* corpse */
X  		break;
X  	    case PM_ETTIN_MUMMY:
X  		obj = mksobj_at(MUMMY_WRAPPING, x, y); /* and fall through */
X***************
X*** 85,90 ****
X--- 88,94 ----
X  	    case PM_ETTIN_ZOMBIE:
X  		obj = mksobj_at(CORPSE, x, y);
X  		obj->corpsenm = PM_ETTIN;
X+ 		obj->age -= 50;			/* this is an *OLD* corpse */
X  		break;
X  #ifdef GOLEMS
X  	    case PM_IRON_GOLEM:
X***************
X*** 173,179 ****
X  		mtmp->mlstmv = moves;
X  
X  		/* most monsters drown in pools */
X! 		{ boolean inpool,infountain,iseel,isgremlin;
X  
X  		  inpool = is_pool(mtmp->mx,mtmp->my);
X  		  iseel = mtmp->data->mlet == S_EEL;
X--- 177,186 ----
X  		mtmp->mlstmv = moves;
X  
X  		/* most monsters drown in pools */
X! 		{ boolean inpool,iseel,isgremlin;
X! #ifdef FOUNTAINS
X! 		  boolean infountain;
X! #endif
X  
X  		  inpool = is_pool(mtmp->mx,mtmp->my);
X  		  iseel = mtmp->data->mlet == S_EEL;
X***************
X*** 226,232 ****
X  		if(mtmp->mspeed != MSLOW || !(moves%2)){
X  			/* continue if the monster died fighting */
X  			fr = -1;
X! /* TODO:	Handle the case of the agressor dying? */
X  			if(Conflict && !mtmp->iswiz &&
X  			   /* area you can see if you're not blind */
X  			   (dist(mtmp->mx,mtmp->my) < 3 ||
X--- 233,239 ----
X  		if(mtmp->mspeed != MSLOW || !(moves%2)){
X  			/* continue if the monster died fighting */
X  			fr = -1;
X! /* TODO:	Handle the case of the aggressor dying? */
X  			if(Conflict && !mtmp->iswiz &&
X  			   /* area you can see if you're not blind */
X  			   (dist(mtmp->mx,mtmp->my) < 3 ||
X***************
X*** 300,308 ****
X  		newsym(mtmp->mx, mtmp->my);
X  	}
X  	/* Eats topmost metal object if it is there */
X! 	for (otmp = fobj; otmp; otmp = otmp->nobj)
X! 	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my &&
X! 		objects[otmp->otyp].oc_material > WOOD &&
X  		objects[otmp->otyp].oc_material < MINERAL) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X--- 307,315 ----
X  		newsym(mtmp->mx, mtmp->my);
X  	}
X  	/* Eats topmost metal object if it is there */
X! 	for (otmp = level.objects[mtmp->mx][mtmp->my];
X! 						    otmp; otmp = otmp->nexthere)
X! 	    if (objects[otmp->otyp].oc_material > WOOD &&
X  		objects[otmp->otyp].oc_material < MINERAL) {
X  		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s eats %s!", Monnam(mtmp),
X***************
X*** 337,365 ****
X  
X  	/* Eats organic, glass, or wood objects if there */
X  	/* Engulfs others, except huge rocks and metal attached to player */
X! 	for (otmp = fobj; otmp; otmp = otmp2) {
X! 	    otmp2 = otmp->nobj;
X! 	    if (otmp->ox == mtmp->mx && otmp->oy == mtmp->my) {
X! 		if(objects[otmp->otyp].oc_material <= WOOD) {
X! 		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X! 			pline("%s eats %s!", Monnam(mtmp),
X! 				distant_name(otmp, doname));
X! 		    else if (flags.soundok && flags.verbose)
X! 			You("hear a slurping sound.");
X!                     /* Heal up to the object's weight in hp */
X! 		    if (mtmp->mhp < mtmp->mhpmax) {
X! 			mtmp->mhp += objects[otmp->otyp].oc_weight;
X! 			if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = mtmp->mhpmax;
X! 		    }
X! 		    delobj(otmp);		/* munch */
X! 		} else if (otmp->olet != ROCK_SYM &&
X! 					otmp != uball && otmp != uchain) {
X! 		    if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X! 			pline("%s engulfs %s.", Monnam(mtmp),
X! 				distant_name(otmp,doname));
X! 		    freeobj(otmp);
X! 		    mpickobj(mtmp, otmp);	/* slurp */
X  		}
X  	    }
X  	    /* Engulf & devour is instant, so don't set meating */
X  	    newsym(mtmp->mx, mtmp->my);
X--- 344,370 ----
X  
X  	/* Eats organic, glass, or wood objects if there */
X  	/* Engulfs others, except huge rocks and metal attached to player */
X! 	for (otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp = otmp2) {
X! 	    otmp2 = otmp->nexthere;
X! 	    if(objects[otmp->otyp].oc_material <= WOOD) {
X! 		if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X! 		    pline("%s eats %s!", Monnam(mtmp),
X! 			    distant_name(otmp, doname));
X! 		else if (flags.soundok && flags.verbose)
X! 		    You("hear a slurping sound.");
X! 		/* Heal up to the object's weight in hp */
X! 		if (mtmp->mhp < mtmp->mhpmax) {
X! 		    mtmp->mhp += objects[otmp->otyp].oc_weight;
X! 		    if (mtmp->mhp > mtmp->mhpmax) mtmp->mhp = mtmp->mhpmax;
X  		}
X+ 		delobj(otmp);		/* munch */
X+ 	    } else if (otmp->olet != ROCK_SYM &&
X+ 				    otmp != uball && otmp != uchain) {
X+ 		if (cansee(mtmp->mx, mtmp->my) && flags.verbose)
X+ 		    pline("%s engulfs %s.", Monnam(mtmp),
X+ 			    distant_name(otmp,doname));
X+ 		freeobj(otmp);
X+ 		mpickobj(mtmp, otmp);	/* slurp */
X  	    }
X  	    /* Engulf & devour is instant, so don't set meating */
X  	    newsym(mtmp->mx, mtmp->my);
X***************
X*** 389,408 ****
X  {
X  	register struct obj *otmp;
X  
X! 	for(otmp = fobj; otmp; otmp = otmp->nobj)
X! 	  if(throws_rocks(mtmp->data) ? otmp->otyp == BOULDER :
X  			(otmp->olet == GEM_SYM && otmp->otyp < LAST_GEM+6))
X! 	    if(otmp->ox == mtmp->mx && otmp->oy == mtmp->my)
X! 	      if(mtmp->data->mlet != S_UNICORN
X! 		 || objects[otmp->otyp].g_val != 0){
X! 		if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s picks up %s.", Monnam(mtmp),
X  				distant_name(otmp, doname));
X! 		freeobj(otmp);
X! 		mpickobj(mtmp, otmp);
X! 		newsym(mtmp->mx, mtmp->my);
X! 		return;	/* pick only one object */
X! 	      }
X  }
X  
X  int
X--- 394,412 ----
X  {
X  	register struct obj *otmp;
X  
X! 	for(otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp=otmp->nexthere)
X! 	    if(throws_rocks(mtmp->data) ? otmp->otyp == BOULDER :
X  			(otmp->olet == GEM_SYM && otmp->otyp < LAST_GEM+6))
X! 		if(mtmp->data->mlet != S_UNICORN
X! 			|| objects[otmp->otyp].g_val != 0){
X! 		    if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s picks up %s.", Monnam(mtmp),
X  				distant_name(otmp, doname));
X! 		    freeobj(otmp);
X! 		    mpickobj(mtmp, otmp);
X! 		    newsym(mtmp->mx, mtmp->my);
X! 		    return;	/* pick only one object */
X! 		}
X  }
X  
X  int
X***************
X*** 481,489 ****
X  /*	prevent shopkeepers from leaving the door of their shop */
X  	if(mtmp->isshk && inhishop(mtmp)) return;
X  
X! 	for(otmp = fobj; otmp; otmp = otmp->nobj)
X! 	  if(index(str, otmp->olet))
X! 	    if(otmp->ox == mtmp->mx && otmp->oy == mtmp->my) {
X  		if(!can_carry(mtmp,otmp)) return;
X  		if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s picks up %s.", Monnam(mtmp), doname(otmp));
X--- 485,492 ----
X  /*	prevent shopkeepers from leaving the door of their shop */
X  	if(mtmp->isshk && inhishop(mtmp)) return;
X  
X! 	for(otmp = level.objects[mtmp->mx][mtmp->my]; otmp; otmp=otmp->nexthere)
X! 	    if(index(str, otmp->olet)) {
X  		if(!can_carry(mtmp,otmp)) return;
X  		if (cansee(mtmp->mx,mtmp->my) && flags.verbose)
X  			pline("%s picks up %s.", Monnam(mtmp), doname(otmp));
X***************
X*** 503,516 ****
X  	long *info;	/* long info[9] */
X  	long flag;
X  {
X! 	register int x,y,nx,ny,cnt = 0,ntyp;
X! 	int nowtyp;
X! 	boolean wantpool,poolok;
X  
X  	x = mon->mx;
X  	y = mon->my;
X  	nowtyp = levl[x][y].typ;
X  
X  	wantpool = mon->data->mlet == S_EEL;
X  	poolok = is_flyer(mon->data) || (is_swimmer(mon->data) && !wantpool);
X  nexttry:	/* eels prefer the water, but if there is no water nearby,
X--- 506,521 ----
X  	long *info;	/* long info[9] */
X  	long flag;
X  {
X! 	register int x,y,nx,ny,cnt = 0;
X! 	register uchar ntyp;
X! 	uchar nowtyp;
X! 	boolean wantpool,poolok,nodiag;
X  
X  	x = mon->mx;
X  	y = mon->my;
X  	nowtyp = levl[x][y].typ;
X  
X+ 	nodiag = (mon->data == &mons[PM_GRID_BUG]);
X  	wantpool = mon->data->mlet == S_EEL;
X  	poolok = is_flyer(mon->data) || (is_swimmer(mon->data) && !wantpool);
X  nexttry:	/* eels prefer the water, but if there is no water nearby,
X***************
X*** 523,528 ****
X--- 528,534 ----
X  		flag |= ALLOW_SSM;
X  	for(nx = x-1; nx <= x+1; nx++) for(ny = y-1; ny <= y+1; ny++) {
X  	    if((nx == x && ny == y) || !isok(nx,ny)) continue;
X+ 	    if(nx != x && ny != y && nodiag) continue;
X  	    if(IS_ROCK(ntyp = levl[nx][ny].typ) && !(flag & ALLOW_WALL) &&
X  		!((flag & ALLOW_DIG) && may_dig(nx,ny))) continue;
X  	    if(IS_DOOR(ntyp) && !amorphous(mon->data) &&
X***************
X*** 532,538 ****
X  		   (verysmall(mon->data) ||
X  		    (!is_giant(mon->data) && nohands(mon->data))))
X  	       ) && !(flag & (ALLOW_WALL|ALLOW_DIG))) continue;
X! 	    if(nx != x && ny != y && (IS_DOOR(nowtyp) || IS_DOOR(ntyp)))
X  		continue;
X  	    if(is_pool(nx,ny) == wantpool || poolok) {
X  		/* Displacement also displaces the Elbereth/scare monster,
X--- 538,553 ----
X  		   (verysmall(mon->data) ||
X  		    (!is_giant(mon->data) && nohands(mon->data))))
X  	       ) && !(flag & (ALLOW_WALL|ALLOW_DIG))) continue;
X! 	    if(nx != x && ny != y &&
X! #ifdef REINCARNATION
X! 	       ((IS_DOOR(nowtyp) && ((levl[x][y].doormask & ~D_BROKEN)
X! 			|| dlevel == rogue_level)) ||
X! 		(IS_DOOR(ntyp) && ((levl[nx][ny].doormask & ~D_BROKEN)
X! 			|| dlevel == rogue_level))))
X! #else
X! 	       ((IS_DOOR(nowtyp) && (levl[x][y].doormask & ~D_BROKEN)) ||
X! 		(IS_DOOR(ntyp) && (levl[nx][ny].doormask & ~D_BROKEN))))
X! #endif
X  		continue;
X  	    if(is_pool(nx,ny) == wantpool || poolok) {
X  		/* Displacement also displaces the Elbereth/scare monster,
X***************
X*** 629,634 ****
X--- 644,660 ----
X  	return dx*dx + dy*dy;
X  }
X  
X+ boolean
X+ monnear(mon, x, y)
X+ register struct monst *mon;
X+ register int x,y;
X+ /* Is the square close enough for the monster to move or attack into? */
X+ {
X+ 	register int distance = dist2(mon->mx, mon->my, x, y);
X+ 	if (distance==2 && mon->data==&mons[PM_GRID_BUG]) return 0;
X+ 	return (distance < 3);
X+ }
X+ 
X  static const char *poiseff[] = {
X  
X  	" feel very weak", "r brain is on fire",
X***************
X*** 659,665 ****
X  	    plural = (string[strlen(string) - 1] == 's')? 1 : 0;
X  	    if(Blind)
X  		pline("%s poisoned.", plural ? "They were" : "It was");
X! #ifdef HARD
X  	    /* avoid "The" Orcus's sting was poisoned... */
X  	    else if(isupper(*string))
X  		pline("%s %s poisoned!", string, plural ? "were" : "was");
X--- 685,691 ----
X  	    plural = (string[strlen(string) - 1] == 's')? 1 : 0;
X  	    if(Blind)
X  		pline("%s poisoned.", plural ? "They were" : "It was");
X! #ifdef INFERNO
X  	    /* avoid "The" Orcus's sting was poisoned... */
X  	    else if(isupper(*string))
X  		pline("%s %s poisoned!", string, plural ? "were" : "was");
X***************
X*** 930,935 ****
X--- 956,966 ----
X  		newsym(x,y);
X  	}
X  #endif
X+ 	if(mdat->mlet == S_UNICORN) {
X+ 		(void) mksobj_at(UNICORN_HORN, x, y);
X+ 		stackobj(fobj);
X+ 		newsym(x,y);
X+ 	}
X  #ifdef MAIL
X  	if(mdat == &mons[PM_MAIL_DAEMON]) {
X  		(void) mksobj_at(SCR_MAIL, x, y);
X***************
X*** 954,960 ****
X  			otmp = mkobj_at(RANDOM_SYM, x, y);
X  			/* Don't create large objects from small monsters */
X  			typ = otmp->otyp;
X! 			if (!bigmonst(mdat) && typ != FOOD_RATION
X  #ifdef WALKIES
X  			    && typ != LEASH
X  #endif
X--- 985,991 ----
X  			otmp = mkobj_at(RANDOM_SYM, x, y);
X  			/* Don't create large objects from small monsters */
X  			typ = otmp->otyp;
X! 			if (mdat->msize < MZ_HUMAN && typ != FOOD_RATION
X  #ifdef WALKIES
X  			    && typ != LEASH
X  #endif
X***************
X*** 973,979 ****
X  		 * different from whether or not the corpse is "special";
X  		 * if we want both, we have to specify it explicitly.
X  		 */
X! 		if (bigmonst(mdat)
X  #ifdef GOLEMS
X  				   || is_golem(mdat)
X  #endif
X--- 1004,1010 ----
X  		 * different from whether or not the corpse is "special";
X  		 * if we want both, we have to specify it explicitly.
X  		 */
X! 		if (bigmonst(mdat) || mdat == &mons[PM_LIZARD]
X  #ifdef GOLEMS
X  				   || is_golem(mdat)
X  #endif
X***************
X*** 1007,1013 ****
X  	register struct monst *mtmp;
X  
X  	for (mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 		if (mtmp->data->mlet == S_CHAMELEON)
X  			mtmp->cham = 1;
X  }
X  
X--- 1038,1044 ----
X  	register struct monst *mtmp;
X  
X  	for (mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X! 		if (mtmp->data == &mons[PM_CHAMELEON])
X  			mtmp->cham = 1;
X  }
X  
X***************
X*** 1045,1055 ****
X  #ifdef WORM
X  	if(mtmp->wormno) wormdead(mtmp);	/* throw tail away */
X  #endif
X- 	mtmp->m_lev = adj_lev(mdat);		/* new monster level */
X- 
X  	hpn = mtmp->mhp;
X   	hpd = (mtmp->m_lev < 50) ? (mtmp->m_lev)*8 : mdat->mlevel;
X   	if(!hpd) hpd = 4;
X   	mhp = (mtmp->m_lev < 50) ? (mtmp->m_lev)*8 : mdat->mlevel;
X   	if(!mhp) mhp = 4;
X  
X--- 1076,1087 ----
X  #ifdef WORM
X  	if(mtmp->wormno) wormdead(mtmp);	/* throw tail away */
X  #endif
X  	hpn = mtmp->mhp;
X   	hpd = (mtmp->m_lev < 50) ? (mtmp->m_lev)*8 : mdat->mlevel;
X   	if(!hpd) hpd = 4;
X+ 
X+ 	mtmp->m_lev = adj_lev(mdat);		/* new monster level */
X+ 
X   	mhp = (mtmp->m_lev < 50) ? (mtmp->m_lev)*8 : mdat->mlevel;
X   	if(!mhp) mhp = 4;
X  
X***************
X*** 1244,1250 ****
X  {
X  	struct obj *otmp;
X  
X! 	if(!verysmall(mdef->data) ||
X  	   !rn2(2 + ((mdef->data->geno & G_FREQ) > 2))) {
X  		otmp = mk_named_object(STATUE, mdef->data, mdef->mx, mdef->my,
X  			NAME(mdef), (int)mdef->mnamelth);
X--- 1276,1282 ----
X  {
X  	struct obj *otmp;
X  
X! 	if(mdef->data->msize > MZ_TINY ||
X  	   !rn2(2 + ((mdef->data->geno & G_FREQ) > 2))) {
X  		otmp = mk_named_object(STATUE, mdef->data, mdef->mx, mdef->my,
X  			NAME(mdef), (int)mdef->mnamelth);
END_OF_FILE
if test 54198 -ne `wc -c <'patches06h'`; then
    echo shar: \"'patches06h'\" unpacked with wrong size!
fi
# end of 'patches06h'
fi
echo shar: End of archive 7 \(of 15\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
