Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i048:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch5a
Message-ID: <4699@tekred.CNA.TEK.COM>
Date: 17 Oct 89 20:20:29 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1228
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 48
Archive-name: NetHack3/Patch5a
Patch-To: NetHack3: Volume 7, Issue 56-93

	[It's mentioned in the UPDATE5 file, but I'll repeat it here:
	 these patches should be applied to unmodified patchlevel 4
	 source files. If you applied the temporary fix posted in the
	 nethack newsgroup, it should be backed out (or you'll get
	 rejects from patch(1).  -br]
		
[From the development team...
Old bones and save files should at least be syntactically correct this time,
but you should still throw them out if you don't want to be confronted with
monsters permanently masquerading as different monsters (since some of the
monsters' letters have changed).

Note that the posted shop fix was a stopgap patch, not an official patch, so
it should be reversed before applying these patches.  If you do not reverse 
it, probably nothing worse than a failure of one shk.c band will happen this
time.  In general, however, you will have to do considerable hand-patching if
you leave intermediate patches in.

The major bug fix in Patch 5 is moving the color definitions to color.h, thus
breaking the annoying dependency loop when bootstrapping NetHack.

Patch 5 contains Johnny Lee's provision of a port to the Macintosh.  The 
Macintosh files live in a new subdirectory, 'mac'.  We know that many of you
were waiting for a Mac port, and for you we are happy to have it.

Basic support for several new other compilers or machines (see README), but 
these probably need some more tweaking.

A major new feature in Patch 5 is timed-out eating, i.e., being able to be
interrupted while eating by monsters attack.  Mike Stephenson provided the 
basic structure for dealing with partially eaten food.  We believe that the
only remaining flaws in this code are occasional non-optimal messages which
are generated by it (we are working on correcting this).

Incorrect iron ball behavior and bugs in the iron ball code were 
systematically corrected by Kevin Darcy who communicated with us about it
and mailed us his patches.  (Yes, Kevin, as you can see, it went in, and 
with only one minor change.)  

There were other, smaller, patches which were mailed to us and which were
implemented.  To repeat:  we are very happy to receive bug-fixing patches
and code-enhancement patches.  But please do as Kevin did, namely, tell us
about it in advance.

Difficulties with dropping objects in shops, burning to death in hell, 
wielding amulets, pets eating corpses were fixed.  So were scores of other
small but annoying bugs.

MICROPORT_BUG was added to cater to compilers that don't like large 
structures.]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 6)."
# Contents:  do_patch5.sh patches05a UPDATE5
# Wrapped by billr@saab on Tue Oct 17 13:15:48 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'do_patch5.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'do_patch5.sh'\"
else
echo shar: Extracting \"'do_patch5.sh'\" \(482 characters\)
sed "s/^X//" >'do_patch5.sh' <<'END_OF_FILE'
X#! /bin/sh
X# script to call patch to apply diff files
X# make sure all of the patch files (and this file) are in your top level
X# NetHack directory
X#
Xecho "applying patch5a"
Xpatch -p <patches05a
Xecho "applying patch5b"
Xpatch -p <patches05b
Xecho "applying patch5c"
Xpatch -p <patches05c
Xecho "applying patch5d"
Xpatch -p <patches05d
Xecho "applying patch5e"
Xpatch -p <patches05e
Xecho "applying patch5f"
Xpatch -p <patches05f
Xrm -f mac/*.orig
Xecho "all patches applied, check for rejects"
END_OF_FILE
if test 482 -ne `wc -c <'do_patch5.sh'`; then
    echo shar: \"'do_patch5.sh'\" unpacked with wrong size!
fi
chmod +x 'do_patch5.sh'
# end of 'do_patch5.sh'
fi
if test -f 'patches05a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches05a'\"
else
echo shar: Extracting \"'patches05a'\" \(29761 characters\)
sed "s/^X//" >'patches05a' <<'END_OF_FILE'
X*** ./Old/Install.unix	Sun Oct 15 18:02:26 1989
X--- ./Install.unix	Sun Oct 15 16:58:56 1989
X***************
X*** 79,81 ****
X--- 79,85 ----
X      to "#define yyleng (int)(yy_cp - yy_bp)" in flex.skel.
X      Flex is not needed with Xenix/386, as its lex generates a proper lexical
X      analyser.  [Xenix instructions by J.T. Conklin]
X+ 
X+ 6.  If you get unexplained deaths by trickery, you are probably running
X+     NetHack on a bunch of workstations, but you have overlooked the NETWORK
X+     definition in unixconf.h that is necessary in that configuration.
X*** ./Old/README	Thu Sep 28 00:28:47 1989
X--- ./README	Mon Oct 16 22:35:02 1989
X***************
X*** 37,43
X      directory as the 'Top' directory.  It makes no difference what you
X      call it.
X  
X! 2.  If there is no flaw in the packaging, SIX sub-directories will be
X      automatically created, and files will be deposited in them: 
X  
X      a.  A 'src' directory, which will contain general *.c files.
X
X--- 37,43 -----
X      directory as the 'Top' directory.  It makes no difference what you
X      call it.
X  
X! 2.  If there is no flaw in the packaging, SEVEN sub-directories will be
X      automatically created, and files will be deposited in them: 
X  
X      a.  A 'src' directory, which will contain general *.c files.
X***************
X*** 46,51
X      d.  An 'amiga' directory, which will contain the Amiga-specific files.
X      e.  An 'others' directory, which will contain MSDOS and TOS files.
X      f.  A 'vms' directory, which will contain VMS files.
X  
X      The names of these directories should not be changed, unless you are
X      ready to go through the makefiles and the makedefs program and change
X
X--- 46,52 -----
X      d.  An 'amiga' directory, which will contain the Amiga-specific files.
X      e.  An 'others' directory, which will contain MSDOS and TOS files.
X      f.  A 'vms' directory, which will contain VMS files.
X+     g.  A 'mac' directory, which will contain Macintosh files.
X  
X      The names of these directories should not be changed, unless you are
X      ready to go through the makefiles and the makedefs program and change
X***************
X*** 80,85
X  	Sun-3s running SunOS 4.0
X  	Encore Multimax running UMAX 4.2
X  	Bull XPS100 running System V R2.2 or R3.1
X  	AT&T 3B4000 running System V
X  	AT&T 3B1 running System V (3.51)
X  	286 box running Microport SysV/AT (not extensively tested)
X
X--- 81,87 -----
X  	Sun-3s running SunOS 4.0
X  	Encore Multimax running UMAX 4.2
X  	Bull XPS100 running System V R2.2 or R3.1
X+ 	Bull DPX/2 100 running System V R3.1
X  	AT&T 3B4000 running System V
X  	AT&T 3B1 running System V (3.51)
X  	286 box running Microport SysV/AT (not extensively tested)
X***************
X*** 89,94
X  	Atari 1040ST under TOS
X  	DEC vaxen running VMS (probably still requires tweaking) 
X  	Data General AViiON systems under DG/UX
X  
X  			- - - - - - - - - - -
X  
X
X--- 91,98 -----
X  	Atari 1040ST under TOS
X  	DEC vaxen running VMS (probably still requires tweaking) 
X  	Data General AViiON systems under DG/UX
X+         Valid Logic Systems SCALD-System
X+         Macintosh (still requires testing)
X  
X  			- - - - - - - - - - -
X  
X*** ./Old/Files	Sun Oct 15 18:02:04 1989
X--- ./Files	Sun Oct 15 11:38:35 1989
X***************
X*** 43,57 ****
X  
X  include:
X  (files for all versions)
X! amiconf.h       artifact.h      attrib.h        config.h        coord.h
X! decl.h          def_os2.h       edog.h          epri.h          eshk.h
X! extern.h        flag.h          func_tab.h      global.h        gold.h
X! hack.h          lev.h           mfndpos.h       mkroom.h        monattk.h
X! mondata.h       monflag.h       monst.h         monsym.h        msdos.h
X! obj.h           objclass.h      patchlevel.h    pcconf.h        permonst.h
X! prop.h          rm.h            sp_lev.h        spell.h         system.h
X! tosconf.h       tradstdc.h      trap.h          trapname.h      unixconf.h
X! vault.h         vmsconf.h       wseg.h          you.h           youprop.h
X  (file for special level compiler (STRONGHOLD option))
X  lev_comp.h
X  
X--- 43,58 ----
X  
X  include:
X  (files for all versions)
X! amiconf.h       artifact.h      attrib.h        color.h         config.h
X! coord.h         decl.h          def_os2.h       edog.h          epri.h
X! eshk.h          extern.h        flag.h          func_tab.h      global.h
X! gold.h          hack.h          lev.h           macconf.h       mfndpos.h
X! mkroom.h        monattk.h       mondata.h       monflag.h       monst.h
X! monsym.h        msdos.h         obj.h           objclass.h      patchlevel.h
X! pcconf.h        permonst.h      prop.h          rm.h            sp_lev.h
X! spell.h         system.h        tosconf.h       tradstdc.h      trap.h
X! trapname.h      unixconf.h      vault.h         vmsconf.h       wseg.h
X! you.h           youprop.h
X  (file for special level compiler (STRONGHOLD option))
X  lev_comp.h
X  
X***************
X*** 86,88 ****
X--- 87,94 ----
X  vmstty.c        vmsunix.c
X  (GNU termcap files that support VMS version)
X  vmstermcap.c    vmstparam.c
X+ 
X+ mac:
X+ (files for Macintosh version)
X+ Install.mac     Segments.mac    mac.c           macfile.c       macinit.c
X+ makedefs.r      nethack.r
X*** auxil/Old/history	Sun Oct 15 18:09:08 1989
X--- auxil/history	Sun Oct 15 11:38:44 1989
X***************
X*** 31,36 ****
X--- 31,38 ----
X  
X  David Gentzel ported NetHack 3.0 to VMS.
X   
X+ Johnny Lee ported NetHack 3.0 to Macintosh.
X+ 
X  From time to time, some depraved individual out there in netland sends a
X  particularly intriguing modification to help out with the game.  The Gods of
X  the Dungeon sometimes make note of the names of the worst of these miscreants
X*** vms/Old/vmsbuild.com	Sun Oct 15 18:17:46 1989
X--- vms/vmsbuild.com	Wed Oct 11 19:08:53 1989
X***************
X*** 1,7 ****
X  $ makedefs := $sys$disk:[]makedefs
X  $ cc = "CC/NOLIST/OPT=NOINLINE/DEB/INCL=[-.INCLUDE]/DEFI=(""WIZARD=""""GENTZEL"""""")"
X! $ link := link/nomap
X  $ if p1 .eqs. "LINK" then goto link
X  $ cc alloc.c
X  $ cc makedefs.c
X  $ cc monst.c
X--- 1,8 ----
X  $ makedefs := $sys$disk:[]makedefs
X  $ cc = "CC/NOLIST/OPT=NOINLINE/DEB/INCL=[-.INCLUDE]/DEFI=(""WIZARD=""""GENTZEL"""""")"
X! $ link := link/nomap'p2'
X  $ if p1 .eqs. "LINK" then goto link
X+ $ define sys sys$library:
X  $ cc alloc.c
X  $ cc makedefs.c
X  $ cc monst.c
X*** vms/Old/vmsmain.c	Sun Oct 15 18:17:58 1989
X--- vms/vmsmain.c	Wed Oct 11 19:09:07 1989
X***************
X*** 83,89 ****
X  		chdirx(dir,0);
X  #endif
X  		prscore(argc, argv);
X! 		getret();
X  		settty(NULL);
X  		exit(0);
X  	    }
X--- 83,89 ----
X  		chdirx(dir,0);
X  #endif
X  		prscore(argc, argv);
X! 		if(isatty(1)) getret();
X  		settty(NULL);
X  		exit(0);
X  	    }
X***************
X*** 125,131 ****
X  # endif
X  		case 'D':
X  # ifdef WIZARD
X! 			if(!strcmp(getenv("USER"), WIZARD))
X  				wizard = TRUE;
X  				break;
X  			}
X--- 125,131 ----
X  # endif
X  		case 'D':
X  # ifdef WIZARD
X! 			if(!strcmp(getenv("USER"), WIZARD)) {
X  				wizard = TRUE;
X  				break;
X  			}
X***************
X*** 354,360 ****
X  	 * The resulting name is overridden by command line options.
X  	 * If everything fails, or if the resulting name is some generic
X  	 * account like "games" then eventually we'll ask him.
X! 	 * Note that we trust him here; it is possible to play under
X  	 * somebody else's name.
X  	 */
X  	register char *s;
X--- 354,360 ----
X  	 * The resulting name is overridden by command line options.
X  	 * If everything fails, or if the resulting name is some generic
X  	 * account like "games" then eventually we'll ask him.
X! 	 * Note that we trust the user here; it is possible to play under
X  	 * somebody else's name.
X  	 */
X  	register char *s;
X*** vms/Old/vmstty.c	Sun Oct 15 18:18:52 1989
X--- vms/vmstty.c	Wed Oct 11 19:09:30 1989
X***************
X*** 155,160 ****
X--- 155,169 ----
X  }
X  
X  
X+ void
X+ intron() {		/* enable kbd interupts if enabled when game started */
X+ }
X+ 
X+ void
X+ introff() {		/* disable kbd interrupts if required*/
X+ }
X+ 
X+ 
X  /* fatal error */
X  /*VARARGS1*/
X  void
X*** /dev/null	Sun Oct 15 18:10:58 1989
X--- mac/Install.mac	Sat Oct 14 11:25:52 1989
X***************
X*** 0 ****
X--- 1,120 ----
X+ Instructions for installing NetHack 3.0 on a Macintosh system
X+ ==============================================================
X+ 
X+ 1.  Make sure all the NetHack files are in the appropriate directory structure.
X+     You should have a main directory with subdirectories src, include, auxil,
X+     mac, and others.  If you do not follow this structure, the Makefile
X+     will not function properly.  All the UNIX .c files and the source Makefile
X+     belong in src; all the PC .c files and Makefiles belong in others; all the
X+     .h files belong in include; other assorted files belong in auxil.  The Mac
X+     .c files belong in mac.
X+ 
X+ 2.  Move the .c files from the mac directory to your src directory, and the
X+     pc*.c files from the others directory to your src directory.  Also move
X+     random.c from others to src if you want to use the Berkeley random number
X+     routines.
X+ 
X+ 3.  If you are using Aztec C, you'll need the Makefile.src.  You'll have 
X+     to make minor modifications to make it work.  If you use Lightspeed/THINK
X+     C the warning concerning the Makefile not functioning properly is a mute
X+     point.
X+ 
X+ 4.  Go to the include subdirectory and edit config.h according to the comments
X+     to match your system and desired set of features.  Similarly edit
X+     macconf.h.  COMPRESS and ZEROCOMP were undefined since I used the
X+     built-in Mac routines PackBits and UnpackBits.  All the options except
X+     for STRONGHOLD were defined.  BITFIELDS was defined in order to come in
X+     under the 32K global data limit.
X+ 
X+     For compilers, you can select from LSC or THINKC4 (or AZTEC if you want to
X+     do some work).  If you select AZTEC or LSC (not THINKC4) you'll have to
X+     define KR1ED and SMALLDATA (AZTEC users might be able to get around it).
X+     This sets up a macro which allows older preprocessors to make use of the
X+     defined() construct.  (The options in part 4 of config.h have a 1
X+     following them to allow the defined() macro to work.)
X+     
X+     If you use precompiled headers in Lightspeed/THINK C v.3 or Think C v.4
X+     you'll have to rename "hack.h" to something else.  Precompile the renamed
X+     hack.h file and save this as "hack.h".  In order for the precompiled
X+     headers to work, they must be the first #include/#define statement in
X+     every source file.  Certain source files contain "#define MONATTK_H" or an
X+     "#include xxx.h" before the first "#include hack.h"; the #defines can just
X+     be commented out while the #includes will have to move after the
X+     "#include hack.h".
X+ 
X+     Under the "Set Project Type..." menu, select Application, File type 'APPL',
X+     Creator 'nh30', Partition 700K, Separate STRS, and select Background Null
X+     Events and Suspend & Resume Events from the Multifinder Popup menu.
X+ 
X+     An executable with all features set, except for STRONGHOLD, will be around
X+     600K in size.
X+ 
X+ 5.  If you want to, look through system.h.  This file attempts to match the
X+     types for system calls and library routines with various flavors of
X+     operating systems.  Leaving this file alone is unlikely to cause problems,
X+     but if you're using a different compiler and get compile errors with
X+     any functions in the standard library, it's worth checking the
X+     declarations there.
X+ 
X+ 6.  If you want to change the high score list behavior, go to the src
X+     subdirectory and look at the top of topten.c.  You may want to change the
X+     definitions of PERSMAX, POINTSMIN, and ENTRYMAX.  I set POINTSMIN of
X+     51 and ENTRYMAX of 50 to keep the size of the score list down.
X+ 
X+ 7.  Build the resource files for Nethack and makedefs with Rez.
X+     It should be easy to derive an RMaker file from the Rez file, if you need
X+     to.
X+ 
X+ 8.  Compile and run the makedefs application.  The source files needed for
X+     makedefs are:
X+ 	alloc.c, macfile.c, makedefs.c, monst.c, objects.c, and panic.c
X+     
X+     You'll have to uncomment the #define's in monst.c, panic.c, makedefs.c,
X+     and macfile.c. These are used especially to construct the monst
X+     resource for the nethack app.
X+     
X+     Link in the necessary libraries (you can get this list from the routines
X+     that your linker complains aren't there).
X+ 
X+     Run makedefs and select all the options [ Note you'll have to run makedefs
X+     several times to do this].  This will build the necessary include and
X+     auxiliary files.
X+ 
X+     N.B.  Lightspeed/Think C users:  you really can't use precompiled headers
X+ 	here since there is no ONE header file.  It is such a small app
X+ 	that the benefit of a precompiled header is small.
X+ 
X+     The makedefs application doesn't use the custom display routines, just
X+     the default console routines that come with your compiler.
X+ 
X+     For ease of use make sure the support files data, rumors, cmdhelp, opthelp,
X+     help, hh, history, and license (and oracles, if you compiled in that
X+     feature) got copied to the game directory.  If not, move them there from
X+     the auxil directory yourself.  rumors can be created manually by selecting
X+     'rumors' from makedefs; data by selecting 'data' from makedefs.
X+ 
X+     If you're industrious you might try working on the special files.
X+     If you compiled in the special levels, make sure castle, tower?, and
X+     perhaps endgame are there, too.  The lev_comp file will create these.
X+ 
X+ Notes:
X+ 
X+ 1.  No, your old save files and bones files will not work with NetHack 3.0.
X+     Don't bother trying to keep them.  The old score list will work fine,
X+     but I recommend you delete it and create a new, empty one ('type record
X+     >record' will do this nicely).  It is a good deal harder to achieve the
X+     same scores in this version.
X+ 
X+ 2.  For Aztec C:
X+     To install an update of this version of NetHack after changing something,
X+     type 'make' from the src directory.  If you created the new version
X+     yourself, it should be safe to use 'make update' as long as you did not
X+     add, delete, or reorder monsters or objects and you did not change 
X+     the format of saved level files.  If you did any of these things, you
X+     should also delete any saved games and bones levels.  (Trying to use such
X+     files often produces amusing but useless confusions on the game's part.)
X+ 
X+ 3.  If you have any problems with Think/Lightspeed C you might try these
X+     two suggestions:
X+            a) Increase the Partition Size for NetHack to >700K.
X+     and/or b) Remove all the objects from the Project and do a full build.
X*** /dev/null	Sun Oct 15 18:11:11 1989
X--- mac/Segments.mac	Sat Oct 14 16:59:03 1989
X***************
X*** 0 ****
X--- 1,148 ----
X+ Segments.mac
X+ ============
X+ 
X+ For THINK C users (v.3.01p4 and 4), you have to construct a project.
X+ The mods I made in allmain.c make use of the placement of the
X+ source files in each segment.  Except for Segment 1 below, changing
X+ the contents of any of the other segments is fine as long as you
X+ make sure the UnloadSeg's still refer to a routine in all segments
X+ except for Segment 1.
X+ This is just an example of the layout of a project. It takes time
X+ to do this.  Probably the slowest part of THINK C!
X+ For THINK C 4 users, the 5 or so different libraries are replaced
X+ by the ANSI and unix libraries of v.4. - JL
X+ For other compilers, you can still follow the same format, though
X+ I haven't done it myself yet.
X+ 
X+ ===== Seg 1 =====
X+ allmain.c
X+ alloc.c
X+ cmd.c
X+ getline.c
X+ mac.c
X+ macfile.c
X+ pcmain.c
X+ prisym.c
X+ random.c
X+ rnd.c
X+ termcap.c
X+ 
X+ ===== Seg 2 =====
X+ apply.c
X+ attrib.c
X+ do.c
X+ hack.c
X+ 
X+ ===== Seg 3 =====
X+ dog.c
X+ dogmove.c
X+ dokick.c
X+ dothrow.c
X+ do_name.c
X+ 
X+ ===== Seg 4 =====
X+ do_wear.c
X+ eat.c
X+ shk.c
X+ shknam.c
X+ 
X+ ===== Seg 5 =====
X+ engrave.c
X+ exper.c
X+ extralev.c
X+ fountain.c
X+ invent.c
X+ vault.c
X+ 
X+ ===== Seg 6 =====
X+ lock.c
X+ makemon.c
X+ mcastu.c
X+ mhitm.c
X+ 
X+ ===== Seg 7 =====
X+ mhitu.c
X+ uhitm.c
X+ 
X+ ===== Seg 8 =====
X+ mklev.c
X+ mkobj.c
X+ mkroom.c
X+ mon.c
X+ 
X+ ===== Seg 9 =====
X+ mondata.c
X+ monmove.c
X+ mthrowu.c
X+ music.c
X+ objnam.c
X+ 
X+ ===== Seg 10 =====
X+ pager.c
X+ pickup.c
X+ polyself.c
X+ potion.c
X+ 
X+ ===== Seg 11 =====
X+ pray.c
X+ pri.c
X+ priest.c
X+ read.c
X+ 
X+ ===== Seg 12 =====
X+ restore.c
X+ rumors.c
X+ save.c
X+ search.c
X+ sit.c
X+ sounds.c
X+ spell.c
X+ steal.c
X+ 
X+ ===== Seg 13 =====
X+ timeout.c
X+ topl.c
X+ track.c
X+ trap.c
X+ weapon.c
X+ were.c
X+ wield.c
X+ 
X+ ===== Seg 14 =====
X+ Math [LIB]
X+ unix [LIB]
X+ worn.c
X+ write.c
X+ zap.c
X+ 
X+ ===== Seg 15 =====
X+ MacTraps
X+ stdio [LIB]
X+ storage [LIB]
X+ strings [LIB]
X+ 
X+ ===== Seg 16 =====
X+ decl.c
X+ macinit.c
X+ monst.c
X+ objects.c
X+ options.c
X+ o_init.c
X+ u_init.c
X+ version.c
X+ 
X+ ===== Seg 17 =====
X+ end.c
X+ pctty.c
X+ pcunix.c
X+ rip.c
X+ topten.c
X+ 
X+ ===== Seg 18 =====
X+ artifact.c
X+ bones.c
X+ dbridge.c
X+ demon.c
X+ mkmaze.c
X+ wizard.c
X+ worm.c
X*** /dev/null	Sun Oct 15 18:11:40 1989
X--- mac/macfile.c	Sat Oct 14 12:10:13 1989
X***************
X*** 0 ****
X--- 1,107 ----
X+ /*	SCCS Id: @(#)macfile.c	3.0	88/08/05
X+ /*      Copyright (c) Johnny Lee, 1989.		 */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ /*	Common routines to locate files using mac dialog boxes */
X+ 
X+ /*#define MAKEDEFS_C	1	/* define when using makedefs */
X+ #include "config.h"
X+ #ifdef MACOS
X+ 
X+ short
X+ findNamedFile(filename,type,reply)
X+ char	*filename;
X+ short	type;	/* if 0 - don't care if name matches selected file */
X+ SFReply	*reply;
X+ {
X+ 	DialogPtr	dialog;
X+ 	short	numTypes;
X+ 	SFTypeList	types;	
X+ 	Str255	prompt, name;
X+ 	Point	where;
X+ 	short	ok;
X+ 	DialogRecord	storage;
X+ 	
X+ 	name[0] = (char)strlen(filename);
X+ 	Strcpy((char *)&name[1], filename);
X+ 	dialog = GetNewDialog(128,&storage,(WindowPtr)-1);
X+ 	
X+ 	if (type == 1)
X+ 		ParamText("\005 save","\004 for",name,"");
X+ 	else
X+ 		ParamText("","",name,"");
X+ 	
X+ 	where.h = 80;
X+ 	where.v = 111;
X+ 	ok = FALSE;
X+ 	
X+ 	switch (type) {
X+ 	  case 0:	/* don't care what file gets loaded */
X+ 	  	numTypes = -1;
X+ 	  	break;
X+ 	  case 1:	/* limit what types of files can be selected */
X+ 	  	numTypes = 2;
X+ 		types[0] = SAVE_TYPE;
X+ 		types[1] = EXPLORE_TYPE;
X+ 		break;
X+ 	  case 2:	/* unlimited types of files but names have to match*/
X+ 	  	numTypes = -1;
X+ 	  	break;
X+ 	}
X+ 	reply->good = TRUE;
X+ 	do {
X+ 		BringToFront((WindowPtr)dialog);
X+ 		ShowWindow((WindowPtr)dialog);
X+ 		DrawDialog(dialog);
X+ 		SFGetFile(where,prompt,0L,numTypes,types,0L,reply);
X+ 		HideWindow((WindowPtr)dialog);
X+ 		if (reply->good) {
X+ 			if ((type == 2 && 
X+ 				!strncmp((char *)&name[1],
X+ 				    (char *)&(reply->fName[1]), (short)name[0]))
X+ 				 || (type<2)) {
X+ 				SetVol(0L,reply->vRefNum);
X+ 				ok = TRUE;
X+ 			}
X+ 		}
X+ 	} while (!ok && reply->good);
X+ 	CloseDialog(dialog);
X+ 	return ok;
X+ }
X+ 
X+ #ifndef MAKEDEFS_C
X+ extern WindowPtr HackWindow;
X+ 
X+ /*	this function also gets called by topten() in topten.c to
X+  *	locate the record file, but it doesn't matter at this point
X+  *	since the game is over by now. If nethack ever restarts,
X+  *	this will have to change.
X+  */
X+ 
X+ FILE *
X+ openFile(fileName)
X+ char	*fileName;
X+ {
X+ 	term_info *t;
X+ 	SFReply	reply;
X+ 	FILE	*fp;
X+ 		
X+ 	t = (term_info *)GetWRefCon(HackWindow);
X+ 	if (t->auxFileVRefNum) {
X+ 		SetVol(0L,t->auxFileVRefNum);
X+ 	}
X+ 	fp = fopen(fileName,"r");
X+ 	if (!fp && findNamedFile(fileName,2,&reply)) {
X+ 		if (reply.good) {
X+ 			t->auxFileVRefNum = reply.vRefNum;
X+ 		}
X+ 	}
X+ 	if (!fp)
X+ 		fp = fopen(fileName,"r");
X+ 	else if (!t->auxFileVRefNum) {
X+ 		(void)GetVol((StringPtr)&reply.fName,&t->auxFileVRefNum);
X+ 	}
X+ 	return fp;
X+ }
X+ #endif
X+ #endif
X*** /dev/null	Sun Oct 15 18:11:51 1989
X--- mac/macinit.c	Sun Oct 15 12:05:22 1989
X***************
X*** 0 ****
X--- 1,304 ----
X+ /*	SCCS Id: @(#)macinit.c	3.0	88/08/05
X+ /* Copyright (c) Johnny Lee, 1989.		 */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ /*	Initialization routine for the Macintosh */
X+ 
X+ #include	"hack.h"
X+ 
X+ #ifdef MACOS
X+ 
X+ /* Global variables */
X+ extern WindowPtr	HackWindow;	/* points to NetHack's window */
X+ char	*keys[8];
X+ short macflags;
X+ typedef struct defaultData {
X+ 	long	defaultFlags;
X+ 	long	fontSize;
X+ 	Str255	fontName;
X+ } defaultData;
X+ #define	fDFZoomWindow	0x02L
X+ #define	fDFUseDefaultFont	0x01L
X+ 
X+ 
X+ int
X+ initterm(row, col)
X+ short	row, col;
X+ {
X+ 	register short	i, j;
X+ 	short		tempFont, tempSize, fontNum, size;
X+ 	char	*l;
X+ 	EventRecord	theEvent;
X+ 	FontInfo	fInfo;
X+ 	Handle	temp;
X+ 	MenuHandle	theMenu;
X+ 	OSErr	error;
X+ 	Rect		boundsRect;
X+ 	Str255	appName, font;
X+ 	defaultData	*dD;
X+ 	term_info	*t;
X+ 	
X+ 	/* standard Mac initialization */
X+ 	MaxApplZone();
X+ 	MoreMasters();
X+ 	MoreMasters();
X+ 	MoreMasters();
X+ 	MoreMasters();
X+ 	InitGraf(&MAINGRAFPORT);
X+ 	
X+ 	InitFonts();
X+ 	InitWindows();
X+ 	InitMenus();
X+ 	InitCursor();
X+ 	FlushEvents(everyEvent, 0);
X+ 	if (error = GetVol((StringPtr)&appName, &tempSize))
X+ 		SysBeep(1);
X+ 	
X+ 	/* Application-specific startup code */
X+ 	theMenu = NewMenu(appleMenu, "\001\024");	/*  apple menu  */
X+ 	AppendMenu(theMenu,"\030About NetHack 3.0g\311;(-");
X+ 	AddResMenu(theMenu, 'DRVR');
X+ 	InsertMenu(theMenu, 0);
X+ 	DisableItem(theMenu,0);
X+ 
X+ 	t = (term_info *)malloc(sizeof(term_info));
X+ 	t->recordVRefNum = tempSize;
X+ 	
X+ 	for (i = fileMenu; i <= extendMenu; i++) {
X+ 		theMenu = GetMenu(i);
X+ 		if (theMenu) {
X+ 			InsertMenu(theMenu, 0);
X+ 			DisableItem(theMenu, 0);
X+ 		}
X+ 		if (i == editMenu) {
X+ 			t->shortMBarHandle = GetMenuBar();
X+ 		}
X+ 	}
X+ 	t->fullMBarHandle = GetMenuBar();
X+ 	
X+ 	DrawMenuBar();
X+ 	HiliteMenu(0);
X+ 	for (i = 0;i <= 7;i++) {
X+ 		temp = GetResource(HACK_DATA,(i + 100 + appleMenu));
X+ 		if (!temp) {
X+ 			SysBeep(1);
X+ 			panic("Can't get MENU_DATA resource");
X+ 		}
X+ 		MoveHHi(temp);
X+ 		HLock(temp);
X+ 		DetachResource(temp);
X+ 		keys[i] = *temp;
X+ 	}
X+ 
X+ 	macflags = (fToggleNumPad | fDoNonKeyEvt);
X+ 	
X+ 	/* Set font to monaco, user-defined font or to Hackfont if available */
X+ 	size = 9;
X+ 	strcpy((char *)&font[0], "\006Monaco");
X+ 	
X+ 	temp = GetResource(HACK_DATA, DEFAULT_DATA);
X+ 	if (temp) {
X+ 		HLock(temp);
X+ 		dD = (defaultData *)(*temp);
X+ 		size = (short)dD->fontSize;
X+ 		strncpy((char *)&font[0], (char *)&dD->fontName[0],
X+ 					(short)dD->fontName[0] + 1);
X+ 		if (dD->defaultFlags & fDFZoomWindow)
X+ 			macflags |= fZoomOnContextSwitch;
X+ 		HUnlock(temp);
X+ 		ReleaseResource(temp);
X+ 	}
X+ 			
X+ 	tempFont = MAINGRAFPORT->txFont;
X+ 	tempSize = MAINGRAFPORT->txSize;
X+ 	GetFNum(font, &fontNum);
X+ 	TextFont(fontNum);
X+ 	TextSize(size);
X+ 	GetFontInfo(&fInfo);
X+ 	TextFont(tempFont);
X+ 	TextSize(tempSize);
X+ 	
X+ 	if (!(dD->defaultFlags & fDFUseDefaultFont)) {
X+ 		Strcpy((char *)&appName[0], "\010HackFont");
X+ 		GetFNum(appName,&tempFont);
X+ 		if (tempFont) {
X+ 			fontNum = tempFont;
X+ 			tempFont = MAINGRAFPORT->txFont;
X+ 			TextFont(fontNum);
X+ 			TextSize(size);
X+ 			GetFontInfo(&fInfo);
X+ 			TextFont(tempFont);
X+ 			TextSize(tempSize);
X+ 			macflags |= fUseCustomFont;
X+ 		}
X+ 	}
X+ 	
X+ 	i = fInfo.ascent + fInfo.descent + fInfo.leading;
X+ 	j = fInfo.widMax;
X+ 	if ((row * i + 2 * Screen_Border) >
X+ 		 (SCREEN_BITS.bounds.bottom - SCREEN_BITS.bounds.top)
X+ 		 ||
X+ 		 (col * j + 2 * Screen_Border) >
X+ 		 	(SCREEN_BITS.bounds.right - SCREEN_BITS.bounds.left)) {
X+ 		size = 9;
X+ 		Strcpy((char *)&font[0], "\006Monaco");
X+ 		tempFont = MAINGRAFPORT->txFont;
X+ 		tempSize = MAINGRAFPORT->txSize;
X+ 		GetFNum(font, &fontNum);
X+ 		TextFont(fontNum);
X+ 		TextSize(size);
X+ 		GetFontInfo(&fInfo);
X+ 		TextFont(tempFont);
X+ 		TextSize(tempSize);
X+ 		i = fInfo.ascent + fInfo.descent + fInfo.leading;
X+ 		j = fInfo.widMax;
X+ 		macflags &= ~fUseCustomFont;
X+ 	}		
X+ 		 
X+ 	t->ascent = fInfo.ascent;
X+ 	t->descent = fInfo.descent;
X+ 	t->height = i;
X+ 	t->charWidth = j;
X+ 	
X+ 	t->fontNum = fontNum;
X+ 	t->fontSize = size;
X+ 	t->maxRow = row;
X+ 	t->maxCol = col;
X+ 	t->tcur_x = 0;
X+ 	t->tcur_y = 0;
X+ 	t->auxFileVRefNum = 0;
X+ 	if (error = SysEnvirons(1, &(t->system))) {
X+ 		SysBeep(1);
X+ 	}
X+ 
X+ #define	KEY_MAP	103
X+ 	temp = GetResource(HACK_DATA, KEY_MAP);
X+ 	if (temp) {
X+ 		MoveHHi(temp);
X+ 		HLock(temp);
X+ 		DetachResource(temp);
X+ 		t->keyMap = (char *)(*temp);
X+ 	} else
X+ 		panic("Can't get keymap resource");
X+ 
X+ 	SetRect(&boundsRect, LEFT_OFFSET, TOP_OFFSET + 10,
X+ 		(col * fInfo.widMax) + LEFT_OFFSET + 2 * Screen_Border,
X+ 		TOP_OFFSET + (row * t->height) + 2 * Screen_Border + 10);
X+ 	
X+ 	t->screen = (char **)malloc(row * sizeof(char *));
X+ 	l = malloc(row * col * sizeof(char));
X+ 	for (i = 0;i < row;i++) {
X+ 		t->screen[i] = (char *)(l + (i * col * sizeof(char)));
X+ 	}
X+ 	for (i = 0; i < row; i++) {
X+ 		for (j = 0; j < col; j++) {
X+ 			t->screen[i][j] = ' ';
X+ 		}
X+ 	}
X+ 
X+ 	/* give time for Multifinder to bring NetHack window to front */
X+ 	for(tempFont = 0; tempFont<10; tempFont++) {
X+ 		(void)GetNextEvent(everyEvent,&theEvent);
X+ 	}
X+ 
X+ 	HackWindow = NewWindow(0L, &boundsRect, "\015NetHack [MOV]",
X+ 			TRUE, noGrowDocProc, (WindowPtr)-1, FALSE, (long)t);
X+ 
X+ 	t->inColor = 0;
X+ #ifdef TEXTCOLOR
X+ 	t->color[0] = blackColor;
X+ 	t->color[1] = redColor;
X+ 	t->color[2] = greenColor;
X+ 	t->color[3] = yellowColor;
X+ 	t->color[4] = blueColor;
X+ 	t->color[5] = magentaColor;
X+ 	t->color[6] = cyanColor;
X+ 	t->color[7] = whiteColor;
X+ 
X+ 	if (t->system.hasColorQD) {
X+ 		Rect	r;
X+ 		GDHandle	gd;
X+ 		
X+ 		r = (**(*(WindowPeek)HackWindow).contRgn).rgnBBox;
X+ 		LocalToGlobal(&r.top);
X+ 		LocalToGlobal(&r.bottom);
X+ 		gd = GetMaxDevice(&r);
X+ 		t->inColor = (**(**gd).gdPMap).pixelSize > 1;
X+ 	}
X+ #endif
X+ 		
X+ 	temp = GetResource(HACK_DATA, MONST_DATA);
X+ 	if (temp) {
X+ 		DetachResource(temp);
X+ 		MoveHHi(temp);
X+ 		HLock(temp);
X+ 		i = GetHandleSize(temp);
X+ 		mons = (struct permonst *)(*temp);
X+ 	} else {
X+ 		panic("Can't get MONST resource data.");
X+ 	}
X+ 	
X+ 	(void)aboutBox(0);	
X+ 	return 0;
X+ }
X+ 
X+ /* not really even needed. NH never gets to the end of main(), */
X+ /* so this never gets called */
X+ int
X+ freeterm()
X+ {
X+ 	return 0;
X+ }
X+ 
X+ #ifdef SMALLDATA
X+ /* SOME [:-( ] Mac compilers have a 32K global & static data limit */
X+ /* these routines help the HANDICAPPED things */
X+ void
X+ init_decl()
X+ {
X+ 	short	i;
X+ 	char	*l;
X+ 	
X+ 	l = calloc(COLNO , sizeof(struct rm **));
X+ 	level.locations = (struct rm **)l;
X+ 	l = calloc(ROWNO * COLNO , sizeof(struct rm));
X+ 	for (i = 0; i < COLNO; i++) {
X+ 	    level.locations[i] = 
X+ 		(struct rm *)(l + (i * ROWNO * sizeof(struct rm)));
X+ 	}
X+ 	
X+ 	l = calloc(COLNO , sizeof(struct obj ***));
X+ 	level.objects = (struct obj ***)l;
X+ 	l = calloc(ROWNO * COLNO , sizeof(struct obj *));
X+ 	for (i = 0; i < COLNO; i++) {
X+ 	    level.objects[i] = 
X+ 		(struct obj **)(l + (i * ROWNO * sizeof(struct obj *)));
X+ 	}
X+ 	
X+ 	l = calloc(COLNO , sizeof(struct monst ***));
X+ 	level.monsters = (struct monst ***)l;
X+ 	l = calloc(ROWNO * COLNO , sizeof(struct monst *));
X+ 	for (i = 0; i < COLNO; i++) {
X+ 	    level.monsters[i] = 
X+ 		(struct monst **)(l + (i * ROWNO * sizeof(struct monst *)));
X+ 	}
X+ 	level.objlist = (struct obj *)0L;
X+ 	level.monlist = (struct monst *)0L;
X+ 	
X+ }
X+ 
X+ /* Since NetHack usually exits before reaching end of main()	*/
X+ /* this routine could probably left out.	- J.L.		*/
X+ void
X+ free_decl()
X+ {
X+ 
X+ 	free((char *)level.locations[0]);
X+ 	free((char *)level.locations);
X+ 	free((char *)level.objects[0]);
X+ 	free((char *)level.objects);
X+ 	free((char *)level.monsters[0]);
X+ 	free((char *)level.monsters);
X+ }
X+ #endif /* SMALLDATA */
X+ #endif /* MACOS */
X*** /dev/null	Sun Oct 15 18:12:02 1989
X--- mac/makedefs.r	Fri Oct 13 23:58:48 1989
X***************
X*** 0 ****
X--- 1,104 ----
X+ /******************************************************
X+  *                                                    *
X+  *        makedefs.r                                  *
X+  *                                                    *
X+  *        Resource file for makedefs application      *
X+  *                                                    *
X+  *        Copyright 1989 by Johnny Lee                *
X+  *        NetHack may be freely redistributed.        *
X+  *	  See license for details. 		      *
X+  *                                                    *
X+  ******************************************************/
X+ 
X+ #include	"Types.r"
X+ 
X+ resource 'DLOG' (200) {
X+ 	{40, 40, 200, 320},
X+ 	dBoxProc,
X+ 	visible,
X+ 	noGoAway,
X+ 	0x0,
X+ 	200,
X+ 	"Which option?"
X+ };
X+ 
X+ resource 'DLOG' (128, "FindFile") {
X+ 	{40, 80, 100, 300},
X+ 	dBoxProc,
X+ 	invisible,
X+ 	noGoAway,
X+ 	0x0,
X+ 	128,
X+ 	"FindFile"
X+ };
X+ 
X+ resource 'DITL' (200) {
X+ 	{ /* array DITLarray: 9 elements */
X+ 		/* [1] */
X+ 		{116, 51, 136, 111},
X+ 		Button {
X+ 			enabled,
X+ 			"OK"
X+ 		},
X+ 		/* [2] */
X+ 		{116, 158, 136, 218},
X+ 		Button {
X+ 			enabled,
X+ 			"Cancel"
X+ 		},
X+ 		/* [3] */
X+ 		{15, 15, 35, 75},
X+ 		RadioButton {
X+ 			enabled,
X+ 			"data"
X+ 		},
X+ 		/* [4] */
X+ 		{15, 95, 35, 155},
X+ 		RadioButton {
X+ 			enabled,
X+ 			"date"
X+ 		},
X+ 		/* [5] */
X+ 		{40, 95, 60, 180},
X+ 		RadioButton {
X+ 			enabled,
X+ 			"permonst"
X+ 		},
X+ 		/* [6] */
X+ 		{15, 180, 35, 250},
X+ 		RadioButton {
X+ 			enabled,
X+ 			"rumors"
X+ 		},
X+ 		/* [7] */
X+ 		{40, 15, 60, 75},
X+ 		RadioButton {
X+ 			enabled,
X+ 			"traps"
X+ 		},
X+ 		/* [8] */
X+ 		{65, 15, 85, 125},
X+ 		RadioButton {
X+ 			enabled,
X+ 			"object names"
X+ 		},
X+ 		/* [9] */
X+ 		{65, 145, 85, 270},
X+ 		RadioButton {
X+ 			enabled,
X+ 			"monst resource"
X+ 		}
X+ 	}
X+ };
X+ 
X+ resource 'DITL' (128) {
X+ 	{ /* array DITLarray: 1 elements */
X+ 		/* [1] */
X+ 		{4, 8, 80, 212},
X+ 		StaticText {
X+ 			disabled,
X+ 			"Please locate^0 file^1 ^2\nor press Cance"
X+ 			"l to abort."
X+ 		}
X+ 	}
X+ };
X
END_OF_FILE
if test 29761 -ne `wc -c <'patches05a'`; then
    echo shar: \"'patches05a'\" unpacked with wrong size!
fi
# end of 'patches05a'
fi
if test -f 'UPDATE5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'UPDATE5'\"
else
echo shar: Extracting \"'UPDATE5'\" \(2197 characters\)
sed "s/^X//" >'UPDATE5' <<'END_OF_FILE'
XOld bones and save files should at least be syntactically correct this time,
Xbut you should still throw them out if you don't want to be confronted with
Xmonsters permanently masquerading as different monsters (since some of the
Xmonsters' letters have changed).
X
X
XNote that the posted shop fix was a stopgap patch, not an official patch, so
Xit should be reversed before applying these patches.  If you do not reverse 
Xit, probably nothing worse than a failure of one shk.c band will happen this
Xtime.  In general, however, you will have to do considerable hand-patching if
Xyou leave intermediate patches in.
X
X
XThe major bug fix in Patch 5 is moving the color definitions to color.h, thus
Xbreaking the annoying dependency loop when bootstrapping NetHack.
X
XPatch 5 contains Johnny Lee's provision of a port to the Macintosh.  The 
XMacintosh files live in a new subdirectory, 'mac'.  We know that many of you
Xwere waiting for a Mac port, and for you we are happy to have it.
X
XBasic support for several new other compilers or machines (see README), but 
Xthese probably need some more tweaking.
X
XA major new feature in Patch 5 is timed-out eating, i.e., being able to be
Xinterrupted while eating by monsters attack.  Mike Stephenson provided the 
Xbasic structure for dealing with partially eaten food.  We believe that the
Xonly remaining flaws in this code are occasional non-optimal messages which
Xare generated by it (we are working on correcting this).
X
XIncorrect iron ball behavior and bugs in the iron ball code were 
Xsystematically corrected by Kevin Darcy who communicated with us about it
Xand mailed us his patches.  (Yes, Kevin, as you can see, it went in, and 
Xwith only one minor change.)  
X
XThere were other, smaller, patches which were mailed to us and which were
Ximplemented.  To repeat:  we are very happy to receive bug-fixing patches
Xand code-enhancement patches.  But please do as Kevin did, namely, tell us
Xabout it in advance.
X
XDifficulties with dropping objects in shops, burning to death in hell, 
Xwielding amulets, pets eating corpses were fixed.  So were scores of other
Xsmall but annoying bugs.
X
XMICROPORT_BUG was added to cater to compilers that don't like large 
Xstructures.
X
END_OF_FILE
if test 2197 -ne `wc -c <'UPDATE5'`; then
    echo shar: \"'UPDATE5'\" unpacked with wrong size!
fi
# end of 'UPDATE5'
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
