Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i050:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch5c
Message-ID: <4701@tekred.CNA.TEK.COM>
Date: 17 Oct 89 20:24:58 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2200
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 50
Archive-name: NetHack3/Patch5c
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 6)."
# Contents:  patches05c
# Wrapped by billr@saab on Tue Oct 17 13:16:26 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches05c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches05c'\"
else
echo shar: Extracting \"'patches05c'\" \(54981 characters\)
sed "s/^X//" >'patches05c' <<'END_OF_FILE'
X*** /dev/null	Sun Oct 15 19:25:34 1989
X--- include/color.h	Tue Oct  3 20:08:13 1989
X***************
X*** 0 ****
X--- 1,38 ----
X+ /*	SCCS Id: @(#)color.h	3.0	89/09/30
X+ /* Copyright (c) Steve Linhart, Eric Raymond, 1989. */
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ 
X+ #ifndef COLOR_H
X+ #define COLOR_H
X+ 
X+ #define BLACK		0
X+ #define RED		1
X+ #define GREEN		2
X+ #define BROWN		3	/* on IBM, lo-intensity yellow is brown */
X+ #define BLUE		4
X+ #define MAGENTA 	5
X+ #define CYAN		6
X+ #define WHITE		7
X+ #define GRAY		7	/* lo-intensity white */
X+ #define BRIGHT		8
X+ #define ORANGE_COLORED	9
X+ #define YELLOW		11
X+ #define MAXCOLORS	16	/* 8 basic + 8 bright */
X+ 
X+ /* these can be configured */
X+ #define HI_MON		RED + BRIGHT	/* default flesh - red slaps! */
X+ #define HI_OBJ		MAGENTA
X+ #define HI_METAL	CYAN
X+ #define HI_COPPER	YELLOW
X+ #define HI_SILVER	GRAY
X+ #define HI_GOLD 	YELLOW
X+ #define HI_LEATHER	BROWN
X+ #define HI_CLOTH	BROWN
X+ #define HI_ORGANIC	GREEN
X+ #define HI_WOOD 	BROWN
X+ #define HI_PAPER	WHITE
X+ #define HI_GLASS	CYAN + BRIGHT
X+ #define HI_MINERAL	GRAY
X+ #define HI_ZAP		BLUE + BRIGHT	/* blue zaps! */
X+ 
X+ #endif /* COLOR_H */
X*** include/Old/config.h	Sun Oct 15 19:25:46 1989
X--- include/config.h	Sat Oct 14 19:19:36 1989
X***************
X*** 14,20 ****
X   *		provides it (comment out the default OS option here).
X   */
X  
X! #define	UNIX		/* delete if no fork(), exec() available */
X  
X  #ifdef __MSDOS__	/* Turbo C auto-defines __MSDOS__, MSC defines MSDOS */
X  #define MSDOS		/* define for MS-DOS (in case compiler doesn't) */
X--- 14,20 ----
X   *		provides it (comment out the default OS option here).
X   */
X  
X! #define UNIX		/* delete if no fork(), exec() available */
X  
X  #ifdef __MSDOS__	/* Turbo C auto-defines __MSDOS__, MSC defines MSDOS */
X  #define MSDOS		/* define for MS-DOS (in case compiler doesn't) */
X***************
X*** 34,42 ****
X--- 34,57 ----
X  			 * library in the makefile */
X  /* #define MINIMAL_TERM	/* if a terminal handles highlighting or tabs poorly,
X  			   try this define, used in pager.c and termcap.c */
X+ /* #define MACOS 1 	/* define for Apple Macintosh */
X  #endif
X  
X+ #ifdef MACOS
X+ #define KR1ED 1		/* for compilers which can't handle defined() */
X+ #define LSC 1		/* for the Lighspeed 3.01p4 C compiler on the Mac */
X+ /* #define AZTEC 1	/* for the Manx Aztec C 3.6c compiler */
X+ /* #define THINKC4	/* for the Think C 4 compiler */
X+ 
X+ #define SMALLDATA 1	/* for Mac compilers with 32K global data limit */
X+  
X+ # ifdef KR1ED
X+ #define defined(x) (x<<1) /* Lightspeed & Aztec can't handle defined() yet */
X+ # endif
X  
X+ #endif
X+ 
X+ 
X  
X  /*
X   * Section 2:	Some global parameters and filenames.
X***************
X*** 46,56 ****
X   */
X  
X  #ifndef WIZARD		/* allow for compile-time or Makefile changes */
X  #define WIZARD  "izchak" /* the person allowed to use the -D option */
X  #endif
X  
X! #define	LOGFILE	"logfile" /* larger file for debugging purposes */
X! #define	NEWS	"news"	  /* the file containing the latest hack news */
X  
X  /*
X   *	If COMPRESS is defined, it should contain the full path name of your
X--- 61,76 ----
X   */
X  
X  #ifndef WIZARD		/* allow for compile-time or Makefile changes */
X+ # ifndef KR1ED
X  #define WIZARD  "izchak" /* the person allowed to use the -D option */
X+ # else
X+ #define WIZARD 1
X+ #define WIZARD_NAME "johnny"
X+ # endif
X  #endif
X  
X! #define LOGFILE "logfile"	/* larger file for debugging purposes */
X! #define NEWS "news"		/* the file containing the latest hack news */
X  
X  /*
X   *	If COMPRESS is defined, it should contain the full path name of your
X***************
X*** 63,69 ****
X  /* #define ZEROCOMP	/* Use only if COMPRESS is not used -- Olaf Seibert */
X  
X  
X! #define	CHDIR		/* delete if no chdir() available */
X  
X  #ifdef CHDIR
X  /*
X--- 83,89 ----
X  /* #define ZEROCOMP	/* Use only if COMPRESS is not used -- Olaf Seibert */
X  
X  
X! #define CHDIR		/* delete if no chdir() available */
X  
X  #ifdef CHDIR
X  /*
X***************
X*** 70,76 ****
X   * If you define HACKDIR, then this will be the default playground;
X   * otherwise it will be the current directory.
X   */
X! #define HACKDIR	"/usr/games/lib/nethackdir"
X  
X  /*
X   * Some system administrators are stupid enough to make Hack suid root
X--- 90,96 ----
X   * If you define HACKDIR, then this will be the default playground;
X   * otherwise it will be the current directory.
X   */
X! #define HACKDIR "/usr/games/lib/nethackdir"
X  
X  /*
X   * Some system administrators are stupid enough to make Hack suid root
X***************
X*** 84,90 ****
X  /*
X   * If it is desirable to limit the number of people that can play Hack
X   * simultaneously, define HACKDIR, SECURE and MAX_NR_OF_PLAYERS.
X!  * #define MAX_NR_OF_PLAYERS	6
X   */
X  #endif /* CHDIR /**/
X  
X--- 104,110 ----
X  /*
X   * If it is desirable to limit the number of people that can play Hack
X   * simultaneously, define HACKDIR, SECURE and MAX_NR_OF_PLAYERS.
X!  * #define MAX_NR_OF_PLAYERS 6
X   */
X  #endif /* CHDIR /**/
X  
X***************
X*** 108,125 ****
X  /*
X   * type schar: small signed integers (8 bits suffice) (eg. TOS)
X   *
X!  *	typedef	char	schar;
X   *
X   *      will do when you have signed characters; otherwise use
X   *
X!  *	typedef	short int schar;
X   */
X! typedef	signed char	schar;
X  
X  /*
X   * type uchar: small unsigned integers (8 bits suffice - but 7 bits do not)
X   *
X!  *	typedef	unsigned char	uchar;
X   *
X   *	will be satisfactory if you have an "unsigned char" type;
X   *	otherwise use
X--- 128,149 ----
X  /*
X   * type schar: small signed integers (8 bits suffice) (eg. TOS)
X   *
X!  *	typedef char	schar;
X   *
X   *      will do when you have signed characters; otherwise use
X   *
X!  *	typedef short int schar;
X   */
X! #ifdef AZTEC
X! #define schar	char
X! #else
X! typedef signed char	schar;
X! #endif
X  
X  /*
X   * type uchar: small unsigned integers (8 bits suffice - but 7 bits do not)
X   *
X!  *	typedef unsigned char	uchar;
X   *
X   *	will be satisfactory if you have an "unsigned char" type;
X   *	otherwise use
X***************
X*** 126,132 ****
X   *
X   *	typedef unsigned short int uchar;
X   */
X! typedef	unsigned char	uchar;
X  
X  /*
X   * Various structures have the option of using bitfields to save space.
X--- 150,156 ----
X   *
X   *	typedef unsigned short int uchar;
X   */
X! typedef unsigned char	uchar;
X  
X  /*
X   * Various structures have the option of using bitfields to save space.
X***************
X*** 147,191 ****
X   * complexity of the game but also to the size of the load module.
X   */ 
X  
X! #define	SPELLS		/* Spell casting by M. Stephenson */
X! #define POLYSELF	/* Polymorph self code by Ken Arromdee */
X! #define THRONES		/* Thrones and Courts by M. Stephenson */
X! #define	PROBING		/* Wand of probing code by Gil Neiger */
X! #define REDO 		/* support for redoing last command - DGK */
X! #define	HARD		/* Enhanced wizard code by M. Stephenson */
X! #define	WALKIES		/* Leash code by M. Stephenson */
X! #define FOUNTAINS	/* Fountain code by SRT (+ GAN + EB) */
X! #define KOPS		/* Keystone Kops by Scott R. Turner */
X! #define COM_COMPL	/* Command line completion by John S. Bien */
X! #define MEDUSA		/* Mirrors and the Medusa by Richard P. Hughey */
X! #define NAMED_ITEMS	/* Special named items handling */
X! #define ARMY		/* Soldiers, barracks by Steve Creps */
X! #define	SHIRT		/* Hawaiian shirt code by Steve Linhart */
X! #define THEOLOGY	/* Smarter gods - The Unknown Hacker */
X! #define SINKS		/* Kitchen sinks - Janet Walz */
X! #define SOUNDS		/* Add more life to the dungeon */
X! #define REINCARNATION	/* Rogue-like levels */
X! #define ELBERETH	/* Allow for disabling the E word - Mike 3point */
X! #define WORM		/* Long worms */
X! #define ORACLE		/* Include another source of information */
X! #define EXPLORE_MODE	/* Allow non-scoring play with additional powers */
X! #define ALTARS		/* Sacrifice sites - Jean-Christophe Collet */
X! #define WALLIFIED_MAZE	/* Fancy mazes - Jean-Christophe Collet */
X  #ifdef HARD
X! #define SEDUCE		/* Succubi/incubi additions, by KAA, suggested by IM */
X  #endif
X! #define STRONGHOLD	/* Challenging special levels - Jean-Christophe Collet*/
X! #define MUSIC		/* Musical instruments - Jean-Christophe Collet */
X! #define GOLEMS		/* Golems, by KAA */
X! #define TOLKIEN		/* More varieties of objects and monsters */
X! #define KICK		/* Allow kicking things besides doors -Izchak Miller */
X! #define TUTTI_FRUTTI	/* Fruits as in Rogue, but which work... -KAA */
X  
X  #ifdef REDO
X! #define DOAGAIN	'\001'		/* The "redo" key used in tty.c and cmd.c */
X  #endif
X  
X! #define	EXP_ON_BOTL	/* Show experience on bottom line */
X  /* #define SCORE_ON_BOTL	/* added by Gary Erickson (erickson@ucivax) */
X  
X  
X--- 171,215 ----
X   * complexity of the game but also to the size of the load module.
X   */ 
X  
X! #define SPELLS        1 /* Spell casting by M. Stephenson */
X! #define POLYSELF      1 /* Polymorph self code by Ken Arromdee */
X! #define THRONES       1 /* Thrones and Courts by M. Stephenson */
X! #define PROBING       1 /* Wand of probing code by Gil Neiger */
X! #define REDO          1 /* support for redoing last command - DGK */
X! #define HARD          1 /* Enhanced wizard code by M. Stephenson */
X! #define WALKIES       1 /* Leash code by M. Stephenson */
X! #define FOUNTAINS     1 /* Fountain code by SRT (+ GAN + EB) */
X! #define KOPS          1 /* Keystone Kops by Scott R. Turner */
X! #define COM_COMPL     1 /* Command line completion by John S. Bien */
X! #define MEDUSA        1 /* Mirrors and the Medusa by Richard P. Hughey */
X! #define NAMED_ITEMS   1 /* Special named items handling */
X! #define ARMY          1 /* Soldiers, barracks by Steve Creps */
X! #define SHIRT         1 /* Hawaiian shirt code by Steve Linhart */
X! #define THEOLOGY      1 /* Smarter gods - The Unknown Hacker */
X! #define SINKS         1 /* Kitchen sinks - Janet Walz */
X! #define SOUNDS        1 /* Add more life to the dungeon */
X! #define REINCARNATION 1 /* Rogue-like levels */
X! #define ELBERETH      1 /* Allow for disabling the E word - Mike 3point */
X! #define WORM          1 /* Long worms */
X! #define ORACLE        1 /* Include another source of information */
X! #define EXPLORE_MODE  1 /* Allow non-scoring play with additional powers */
X! #define ALTARS        1 /* Sacrifice sites - Jean-Christophe Collet */
X! #define WALLIFIED_MAZE 1 /* Fancy mazes - Jean-Christophe Collet */
X  #ifdef HARD
X! #define SEDUCE        1 /* Succubi/incubi additions, by KAA, suggested by IM */
X  #endif
X! #define STRONGHOLD    1 /* Challenging special levels - Jean-Christophe Collet*/
X! #define MUSIC         1 /* Musical instruments - Jean-Christophe Collet */
X! #define GOLEMS        1 /* Golems, by KAA */
X! #define TOLKIEN       1 /* More varieties of objects and monsters */
X! #define KICK          1 /* Allow kicking things besides doors -Izchak Miller */
X! #define TUTTI_FRUTTI  1 /* Fruits as in Rogue, but which work... -KAA */
X  
X  #ifdef REDO
X! #define DOAGAIN '\001'		/* The "redo" key used in tty.c and cmd.c */
X  #endif
X  
X! #define EXP_ON_BOTL	/* Show experience on bottom line */
X  /* #define SCORE_ON_BOTL	/* added by Gary Erickson (erickson@ucivax) */
X  
X  
X*** include/Old/decl.h	Sun Oct 15 19:26:17 1989
X--- include/decl.h	Sun Oct 15 17:23:37 1989
X***************
X*** 121,157 ****
X  #endif
X  
X  #ifdef TEXTCOLOR
X! 
X! #define BLACK		0
X! #define RED		1
X! #define GREEN		2
X! #define BROWN		3	/* on IBM, lo-intensity yellow is brown */
X! #define BLUE		4
X! #define MAGENTA 	5
X! #define CYAN		6
X! #define WHITE		7
X! #define GRAY		7	/* lo-intensity white */
X! #define BRIGHT		8
X! #define ORANGE_COLORED	9
X! #define YELLOW		11
X! #define MAXCOLORS	16	/* 8 basic + 8 bright */
X! 
X! /* these can be configured */
X! #  define HI_MON	RED + BRIGHT		/* red slaps! */
X! #  define HI_OBJ	MAGENTA
X! #  define HI_METAL	CYAN
X! #  define HI_COPPER	YELLOW
X! #  define HI_SILVER	GRAY
X! #  define HI_GOLD	YELLOW
X! #  define HI_LEATHER	BROWN
X! #  define HI_CLOTH	BROWN
X! #  define HI_ORGANIC	GREEN
X! #  define HI_WOOD	BROWN
X! #  define HI_PAPER	BROWN
X! #  define HI_GLASS	CYAN + BRIGHT
X! #  define HI_MINERAL	GRAY
X! #  define HI_ZAP	BLUE + BRIGHT		/* blue zaps! */
X! 
X  E char *hilites[MAXCOLORS];
X  #endif
X  
X--- 121,129 ----
X  #endif
X  
X  #ifdef TEXTCOLOR
X! #ifndef COLOR_H
X! #include "color.h"
X! #endif
X  E char *hilites[MAXCOLORS];
X  #endif
X  
X*** include/Old/extern.h	Sun Oct 15 19:27:24 1989
X--- include/extern.h	Sun Oct 15 12:47:49 1989
X***************
X*** 27,32 ****
X--- 27,33 ----
X  #endif
X  
X  #if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
X+ 
X  /* ### apply.c ### */
X  
X  E int doapply();
X***************
X*** 137,143 ****
X  E int doddrop();
X  E int dodown();
X  E int doup();
X! E void goto_level P((int,BOOLEAN_P));
X  E int donull();
X  E int dowipe();
X  E struct obj *splitobj P((struct obj *,int));
X--- 138,144 ----
X  E int doddrop();
X  E int dodown();
X  E int doup();
X! E void goto_level P((int,BOOLEAN_P,BOOLEAN_P));
X  E int donull();
X  E int dowipe();
X  E struct obj *splitobj P((struct obj *,int));
X***************
X*** 156,161 ****
X--- 157,163 ----
X  E char *mon_nam P((struct monst *));
X  E char *Monnam P((struct monst *));
X  E char *a_monnam P((struct monst *,char *));
X+ E char *a2_monnam P((struct monst *,char *));
X  E char *Amonnam P((struct monst *,char *));
X  E char *Xmonnam P((struct monst *));
X  E char *defmonnam P((struct monst *));
X***************
X*** 235,247 ****
X  
X  E void init_uhunger();
X  E int Hear_again();
X  E int doeat();
X  E void gethungry();
X  E void morehungry P((int));
X  E void lesshungry P((int));
X  E void newuhs P((BOOLEAN_P));
X- E void vomit();
X  E struct obj *floorfood P((char *,BOOLEAN_P));
X  
X  /* ### end.c ### */
X  
X--- 237,250 ----
X  
X  E void init_uhunger();
X  E int Hear_again();
X+ E void reset_eat();
X  E int doeat();
X  E void gethungry();
X  E void morehungry P((int));
X  E void lesshungry P((int));
X  E void newuhs P((BOOLEAN_P));
X  E struct obj *floorfood P((char *,BOOLEAN_P));
X+ E void vomit();
X  
X  /* ### end.c ### */
X  
X***************
X*** 379,387 ****
X  #ifdef UNIX
X  E void getioctls();
X  E void setioctls();
X! #ifdef SUSPEND
X  E int dosuspend();
X! #endif /* SUSPEND */
X  #endif /* UNIX */
X  
X  /* ### lock.c ### */
X--- 382,390 ----
X  #ifdef UNIX
X  E void getioctls();
X  E void setioctls();
X! # ifdef SUSPEND
X  E int dosuspend();
X! # endif /* SUSPEND */
X  #endif /* UNIX */
X  
X  /* ### lock.c ### */
X***************
X*** 394,405 ****
X  E int doopen();
X  E int doclose();
X  
X  /* ### mail.c ### */
X  
X  #ifdef MAIL
X! #ifdef UNIX
X  E void getmailstatus();
X! #endif
X  E void ckmailstatus();
X  E void readmail();
X  #endif /* MAIL */
X--- 397,442 ----
X  E int doopen();
X  E int doclose();
X  
X+ /* ### mac.c ### */
X+ #ifdef MACOS
X+ E int tgetch();
X+ E void gethdate();
X+ E int uptodate();
X+ # ifndef THINKC4
X+ E char *getenv();
X+ E int memcmp();
X+ # else
X+ E int kbhit();
X+ # endif
X+ E int mcurs();
X+ E int mputc();
X+ E int mputs();
X+ E int mprintf();
X+ E int about();
X+ #endif  /* MACOS */
X+ 
X+ /* ### macfile.c ### */
X+ #ifdef MACOS
X+ E short findNamedFile();
X+ E FILE *openFile();
X+ #endif	/* MACOS */
X+ 
X+ /* ### macinit.c ### */
X+ #ifdef MACOS
X+ E int initterm();
X+ E int freeterm();
X+ #ifdef SMALLDATA
X+ E void init_decl();
X+ E void free_decl();
X+ #endif  /* SMALLDATA */
X+ #endif	/* MACOS */
X+ 
X  /* ### mail.c ### */
X  
X  #ifdef MAIL
X! # ifdef UNIX
X  E void getmailstatus();
X! # endif
X  E void ckmailstatus();
X  E void readmail();
X  #endif /* MAIL */
X***************
X*** 410,415 ****
X--- 447,453 ----
X  E void enexto P((coord *,XCHAR_P,XCHAR_P,struct permonst *));
X  E int goodpos P((int,int, struct permonst *));
X  E void rloc P((struct monst *));
X+ E void vloc P((struct monst *));
X  E void init_monstr();
X  E struct permonst *rndmonst();
X  E struct permonst *mkclass P((CHAR_P));
X***************
X*** 494,499 ****
X--- 532,538 ----
X  E boolean is_flammable P((struct obj *));
X  E boolean is_rustprone P((struct obj *));
X  E boolean is_corrodeable P((struct obj *));
X+ E boolean OBJ_AT P((int, int));
X  #endif
X  E void place_object P((struct obj *,int,int));
X  E void move_object P((struct obj *,int,int));
X***************
X*** 582,587 ****
X--- 621,627 ----
X  E void set_apparxy P((struct monst *));
X  E boolean mdig_tunnel P((struct monst *));
X  #ifdef STUPID_CPP
X+ E boolean MON_AT P((int, int));
X  E void place_monster P((struct monst *, int, int));
X  E void place_worm_seg P((struct monst *, int, int));
X  E void remove_monster P((int, int));
X***************
X*** 662,667 ****
X--- 702,708 ----
X  E char *distant_name P((struct obj *, char *(*)(struct obj *)));
X  E char *xname P((struct obj *));
X  E char *doname P((struct obj *));
X+ E char *singular P((struct obj *));
X  E void setan P((char *,char *));
X  E char *aobjnam P((struct obj *,char *));
X  E char *Doname2 P((struct obj *));
X***************
X*** 696,730 ****
X  E int dohistory();
X  E int page_file P((char *,BOOLEAN_P));
X  #ifdef UNIX
X! #ifdef SHELL
X  E int dosh();
X! #endif /* SHELL */
X! #if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
X  E int child P((int));
X! #endif
X  #endif /* UNIX */
X  
X  /* ### pcmain.c ### */
X  
X! #ifdef MSDOS
X  E void askname();
X! #ifdef CHDIR
X  E void chdirx P((char *,BOOLEAN_P));
X! #endif /* CHDIR */
X! #endif /* MSDOS */
X  
X  /* ### pctty.c ### */
X  
X! #ifdef MSDOS
X  E void gettty();
X  E void settty P((char *));
X  E void error V((char *,...));
X! #endif /* MSDOS */
X  
X  /* ### pcunix.c ### */
X  
X! #ifdef MSDOS
X! #ifndef OLD_TOS
X  E void setrandom();
X  E int getyear();
X  E char *getdate();
X--- 737,771 ----
X  E int dohistory();
X  E int page_file P((char *,BOOLEAN_P));
X  #ifdef UNIX
X! # ifdef SHELL
X  E int dosh();
X! # endif /* SHELL */
X! # if defined(SHELL) || defined(DEF_PAGER) || defined(DEF_MAILREADER)
X  E int child P((int));
X! # endif
X  #endif /* UNIX */
X  
X  /* ### pcmain.c ### */
X  
X! #if defined(MSDOS) || defined(MACOS)
X  E void askname();
X! # ifdef CHDIR
X  E void chdirx P((char *,BOOLEAN_P));
X! # endif /* CHDIR */
X! #endif /* MSDOS || MACOS */
X  
X  /* ### pctty.c ### */
X  
X! #if defined(MSDOS) || defined(MACOS)
X  E void gettty();
X  E void settty P((char *));
X  E void error V((char *,...));
X! #endif /* MSDOS || MACOS  */
X  
X  /* ### pcunix.c ### */
X  
X! #if defined(MSDOS) || defined(MACOS)
X! # ifndef OLD_TOS
X  E void setrandom();
X  E int getyear();
X  E char *getdate();
X***************
X*** 733,739 ****
X  E int midnight();
X  E void gethdate P((char *));
X  E int uptodate P((int));
X! #endif /* TOS */
X  E void regularize P((char *));
X  #endif /* MSDOS */
X  
X--- 774,780 ----
X  E int midnight();
X  E void gethdate P((char *));
X  E int uptodate P((int));
X! # endif /* TOS */
X  E void regularize P((char *));
X  #endif /* MSDOS */
X  
X***************
X*** 740,745 ****
X--- 781,787 ----
X  /* ### pickup.c ### */
X  
X  E void pickup P((int));
X+ E struct obj *pick_obj P((struct obj *));
X  E int doloot();
X  E void get_all_from_box();
X  E void use_container P((struct obj *, int));
X***************
X*** 765,773 ****
X  E char *body_part P((int));
X  E int poly_gender();
X  #ifdef POLYSELF
X! #ifdef GOLEMS
X  E void ugolemeffects P((int, int));
X! #endif /* GOLEMS */
X  #endif
X  
X  /* ### potion.c ### */
X--- 807,815 ----
X  E char *body_part P((int));
X  E int poly_gender();
X  #ifdef POLYSELF
X! # ifdef GOLEMS
X  E void ugolemeffects P((int, int));
X! # endif /* GOLEMS */
X  #endif
X  
X  /* ### potion.c ### */
X***************
X*** 776,781 ****
X--- 818,824 ----
X  E void make_stunned P((long,BOOLEAN_P));
X  E void make_blinded P((long,BOOLEAN_P));
X  E void make_sick P((long,BOOLEAN_P));
X+ E void make_vomiting P((long,BOOLEAN_P));
X  E void make_hallucinated P((long,BOOLEAN_P));
X  E int dodrink();
X  E int dopotion P((struct obj *));
X***************
X*** 957,962 ****
X--- 1000,1006 ----
X  E void replshk P((struct monst *,struct monst *));
X  E int inshop();
X  E int inhishop P((struct monst *));
X+ E boolean tended_shop P((int));
X  E void obfree P((struct obj *,struct obj *));
X  E int dopay();
X  E void home_shk P((struct monst *));
X***************
X*** 1069,1077 ****
X  E void cmore P((char *));
X  E void clrlin();
X  #ifdef NEED_VARARGS
X! #if defined(USE_STDARG) || defined(USE_VARARGS)
X  E void vpline P((const char *, va_list));
X! #endif
X  #endif
X  E void pline V((const char *,...));
X  E void Norep V((const char *,...));
X--- 1113,1121 ----
X  E void cmore P((char *));
X  E void clrlin();
X  #ifdef NEED_VARARGS
X! # if defined(USE_STDARG) || defined(USE_VARARGS)
X  E void vpline P((const char *, va_list));
X! # endif
X  #endif
X  E void pline V((const char *,...));
X  E void Norep V((const char *,...));
X***************
X*** 1190,1198 ****
X  /* ### vmsmain.c ### */
X  
X  #ifdef VMS
X! #ifdef CHDIR
X  E void chdirx P((char *,char));
X! #endif /* CHDIR */
X  E void glo P((int));
X  E void askname();
X  #endif /* VMS */
X--- 1234,1242 ----
X  /* ### vmsmain.c ### */
X  
X  #ifdef VMS
X! # ifdef CHDIR
X  E void chdirx P((char *,char));
X! # endif /* CHDIR */
X  E void glo P((int));
X  E void askname();
X  #endif /* VMS */
X*** include/Old/global.h	Sun Oct 15 19:28:53 1989
X--- include/global.h	Sat Oct 14 19:19:35 1989
X***************
X*** 55,62 ****
X--- 55,64 ----
X  typedef schar	xchar;
X  typedef	xchar	boolean;		/* 0 or 1 */
X  
X+ #ifndef MACOS	/* defined in MacTypes.h(LSC) or Types.h(Aztec & MPW) */
X  #define	TRUE	((boolean)1)
X  #define	FALSE	((boolean)0)
X+ #endif
X  
X  #ifdef BITFIELDS
X  #define	Bitfield(x,n)	unsigned x:n
X***************
X*** 72,78 ****
X   * prototypes for the ANSI compilers so people quit trying to fix the prototypes
X   * to match the standard and thus lose the typechecking.
X   */
X! #if defined(MSDOS) && !(defined(AMIGA) || defined(TOS))
X  # define CHAR_P char
X  # define SCHAR_P schar
X  # define UCHAR_P uchar
X--- 74,80 ----
X   * prototypes for the ANSI compilers so people quit trying to fix the prototypes
X   * to match the standard and thus lose the typechecking.
X   */
X! #if defined(MSDOS) || defined(THINKC4) && !(defined(AMIGA) || defined(TOS))
X  # define CHAR_P char
X  # define SCHAR_P schar
X  # define UCHAR_P uchar
X***************
X*** 138,143 ****
X--- 140,148 ----
X  # include "amiconf.h"
X  #endif
X  
X+ #if defined(MACOS) && !defined(MACCONF_H)
X+ # include "macconf.h"
X+ #endif
X  
X  
X  /*
X*** include/Old/lev.h	Sun Oct 15 19:29:30 1989
X--- include/lev.h	Sat Oct 14 16:09:34 1989
X***************
X*** 8,14 ****
X--- 8,18 ----
X  #define LEV_H
X  
X  #ifndef OLD_TOS
X+ # ifdef MACOS
X+ #define OMASK	0x8000	/* O_BINARY */
X+ # else
X  #define OMASK	0
X+ # endif
X  #else
X  #define msmsg	cprintf
X  #define OMASK	0x8000
X*** /dev/null	Sun Oct 15 19:29:49 1989
X--- include/macconf.h	Sat Oct 14 11:45:16 1989
X***************
X*** 0 ****
X--- 1,198 ----
X+ /*	SCCS Id: @(#)macconf.h	3.0	88/07/21 */
X+ /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X+ /* Copyright (c) Johnny Lee, 1989 		*/
X+ /* NetHack may be freely redistributed.  See license for details. */
X+ #ifdef MACOS
X+ #ifndef MACCONF_H
X+ #define MACCONF_H
X+ 
X+ /*
X+  *  The following options are configurable:
X+  */
X+ 
X+ #define RANDOM		1 /* have Berkeley random(3) */
X+ 
X+ #define PATHLEN	220	/* maximum pathlength */
X+ #define FILENAME	31	/* maximum filename length (conservative) */
X+ 
X+ #define glo(x)	name_file(lock, x)	/* name_file used for bones */
X+ #include "msdos.h"	/* contains necessary externs for [os_name].c */
X+ extern char *configfile;
X+ #define NO_SIGNAL	1
X+ #define	perror(x)
X+ 
X+ /*
X+  *  The remaining code shouldn't need modification.
X+  */
X+ 
X+ #ifndef SYSTEM_H
X+ #include "system.h"
X+ #endif
X+ 
X+ 
X+ #ifdef RANDOM
X+ /* Use the high quality random number routines. */
X+ #define Rand()	random()
X+ #define Srand(seed)	srandom(seed)
X+ #else
X+ #define Rand()	rand()
X+ #define Srand(seed)	srand(seed)
X+ #endif /* RANDOM */
X+ 
X+ #ifndef REDO
X+ #undef	Getchar
X+ #define Getchar tgetch
X+ #endif
X+ 
X+ #ifdef THINK_C
X+ 
X+ #define index	strchr
X+ #define rindex	strrchr
X+ #include <time.h>
X+ #define	FCMASK	O_WRONLY | O_BINARY | O_CREAT	/* file creation mask */
X+ 
X+ #ifdef LSC
X+ #include	<types.h>
X+ #include	<io.h>
X+ #define	memcpy(x,y,j)	movmem(y,x,j)
X+ extern char	*calloc();
X+ #else
X+ #include	<Fcntl.h>
X+ #include	<Stddef.h>
X+ #include	<Stdlib.h>
X+ #include	<String.h>
X+ #undef getuid
X+ #ifndef MAKEDEFS_C
X+ #ifdef stdout
X+ #undef stdout
X+ #define stdout (FILE *)NULL
X+ #endif
X+ #endif
X+ #endif
X+ 
X+ #include	<Quickdraw.h>
X+ #include	<FontMgr.h>
X+ #include	<EventMgr.h>
X+ #include	<WindowMgr.h>
X+ #include	<MenuMgr.h>
X+ #include	<StdFilePkg.h>
X+ #include	<SegmentLdr.h>
X+ #include	<ToolboxUtil.h>
X+ #include	<OSUtil.h>
X+ #include	<DialogMgr.h>
X+ #include	<FileMgr.h>
X+ #include	<HFS.h>
X+ #include	<Color.h>
X+ #include	<ResourceMgr.h>
X+ 
X+ #ifdef fflush
X+ #undef	fflush
X+ #define	fflush(x)
X+ #endif
X+ 
X+ /* these two defines for variables in decl.c; they conflict with */
X+ /* variables in Quickdraw.h - the Quickdraw variables are never used in NH */
X+ #define	black	Black
X+ #define	white	White
X+ 
X+ 
X+ #else	/* Aztec and MPW */
X+ 
X+ #ifdef AZTEC
X+ #include	<utime.h>	/* AZTEC 3.6c */
X+ #define	curs(x,y)	tcurs(x,y)
X+ #else
X+ #include	<Time.h>	/* MPW 3.0 */
X+ #endif
X+ 
X+ 
X+ #include	<Quickdraw.h>
X+ #include	<Fonts.h>
X+ #include	<Events.h>
X+ #include	<Windows.h>
X+ #include	<Menus.h>
X+ #include	<Packages.h>
X+ #include	<SegLoad.h>
X+ #include	<ToolUtils.h>
X+ #include	<OSUtils.h>
X+ #include	<Dialogs.h>
X+ #include	<Files.h>
X+ #include	<Resources.h>
X+ #ifdef MPW
X+ #include	<Script.h>
X+ #include	<SysEqu.h>
X+ #endif
X+ #include	<Signal.h>
X+ #include	<String.h>
X+ #include	<FCntl.h>
X+ #define	FCMASK	O_WRONLY | O_CREAT	/* file creation mask */
X+ #endif
X+ 
X+ /* typdef and defines for special custom termcap routines */
X+ typedef struct term_info {
X+ 	short	tcur_x,tcur_y;
X+ 	short	fontNum,fontSize;
X+ 	short	ascent,descent,height,charWidth;
X+ 	short	maxRow,maxCol;
X+ 	char	**screen;
X+ 	short	inColor;
X+ 	short	auxFileVRefNum;
X+ 	short	recordVRefNum;
X+ 	SysEnvRec	system;
X+ 	char	*keyMap;
X+ 	short	color[8];
X+ 	Handle	shortMBarHandle,
X+ 			fullMBarHandle;
X+ } term_info;
X+ 
X+ #define TEXTCOLOR	1
X+ 
X+ #define	appleMenu	101
X+ #define	fileMenu	102
X+ #define	editMenu	103
X+ #define	inventMenu	104
X+ #define actionMenu	105
X+ #define prepMenu	106
X+ #define	moveMenu	107
X+ #define extendMenu	108
X+ 
X+ #ifdef THINK_C
X+ #define MAINGRAFPORT	thePort
X+ #define	ARROW_CURSOR	arrow
X+ #define	SCREEN_BITS	screenBits
X+ #else
X+ #define MAINGRAFPORT	qd.thePort
X+ #define	ARROW_CURSOR	qd.arrow
X+ #define	SCREEN_BITS	qd.screenBits
X+ #endif
X+ 
X+ /* used in mac.c */
X+ #define Screen_Border	4
X+ #define	TOP_OFFSET		30
X+ #define	LEFT_OFFSET	10
X+ 
X+ /* for macflags variable */
X+ #define	fZoomOnContextSwitch		0x200
X+ #define	fUseCustomFont		0x100
X+ #define	fToggleNumPad		0x80
X+ #define	fInvertedScreen		0x40
X+ #define	fExtCmdSeq1			0x20
X+ #define	fExtCmdSeq2			0x10
X+ #define	fExtCmdSeq3			0x08
X+ #define	fDoNonKeyEvt		0x02
X+ #define	fDoUpdate			0x01
X+ 
X+ 
X+ #define	CREATOR	'nh30'
X+ #define	EXPLORE_TYPE	'XPLR'
X+ #define	SAVE_TYPE	'SAVE'
X+ #define	BONES_TYPE	'BONE'
X+ #define	LEVEL_TYPE	'LEVL'
X+ #define	HACK_DATA	'HDTA'
X+ #define MONST_DATA	101
X+ #define	DEFAULT_DATA	100
X+ 
X+ #include "extern.h"
X+ 
X+ #endif /* MACCONF_H /* */
X+ #endif /* MACOS / */
X*** include/Old/monsym.h	Sun Oct 15 19:31:02 1989
X--- include/monsym.h	Sat Oct 14 23:23:25 1989
X***************
X*** 14,20 ****
X  #define	S_GREMLIN	'g'
X  #define	S_HUMANOID	'h'
X  #define	S_IMP		'i'
X! #define	S_J		'j'
X  #define	S_KOBOLD	'k'
X  #define	S_LICH		'l'
X  #define	S_MIMIC		'm'
X--- 14,20 ----
X  #define	S_GREMLIN	'g'
X  #define	S_HUMANOID	'h'
X  #define	S_IMP		'i'
X! #define	S_JELLY		'j'
X  #define	S_KOBOLD	'k'
X  #define	S_LICH		'l'
X  #define	S_MIMIC		'm'
X***************
X*** 21,27 ****
X  #define	S_NAGA		'n'
X  #define	S_ORC		'o'
X  #define	S_PIERCER	'p'
X! #define	S_QUADRUPED		'q'
X  #define	S_RODENT	'r'
X  #define	S_SPIDER	's'
X  #define	S_TRAPPER	't'
X--- 21,27 ----
X  #define	S_NAGA		'n'
X  #define	S_ORC		'o'
X  #define	S_PIERCER	'p'
X! #define	S_QUADRUPED	'q'
X  #define	S_RODENT	'r'
X  #define	S_SPIDER	's'
X  #define	S_TRAPPER	't'
X***************
X*** 40,46 ****
X  #define	S_GNOME		'G'
X  #define	S_GIANT		'H'
X  #define	S_STALKER	'I'
X! #define	S_JELLY		'J'
X  #define	S_KOP		'K'
X  #define	S_LEPRECHAUN	'L'
X  #define	S_MUMMY		'M'
X--- 40,46 ----
X  #define	S_GNOME		'G'
X  #define	S_GIANT		'H'
X  #define	S_STALKER	'I'
X! #define	S_JABBERWOCK	'J'
X  #define	S_KOP		'K'
X  #define	S_LEPRECHAUN	'L'
X  #define	S_MUMMY		'M'
X*** include/Old/obj.h	Sun Oct 15 19:31:32 1989
X--- include/obj.h	Thu Oct  5 21:20:45 1989
X***************
X*** 31,36 ****
X--- 31,37 ----
X  	Bitfield(oinvis,1);	/* not yet implemented */
X  	Bitfield(olocked,1);	/* object is locked */
X  #define recharged olocked	/* recharged once */
X+ #define oeaten	olocked		/* partially eaten food */
X  	Bitfield(otrapped,1);	/* container is trapped */
X  #define opoisoned otrapped	/* weapon has been coated with poison */
X  	Bitfield(odispl,1);
X***************
X*** 42,52 ****
X  	Bitfield(unpaid,1);	/* on some bill */
X  	Bitfield(rustfree,1);
X  #define flameproof 	rustfree/* for non-metal armor items */
X  	Bitfield(no_charge,1);	/* if shk shouldn't charge for this */
X  	Bitfield(onamelth,6);
X  	long age;		/* creation date */
X  	long owornmask;
X- #define oeaten		rustfree
X  
X  /* note that TIMEOUT in you.h is defined as 07777L; no bits for items that
X   * confer properties may overlap that mask, or timeout.c will happily 
X--- 43,53 ----
X  	Bitfield(unpaid,1);	/* on some bill */
X  	Bitfield(rustfree,1);
X  #define flameproof 	rustfree/* for non-metal armor items */
X+ #define in_use 		rustfree/* for magic items before useup items */
X  	Bitfield(no_charge,1);	/* if shk shouldn't charge for this */
X  	Bitfield(onamelth,6);
X  	long age;		/* creation date */
X  	long owornmask;
X  
X  /* note that TIMEOUT in you.h is defined as 07777L; no bits for items that
X   * confer properties may overlap that mask, or timeout.c will happily 
X***************
X*** 80,86 ****
X  #define newobj(xl)	(struct obj *) alloc((unsigned)(xl) + sizeof(struct obj))
X  #define	ONAME(otmp)	((char *) otmp->oextra)
X  #define	OGOLD(otmp)	(otmp->oextra[0])
X- #define	OEATEN(otmp)	(otmp->oeaten)
X  
X  # ifndef STUPID_CPP	/* otherwise these macros are functions */
X  
X--- 81,86 ----
X*** include/Old/patchlevel.h	Sun Oct 15 19:31:56 1989
X--- include/patchlevel.h	Sun Oct 15 19:17:26 1989
X***************
X*** 43,46 ****
X   *  assorted bug fixes
X   */
X  
X! #define PATCHLEVEL	4
X--- 43,55 ----
X   *  assorted bug fixes
X   */
X  
X! /*
X!  *  Patch 5, October 15, 1989
X!  *  add support for Macintosh OS (courtesy Johnny Lee)
X!  *  fix annoying dependency loop via new color.h file
X!  *  allow interruption while eating -- general handling of partially eaten food
X!  *  smarter treatment of iron balls
X!  *  a handful of other bug fixes
X!  */
X! 
X! #define PATCHLEVEL	5
X*** include/Old/pcconf.h	Sun Oct 15 19:32:10 1989
X--- include/pcconf.h	Sat Oct 14 19:19:35 1989
X***************
X*** 16,22 ****
X  
X  #define DGK			/* MS DOS specific enhancements by dgk */
X  
X! #define TERMLIB		/* enable use of termcap file /etc/termcap */
X  			/* or ./termcap for MSDOS (SAC) */
X  			/* compile and link in Fred Fish's termcap library, */
X  			/* enclosed in TERMCAP.ARC, to use this */
X--- 16,22 ----
X  
X  #define DGK			/* MS DOS specific enhancements by dgk */
X  
X! /* #define TERMLIB		/* enable use of termcap file /etc/termcap */
X  			/* or ./termcap for MSDOS (SAC) */
X  			/* compile and link in Fred Fish's termcap library, */
X  			/* enclosed in TERMCAP.ARC, to use this */
X*** include/Old/permonst.h	Sun Oct 15 19:32:21 1989
X--- include/permonst.h	Sat Oct 14 16:10:57 1989
X***************
X*** 32,38 ****
X--- 32,42 ----
X  
X  struct permonst {
X  
X+ #if defined(SMALLDATA) && !defined(MAKEDEFS_C)
X+ 	char		mname[24], mlet;		/* full name and sym */
X+ #else
X  	char		*mname, mlet;		/* full name and sym */
X+ #endif
X  	schar		mlevel,			/* base monster level */
X  			mmove,			/* move speed */
X  			ac,			/* (base) armor class */
X***************
X*** 51,57 ****
X  # endif
X  };
X  
X! extern struct permonst mons[];		/* the master list of monster types */
X  extern struct permonst playermon, *uasmon;	/* you in the same terms */
X  
X  #endif /* PERMONST_H /**/
X--- 55,95 ----
X  # endif
X  };
X  
X! extern struct permonst
X! #if defined(SMALLDATA) && !defined(MAKEDEFS_C)
X! 			*mons;
X! #else
X! 			mons[];		/* the master list of monster types */
X! #endif
X  extern struct permonst playermon, *uasmon;	/* you in the same terms */
X+ 
X+ #if defined(SMALLDATA) && defined(MAKEDEFS_C)
X+ 
X+ typedef struct pmpart {
X+ 	char		mlet;			/* full name and sym */
X+ 	schar		mlevel,			/* base monster level */
X+ 			mmove,			/* move speed */
X+ 			ac,			/* (base) armor class */
X+ 			mr,			/* (base) magic resistance */
X+ 			maligntyp;		/* basic monster alignment */
X+ 	unsigned	geno;			/* creation/geno mask value */
X+ 	struct	attack	mattk[NATTK];		/* attacks matrix */
X+ 	unsigned	cwt,			/* weight of corpse */
X+ 			cnutrit;		/* its nutritional value */
X+ 	short		pxlth;			/* length of extension */
X+ 	uchar		msound;			/* noise it makes */
X+ 	long		mflags1,		/* boolean bitflags */
X+ 			mflags2;		/* more boolean bitflags */
X+ # ifdef TEXTCOLOR
X+ 	uchar		mcolor;			/* color to use */
X+ # endif
X+ } pmpart;
X+ 
X+ typedef struct pmstr {
X+ 	char		mname[24];		/* full name and sym */
X+ 	pmpart		pmp;
X+ } pmstr;
X+ 
X+ #endif
X  
X  #endif /* PERMONST_H /**/
X*** include/Old/prop.h	Sun Oct 15 19:32:33 1989
X--- include/prop.h	Tue Oct  3 20:02:02 1989
X***************
X*** 48,53 ****
X  #define ANTIMAGIC		41
X  #define DISPLACED		42
X  #define CLAIRVOYANT		43
X! #define LAST_PROP		(CLAIRVOYANT)		/* the last property */
X  
X  #endif /* PROP_H /**/
X--- 48,54 ----
X  #define ANTIMAGIC		41
X  #define DISPLACED		42
X  #define CLAIRVOYANT		43
X! #define VOMITING		44
X! #define LAST_PROP		(VOMITING)		/* the last property */
X  
X  #endif /* PROP_H /**/
X*** include/Old/rm.h	Sun Oct 15 19:32:45 1989
X--- include/rm.h	Sat Oct 14 16:12:54 1989
X***************
X*** 214,245 ****
X  #define ladder		doormask
X  #define drawbridgemask	doormask
X  
X  typedef struct
X  {
X      struct rm		locations[COLNO][ROWNO];
X      struct obj		*objects[COLNO][ROWNO];
X      struct monst	*monsters[COLNO][ROWNO];
X      struct obj		*objlist;
X      struct monst	*monlist;
X  }
X! level_t;
X  
X! extern level_t	level;	/* structure describing the current level */
X  
X  /*
X   * Macros for compatibility with old code. Someday these will go away.
X   */
X- #define OBJ_AT(x, y)	(level.objects[x][y] != (struct obj *)0)
X- #define MON_AT(x, y)	(level.monsters[x][y] != (struct monst *)0)
X  #define levl		level.locations
X  #define fobj		level.objlist
X  #define fmon		level.monlist
X  
X! #ifndef STUPID_CPP	/* otherwise these macros are functions in monmove.c */
X  /*
X   * Macros for encapsulation of level.monsters references.
X   */
X! #define place_monster(m, x, y)	level.monsters[m->mx=x][m->my=y] = m
X  #define place_worm_seg(m, x, y) level.monsters[x][y] = m
X  #define remove_monster(x, y)	level.monsters[x][y] = (struct monst *)0
X  #define m_at(x, y)		level.monsters[x][y]
X--- 214,264 ----
X  #define ladder		doormask
X  #define drawbridgemask	doormask
X  
X+ #ifdef MACOS
X  typedef struct
X  {
X+     struct rm		**locations;
X+     struct obj		***objects;
X+     struct monst	***monsters;
X+     struct obj		*objlist;
X+     struct monst	*monlist;
X+ }
X+ dlevel_t;
X+ #else
X+ typedef struct
X+ {
X      struct rm		locations[COLNO][ROWNO];
X+ #ifndef MICROPORT_BUG
X      struct obj		*objects[COLNO][ROWNO];
X      struct monst	*monsters[COLNO][ROWNO];
X+ #else
X+     struct obj		*objects[1][ROWNO];
X+     char		*yuk1[COLNO-1][ROWNO];
X+     struct monst	*monsters[1][ROWNO];
X+     char		*yuk2[COLNO-1][ROWNO];
X+ #endif
X      struct obj		*objlist;
X      struct monst	*monlist;
X  }
X! dlevel_t;
X! #endif
X  
X! extern dlevel_t	level;	/* structure describing the current level */
X  
X  /*
X   * Macros for compatibility with old code. Someday these will go away.
X   */
X  #define levl		level.locations
X  #define fobj		level.objlist
X  #define fmon		level.monlist
X  
X! #ifndef STUPID_CPP	/* otherwise these macros are functions */
X! #define OBJ_AT(x, y)	(level.objects[x][y] != (struct obj *)0)
X  /*
X   * Macros for encapsulation of level.monsters references.
X   */
X! #define MON_AT(x, y)	(level.monsters[x][y] != (struct monst *)0)
X! #define place_monster(m, x, y)	m->mx=x,m->my=y,level.monsters[m->mx][m->my]=m
X  #define place_worm_seg(m, x, y) level.monsters[x][y] = m
X  #define remove_monster(x, y)	level.monsters[x][y] = (struct monst *)0
X  #define m_at(x, y)		level.monsters[x][y]
X*** include/Old/system.h	Sun Oct 15 19:33:19 1989
X--- include/system.h	Sat Oct 14 16:16:48 1989
X***************
X*** 7,18 ****
X  
X  #define E extern
X  
X! #ifdef AMIGA
X  #define _SIZE_T
X  typedef unsigned int	size_t;
X! #else
X  # include <sys/types.h>
X  #endif
X  
X  #ifdef ULTRIX
X  /* The Ultrix v3.0 <sys/types.h> seems to be very wrong. */
X--- 7,23 ----
X  
X  #define E extern
X  
X! #ifndef THINKC4
X! # if defined(AMIGA) || defined(MACOS)
X  #define _SIZE_T
X  typedef unsigned int	size_t;
X! # else
X  # include <sys/types.h>
X+ # endif
X  #endif
X+ #if defined(AZTEC) || defined(THINKC4)
X+ typedef long	off_t;
X+ #endif
X  
X  #ifdef ULTRIX
X  /* The Ultrix v3.0 <sys/types.h> seems to be very wrong. */
X***************
X*** 20,26 ****
X  #define time_t long
X  #endif
X  
X! #if defined(TOS) && defined(__GNUC__)
X  #define _SIZE_T
X  #endif
X  
X--- 25,31 ----
X  #define time_t long
X  #endif
X  
X! #if defined(TOS) && defined(__GNUC__) && !defined(_SIZE_T)
X  #define _SIZE_T
X  #endif
X  
X***************
X*** 67,76 ****
X  E void exit P((int));
X  # endif /* MSDOS */
X  E void free P((genericptr_t));
X  E void perror P((const char *));
X  #endif
X  
X! #if defined(BSD) || defined(ULTRIX)
X  E int qsort();
X  #else
X  E void qsort P((genericptr_t,size_t,size_t,int(*)(genericptr_t,genericptr_t)));
X--- 72,83 ----
X  E void exit P((int));
X  # endif /* MSDOS */
X  E void free P((genericptr_t));
X+ # ifndef MACOS
X  E void perror P((const char *));
X+ # endif
X  #endif
X  
X! #if defined(BSD) || defined(ULTRIX) || (defined(MACOS) && !defined(THINKC4))
X  E int qsort();
X  #else
X  E void qsort P((genericptr_t,size_t,size_t,int(*)(genericptr_t,genericptr_t)));
X***************
X*** 83,88 ****
X--- 90,97 ----
X  #else
X  E long lseek P((int,long,int));
X  E int write P((int,genericptr_t,unsigned));
X+ #endif /* ULTRIX */
X+ 
X  #ifdef MSDOS
X  E int close P((int));
X  E int read P((int,genericptr_t,unsigned int));
X***************
X*** 90,99 ****
X  E int dup2 P((int, int));
X  E int setmode P((int,int));
X  E int kbhit P((void));
X- #endif
X- #endif /* ULTRIX */
X- 
X- #ifdef MSDOS
X  E int chdir P((char *));
X  E char *getcwd P((char *,int));
X  #endif
X--- 99,104 ----
X***************
X*** 142,148 ****
X  E char	*strcat P((char *,const char *));
X  E char	*strncat P((char *,const char *,size_t));
X  
X! #if defined(SYSV) || defined(MSDOS)
X  E char	*strchr P((const char *,int));
X  E char	*strrchr P((const char *,int));
X  #else /* BSD */
X--- 147,153 ----
X  E char	*strcat P((char *,const char *));
X  E char	*strncat P((char *,const char *,size_t));
X  
X! #if defined(SYSV) || defined(MSDOS) || defined(THINK_C)
X  E char	*strchr P((const char *,int));
X  E char	*strrchr P((const char *,int));
X  #else /* BSD */
X***************
X*** 153,159 ****
X  
X  E int	strcmp P((const char *,const char *));
X  E int	strncmp P((const char *,const char *,size_t));
X! #ifdef MSDOS
X  E size_t strlen P((const char *));
X  #else
X  E int	strlen();
X--- 158,164 ----
X  
X  E int	strcmp P((const char *,const char *));
X  E int	strncmp P((const char *,const char *,size_t));
X! #if defined(MSDOS) || defined(THINKC4)
X  E size_t strlen P((const char *));
X  #else
X  E int	strlen();
X***************
X*** 188,194 ****
X  #define Sprintf	(void) sprintf
X  #define Strcat	(void) strcat
X  #define Strcpy	(void) strcpy
X! #define Printf  (void) printf
X  
X  #ifdef NEED_VARARGS
X  #define Vprintf (void) vprintf
X--- 193,212 ----
X  #define Sprintf	(void) sprintf
X  #define Strcat	(void) strcat
X  #define Strcpy	(void) strcpy
X! 
X! #if defined(MACOS) && !defined(MAKEDEFS_C)
X! #undef printf
X! #undef puts
X! #undef putchar
X! #undef putc
X! #define printf  (void) mprintf
X! #define	puts	mputs
X! #define putchar	mputc
X! #define	putc	mputc
X! #define Printf	(void) mprintf
X! #else
X! #define Printf	(void) printf
X! #endif
X  
X  #ifdef NEED_VARARGS
X  #define Vprintf (void) vprintf
X***************
X*** 206,218 ****
X  
X  /* time functions */
X  
X  E struct tm *localtime P((const time_t *));
X  
X! #if (defined(ULTRIX) || defined(SYSV) || defined(MSDOS)) && !defined(AMIGA)
X  E time_t time P((time_t *));
X! #else
X  E long time P((time_t *));
X! #endif /* ULTRIX */
X  
X  #ifdef MSDOS
X  E int abs P((int));
X--- 224,238 ----
X  
X  /* time functions */
X  
X+ #ifndef MACOS
X  E struct tm *localtime P((const time_t *));
X  
X! # if defined(ULTRIX) || defined(SYSV) || (defined(MSDOS) && !defined(AMIGA))
X  E time_t time P((time_t *));
X! # else
X  E long time P((time_t *));
X! # endif /* ULTRIX */
X! #endif
X  
X  #ifdef MSDOS
X  E int abs P((int));
X*** include/Old/tosconf.h	Sun Oct 15 19:33:34 1989
X--- include/tosconf.h	Sat Oct 14 19:19:35 1989
X***************
X*** 38,43 ****
X--- 38,44 ----
X  #define RANDOM
X  #define SHELL
X  #define TEXTCOLOR
X+ #define TERMLIB
X  
X  #ifndef MSDOS_H
X  #include "msdos.h"
X***************
X*** 45,50 ****
X--- 46,53 ----
X  #ifndef PCCONF_H
X  #include "pcconf.h"	 	 /* remainder of stuff is same as the PC */
X  #endif
X+ #ifdef TERMLIB
X  #undef ANSI_DEFAULT
X+ #endif
X  #endif /* TOSCONF_H /* */
X  #endif /* TOS /* */
X*** include/Old/tradstdc.h	Sun Oct 15 19:33:46 1989
X--- include/tradstdc.h	Wed Oct 11 19:06:46 1989
X***************
X*** 54,60 ****
X  		va_list the_args; typ1 var1; typ2 var2;
X  #  define VA_ARGS		the_args
X  #  define VA_START(x)		va_start(the_args)
X! #  define VA_INIT(var1,typ1) 	va_arg(var1, typ1)
X  #  define VA_NEXT(var1,typ1)	var1 = va_arg(the_args,typ1)
X  #  define VA_END()		va_end(the_args)
X  # else
X--- 54,60 ----
X  		va_list the_args; typ1 var1; typ2 var2;
X  #  define VA_ARGS		the_args
X  #  define VA_START(x)		va_start(the_args)
X! #  define VA_INIT(var1,typ1) 	var1 = va_arg(the_args, typ1)
X  #  define VA_NEXT(var1,typ1)	var1 = va_arg(the_args,typ1)
X  #  define VA_END()		va_end(the_args)
X  # else
X*** include/Old/unixconf.h	Sun Oct 15 19:34:17 1989
X--- include/unixconf.h	Sat Oct 14 19:19:34 1989
X***************
X*** 36,47 ****
X  
X  /* #define PYRAMID_BUG 	/* avoid a bug on the Pyramid */
X  /* #define APOLLO	/* same for the Apollo */
X! /* #define RANDOM	/* if neither random/srandom nor lrand48/srand48
X! 			   is available from your system */
X  /* #define MICROPORT_286_BUG /* Changes needed in termcap.c to get it to
X  			   run with Microport Sys V/AT version 2.4.
X  			   By Jay Maynard */
X  
X  /* #define TEXTCOLOR	/* Use System V r3.2 terminfo color support */
X  
X  
X--- 36,48 ----
X  
X  /* #define PYRAMID_BUG 	/* avoid a bug on the Pyramid */
X  /* #define APOLLO	/* same for the Apollo */
X! /* #define MICROPORT_BUG /* problems with large arrays in structs */
X  /* #define MICROPORT_286_BUG /* Changes needed in termcap.c to get it to
X  			   run with Microport Sys V/AT version 2.4.
X  			   By Jay Maynard */
X  
X+ /* #define RANDOM	/* if neither random/srandom nor lrand48/srand48
X+ 			   is available from your system */
X  /* #define TEXTCOLOR	/* Use System V r3.2 terminfo color support */
X  
X  
X*** include/Old/youprop.h	Sun Oct 15 19:35:11 1989
X--- include/youprop.h	Sun Oct 15 17:23:36 1989
X***************
X*** 163,167 ****
X--- 163,168 ----
X  #define Antimagic		u.uprops[ANTIMAGIC].p_flgs
X  #define Displaced		u.uprops[DISPLACED].p_flgs
X  #define Clairvoyant		u.uprops[CLAIRVOYANT].p_flgs
X+ #define Vomiting		u.uprops[VOMITING].p_flgs
X  
X  #endif /* YOUPROP_H /**/
X*** others/Old/Makefile.tcc	Sun Oct 15 18:14:11 1989
X--- others/Makefile.tcc	Fri Sep 29 11:54:15 1989
X***************
X*** 153,158 ****
X--- 153,159 ----
X  	@$(TLINK) $(TLFLAGS) $(C0) $(SPLEVOBJS),$@,,$(LIBS);
X  
X  o\lev_comp.obj:  $(HACK_H) $(INCL)\sp_lev.h
X+ 	$(CC) $(CFLAGS) -A- $*.c
X  o\lev_lex.obj:  $(INCL)\lev_comp.h $(HACK_H) $(INCL)\sp_lev.h
X  o\lev_main.obj:  $(HACK_H) $(INCL)\sp_lev.h
X  
X***************
X*** 227,233 ****
X  	del date.h
X  	del onames.h
X  	del pm.h
X! 	touch date.h onames.h pm.h
X  	cd $(AUX)
X  	del data
X  	del rumors
X--- 228,234 ----
X  	del date.h
X  	del onames.h
X  	del pm.h
X! 	touch onames.h pm.h
X  	cd $(AUX)
X  	del data
X  	del rumors
X*** others/Old/pcmain.c	Sun Oct 15 18:15:37 1989
X--- others/pcmain.c	Sun Oct 15 12:47:03 1989
X***************
X*** 8,15 ****
X--- 8,23 ----
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif
X+ #ifdef MACOS
X+ extern WindowPtr	HackWindow;
X+ extern short *switches;
X+ extern short macflags;
X+ #define msmsg mprintf
X+ #endif
X  
X+ #ifndef MACOS
X  char orgdir[PATHLEN];
X+ #endif
X  char SAVEF[FILENAME];
X  
X  char *hname = "NetHack";	/* used for syntax messages */
X***************
X*** 38,44 ****
X--- 46,60 ----
X  #ifdef OLD_TOS
X  #define OMASK	0x8000
X  #else
X+ # ifdef MACOS
X+ #  ifdef AZTEC
X+ #define OMASK	O_RDONLY
X+ #  else
X+ #define OMASK	(O_RDONLY | O_BINARY )
X+ #  endif
X+ # else
X  #define OMASK	0
X+ # endif
X  #endif
X  
X  int
X***************
X*** 56,71 ****
X  	extern int _unixmode;
X  	_unixmode = 0;
X  #endif
X! 
X! # ifdef __TURBOC__
X  	if (_osmajor >= 3) hname = argv[0];	/* DOS 3.0+ */
X! # endif
X! # ifdef TOS
X  	if (*argv[0]) {			/* only a CLI can give us argv[0] */
X  		hname = argv[0];
X  		run_from_desktop = FALSE;
X  	}
X! # endif
X  
X  	/*
X  	 *  Initialize screen I/O before anything is displayed.
X--- 72,123 ----
X  	extern int _unixmode;
X  	_unixmode = 0;
X  #endif
X! #ifdef __TURBOC__
X  	if (_osmajor >= 3) hname = argv[0];	/* DOS 3.0+ */
X! #endif
X! #ifdef TOS
X  	if (*argv[0]) {			/* only a CLI can give us argv[0] */
X  		hname = argv[0];
X  		run_from_desktop = FALSE;
X  	}
X! #endif
X! #ifdef MACOS
X! 	AppFile	theFile;
X! 	short	message,numFiles;
X! 	SFReply	reply;
X! 
X! 	initterm(24,80);
X! 	ObscureCursor();
X! # ifdef SMALLDATA
X! 	init_decl();
X! # endif
X! 	/* user might have started up with a save file, so check */
X! 	CountAppFiles(&message,&numFiles);
X! 	if (!message && numFiles) {
X! 		message = 1;
X! 		
X! 		while(message <= numFiles) {
X! 			GetAppFiles(message,&theFile);
X! 			ClrAppFiles(message);
X! 			if (theFile.fType == SAVE_TYPE)
X! 				break;
X! 		}
X! 		if (theFile.fType == SAVE_TYPE) {
X! 			(void)strncpy(SAVEF, (char *)&theFile.fName[1],
X! 						(int)theFile.fName[0]);
X! 			(void)strncpy(plname, (char *)&theFile.fName[1],
X! 						(int)theFile.fName[0]);
X! 			SetVol(0,theFile.vRefNum);
X! 			SAVEF[(int)theFile.fName[0]] = '\0';
X! 			numFiles = 1;
X! 		} else
X! 			numFiles = 0;
X! 	} 
X! 	switches = (short *)malloc((NROFOBJECTS+2) * sizeof(long));
X! 	for (fd = 0; fd < (NROFOBJECTS + 2); fd++)
X! 		switches[fd] = fd;
X! #endif
X! 
X  
X  	/*
X  	 *  Initialize screen I/O before anything is displayed.
X***************
X*** 75,86 ****
X  	 *  and before error(), due to use of termcap strings.
X  	 */
X  	gettty();
X! #ifndef AMIGA
X  	setbuf(stdout,obuf);
X  #endif
X  	startup();
X! 
X! #ifndef AMIGA
X  	/* Save current directory and make sure it gets restored when
X  	 * the game is exited.
X  	 */
X--- 127,137 ----
X  	 *  and before error(), due to use of termcap strings.
X  	 */
X  	gettty();
X! #if !defined(AMIGA) && !defined(MACOS)
X  	setbuf(stdout,obuf);
X  #endif
X  	startup();
X! #if !defined(AMIGA) && !defined(MACOS)
X  	/* Save current directory and make sure it gets restored when
X  	 * the game is exited.
X  	 */
X***************
X*** 92,117 ****
X  # ifndef NO_SIGNAL
X  	signal(SIGINT, (SIG_RET_TYPE) funcp);	/* restore original directory */
X  # endif
X! #endif /* AMIGA */
X  
X  	if ((dir = getenv("HACKDIR")) != NULL) {
X  		Strcpy(hackdir, dir);
X! #ifdef CHDIR
X  		chdirx (dir, 1);
X! #endif
X  	}
X! #if defined(DGK) && !defined(OLD_TOS)
X  	/* zero "fileinfo" array to prevent crashes on level change */
X  	for (i = 0 ; i <= MAXLEVEL; i++) {
X  		fileinfo[i] = zfinfo;
X  	}
X! #endif /* DGK && !OLD_TOS */
X  
X  	initoptions();
X! #ifdef TOS
X  	if (flags.IBMBIOS && flags.use_color)
X  		set_colors();
X! #endif
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X  
X--- 143,169 ----
X  # ifndef NO_SIGNAL
X  	signal(SIGINT, (SIG_RET_TYPE) funcp);	/* restore original directory */
X  # endif
X! #endif /* AMIGA || MACOS */
X  
X+ #ifndef MACOS
X  	if ((dir = getenv("HACKDIR")) != NULL) {
X  		Strcpy(hackdir, dir);
X! # ifdef CHDIR
X  		chdirx (dir, 1);
X! # endif
X  	}
X! # if defined(DGK) && !defined(OLD_TOS)
X  	/* zero "fileinfo" array to prevent crashes on level change */
X  	for (i = 0 ; i <= MAXLEVEL; i++) {
X  		fileinfo[i] = zfinfo;
X  	}
X! # endif /* DGK && !OLD_TOS */
X  
X  	initoptions();
X! # ifdef TOS
X  	if (flags.IBMBIOS && flags.use_color)
X  		set_colors();
X! # endif
X  	if (!hackdir[0])
X  		Strcpy(hackdir, orgdir);
X  
X***************
X*** 136,148 ****
X  	 * may do a prscore().
X  	 */
X  	    if (!strncmp(argv[1], "-s", 2)) {
X! #ifdef CHDIR
X  		chdirx(hackdir,0);
X! #endif
X  		prscore(argc, argv);
X  		exit(0);
X  	    }
X  	}
X  
X  	/*
X  	 * It seems you really want to play.
X--- 188,203 ----
X  	 * may do a prscore().
X  	 */
X  	    if (!strncmp(argv[1], "-s", 2)) {
X! # ifdef CHDIR
X  		chdirx(hackdir,0);
X! # endif
X  		prscore(argc, argv);
X  		exit(0);
X  	    }
X  	}
X+ #else
X+ 	initoptions();
X+ #endif	/* MACOS /* */	
X  
X  	/*
X  	 * It seems you really want to play.
X***************
X*** 233,238 ****
X--- 288,298 ----
X  		Strcpy(plname, "wizard");
X  	else
X  #endif
X+ #if defined(KR1ED) && defined(WIZARD) && defined(MACOS)
X+ 	if (!strcmp(plname,WIZARD))
X+ 		Strcpy(plname, "wizard");
X+ 	else
X+ #endif
X  	if (!*plname)
X  		askname();
X  	plnamesuffix();		/* strip suffix from name; calls askname() */
X***************
X*** 258,270 ****
X  
X  	/* initialize static monster strength array */
X  	init_monstr();
X! 
X! #ifdef AMIGA
X  	(void) strncat(SAVEF, plname, 31-4);
X  #else
X  	(void) strncat(SAVEF, plname, 8);
X  #endif
X  	Strcat(SAVEF, ".sav");
X  	cls();
X  	if (
X  #ifdef DGK
X--- 318,339 ----
X  
X  	/* initialize static monster strength array */
X  	init_monstr();
X! #ifdef MACOS
X! 	if (!numFiles && findNamedFile(plname,1,&reply)) {
X! 		if (reply.good) {
X! 		    strncpy(SAVEF,(char *)&reply.fName[1],(int)reply.fName[0]);
X! 		    SAVEF[(int)reply.fName[0]] = '\0';
X! 		}
X! 	} else if (!numFiles)
X! #endif
X! #if defined(AMIGA) || defined(MACOS)
X  	(void) strncat(SAVEF, plname, 31-4);
X  #else
X  	(void) strncat(SAVEF, plname, 8);
X  #endif
X+ #ifndef MACOS
X  	Strcat(SAVEF, ".sav");
X+ #endif
X  	cls();
X  	if (
X  #ifdef DGK
X***************
X*** 317,323 ****
X  		pickup(1);
X  		read_engr_at(u.ux,u.uy);
X  	}
X! 
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X--- 386,411 ----
X  		pickup(1);
X  		read_engr_at(u.ux,u.uy);
X  	}
X! 	
X! #ifdef MACOS
X! 	{
X! 		short	i;
X! 		MenuHandle	theMenu;
X! 		
X! 		theMenu = GetMHandle(appleMenu);
X! 		EnableItem(theMenu, 0);
X! 		EnableItem(theMenu, 1);
X! 		theMenu = GetMHandle(fileMenu);
X! 		EnableItem(theMenu,0);
X! 		for (i = inventMenu;i <= extendMenu; i++) {
X! 			theMenu = GetMHandle(i);
X! 			EnableItem(theMenu, 0);
X! 		}
X! 		DrawMenuBar();
X! 		macflags |= fDoUpdate;
X! 	}
X! #endif
X! 			
X  	flags.moonphase = phase_of_the_moon();
X  	if(flags.moonphase == FULL_MOON) {
X  		You("are lucky!  Full moon tonight.");
X***************
X*** 335,340 ****
X--- 423,432 ----
X  #endif
X  
X  	moveloop();
X+ #ifdef MACOS 
X+ 	/* Help for Mac compilers */
X+ 	free_decl();
X+ #endif
X  	return 0;
X  }
X  
X***************
X*** 359,364 ****
X--- 451,459 ----
X  #ifdef MSDOS
X  				msmsg("\b \b");
X  #endif
X+ #ifdef MACOS
X+ 				putc('\b');
X+ #endif
X  			}
X  			continue;
X  		}
X***************
X*** 365,371 ****
X  		if(c != '-')
X  		if(c < 'A' || (c > 'Z' && c < 'a') || c > 'z') c = '_';
X  		if(ct < sizeof(plname)-1) {
X! #ifdef MSDOS
X  			msmsg("%c", c);
X  #endif
X  			plname[ct++] = c;
X--- 460,466 ----
X  		if(c != '-')
X  		if(c < 'A' || (c > 'Z' && c < 'a') || c > 'z') c = '_';
X  		if(ct < sizeof(plname)-1) {
X! #if defined(MSDOS) || defined(MACOS)
X  			msmsg("%c", c);
X  #endif
X  			plname[ct++] = c;
X*** others/Old/pctty.c	Sun Oct 15 18:16:06 1989
X--- others/pctty.c	Sun Oct 15 12:52:32 1989
X***************
X*** 18,24 ****
X  	erase_char = '\b';
X  	kill_char = 21;		/* cntl-U */
X  	flags.cbreak = TRUE;
X! #ifndef TOS
X  	disable_ctrlP();	/* turn off ^P processing */
X  #endif
X  }
X--- 18,24 ----
X  	erase_char = '\b';
X  	kill_char = 21;		/* cntl-U */
X  	flags.cbreak = TRUE;
X! #if !defined(TOS) && !defined(MACOS)
X  	disable_ctrlP();	/* turn off ^P processing */
X  #endif
X  }
X***************
X*** 29,35 ****
X  	end_screen();
X  	if(s) Printf(s);
X  	(void) fflush(stdout);
X! #ifndef TOS
X  	enable_ctrlP();		/* turn on ^P processing */
X  #endif
X  }
X--- 29,35 ----
X  	end_screen();
X  	if(s) Printf(s);
X  	(void) fflush(stdout);
X! #if !defined(TOS) && !defined(MACOS)
X  	enable_ctrlP();		/* turn on ^P processing */
X  #endif
X  }
X*** others/Old/pcunix.c	Sun Oct 15 18:16:18 1989
X--- others/pcunix.c	Sat Oct 14 22:40:07 1989
X***************
X*** 19,32 ****
X  #include <errno.h>
X  #else
X  #include <error.h>
X! #endif /* UNIXDEBUG */
X  #endif
X  
X  #include	<sys/types.h>
X  #include	<sys/stat.h>
X  
X  #ifndef OLD_TOS
X  static struct stat buf, hbuf;
X  void
X  setrandom()
X  {
X--- 19,37 ----
X  #include <errno.h>
X  #else
X  #include <error.h>
X! #endif /* OLD_TOS */
X  #endif
X  
X+ #ifndef MACOS
X  #include	<sys/types.h>
X  #include	<sys/stat.h>
X+ #endif
X  
X  #ifndef OLD_TOS
X+ # ifndef MACOS
X  static struct stat buf, hbuf;
X+ # endif
X+ 
X  void
X  setrandom()
X  {
X***************
X*** 91,101 ****
X  	return(getlt()->tm_hour == 0);
X  }
X  
X  void
X  gethdate(name)
X  char *name;
X  {
X! #if defined(TOS) && !defined(__GNUC__)
X  /* old version - for people short of space */
X  /*
X  /* register char *np;
X--- 96,107 ----
X  	return(getlt()->tm_hour == 0);
X  }
X  
X+ # ifndef MACOS
X  void
X  gethdate(name)
X  char *name;
X  {
X! #  if defined(TOS) && !defined(__GNUC__)
X  /* old version - for people short of space */
X  /*
X  /* register char *np;
X***************
X*** 135,146 ****
X  	path = np + 1;
X      }
X      error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X! #endif /* TOS && __GNUC__ */
X  }
X  
X  int
X  uptodate(fd) {
X! #if defined(TOS) && !defined(__GNUC__) /* no fstat yet */
X      if(fstat(fd, &buf)) {
X  	pline("Cannot get status of saved level? ");
X  	return(0);
X--- 141,152 ----
X  	path = np + 1;
X      }
X      error("Cannot get status of %s.", (np = rindex(name, '/')) ? np+1 : name);
X! #  endif /* TOS && __GNUC__ */
X  }
X  
X  int
X  uptodate(fd) {
X! #  if defined(TOS) && !defined(__GNUC__) /* no fstat yet */
X      if(fstat(fd, &buf)) {
X  	pline("Cannot get status of saved level? ");
X  	return(0);
X***************
X*** 149,165 ****
X  	pline("Saved level is out of date. ");
X  	return(0);
X      }
X! #endif
X      return(1);
X  }
X! #endif /* MIN_TOS /* */
X  
X  void
X! regularize(s)	/* normalize file name - we don't like .'s, /'s, spaces */
X  register char *s;
X  {
X  	register char *lp;
X  
X! 	while((lp=index(s, '.')) || (lp=index(s, '/')) || (lp=index(s,' ')))
X  		*lp = '_';
X  }
X--- 155,177 ----
X  	pline("Saved level is out of date. ");
X  	return(0);
X      }
X! #  endif
X      return(1);
X  }
X! # endif	/* MACOS /* */
X! #endif /* OLD_TOS /* */
X  
X  void
X! regularize(s)
X! 	/* normalize file name - we don't like .'s, /'s, :'s [Mac], or spaces */
X  register char *s;
X  {
X  	register char *lp;
X  
X! 	while((lp=index(s, '.')) || (lp=index(s, '/')) || (lp=index(s,' '))
X! #ifdef MACOS
X! 			|| (lp=index(s, ':'))
X! #endif
X! 								)
X  		*lp = '_';
X  }
X
END_OF_FILE
if test 54981 -ne `wc -c <'patches05c'`; then
    echo shar: \"'patches05c'\" unpacked with wrong size!
fi
# end of 'patches05c'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
