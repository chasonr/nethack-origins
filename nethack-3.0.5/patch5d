Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i051:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch5d
Message-ID: <4702@tekred.CNA.TEK.COM>
Date: 17 Oct 89 20:26:05 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2283
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 51
Archive-name: NetHack3/Patch5d
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 6)."
# Contents:  patches05d
# Wrapped by billr@saab on Tue Oct 17 13:16:44 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches05d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches05d'\"
else
echo shar: Extracting \"'patches05d'\" \(56241 characters\)
sed "s/^X//" >'patches05d' <<'END_OF_FILE'
X*** src/Old/allmain.c	Sun Oct 15 18:28:13 1989
X--- src/allmain.c	Sat Oct 14 21:51:34 1989
X***************
X*** 22,27 ****
X--- 22,47 ----
X  #endif
X  
X  	for(;;) {
X+ #ifdef MACOS
X+ 	if (!(moves % 20)) {
X+ 		UnloadSeg(doapply);
X+ 		UnloadSeg(initedog);
X+ 		UnloadSeg(doeat);
X+ 		UnloadSeg(doengrave);
X+ 		UnloadSeg(doopen);
X+ 		UnloadSeg(mattacku);
X+ 		UnloadSeg(mklev);
X+ 		UnloadSeg(attacktype);
X+ 		UnloadSeg(dohelp);
X+ 		UnloadSeg(dopray);
X+ 		UnloadSeg(dorecover);
X+ 		UnloadSeg(timeout);
X+ 		UnloadSeg(setworn);
X+ 		UnloadSeg(initterm);
X+ 		UnloadSeg(done);
X+ 		UnloadSeg(savebones);
X+ 	}
X+ #endif
X  		if(flags.move) {	/* actual time passed */
X  
X  #ifdef SOUNDS
X***************
X*** 149,160 ****
X  					pushch(ch);
X  # endif /* REDO */
X  			}
X! 			if(abort || monster_nearby())
X  #else
X! 			if(monster_nearby())
X  #endif
X  				stop_occupation();
X! 			else if ((*occupation)() == 0)
X  				occupation = 0;
X  #ifdef MSDOS
X  			if (!(++occtime % 7))
X--- 169,181 ----
X  					pushch(ch);
X  # endif /* REDO */
X  			}
X! 			if(abort || monster_nearby()) {
X  #else
X! 			if(monster_nearby()) {
X  #endif
X  				stop_occupation();
X! 				reset_eat();
X! 			} else if ((*occupation)() == 0)
X  				occupation = 0;
X  #ifdef MSDOS
X  			if (!(++occtime % 7))
X*** src/Old/apply.c	Sun Oct 15 18:28:44 1989
X--- src/apply.c	Sat Oct 14 19:20:37 1989
X***************
X*** 601,607 ****
X  				u.utraptype = 0;
X  			    }
X  			    unsee();
X! 			    goto_level(dlevel+1, FALSE);
X  #ifdef WALKIES
X  			}
X  #endif
X--- 601,607 ----
X  				u.utraptype = 0;
X  			    }
X  			    unsee();
X! 			    goto_level(dlevel+1, FALSE, TRUE);
X  #ifdef WALKIES
X  			}
X  #endif
X***************
X*** 1111,1116 ****
X--- 1111,1120 ----
X  	 * moves, we've got to deal with decaying corpses...
X  	 */
X  	if (!(corpse = floorfood("can", 1))) return;
X+ 	if (corpse->oeaten) {
X+ 		pline("You cannot tin something which is partly eaten.");
X+ 		return;
X+ 	}
X  	if ((corpse->corpsenm == PM_COCKATRICE)
X  #ifdef POLYSELF
X  		&& !resists_ston(uasmon)
X*** src/Old/bones.c	Sun Oct 15 18:29:52 1989
X--- src/bones.c	Sat Oct 14 21:54:44 1989
X***************
X*** 230,236 ****
X--- 230,258 ----
X  #ifdef MSDOS
X  	fd = open(bones, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X  #else
X+ # ifdef MACOS
X+ 	{
X+ 		Str255	fileName;
X+ 		OSErr	er;
X+ 		struct term_info	*t;
X+ 		extern WindowPtr	HackWindow;
X+ 		short	oldvolume;
X+ 		
X+ 		t = (term_info *)GetWRefCon(HackWindow);
X+ 		(void)GetVol(&fileName,&oldvolume);
X+ 		(void)SetVol(0L, t->system.sysVRefNum);
X+ 		fileName[0] = (uchar)strlen(bones);
X+ 		(void)strcpy((char *)&fileName[1],bones);
X+ 		
X+ 		if (er = Create(&fileName,0,CREATOR,BONES_TYPE))
X+ 			SysBeep(1);
X+ 		fd = open(bones,
X+ 			O_WRONLY | O_BINARY | O_TRUNC | ((er) ? O_CREAT : 0));
X+ 		(void)SetVol(0L, oldvolume);
X+ 	}
X+ # else
X  	fd = creat(bones, FCMASK);
X+ # endif /* MACOS */
X  #endif
X  	if(fd < 0) {
X  #ifdef WIZARD
X*** src/Old/decl.c	Sun Oct 15 18:30:46 1989
X--- src/decl.c	Sun Oct 15 12:05:32 1989
X***************
X*** 60,66 ****
X--- 60,70 ----
X  #  endif
X  #endif
X  
X+ #ifdef SMALLDATA
X+ char *occtxt = 0;
X+ #else
X  char *occtxt = DUMMY;
X+ #endif
X  const char quitchars[] = " \r\n\033";
X  const char vowels[] = "aeiouAEIOU";
X  const char ynchars[] = "yn";
X***************
X*** 67,80 ****
X  const char ynqchars[] = "ynq";
X  const char ynaqchars[] = "ynaq";
X  const char nyaqchars[] = "nyaq";
X  char *HI = DUMMY, *HE = DUMMY, *AS = DUMMY, *AE = DUMMY, *CD = DUMMY;
X  	/* set up in termcap.c */
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X  #ifdef TEXTCOLOR
X  char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X  #endif
X- 
X  #ifdef MSDOS
X  char hackdir[PATHLEN];		/* where rumors, help, record are */
X  const char *configfile = "NetHack.cnf";	/* read by read_config_file() */
X--- 71,89 ----
X  const char ynqchars[] = "ynq";
X  const char ynaqchars[] = "ynaq";
X  const char nyaqchars[] = "nyaq";
X+ 
X+ #ifdef SMALLDATA
X+ char *HI = 0, *HE = 0, *AS = 0, *AE = 0, *CD = 0;
X+ 	/* set up in termcap.c */
X+ #else
X  char *HI = DUMMY, *HE = DUMMY, *AS = DUMMY, *AE = DUMMY, *CD = DUMMY;
X  	/* set up in termcap.c */
X+ #endif
X  int CO = 0, LI = 0;	/* set up in termcap.c: usually COLNO and ROWNO+3 */
X  
X  #ifdef TEXTCOLOR
X  char *hilites[MAXCOLORS];	/* terminal escapes for the various colors */
X  #endif
X  #ifdef MSDOS
X  char hackdir[PATHLEN];		/* where rumors, help, record are */
X  const char *configfile = "NetHack.cnf";	/* read by read_config_file() */
X***************
X*** 129,135 ****
X  coord doors[DOORMAX] = DUMMY;
X  
X  struct mkroom rooms[MAXNROFROOMS+1] = DUMMY;
X! level_t level;		/* level map */
X  struct trap *ftrap = 0;
X  struct gold *fgold = 0;
X  struct monst youmonst = DUMMY;	/* dummy; used as return value for boomhit */
X--- 138,144 ----
X  coord doors[DOORMAX] = DUMMY;
X  
X  struct mkroom rooms[MAXNROFROOMS+1] = DUMMY;
X! dlevel_t level;		/* level map */
X  struct trap *ftrap = 0;
X  struct gold *fgold = 0;
X  struct monst youmonst = DUMMY;	/* dummy; used as return value for boomhit */
X***************
X*** 196,202 ****
X--- 205,215 ----
X  
X  struct obj *billobjs = 0;
X  
X+ #ifdef THINK_C
X+ const char Black[] = "black";
X+ #else
X  const char black[] = "black";
X+ #endif
X  const char amber[] = "amber";
X  #ifdef THEOLOGY
X  const char golden[] = "golden";
X***************
X*** 207,213 ****
X--- 220,230 ----
X  const char silver[] = "silver";
X  const char blue[] = "blue";
X  const char purple[] = "purple";
X+ #ifdef THINK_C
X+ const char White[] = "white";
X+ #else
X  const char white[] = "white";
X+ #endif
X  
X  const char nothing_happens[] = "Nothing happens.";
X  const char thats_enough_tries[] = "That's enough tries!";
X*** src/Old/do.c	Sun Oct 15 18:31:17 1989
X--- src/do.c	Sun Oct 15 17:25:04 1989
X***************
X*** 246,265 ****
X  register char *word;
X  {
X  	if(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)){
X! 		You("cannot %s something you are wearing.",word);
X  		return(FALSE);
X  	}
X  	if (obj->otyp == LOADSTONE && obj->cursed) {
X  		obj->bknown = 1;
X! 		pline("For some reason, you cannot %s the stone%s!",
X! 			word,
X! 			plur((long)obj->quan));
X  		return(FALSE);
X  	}
X  #ifdef WALKIES
X  	if (obj->otyp == LEASH && obj->leashmon != 0) {
X! 		pline ("The leash is tied around your %s.",
X! 			body_part(HAND));
X  		return(FALSE);
X  	}
X  #endif
X--- 246,268 ----
X  register char *word;
X  {
X  	if(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)){
X! 	       if (*word)
X! 			You("cannot %s something you are wearing.",word);
X  		return(FALSE);
X  	}
X  	if (obj->otyp == LOADSTONE && obj->cursed) {
X  		obj->bknown = 1;
X! 		if (*word)
X! 			pline("For some reason, you cannot %s the stone%s!",
X! 				word,
X! 		      		plur((long)obj->quan));
X  		return(FALSE);
X  	}
X  #ifdef WALKIES
X  	if (obj->otyp == LEASH && obj->leashmon != 0) {
X! 	       if (*word)
X! 			pline ("The leash is tied around your %s.",
X! 					body_part(HAND));
X  		return(FALSE);
X  	}
X  #endif
X***************
X*** 412,418 ****
X  #endif
X  		if (trap)
X  			pline("You jump into the trapdoor...");
X! 		goto_level(dlevel+1, !trap);
X  #ifdef STRONGHOLD
X  		at_ladder = FALSE;
X  #endif
X--- 415,421 ----
X  #endif
X  		if (trap)
X  			pline("You jump into the trapdoor...");
X! 		goto_level(dlevel+1, !trap, TRUE);
X  #ifdef STRONGHOLD
X  		at_ladder = FALSE;
X  #endif
X***************
X*** 473,482 ****
X  		if (levl[u.ux][u.uy].typ == LADDER) at_ladder = TRUE;
X  		goto_level(dlevel-1, 
X  		    (dlevel-1 < stronghold_level || (at_ladder && 
X! 		       dlevel-1 >= tower_level && dlevel-1 < tower_level+2)));
X  		at_ladder = FALSE;
X  #else
X! 		goto_level(dlevel-1, (dlevel-1 <= medusa_level));
X  #endif
X  #ifdef WALKIES
X  	}
X--- 476,486 ----
X  		if (levl[u.ux][u.uy].typ == LADDER) at_ladder = TRUE;
X  		goto_level(dlevel-1, 
X  		    (dlevel-1 < stronghold_level || (at_ladder && 
X! 		       dlevel-1 >= tower_level && dlevel-1 < tower_level+2)),
X! 			   FALSE);
X  		at_ladder = FALSE;
X  #else
X! 		goto_level(dlevel-1, (dlevel-1 <= medusa_level), FALSE);
X  #endif
X  #ifdef WALKIES
X  	}
X***************
X*** 484,496 ****
X  	return(1);
X  }
X  
X  void
X! goto_level(newlevel, at_stairs)
X  register int newlevel;
X! register boolean at_stairs;
X  {
X  	register int fd;
X  	register boolean up = (newlevel < dlevel);
X  
X  #ifdef ENDGAME
X  	if(dlevel == ENDLEVEL) return;	/* To be on the safe side.. */
X--- 488,569 ----
X  	return(1);
X  }
X  
X+ 
X+ static void
X+ litter()
X+ {
X+ 	struct obj *otmp = invent, *nextobj;
X+ 	int capacity = weight_cap();
X+ 
X+ 	while (otmp) {
X+ 		nextobj = otmp->nobj;
X+ 		if ((otmp != uball) && (rnd(capacity) <= otmp->owt)) {
X+ 			if (otmp == uwep)
X+ 				setuwep((struct obj *)0);
X+ 			if ((otmp != uwep) && (canletgo(otmp, ""))) {
X+ 				Your("%s left behind on the stairs.",
X+ 				     aobjnam(otmp, "get"));
X+ 				dropx(otmp);
X+ 			}
X+ 		}
X+ 		otmp = nextobj;
X+ 	}
X+ }
X+ 
X+ boolean
X+ drag_down()
X+ {
X+ 	boolean forward;
X+ 	uchar dragchance = 3;
X+ 
X+ 
X+ 	/* 
X+ 		Assume that the ball falls forward if:
X+ 
X+ 		a) the character is wielding it, or
X+ 		b) the character has both hands available to hold it (i.e. is 
X+ 		   not wielding any weapon), or 
X+ 		c) (perhaps) it falls forward out of his non-weapon hand
X+ 	*/
X+ 
X+ 	forward = (!(carried(uball))? 
X+ 		  FALSE : ((uwep == uball) || (!uwep))? 
X+ 			  TRUE : (boolean)(rn2(3) / 2));
X+ 
X+ 	if (carried(uball)) 
X+ 		You("lose your grip on the iron ball.");
X+ 
X+ 	if(forward) {
X+ 		if(rn2(6)) {
X+ 			You("get dragged downstairs by the iron ball.");
X+ 			losehp(rnd(6), "iron ball accident");
X+ 			return(TRUE);
X+ 		}
X+ 	} else {
X+ 		if(rn2(2)) {
X+ 			pline("The iron ball smacks into you!");
X+ 			losehp(rnd(20), "iron ball collision");
X+ 			dragchance -= 2;
X+ 		} 
X+ 		if(dragchance >= rnd(6)) {
X+ 			You("get dragged downstairs by the iron ball.");
X+ 			losehp(rnd(3), "iron ball accident");
X+ 			return(TRUE);
X+ 		}
X+ 	}
X+ 	return(FALSE);
X+ }
X+ 
X  void
X! goto_level(newlevel, at_stairs, falling)
X  register int newlevel;
X! register boolean at_stairs, falling;
X  {
X  	register int fd;
X  	register boolean up = (newlevel < dlevel);
X+ 	boolean stair_fall = (at_stairs && !up && ((inv_weight() + 5 > 0) || 
X+ 						  Punished || Fumbling));
X+ 	boolean stair_drag = FALSE;
X  
X  #ifdef ENDGAME
X  	if(dlevel == ENDLEVEL) return;	/* To be on the safe side.. */
X***************
X*** 560,566 ****
X--- 633,663 ----
X  	 */
X  	fd = open(lock, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X  #else
X+ # ifdef MACOS
X+ 	{
X+ 		Str255	fileName;
X+ 		OSErr	er;
X+ 		short	refNum;
X+ 		struct term_info	*t;
X+ 		extern WindowPtr	HackWindow;
X+ 		
X+ 		t = (term_info *)GetWRefCon(HackWindow);
X+ 		fileName[0] = (char)strlen(lock);
X+ 		(void)Strcpy((char *)&fileName[1],lock);
X+ 		if (FSOpen(fileName, t->system.sysVRefNum, &refNum)) {
X+ 				if (er = Create(&fileName,t->system.sysVRefNum,
X+ 							CREATOR,LEVEL_TYPE))
X+ 					SysBeep(1);
X+ 		} else {
X+ 			(void)SetEOF(refNum,0L);
X+ 			(void)FSClose(refNum);
X+ 		}
X+ 		SetVol(0L,t->system.sysVRefNum);
X+ 		fd = open(lock,O_WRONLY | O_BINARY | ((er) ? O_CREAT : 0));
X+ 	}
X+ # else
X  	fd = creat(lock, FCMASK);
X+ # endif /* MACOS */
X  #endif
X  	if(fd < 0) {
X  		/*
X***************
X*** 592,597 ****
X--- 689,702 ----
X  	}
X  #endif
X  	if(Punished) unplacebc();
X+ 	if (stair_fall) {
X+ #ifdef STRONGHOLD
X+ 			You("fall down the %s.",
X+ 			    !at_ladder ? "stairs" : "ladder");
X+ #else
X+ 		You("fall down the stairs.");
X+ #endif
X+ 	}
X  	u.utrap = 0;				/* needed in level_tele */
X  	u.ustuck = 0;				/* idem */
X  	keepdogs();
X***************
X*** 646,652 ****
X  		if (fileinfo[dlevel].where != ACTIVE)
X  			swapin_file(dlevel);
X  #endif
X! #if defined(MSDOS) && !defined(TOS)
X  		if((fd = open(lock, O_RDONLY | O_BINARY)) < 0) {
X  #else
X  		if((fd = open(lock,0)) < 0) {
X--- 751,757 ----
X  		if (fileinfo[dlevel].where != ACTIVE)
X  			swapin_file(dlevel);
X  #endif
X! #if (defined(MSDOS) && !defined(TOS)) || defined(MACOS)
X  		if((fd = open(lock, O_RDONLY | O_BINARY)) < 0) {
X  #else
X  		if((fd = open(lock,0)) < 0) {
X***************
X*** 701,721 ****
X  		    u.uy = yupladder;
X  		}
X  #endif
X! 		if(inv_weight() + 5 > 0 || Punished || Fumbling) {
X! #ifdef STRONGHOLD
X! 			You("fall down the %s.",
X! 			      !at_ladder ? "stairs" : "ladder");
X! #else
X! 			You("fall down the stairs.");
X! #endif
X  			losehp(rnd(3), "fall");
X- 			if(Punished) {
X- 			    if(uwep != uball && rn2(3)) {
X- 				pline("... and are hit by the iron ball.");
X- 				losehp(rnd(20), "iron ball");
X- 			    }
X- 			    placebc(1);
X- 			}
X  			selftouch("Falling, you");
X  		}
X  	    }
X--- 806,824 ----
X  		    u.uy = yupladder;
X  		}
X  #endif
X! 		if(stair_fall) {
X! 			if (Punished) {
X! 				if (stair_drag)
X! 					litter();
X! 				if (carried(uball)) {
X! 					if (uwep == uball)
X! 						setuwep((struct obj *)0);
X! 					if (uwep != uball)
X! 						freeinv(uball);
X! 				}
X! 				placebc(1);
X! 			} 
X  			losehp(rnd(3), "fall");
X  			selftouch("Falling, you");
X  		}
X  	    }
X***************
X*** 743,759 ****
X  		     levl[u.ux][u.uy].typ != CORR) || MON_AT(u.ux, u.uy));
X  	    if(tryct >= 100)
X  		panic("goto_level: could not relocate player!");
X! 	    if(Punished){
X! 		if(uwep != uball && !up /* %% */ && rn2(5)){
X! 			pline("The iron ball falls on your %s.",
X! 				body_part(HEAD));
X! 			if (uarmh)
X! 				Your("helmet doesn't help too much...");
X! 			losehp(rnd(25), "iron ball");
X  		}
X  		placebc(1);
X  	    }
X! 	    selftouch("Falling, you");
X  	}
X  	(void) inshop();
X  	initrack();
X--- 846,875 ----
X  		     levl[u.ux][u.uy].typ != CORR) || MON_AT(u.ux, u.uy));
X  	    if(tryct >= 100)
X  		panic("goto_level: could not relocate player!");
X! 	    if(Punished) {
X! 		if(falling) {
X! 			boolean gets_hit;
X! 
X! 			gets_hit = (uwep == uball)? FALSE : (boolean)rn2(5);
X! 			if (carried(uball)) {
X! 				pline("Startled, you drop the iron ball.");
X! 				if (uwep == uball)
X! 					setuwep((struct obj *)0);
X! 				if (uwep != uball)
X! 					freeinv(uball);
X! 			} 
X! 			if(gets_hit){
X! 					pline("The iron ball falls on your %s.",
X! 					body_part(HEAD));
X! 				if (uarmh)
X! 					Your("helmet doesn't help too much...");
X! 				losehp(rnd(25), "iron ball");
X! 			}
X  		}
X  		placebc(1);
X  	    }
X! 	    if(falling)
X! 		selftouch("Falling, you");
X  	}
X  	(void) inshop();
X  	initrack();
X*** src/Old/do_name.c	Sun Oct 15 18:31:51 1989
X--- src/do_name.c	Wed Oct 11 17:14:47 1989
X***************
X*** 189,196 ****
X  #endif
X  	if(lth) Strcpy(ONAME(otmp2), buf);
X  
X! 	setworn((struct obj *)0, obj->owornmask);
X! 	setworn(otmp2, otmp2->owornmask);
X  
X  	if (ininv) {
X  		/* do freeinv(obj); etc. by hand in order to preserve
X--- 189,201 ----
X  #endif
X  	if(lth) Strcpy(ONAME(otmp2), buf);
X  
X! 	if (obj->owornmask) {
X! 		/* Note: dying by burning in Hell causes problems if you
X! 		 * try doing this when owornmask isn't set.
X! 		 */
X! 		setworn((struct obj *)0, obj->owornmask);
X! 		setworn(otmp2, otmp2->owornmask);
X! 	}
X  
X  	if (ininv) {
X  		/* do freeinv(obj); etc. by hand in order to preserve
X***************
X*** 401,406 ****
X--- 406,432 ----
X  
X  	if(!strncmp(bp, "the ", 4)) bp += 4;
X  	Sprintf(buf, "the %s %s", adj, bp);
X+ 	return(buf);
X+ }
X+ 
X+ /* sometimes we don't want an article in front of definite names */
X+ 
X+ char *
X+ a2_monnam(mtmp,adj)
X+ register struct monst *mtmp;
X+ register char *adj;
X+ {
X+ 	register char *bp = mon_nam(mtmp);
X+ #ifdef LINT	/* static char buf[BUFSZ]; */
X+ 	char buf[BUFSZ];
X+ #else
X+ 	static char buf[BUFSZ];
X+ #endif
X+ 
X+ 	if(!strncmp(bp, "the ", 4))
X+ 		Sprintf(buf, "the %s %s", adj, bp+4);
X+ 	else
X+ 		Sprintf(buf, "%s %s", adj, bp);
X  	return(buf);
X  }
X  
X*** src/Old/do_wear.c	Sun Oct 15 18:32:16 1989
X--- src/do_wear.c	Thu Oct  5 16:24:40 1989
X***************
X*** 1152,1160 ****
X  #ifdef HARD
X  	boolean leftfall, rightfall;
X  
X! 	leftfall = (uleft && !uleft->cursed && (!uwep || !uwep->cursed));
X! 	rightfall = (uright && !uright->cursed && (!uwep || !uwep->cursed
X  		|| !bimanual(uwep)));
X  #else
X  #define leftfall uleft
X  #define rightfall uright
X--- 1152,1160 ----
X  #ifdef HARD
X  	boolean leftfall, rightfall;
X  
X! 	leftfall = (uleft && !uleft->cursed && (!uwep || !uwep->cursed
X  		|| !bimanual(uwep)));
X+ 	rightfall = (uright && !uright->cursed && (!uwep || !uwep->cursed));
X  #else
X  #define leftfall uleft
X  #define rightfall uright
X*** src/Old/dogmove.c	Sun Oct 15 18:33:08 1989
X--- src/dogmove.c	Wed Oct 11 18:22:36 1989
X***************
X*** 261,272 ****
X  			niy = ny;
X  			chi = i;
X  		     eatobj:
X- 			mtmp->meating =
X- 			    obj->quan * objects[obj->otyp].oc_delay;
X  			if(EDOG(mtmp)->hungrytime < moves)
X  			    EDOG(mtmp)->hungrytime = moves;
X! 			EDOG(mtmp)->hungrytime +=
X! 			    5*obj->quan * objects[obj->otyp].nutrition;
X  			mtmp->mconf = 0;
X  			if (mtmp->mtame < 20) mtmp->mtame++;
X  			if(cansee(nix,niy))
X--- 261,291 ----
X  			niy = ny;
X  			chi = i;
X  		     eatobj:
X  			if(EDOG(mtmp)->hungrytime < moves)
X  			    EDOG(mtmp)->hungrytime = moves;
X! 			/* Note: to get the correct percentage-eaten in case
X! 			 * oeaten is set, use "obj->owt / obj->quan /
X! 			 * base-weight".  It so happens that here we want to
X! 			 * multiply by obj->quan, which thus cancels out.
X! 			 * It is arbitrary that the pet takes the same length
X! 			 * of time to eat as a human, but gets 5X as much
X! 			 * nutrition.
X! 			 */
X! 			if(obj->otyp == CORPSE) {
X! 			    mtmp->meating =
X! 				(3 + (mons[obj->corpsenm].cwt >> 2))
X! 				* obj->owt / mons[obj->corpsenm].cwt;
X! 			    EDOG(mtmp)->hungrytime += 5 * 
X! 				mons[obj->corpsenm].cnutrit
X! 				* obj->owt / mons[obj->corpsenm].cwt;
X! 			} else {
X! 			    mtmp->meating =
X! 				objects[obj->otyp].oc_delay
X! 				* obj->owt / objects[obj->otyp].oc_weight;
X! 			    EDOG(mtmp)->hungrytime += 5 *
X! 				objects[obj->otyp].nutrition
X! 				* obj->owt / objects[obj->otyp].oc_weight;
X! 			}
X  			mtmp->mconf = 0;
X  			if (mtmp->mtame < 20) mtmp->mtame++;
X  			if(cansee(nix,niy))
X*** src/Old/eat.c	Sun Oct 15 18:34:06 1989
X--- src/eat.c	Thu Oct 12 17:45:45 1989
X***************
X*** 3,10 ****
X--- 3,15 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  #include	"hack.h"
X+ /*#define DEBUG 	/* uncomment to enable new eat code debugging */
X  
X+ static int fpostfx P((struct obj *));
X+ static int cpostfx P((int));
X+ 
X  char corpsename[60];
X+ char msgbuf[BUFSZ];
X  
X  /* hunger texts used on bottom line (each 8 chars long) */
X  #define	SATIATED	0
X***************
X*** 27,32 ****
X--- 32,57 ----
X  
X  static const char comestibles[] = { FOOD_SYM, 0 };
X  
X+ /* calculate x/y, rounding as appropriate */
X+ 
X+ static int
X+ rounddiv(x, y)
X+ int x, y;
X+ {
X+ 	int divsgn;
X+ 	int r, m;
X+ 
X+ 	if (y == 0)
X+ 		panic("division by zero in rounddiv");
X+ 	divsgn = (x*y > 0) ? 1 : -1;
X+ 	x = abs(x); y = abs(y);
X+ 	r = x/y;
X+ 	m = x%y;
X+ 	if (2*m >= y)
X+ 		r++;
X+ 	return divsgn*r;
X+ }
X+ 
X  void
X  init_uhunger(){
X  	u.uhunger = 900;
X***************
X*** 44,55 ****
X  #define	TTSZ	SIZE(tintxts)
X  
X  static struct {
X! 	struct obj *tin;
X! 	int usedtime, reqtime;
X  } tin;
X  
X  static int
X! Meatdone() {
X  	u.usym =
X  #ifdef POLYSELF
X  		u.mtimedone ? uasmon->mlet :
X--- 69,94 ----
X  #define	TTSZ	SIZE(tintxts)
X  
X  static struct {
X! 	struct	obj *tin;
X! 	int	usedtime, reqtime;
X  } tin;
X  
X+ static struct {
X+ 	struct	obj *piece;	/* the thing being eaten, or last thing that
X+ 				 * was partially eaten, unless that thing was
X+ 				 * a tin, which uses the tin structure above */
X+ 	int	usedtime,	/* turns spent eating */
X+ 		reqtime;	/* turns required to eat */
X+ 	int	nutrit,		/* total nutrition at beginning */
X+ 		nmod;		/* coded nutrition per turn */
X+ 	Bitfield(canchoke,1);	/* was satiated at beginning */
X+ 	Bitfield(fullwarn,1);	/* have warned about being full */
X+ 	Bitfield(eating,1);	/* victual currently being eaten */
X+ 	Bitfield(doreset,1);	/* stop eating at end of turn */
X+ } victual;
X+ 
X  static int
X! Meatdone() {		/* called after mimicing is over */
X  	u.usym =
X  #ifdef POLYSELF
X  		u.mtimedone ? uasmon->mlet :
X***************
X*** 59,70 ****
X  	return 0;
X  }
X  
X  static int
X! corpsefx(pm)
X  register int pm;
X  {
X- 	register int tmp = 0, tp = 0;
X- 
X  	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X  		You("cannibal!  You will be sorry for this!");
X  		Aggravate_monster |= INTRINSIC;
X--- 98,247 ----
X  	return 0;
X  }
X  
X+ /* Created by GAN 01/28/87
X+  * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X+  * Amended by 3.  06/12/89: if not hard, sometimes choke anyway, to keep risk.
X+  */
X+ /*ARGSUSED*/
X+ static void
X+ choke(food)
X+ 	register struct obj *food;
X+ {
X+ 	/* only happens if you were satiated */
X+ 	if(u.uhs != SATIATED) return;
X+ 
X+ 	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL)
X+ 		u.ualign--;	/* gluttony is unchivalrous */
X+ 
X+ #ifndef HARD
X+ 	if (rn2(20)) {
X+ 		You("stuff yourself and then vomit voluminously.");
X+ 		morehungry(1000);	/* you just got *very* sick! */
X+ 		vomit();
X+ 	} else {
X+ #endif
X+ 		if(food) {
X+ 			killer = singular(food);
X+ 		} else
X+ 			killer = "exuberant appetite";
X+ 		You("choke over your food.");
X+ 		You("die...");
X+ 		done(CHOKING);
X+ #ifndef HARD
X+ 	}
X+ #endif
X+ }
X+ 
X+ static void
X+ recalc_wt() {	/* modify object wt. depending on time spent consuming it */
X+ 	int baseweight = weight(victual.piece);	/* weight of full item */
X+ 
X+ #ifdef DEBUG
X+ 	pline("Old weight = %d", victual.piece->owt);
X+ 	pline("Used time = %d, Req'd time = %d",
X+ 		victual.usedtime, victual.reqtime);
X+ #endif
X+ 	if(victual.usedtime)
X+ 	    victual.piece->owt = (unsigned)rounddiv(
X+ 			    baseweight * (victual.reqtime - victual.usedtime),
X+ 			    victual.reqtime );
X+ #ifdef DEBUG
X+ 	pline("New weight = %d", victual.piece->owt);
X+ #endif
X+ }
X+ 
X+ void
X+ reset_eat() {		/* called when eating interrupted by an event */
X+ 
X+     /* we only set a flag here - the actual reset process is done after
X+      * the round is spent eating.
X+      */
X+ 	if(victual.eating && !victual.doreset) {
X+ #ifdef DEBUG
X+ 	    pline("reset_eat...");
X+ #endif
X+ 	    victual.doreset = TRUE;
X+ 	}
X+ 	return;
X+ }
X+ 
X+ static struct obj *
X+ touchfood(otmp)
X+ register struct obj *otmp;
X+ {
X+ 	if(otmp->quan > 1) {
X+ 
X+ 	    otmp = splitobj(otmp, (int)otmp->quan-1);
X+ #ifdef DEBUG
X+ 	    pline("split object,");
X+ #endif
X+ 
X+ 	    otmp->oeaten = TRUE;
X+ 	    if(carried(otmp)) {
X+ 		freeinv(otmp);
X+ 		if(inv_cnt() >= 52)
X+ 		    dropy(otmp);
X+ 		else
X+ 		    otmp = addinv(otmp); /* unlikely but a merge is possible */
X+ 	    }
X+ 	} else
X+ 	    otmp->oeaten = TRUE;
X+ 	return(otmp);
X+ }
X+ 
X+ static void
X+ do_reset_eat() {
X+ 
X+ #ifdef DEBUG
X+ 	pline("do_reset_eat...");
X+ #endif
X+ 	victual.piece = touchfood(victual.piece);
X+ 	recalc_wt();
X+ 	victual.fullwarn = victual.eating = victual.doreset = 
X+ 		victual.canchoke = FALSE;
X+ 	stop_occupation();
X+ }
X+ 
X  static int
X! eatfood() {		/* called each move during eating process */
X! 
X! 	if(!victual.eating) return(0);
X! 	if(victual.usedtime++ < victual.reqtime) {
X! 	/* You can only choke if you were satiated before you started
X! 	 * eating.
X! 	 */
X! 	    if(victual.canchoke && u.uhunger >= 2000) choke(victual.piece);
X! 
X! 	    if(victual.nmod < 0)
X! 		lesshungry(-victual.nmod);
X! 	    else if(victual.nmod > 0 && (victual.usedtime % victual.nmod))
X! 		lesshungry(1);
X! 
X! 	    if(victual.doreset) do_reset_eat();
X! 	    return 1;	/* still busy */
X! 	} else {	/* done */
X! 
X! 	    register int tp;
X! 
X! 	    if(victual.piece->otyp == CORPSE)
X! 		tp = cpostfx(victual.piece->corpsenm);
X! 	    else
X! 		tp = fpostfx(victual.piece);
X! 
X! 	    You("finish eating the %s.", singular(victual.piece));
X! 
X! 	    useup(victual.piece);
X! 	    victual.piece = (struct obj *) 0;
X! 	    victual.fullwarn = victual.eating = victual.doreset = 
X! 		victual.canchoke = FALSE;
X! 	    return(tp);
X! 	}
X! }
X! 
X! static void
X! cprefx(pm)		/* called at the "first bite" of a corpse */
X  register int pm;
X  {
X  	if ((pl_character[0]=='E') ? is_elf(&mons[pm]) : is_human(&mons[pm])) {
X  		You("cannibal!  You will be sorry for this!");
X  		Aggravate_monster |= INTRINSIC;
X***************
X*** 71,76 ****
X--- 248,293 ----
X  	}
X  
X  	switch(pm) {
X+ 	    case PM_LITTLE_DOG:
X+ 	    case PM_DOG:
X+ 	    case PM_LARGE_DOG:
X+ 	    case PM_KITTEN:
X+ 	    case PM_HOUSECAT:
X+ 	    case PM_LARGE_CAT:
X+ 		Aggravate_monster |= INTRINSIC;
X+ 		break;
X+ 	    case PM_COCKATRICE:
X+ #ifdef MEDUSA
X+ 	    case PM_MEDUSA:
X+ #endif
X+ #ifdef POLYSELF
X+ 		if(!resists_ston(uasmon)) {
X+ #endif
X+ 			killer = (char *) alloc(40);
X+ 			You("turn to stone.");
X+ 			Sprintf(killer, "%s meat", mons[pm].mname);
X+ 			done(STONING);
X+ #ifdef POLYSELF
X+ 		}
X+ 		break;
X+ 	    default:
X+ 
X+ 		if(dmgtype(&mons[pm], AD_ACID) && Stoned) {
X+ 		    pline("What a pity - you just destroyed a future piece of art!");
X+ 		    Stoned = 0;
X+ 		}
X+ #endif
X+ 	}
X+ 	return;
X+ }
X+ 
X+ static int
X+ cpostfx(pm)		/* called after completely consuming a corpse */
X+ register int pm;
X+ {
X+ 	register int tmp = 0, tp = 0;
X+ 
X+ 	switch(pm) {
X  	    case PM_WRAITH:
X  		pluslvl();
X  		break;
X***************
X*** 89,102 ****
X  		u.uhp = u.uhpmax;
X  		flags.botl = 1;
X  		break;
X- 	    case PM_LITTLE_DOG:
X- 	    case PM_DOG:
X- 	    case PM_LARGE_DOG:
X- 	    case PM_KITTEN:
X- 	    case PM_HOUSECAT:
X- 	    case PM_LARGE_CAT:
X- 		Aggravate_monster |= INTRINSIC;
X- 		break;
X  	    case PM_STALKER:
X  		if(!Invis) {
X  			HInvis = 50+rn2(100);
X--- 306,311 ----
X***************
X*** 103,109 ****
X  			if(!See_invisible)
X  				newsym(u.ux, u.uy);
X  		} else {
X! 			if (!HInvis) You("feel hidden!");
X  			HInvis |= INTRINSIC;
X  			HSee_invisible |= INTRINSIC;
X  		}
X--- 312,318 ----
X  			if(!See_invisible)
X  				newsym(u.ux, u.uy);
X  		} else {
X! 			if (!(HInvis & INTRINSIC)) You("feel hidden!");
X  			HInvis |= INTRINSIC;
X  			HSee_invisible |= INTRINSIC;
X  		}
X***************
X*** 116,137 ****
X  	    case PM_BAT:
X  		make_stunned(HStun + 30,FALSE);
X  		break;
X- 	    case PM_COCKATRICE:
X- #ifdef MEDUSA
X- 	    case PM_MEDUSA:
X- #endif
X- #ifdef POLYSELF
X- 		if(!resists_ston(uasmon)) {
X- #endif
X- 			killer = (char *) alloc(40);
X- 			You("turn to stone.");
X- 			Sprintf(killer, "%s meat",
X- 				      mons[pm].mname);
X- 			done(STONING);
X- #ifdef POLYSELF
X- 		}
X- #endif
X- 		break;
X  	    case PM_GIANT_MIMIC:
X  		tmp += 10;
X  		/* fall into next case */
X--- 325,330 ----
X***************
X*** 142,151 ****
X  		tmp += 20;
X  		if(u.usym == S_HUMAN) {
X  		    You("cannot resist the temptation to mimic a treasure chest.");
X- 		    tp++;
X  		    nomul(tmp);
X  		    afternmv = Meatdone;
X! 		    nomovemsg = "You now again prefer mimicking a human.";
X  		    u.usym = GOLD_SYM;
X  		    prme();
X  		}
X--- 335,347 ----
X  		tmp += 20;
X  		if(u.usym == S_HUMAN) {
X  		    You("cannot resist the temptation to mimic a treasure chest.");
X  		    nomul(tmp);
X+ 		    tp++;
X  		    afternmv = Meatdone;
X! 		    if (pl_character[0]=='E')
X! 			nomovemsg = "You now again prefer mimicking an elf.";
X! 		    else
X! 			nomovemsg = "You now again prefer mimicking a human.";
X  		    u.usym = GOLD_SYM;
X  		    prme();
X  		}
X***************
X*** 179,191 ****
X  		    pline ("Oh wow!  Great stuff!");
X  		    make_hallucinated(Hallucination + 200,FALSE);
X  		}
X- 		if(dmgtype(ptr, AD_ACID)) {
X- 		  if(Stoned) {
X- 			pline("What a pity - you just destroyed a future piece of art!");
X- 			tp++;
X- 			Stoned = 0;
X- 		  }
X- 		}
X  		if(is_giant(ptr)) gainstr((struct obj *)0, 0);
X  
X  		if(can_teleport(ptr) && ptr->mlevel > rn2(10)) {
X--- 375,380 ----
X***************
X*** 242,248 ****
X  }
X  
X  static int
X! opentin(){
X  	register int r;
X  
X  	if(!carried(tin.tin))		/* perhaps it was stolen? */
X--- 431,437 ----
X  }
X  
X  static int
X! opentin() {		/* called during each move whilst opening a tin */
X  	register int r;
X  
X  	if(!carried(tin.tin))		/* perhaps it was stolen? */
X***************
X*** 278,290 ****
X  	    You("consume %s %s.", tintxts[r].txt,
X  		  mons[tin.tin->corpsenm].mname);
X  	    tin.tin->dknown = tin.tin->known = TRUE;
X! 	    (void) corpsefx(tin.tin->corpsenm);
X  	    /* check for vomiting added by GAN 01/16/87 */
X! 	    if(tintxts[r].nut < 0) {
X! 		You("vomit.");
X! 		vomit();
X! 		morehungry(-tintxts[r].nut);
X! 	    } else lesshungry(tintxts[r].nut);
X  	    if(r == 0) {			/* Deep Fried */
X  		Glib = rnd(15);
X  		pline("Eating deep fried food made your %s very slippery.",
X--- 467,478 ----
X  	    You("consume %s %s.", tintxts[r].txt,
X  		  mons[tin.tin->corpsenm].mname);
X  	    tin.tin->dknown = tin.tin->known = TRUE;
X! 	    cprefx(tin.tin->corpsenm); (void) cpostfx(tin.tin->corpsenm);
X! 
X  	    /* check for vomiting added by GAN 01/16/87 */
X! 	    if(tintxts[r].nut < 0) make_vomiting((long)rn1(15,10), FALSE);
X! 	    else lesshungry(tintxts[r].nut);
X! 
X  	    if(r == 0) {			/* Deep Fried */
X  		Glib = rnd(15);
X  		pline("Eating deep fried food made your %s very slippery.",
X***************
X*** 306,327 ****
X  	return(0);
X  }
X  
X! int
X! Hear_again()
X  {
X  	flags.soundok = 1;
X  	return 0;
X  }
X  
X! static void
X! rottenfood() {
X  
X  	pline("Blecch!  Rotten food!");
X  	if(!rn2(4)) {
X  		if (Hallucination) You("feel rather trippy.");
X! 		else
X! 			You("feel rather %s.",
X! 				body_part(LIGHT_HEADED));
X  		make_confused(HConfusion + d(2,4),FALSE);
X  	} else if(!rn2(4) && !Blind) {
X  		pline("Everything suddenly goes dark.");
X--- 494,568 ----
X  	return(0);
X  }
X  
X! static void
X! start_tin(otmp)		/* called when starting to open a tin */
X! 	register struct obj *otmp;
X  {
X+ 	register int tmp;
X+ 
X+ 	if (otmp->blessed) {
X+ 		pline("The tin opens like magic!");
X+ 		tmp = 1;
X+ 	} else if(uwep) {
X+ 		switch(uwep->otyp) {
X+ 		case TIN_OPENER:
X+ 			tmp = 1;
X+ 			break;
X+ 		case DAGGER:
X+ #ifdef TOLKIEN
X+ 		case ELVEN_DAGGER:
X+ 		case ORCISH_DAGGER:
X+ #endif
X+ 		case ATHAME:
X+ #ifdef WORM
X+ 		case CRYSKNIFE:
X+ #endif
X+ 			tmp = 3;
X+ 			break;
X+ 		case PICK_AXE:
X+ 		case AXE:
X+ 			tmp = 6;
X+ 			break;
X+ 		default:
X+ 			goto no_opener;
X+ 		}
X+ 		pline("Using your %s you try to open the tin.",
X+ 			aobjnam(uwep, NULL));
X+ 	} else {
X+ no_opener:
X+ 		pline("It is not so easy to open this tin.");
X+ 		if(Glib) {
X+ 			pline("The tin slips out of your hands.");
X+ 			if(otmp->quan > 1) {
X+ 				register struct obj *obj;
X+ 				obj = splitobj(otmp, 1);
X+ 				if(otmp == uwep) setuwep(obj);
X+ 			}
X+ 			dropx(otmp);
X+ 			return;
X+ 		}
X+ 		tmp = 10 + rn2(1 + 500/((int)(ACURR(A_DEX) + ACURR(A_STR))));
X+ 	}
X+ 	tin.reqtime = tmp;
X+ 	tin.usedtime = 0;
X+ 	tin.tin = otmp;
X+ 	set_occupation(opentin, "opening the tin", 0);
X+ 	return;
X+ }
X+ 
X+ int
X+ Hear_again() {		/* called when waking up after fainting */
X  	flags.soundok = 1;
X  	return 0;
X  }
X  
X! static int
X! rottenfood() {		/* called on the "first bite" of rotten food */
X  
X  	pline("Blecch!  Rotten food!");
X  	if(!rn2(4)) {
X  		if (Hallucination) You("feel rather trippy.");
X! 		else You("feel rather %s.", body_part(LIGHT_HEADED));
X  		make_confused(HConfusion + d(2,4),FALSE);
X  	} else if(!rn2(4) && !Blind) {
X  		pline("Everything suddenly goes dark.");
X***************
X*** 335,345 ****
X  		nomul(-rnd(10));
X  		nomovemsg = "You are conscious again.";
X  		afternmv = Hear_again;
X  	}
X  }
X  
X! static void
X! eatcorpse(otmp) register struct obj *otmp; {
X  	register char *cname = mons[otmp->corpsenm].mname;
X  	register int tp, rotted;
X  
X--- 576,590 ----
X  		nomul(-rnd(10));
X  		nomovemsg = "You are conscious again.";
X  		afternmv = Hear_again;
X+ 		return(1);
X  	}
X+ 	return(0);
X  }
X  
X! static int
X! eatcorpse(otmp)		/* called when a corpse is selected as food */
X! 	register struct obj *otmp;
X! {
X  	register char *cname = mons[otmp->corpsenm].mname;
X  	register int tp, rotted;
X  
X***************
X*** 370,383 ****
X  #ifdef POLYSELF
X  		}
X  #endif
X  	} else if(poisonous(&mons[otmp->corpsenm]) && rn2(5)){
X  		pline("Ecch - that must have been poisonous!");
X  		if(!Poison_resistance) {
X  			losestr(rnd(4));
X  			losehp(rnd(15), "poisonous corpse");
X  		} else	You("seem unaffected by the poison.");
X- 		(void) corpsefx(otmp->corpsenm);
X- 		tp++;
X  	/* now any corpse left too long will make you mildly ill */
X  	} else if(((rotted > 5) || ((rotted > 3) && rn2(5)))
X  #ifdef POLYSELF
X--- 615,629 ----
X  #ifdef POLYSELF
X  		}
X  #endif
X+ 		useup(otmp);
X+ 		return(1);
X  	} else if(poisonous(&mons[otmp->corpsenm]) && rn2(5)){
X+ 		tp++;
X  		pline("Ecch - that must have been poisonous!");
X  		if(!Poison_resistance) {
X  			losestr(rnd(4));
X  			losehp(rnd(15), "poisonous corpse");
X  		} else	You("seem unaffected by the poison.");
X  	/* now any corpse left too long will make you mildly ill */
X  	} else if(((rotted > 5) || ((rotted > 3) && rn2(5)))
X  #ifdef POLYSELF
X***************
X*** 387,397 ****
X  		tp++;
X  		You("feel%s sick.", (Sick) ? " very" : "");
X  		losehp(rnd(8), "cadaver");
X! 	} else	tp = corpsefx(otmp->corpsenm);
X  	if(!tp && !rn2(7)) {
X  
X! 	    rottenfood();
X! 	    lesshungry((int)mons[otmp->corpsenm].cnutrit >> 2);
X  	} else {
X  #ifdef POLYSELF
X  	    pline("That %s corpse %s!", cname,
X--- 633,646 ----
X  		tp++;
X  		You("feel%s sick.", (Sick) ? " very" : "");
X  		losehp(rnd(8), "cadaver");
X! 	}
X  	if(!tp && !rn2(7)) {
X  
X! 	    if(rottenfood()) {
X! 		(void)touchfood(otmp);
X! 		return(1);
X! 	    }
X! 	    victual.nutrit = (int)mons[otmp->corpsenm].cnutrit >> 2;
X  	} else {
X  #ifdef POLYSELF
X  	    pline("That %s corpse %s!", cname,
X***************
X*** 399,689 ****
X  #else
X  	    pline("That %s corpse tasted terrible!", cname);
X  #endif
X! 	    lesshungry((int)mons[otmp->corpsenm].cnutrit);
X  	}
X  
X  	/* delay is weight dependant */
X! 	multi = -(3 + (mons[otmp->corpsenm].cwt >> 2));
X  }
X  
X- /* Created by GAN 01/28/87
X-  * Amended by AKP 09/22/87: if not hard, don't choke, just vomit.
X-  * Amended by 3.  06/12/89: if not hard, sometimes choke anyway, to keep risk.
X-  */
X- /*ARGSUSED*/
X  static void
X! choke(food)
X! register struct obj *food;
X  {
X! 	/* only happens if you were satiated */
X! 	if(u.uhs != SATIATED) return;
X! 
X! 	if (pl_character[0] == 'K' && u.ualigntyp == U_LAWFUL)
X! 		u.ualign--;	/* gluttony is unchivalrous */
X! 
X! #ifndef HARD
X! 	if (rn2(20)) {
X! 		You("stuff yourself and then vomit voluminously.");
X! 		morehungry(1000);	/* you just got *very* sick! */
X! 		vomit();
X! 	} else {
X! #endif
X! 		if(food) {
X! 			int savequan = food->quan;
X! 			food->quan = 1;
X! 			killer = xname(food);
X! 			food->quan = savequan;
X! 		} else
X! 			killer = "exuberant appetite";
X! 		You("choke over your food.");
X! 		You("die...");
X! 		done(CHOKING);
X! #ifndef HARD
X! 	}
X! #endif
X  }
X  
X- int
X- doeat() {
X- 	register struct obj *otmp;
X- 	register struct objclass *ftmp;
X- 	register int tmp;
X- 
X- 	if (!(otmp = floorfood("eat", 0))) return 0;
X  
X! 	if(otmp->otyp == TIN) {
X! 		if (otmp->blessed) {
X! 			pline("The tin opens like magic!");
X! 			tmp = 1;
X! 		} else if(uwep) {
X! 			switch(uwep->otyp) {
X! 			case TIN_OPENER:
X! 				tmp = 1;
X! 				break;
X! 			case DAGGER:
X! 			case ATHAME:
X! #ifdef WORM
X! 			case CRYSKNIFE:
X! #endif
X! 				tmp = 3;
X! 				break;
X! 			case PICK_AXE:
X! 			case AXE:
X! 				tmp = 6;
X! 				break;
X! 			default:
X! 				goto no_opener;
X! 			}
X! 			pline("Using your %s you try to open the tin.",
X! 				aobjnam(uwep, NULL));
X! 		} else {
X! 		no_opener:
X! 			pline("It is not so easy to open this tin.");
X! 			if(Glib) {
X! 				pline("The tin slips out of your hands.");
X! 				if(otmp->quan > 1) {
X! 					register struct obj *obj;
X! 					obj = splitobj(otmp, 1);
X! 					if(otmp == uwep) setuwep(obj);
X! 				}
X! 				dropx(otmp);
X! 				return(1);
X! 			}
X! 			tmp = 10 + rn2(1 + 500/((int)(ACURR(A_DEX) + ACURR(A_STR))));
X! 		}
X! 		tin.reqtime = tmp;
X! 		tin.usedtime = 0;
X! 		tin.tin = otmp;
X! 		set_occupation(opentin, "opening the tin", 0);
X! 		return(1);
X! 	}
X  
X! 	ftmp = &objects[otmp->otyp];
X! 	multi = -ftmp->oc_delay;
X! 	if(otmp->otyp == CORPSE) eatcorpse(otmp);
X! 	else {
X! 	    if (otmp->otyp != FORTUNE_COOKIE &&
X! 		otmp->otyp != DEAD_LIZARD &&
X! 		(otmp->cursed ||
X! 		 ((monstermoves - otmp->age) > otmp->blessed ? 50 : 30)) &&
X! 		  !rn2(7)) {
X  
X! 		rottenfood();
X! 		lesshungry(ftmp->nutrition >> 2);
X! 	    } else {
X! 		if(u.uhunger >= 1500) choke(otmp);
X! 
X! 		switch(otmp->otyp){
X! 		case FOOD_RATION:
X! 			if(u.uhunger <= 200)
X! 			    if (Hallucination)
X! 				pline("Oh wow, like, superior, man!");
X! 			    else
X! 				pline("That food really hit the spot!");
X! 			else if(u.uhunger <= 700)
X! 				pline("That satiated your stomach!");
X! 	/* Have lesshungry() report when you are nearly full so all eating
X! 	 * warns when you are about to choke.
X! 	 */
X! 			lesshungry(ftmp->nutrition);
X! 			if(multi < 0) nomovemsg = "You finished your meal.";
X! 			break;
X! 		case TRIPE_RATION:
X  #ifdef POLYSELF
X! 			if (carnivorous(uasmon))
X! 			    pline("That tripe ration was surprisingly good!");
X! 			else {
X  #endif
X! 			    pline("Yak - dog food!");
X! 			    more_experienced(1,0);
X! 			    flags.botl = 1;
X  #ifdef POLYSELF
X! 			}
X! #endif
X! 			if(rn2(2)
X  #ifdef POLYSELF
X! 				&& !carnivorous(uasmon)
X! #endif
X! 							){
X! 				You("vomit.");
X! 				morehungry(20);
X! 				vomit();
X! 			} else	lesshungry(ftmp->nutrition);
X  			break;
X! #ifdef POLYSELF
X! 		case CLOVE_OF_GARLIC:
X! 			if (is_undead(uasmon)) {
X! 				You("cannot stand eating it.  You vomit.");
X! 				vomit();
X! 				break;
X! 			}
X! 			/* Fall through otherwise */
X  #endif
X! 		default:
X  #ifdef TUTTI_FRUTTI
X! 			if (otmp->otyp==SLIME_MOLD && !otmp->cursed
X! 				&& otmp->spe == current_fruit
X! 								)
X! 			    pline(!Hallucination ?
X! 				    "Mmm!  Your favorite!" :
X! 				    "Yum!  Your fave fruit!");
X! 			else
X  #endif
X  #ifdef UNIX
X! 			if (otmp->otyp == APPLE || otmp->otyp == PEAR) {
X! 			    if (!Hallucination)
X! 				pline("Core dumped.");
X! 			    else {
X! 	/* This is based on an old Usenet joke, a fake a.out manual page */
X! 				int x = rnd(100);
X! 				if (x <= 75)
X! 				    pline("Segmentation fault -- core dumped.");
X! 				else if (x <= 99)
X! 				    pline("Bus error -- core dumped.");
X! 				else pline("Yo' mama -- core dumped.");
X! 			    }
X! 			} else
X! #endif
X! 			{
X! 			    int oldquan = otmp->quan;
X! 			    otmp->quan = 1;
X! 			    pline("That %s was %s!", xname(otmp),
X! 			      otmp->cursed ?
X! 				(Hallucination ? "grody" : "terrible"):
X! 			      Hallucination ? "gnarly" : (
X  #ifdef TOLKIEN
X! 			       otmp->otyp==CRAM_RATION ? "bland":
X  #endif
X! 			       "delicious"));
X! 			    otmp->quan = oldquan;
X! 			}
X! 			lesshungry(ftmp->nutrition);
X  
X! 			switch(otmp->otyp) {
X  #ifdef POLYSELF
X! 			    case CLOVE_OF_GARLIC:
X! 				if (u.ulycn != -1) {
X! 					You("feel purified.");
X! 					if(uasmon == &mons[u.ulycn] &&
X! 					  !Polymorph_control)
X! 						rehumanize();
X! 					u.ulycn = -1;
X! 				}
X! 				break;
X! #endif
X! 			    case DEAD_LIZARD:
X! 				/* Relief from cockatrices -dgk */
X! 				if (Stoned) {
X! 					Stoned = 0;
X! 					You("feel limber!");
X! 				}
X! 				if (HStun > 2)  make_stunned(2L,FALSE);
X! 				if (HConfusion > 2)  make_confused(2L,FALSE);
X! 				break;
X! 			    case CARROT:
X! 				make_blinded(0L,TRUE);
X! 				break;
X! 			    case FORTUNE_COOKIE:
X! 				outrumor(bcsign(otmp), TRUE);
X! 				break;
X! 			    case LUMP_OF_ROYAL_JELLY:
X! 				/* This stuff seems to be VERY healthy! */
X! 				gainstr(otmp, 1);
X! 				u.uhp += (otmp->cursed) ? -rnd(20) : rnd(20);
X! 				if(u.uhp > u.uhpmax) {
X! 					if(!rn2(17)) u.uhpmax++;
X! 					u.uhp = u.uhpmax;
X! 				} else if(u.uhp <= 0) {
X! 					killer = "rotten jelly lump";
X! 					done(POISONING);
X! 				}
X! 				if(!otmp->cursed) heal_legs();
X! 				break;
X! 			    case EGG:
X! 				if(otmp->corpsenm == PM_COCKATRICE) {
X! #ifdef POLYSELF
X! 				    if(!resists_ston(uasmon)) {
X! #endif
X! 					if (!Stoned) Stoned = 5;
X! 					killer = "cockatrice egg";
X! #ifdef POLYSELF
X! 				    }
X! #endif
X! 				}
X! 				break;
X! 			    default:	break;
X! 			}
X! 			break;
X! 		}
X! 	    }
X  	}
X! 	
X  
X! 	if(multi < 0 && !nomovemsg){
X! #ifdef LINT	/* JAR		static char msgbuf[BUFSZ]; */
X! 		char msgbuf[BUFSZ];
X! #else
X! 		static char msgbuf[BUFSZ];
X! #endif
X! 		/* note: ftmp->oc_name usually works, the exception being
X! 		 * for fruits.  If fruits are changed to take more time to
X! 		 * eat, this has to be modified.
X! 		 */
X! 		if (otmp->otyp != CORPSE)
X! 			Sprintf(msgbuf, "You finish eating the %s.",
X! 						ftmp->oc_name);
X! 		else
X! 			Sprintf(msgbuf, "You finish eating the %s corpse.",
X! 						mons[otmp->corpsenm].mname);
X! 		nomovemsg = msgbuf;
X  	}
X! 	useup(otmp);
X  	return(1);
X  }
X  
X- /* called in main.c */
X  void
X! gethungry(){
X  	--u.uhunger;
X  	if(moves % 2) {
X  		if(HRegeneration) u.uhunger--;
X--- 648,908 ----
X  #else
X  	    pline("That %s corpse tasted terrible!", cname);
X  #endif
X! 	    victual.nutrit = (int)mons[otmp->corpsenm].cnutrit;
X  	}
X  
X  	/* delay is weight dependant */
X! 	victual.reqtime = 3 + (mons[otmp->corpsenm].cwt >> 2);
X! 	return(0);
X  }
X  
X  static void
X! start_eating(otmp)		/* called as you start to eat */
X! 	register struct obj *otmp;
X  {
X! #ifdef DEBUG
X! 	pline("start_eating: %x (victual = %x)", otmp, victual.piece);
X! 	pline("reqtime = %d", victual.reqtime);
X! 	pline("nutrit = %d", victual.nutrit);
X! 	pline("nmod = %d", victual.nmod);
X! #endif
X! 	victual.fullwarn = victual.doreset = FALSE;
X! 	victual.canchoke = (u.uhs == SATIATED);
X! 	victual.eating = TRUE;
X! 
X! 	if (otmp->otyp == CORPSE)
X! 	    cprefx(victual.piece->corpsenm);
X! 
X! 	Sprintf(msgbuf, "eating the %s", singular(otmp));
X! 	set_occupation(eatfood, msgbuf, 0);
X  }
X  
X  
X! static void
X! fprefx(otmp)		/* called on "first bite" of (non-corpse) food */
X  
X! 	register struct obj *otmp;
X! {
X! 	switch(otmp->otyp) {
X  
X! 	    case FOOD_RATION:
X! 		if(u.uhunger <= 200)
X! 		    if (Hallucination) pline("Oh wow, like, superior, man!");
X! 		    else	       pline("That food really hit the spot!");
X! 		else if(u.uhunger <= 700) pline("That satiated your stomach!");
X! 		break;
X! 	    case TRIPE_RATION:
X  #ifdef POLYSELF
X! 		if (carnivorous(uasmon))
X! 		    pline("That tripe ration was surprisingly good!");
X! 		else {
X  #endif
X! 		    pline("Yak - dog food!");
X! 		    more_experienced(1,0);
X! 		    flags.botl = 1;
X  #ifdef POLYSELF
X! 		}
X! #endif
X! 		if(rn2(2)
X! #ifdef POLYSELF
X! 			&& !carnivorous(uasmon)
X! #endif
X! 						) {
X! 			make_vomiting((long)rn1(victual.reqtime, 10), FALSE);
X! 		}
X! 		break;
X! 	    case DEAD_LIZARD:
X! 		/* Relief from cockatrices -dgk */
X! 		if (Stoned) {
X! 			Stoned = 0;
X! 			You("feel limber!");
X! 		}
X! 		break;
X  #ifdef POLYSELF
X! 	    case CLOVE_OF_GARLIC:
X! 		if (is_undead(uasmon)) {
X! 			make_vomiting((long)rn1(victual.reqtime, 5), FALSE);
X  			break;
X! 		}
X! 		/* Fall through otherwise */
X  #endif
X! 	    default:
X  #ifdef TUTTI_FRUTTI
X! 		if (otmp->otyp==SLIME_MOLD && !otmp->cursed
X! 			&& otmp->spe == current_fruit)
X! 		    pline(!Hallucination ? "Mmm!  Your favorite!" :
X! 			    		   "Yum!  Your fave fruit!");
X! 		else
X  #endif
X  #ifdef UNIX
X! 		if (otmp->otyp == APPLE || otmp->otyp == PEAR) {
X! 		    if (!Hallucination) pline("Core dumped.");
X! 		    else {
X! /* This is based on an old Usenet joke, a fake a.out manual page */
X! 			int x = rnd(100);
X! 			if (x <= 75)
X! 			    pline("Segmentation fault -- core dumped.");
X! 			else if (x <= 99)
X! 			    pline("Bus error -- core dumped.");
X! 			else pline("Yo' mama -- core dumped.");
X! 		    }
X! 		} else 
X! #endif
X! 		{
X! 		    int oldquan = otmp->quan;
X! 		    otmp->quan = 1;
X! 		    pline("This %s is %s!", xname(otmp),
X! 		      otmp->cursed ? (Hallucination ? "grody" : "terrible"):
X! 		      Hallucination ? "gnarly" : (
X  #ifdef TOLKIEN
X! 		       otmp->otyp==CRAM_RATION ? "bland":
X  #endif
X! 		       "delicious"));
X! 		    otmp->quan = oldquan;
X! 		}
X! 		break;
X! 	}
X! }
X! 
X! static int
X! fpostfx(otmp)		/* called after consuming (non-corpse) food */
X  
X! 	register struct obj *otmp;
X! {
X! 	switch(otmp->otyp) {
X  #ifdef POLYSELF
X! 	    case CLOVE_OF_GARLIC:
X! 		if (u.ulycn != -1) {
X! 		    u.ulycn = -1;
X! 		    You("feel purified.");
X! 		    if(uasmon == &mons[u.ulycn] && !Polymorph_control)
X! 			rehumanize();
X! 		}
X! 		break;
X! #endif
X! 	    case DEAD_LIZARD:
X! 		if (HStun > 2)  make_stunned(2L,FALSE);
X! 		if (HConfusion > 2)  make_confused(2L,FALSE);
X! 		break;
X! 	    case CARROT:
X! 		make_blinded(0L,TRUE);
X! 		break;
X! 	    case FORTUNE_COOKIE:
X! 		outrumor(bcsign(otmp), TRUE);
X! 		break;
X! 	    case LUMP_OF_ROYAL_JELLY:
X! 		/* This stuff seems to be VERY healthy! */
X! 		gainstr(otmp, 1);
X! 		u.uhp += (otmp->cursed) ? -rnd(20) : rnd(20);
X! 		if(u.uhp > u.uhpmax) {
X! 			if(!rn2(17)) u.uhpmax++;
X! 			u.uhp = u.uhpmax;
X! 		} else if(u.uhp <= 0) {
X! 			killer = "rotten jelly lump";
X! 			done(POISONING);
X! 		}
X! 		if(!otmp->cursed) heal_legs();
X! 		break;
X! 	    case EGG:
X! 		if(otmp->corpsenm == PM_COCKATRICE) {
X! #ifdef POLYSELF
X! 		    if(!resists_ston(uasmon)) {
X! #endif
X! 			if (!Stoned) Stoned = 5;
X! 			killer = "cockatrice egg";
X! #ifdef POLYSELF
X! 		    }
X! #endif
X! 		}
X! 		break;
X  	}
X! 	return(0);	/* must do this for sync with cpostfx() */
X! }
X  
X! int
X! doeat() {		/* generic "eat" command funtion (see cmd.c) */
X! 	register struct obj *otmp;
X! 
X! 	if(victual.piece &&
X! 	   (carried(victual.piece) ||
X! 	    (victual.piece->ox == u.ux && victual.piece->oy == u.uy))) {
X! 
X! 	    You("resume your meal.");
X! 	    if(!carried(victual.piece)) {
X! 		if(victual.piece->quan != 1)
X! 			(void) splitobj(victual.piece, 1);
X! 		victual.piece = pick_obj(victual.piece);
X! 	    }
X! 	    start_eating(victual.piece);
X! 	    return(1);
X! 	}
X! 
X! 	/* nothing in progress - so try to find something. */
X! 	if (!(otmp = floorfood("eat", 0))) return 0;
X! 
X! 	/* tins are a special case */
X! 	if(otmp->otyp == TIN) {
X! 	    start_tin(otmp);
X! 	    return(1);
X  	}
X! 
X! 	/* Now we need to calculate delay and nutritional info.
X! 	 * The base nutrition calculated here and in eatcorpse() accounts
X! 	 * for normal vs. rotten food.  The reqtime and nutrit values are
X! 	 * then adjusted in accordance with the amount of food left.
X! 	 */
X! 	if(otmp->otyp == CORPSE) {
X! 	    if(eatcorpse(otmp)) return(1);
X! 	    /* else eatcorpse sets up reqtime and nutrit */
X! 	} else {
X! 	    victual.reqtime = objects[otmp->otyp].oc_delay;
X! 	    victual.nutrit = objects[otmp->otyp].nutrition;
X! 	    if (otmp->otyp != FORTUNE_COOKIE && otmp->otyp != DEAD_LIZARD &&
X! 		(otmp->cursed ||
X! 		 ((monstermoves - otmp->age) > otmp->blessed ? 50 : 30)) &&
X! 		!rn2(7)) {
X! 
X! 		if(rottenfood()) {
X! 		    (void)touchfood(otmp);
X! 		    return(1);
X! 		}
X! 		victual.nutrit /= 2;
X! 	    } else fprefx(otmp);
X! 	}
X! 
X! 	victual.piece = otmp;
X! 	victual.usedtime = 0;
X! 
X! 	/* re-calc the nutrition (already set) to account for weight */
X! 	if(otmp->oeaten) {
X! 	    int baseweight = weight(otmp);	/* weight of full item */
X! 
X! 	    victual.reqtime = 
X! 		rounddiv((int)(victual.reqtime * otmp->owt), baseweight);
X! 	    victual.nutrit = 
X! 		rounddiv((int)(victual.nutrit * otmp->owt), baseweight);
X! 	}
X! 
X! 	/* calculate the modulo value (nutrit. units per round eating)
X! 	 * note: this isn't exact - you actually lose a little nutrition
X! 	 *	 due to this method.
X! 	 * TODO: add in a "remainder" value to be given at the end of the
X! 	 *	 meal.
X! 	 */
X! 	if(victual.nutrit == 0 || victual.reqtime == 0)
X! 	    /* possible if most has been eaten before */
X! 	    victual.nmod = 0;
X! 	else if(victual.nutrit > victual.reqtime)
X! 	    victual.nmod = -(victual.nutrit / victual.reqtime);
X! 	else
X! 	    victual.nmod = victual.reqtime % victual.nutrit;
X! 
X! 	start_eating(otmp);
X  	return(1);
X  }
X  
X  void
X! gethungry() {		/* as time goes by - called in main.c */
X  	--u.uhunger;
X  	if(moves % 2) {
X  		if(HRegeneration) u.uhunger--;
X***************
X*** 704,712 ****
X  	newuhs(TRUE);
X  }
X  
X! /* called after vomiting and after performing feats of magic */
X  void
X! morehungry(num)
X  register int num;
X  {
X  	u.uhunger -= num;
X--- 923,931 ----
X  	newuhs(TRUE);
X  }
X  
X! 
X  void
X! morehungry(num)	/* called after vomiting and after performing feats of magic */
X  register int num;
X  {
X  	u.uhunger -= num;
X***************
X*** 713,733 ****
X  	newuhs(TRUE);
X  }
X  
X! /* called after eating something (and after drinking fruit juice) */
X  void
X! lesshungry(num)
X  register int num;
X  {
X  	u.uhunger += num;
X! 	if(u.uhunger >= 2000) choke((struct obj *) 0);
X! 	else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X  	     */
X  	    if (u.uhunger >= 1500) {
X  		pline("You're having a hard time getting all of it down.");
X- 		multi -= 2;
X  		nomovemsg = "You're finally finished.";
X  	    }
X  	}
X  	newuhs(FALSE);
X--- 932,967 ----
X  	newuhs(TRUE);
X  }
X  
X! 
X  void
X! lesshungry(num)	/* called after eating (and after drinking fruit juice) */
X  register int num;
X  {
X+ #ifdef DEBUG
X+ 	pline("lesshungry(%d)", num);
X+ #endif
X  	u.uhunger += num;
X! 	if(u.uhunger >= 2000) {
X! 	    if (!victual.eating || victual.canchoke)
X! 		choke((struct obj *) 0);
X! 	} else {
X  	    /* Have lesshungry() report when you're nearly full so all eating
X  	     * warns when you're about to choke.
X  	     */
X  	    if (u.uhunger >= 1500) {
X+ 	      if(!victual.eating || (victual.eating && !victual.fullwarn)) {
X  		pline("You're having a hard time getting all of it down.");
X  		nomovemsg = "You're finally finished.";
X+ 		if(!victual.eating)
X+ 		    multi = -2;
X+ 		else {
X+ 		    victual.fullwarn = TRUE;
X+ 		    if (victual.canchoke) {
X+ 			pline("Stop eating?");
X+ 			if(yn() == 'y') reset_eat();
X+ 		    }
X+ 		}
X+ 	      }
X  	    }
X  	}
X  	newuhs(FALSE);
X***************
X*** 742,748 ****
X  }
X  
X  void
X! newuhs(incr) boolean incr; {
X  	register int newhs, h = u.uhunger;
X  
X  	newhs = (h > 1000) ? SATIATED :
X--- 976,984 ----
X  }
X  
X  void
X! newuhs(incr)		/* compute and comment on your (new?) hunger status */
X! 	boolean incr;
X! {
X  	register int newhs, h = u.uhunger;
X  
X  	newhs = (h > 1000) ? SATIATED :
X***************
X*** 792,798 ****
X  			if (Hallucination)
X  			    pline((!incr) ?
X  				  "You still have the munchies." :
X! 				  "The munchies are starting to interfere with your motor capabilities.");
X  			else
X  			    You((!incr) ? "feel weak now." :
X  				  (u.uhunger < 45) ? "feel weak." :
X--- 1028,1034 ----
X  			if (Hallucination)
X  			    pline((!incr) ?
X  				  "You still have the munchies." :
X!       "The munchies are starting to interfere with your motor capabilities.");
X  			else
X  			    You((!incr) ? "feel weak now." :
X  				  (u.uhunger < 45) ? "feel weak." :
X***************
X*** 810,827 ****
X  }
X  
X  struct obj *
X! floorfood(verb,corpseonly)
X! char *verb;
X! boolean corpseonly;
X  {
X  	register struct obj *otmp;
X  
X  	/* Is there some food (probably a heavy corpse) here on the ground? */
X  	if(!Levitation && !u.uswallow) {
X! 	if(OBJ_AT(u.ux, u.uy))
X! 	    for(otmp = fobj; otmp; otmp = otmp->nobj) {
X! 		if(otmp->ox == u.ux && otmp->oy == u.uy &&
X! 		   (corpseonly ? otmp->otyp==CORPSE : otmp->olet==FOOD_SYM)) {
X  			pline("There %s %s here; %s %s? ",
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X--- 1046,1061 ----
X  }
X  
X  struct obj *
X! floorfood(verb,corpseonly)	/* get food from floor or pack */
X! 	char *verb;
X! 	boolean corpseonly;
X  {
X  	register struct obj *otmp;
X  
X  	/* Is there some food (probably a heavy corpse) here on the ground? */
X  	if(!Levitation && !u.uswallow) {
X! 	    for(otmp = level.objects[u.ux][u.uy]; otmp; otmp = otmp->nexthere) {
X! 		if(corpseonly ? otmp->otyp==CORPSE : otmp->olet==FOOD_SYM) {
X  			pline("There %s %s here; %s %s? ",
X  				(otmp->quan == 1) ? "is" : "are",
X  				doname(otmp), verb,
X***************
X*** 829,839 ****
X  			if(yn() == 'y') {
X  				if(otmp->quan != 1)
X  					(void) splitobj(otmp, 1);
X! 				freeobj(otmp);
X! 				otmp = addinv(otmp);
X! 				addtobill(otmp, TRUE);
X! 				if(Invisible) newsym(u.ux, u.uy);
X! 				return otmp;
X  			}
X  		}
X  	    }
X--- 1063,1069 ----
X  			if(yn() == 'y') {
X  				if(otmp->quan != 1)
X  					(void) splitobj(otmp, 1);
X! 				return(pick_obj(otmp));
X  			}
X  		}
X  	    }
X***************
X*** 842,849 ****
X  }
X  
X  /* Side effects of vomiting */
X  /* TO DO: regurgitate swallowed monsters when poly'd */
X  void
X! vomit() { /* A good idea from David Neves */
X  	make_sick(0L,TRUE);
X  }
X--- 1072,1081 ----
X  }
X  
X  /* Side effects of vomiting */
X+ /* added nomul (MRS) - it makes sense, you're too busy being sick! */
X  /* TO DO: regurgitate swallowed monsters when poly'd */
X  void
X! vomit() {		/* A good idea from David Neves */
X  	make_sick(0L,TRUE);
X+ 	nomul(-2);
X  }
X*** src/Old/end.c	Sun Oct 15 18:34:53 1989
X--- src/end.c	Sun Oct 15 17:25:26 1989
X***************
X*** 158,163 ****
X--- 158,168 ----
X  panic VA_DECL(char *, str)
X  	VA_START(str);
X  	VA_INIT(str, char *);
X+ #ifdef MACOS
X+ 	puts(str);
X+ 	more();
X+ #endif
X+ 
X  	if(panicking++)
X  #ifdef SYSV
X  	    (void)
X***************
X*** 185,191 ****
X--- 190,200 ----
X  	hu = FALSE;
X  	(void) dosave0();
X  #endif
X+ #ifdef MACOS
X+ 	puts(" ERROR:  ");
X+ #else
X  	(void) fputs(" ERROR:  ", stdout);
X+ #endif
X  	Vprintf(str,VA_ARGS);
X  	more();				/* contains a fflush() */
X  #if defined(WIZARD) && (defined(UNIX) || defined(VMS))
X***************
X*** 234,240 ****
X  		      !Blind ? "begins to glow" : "feels warm");
X  		You("feel much better!");
X  		pline("The medallion crumbles to dust!");
X! 		useup(uamul);
X  		if (u.uhunger < 500) u.uhunger = 500;
X  		nomovemsg = "You survived that attempt on your life.";
X  		curs_on_u();
X--- 243,254 ----
X  		      !Blind ? "begins to glow" : "feels warm");
X  		You("feel much better!");
X  		pline("The medallion crumbles to dust!");
X! 		if (uamul)	/* Huss:  Check if amulet really is worn */
X! 			useup(uamul);
X! 		else if (uwep && uwep->otyp == AMULET_OF_LIFE_SAVING)
X! 			useup(uwep);	/* Oops, he must be wielding it. */
X! 		else
X! 			impossible("Using an amulet without having it?");
X  		if (u.uhunger < 500) u.uhunger = 500;
X  		nomovemsg = "You survived that attempt on your life.";
X  		curs_on_u();
X***************
X*** 281,287 ****
X  	else if(how == STONED)
X  		(mk_named_object(STATUE, upmon, u.ux, u.uy, plname,
X  					strlen(plname)))->spe = 0;
X! 	else
X  		(void) mk_named_object(CORPSE, upmon, u.ux, u.uy, plname,
X  							strlen(plname));
X  
X--- 295,304 ----
X  	else if(how == STONED)
X  		(mk_named_object(STATUE, upmon, u.ux, u.uy, plname,
X  					strlen(plname)))->spe = 0;
X! /*
X!  * If you're burned to a crisp, why leave a corpse?
X!  */
X! 	else if (how != BURNING)
X  		(void) mk_named_object(CORPSE, upmon, u.ux, u.uy, plname,
X  							strlen(plname));
X  
X***************
X*** 468,474 ****
X  		topten();
X  /* "So when I die, the first thing I will see in Heaven is a score list?" */
X  	if(done_stopprint) Printf("\n\n");
X! #ifdef APOLLO
X  	getret();
X  #endif
X  	exit(0);
X--- 485,491 ----
X  		topten();
X  /* "So when I die, the first thing I will see in Heaven is a score list?" */
X  	if(done_stopprint) Printf("\n\n");
X! #if defined(APOLLO) || defined(MACOS)
X  	getret();
X  #endif
X  	exit(0);
X***************
X*** 481,496 ****
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! #if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS)) || defined(VMS)
X  	register int x;
X! #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X! #endif
X  	for(x = maxdlevel; x >= 0; x--) {
X  		glo(x);
X  		(void) unlink(lock);	/* not all levels need be present */
X  	}
X! #endif
X  #endif
X  }
X  
X--- 498,514 ----
X  	if (ramdisk)
X  		eraseall(permbones, alllevels);
X  #else
X! # if defined(UNIX) || (defined(MSDOS) && !defined(OLD_TOS)) || defined(VMS) \
X! 							|| defined(MACOS)
X  	register int x;
X! #  if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP,SIG_IGN);
X! #  endif
X  	for(x = maxdlevel; x >= 0; x--) {
X  		glo(x);
X  		(void) unlink(lock);	/* not all levels need be present */
X  	}
X! # endif
X  #endif
X  }
X  
X*** src/Old/invent.c	Sun Oct 15 18:37:27 1989
X--- src/invent.c	Thu Oct  5 21:18:12 1989
X***************
X*** 140,145 ****
X--- 140,146 ----
X  register struct obj *obj;
X  {
X  	if(obj->quan > 1){
X+ 		obj->in_use = FALSE;	/* no longer in use */
X  		obj->quan--;
X  		obj->owt = weight(obj);
X  	} else {
X***************
X*** 1096,1102 ****
X  	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X! 	else if(obj->olet == FOOD_SYM && OEATEN(obj) != OEATEN(otmp))
X  		return(FALSE);
X  
X  	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X--- 1097,1103 ----
X  	else if((obj->olet==WEAPON_SYM || obj->olet==ARMOR_SYM) &&
X  		obj->rustfree != otmp->rustfree) return FALSE;
X  
X! 	else if(obj->olet == FOOD_SYM && obj->oeaten != otmp->oeaten)
X  		return(FALSE);
X  
X  	else if(obj->otyp == CORPSE || obj->otyp == EGG || obj->otyp == TIN)
X
END_OF_FILE
if test 56241 -ne `wc -c <'patches05d'`; then
    echo shar: \"'patches05d'\" unpacked with wrong size!
fi
# end of 'patches05d'
fi
echo shar: End of archive 4 \(of 6\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
