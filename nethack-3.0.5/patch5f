Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i053:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch5f
Message-ID: <4704@tekred.CNA.TEK.COM>
Date: 17 Oct 89 20:28:17 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 1622
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 53
Archive-name: NetHack3/Patch5f
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 6)."
# Contents:  patches05f
# Wrapped by billr@saab on Tue Oct 17 13:17:13 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches05f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches05f'\"
else
echo shar: Extracting \"'patches05f'\" \(42408 characters\)
sed "s/^X//" >'patches05f' <<'END_OF_FILE'
X*** src/Old/read.c	Sun Oct 15 18:57:18 1989
X--- src/read.c	Thu Oct 12 16:51:27 1989
X***************
X*** 52,57 ****
X--- 52,58 ----
X  		pline("Being blind, you cannot read the formula on the scroll.");
X  		return(0);
X  	    }
X+ 	scroll->in_use = TRUE;		/* now being read */
X  #ifdef SPELLS
X  	if(scroll->olet == SPBOOK_SYM) {
X  	    if(confused) {
X***************
X*** 911,917 ****
X  		return;
X  	    }
X  #ifdef POLYSELF
X! 	    else if ((how & REALLY) && ptr == &mons[u.umonnum]) rehumanize();
X  #endif
X  	    ptr->geno |= G_GENOD;
X  	    for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X--- 912,918 ----
X  		return;
X  	    }
X  #ifdef POLYSELF
X! 	    else if (ptr == uasmon) rehumanize();
X  #endif
X  	    ptr->geno |= G_GENOD;
X  	    for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X*** src/Old/restore.c	Sun Oct 15 18:58:06 1989
X--- src/restore.c	Sat Oct 14 22:42:55 1989
X***************
X*** 90,95 ****
X--- 90,100 ----
X  		else otmp2->nobj = otmp;
X  		mread(fd, (genericptr_t) otmp, (unsigned) xl + sizeof(struct obj));
X  		if(!otmp->o_id) otmp->o_id = flags.ident++;
X+ 	/* Things that were marked "in_use" when the game was saved (eg. via
X+ 	 * the infamous "HUP" cheat get used up here.
X+ 	 */
X+ 		if(otmp->olet != ARMOR_SYM && otmp->olet != WEAPON_SYM
X+ 			&& otmp->otyp != PICK_AXE && otmp->in_use) useup(otmp);
X  #ifdef TUTTI_FRUTTI
X  		if(ghostly && otmp->otyp == SLIME_MOLD) {
X  			for(oldf=oldfruit; oldf; oldf=oldf->nextf)
X***************
X*** 127,133 ****
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X--- 132,138 ----
X  	off_t differ;
X  
X  	mread(fd, (genericptr_t)&monbegin, sizeof(monbegin));
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4)
X  	differ = (genericptr_t)(&mons[0]) - (genericptr_t)(monbegin);
X  #else
X  	differ = (long)(&mons[0]) - (long)(monbegin);
X***************
X*** 146,152 ****
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  		/* ANSI type for differ is ptrdiff_t --
X  		 * long may be wrong for segmented architecture --
X  		 * may be better to cast pointers to (struct permonst *)
X--- 151,157 ----
X  		mread(fd, (genericptr_t) mtmp, (unsigned) xl + sizeof(struct monst));
X  		if(!mtmp->m_id)
X  			mtmp->m_id = flags.ident++;
X! #if !defined(MSDOS) && !defined(M_XENIX) && !defined(THINKC4)
X  		/* ANSI type for differ is ptrdiff_t --
X  		 * long may be wrong for segmented architecture --
X  		 * may be better to cast pointers to (struct permonst *)
X***************
X*** 281,287 ****
X  #endif
X  
X  	restnames(fd);
X! #ifdef DGK
X  	msmsg("\n");
X  	cl_end();
X  	msmsg("You got as far as level %d%s.\n", maxdlevel,
X--- 286,295 ----
X  #endif
X  
X  	restnames(fd);
X! #if defined(DGK) || defined(MACOS)
X! # ifdef MACOS
X! #define msmsg printf
X! # endif
X  	msmsg("\n");
X  	cl_end();
X  	msmsg("You got as far as level %d%s.\n", maxdlevel,
X***************
X*** 299,311 ****
X  			break;
X  		getlev(fd, 0, ltmp, FALSE);
X  		glo(ltmp);
X! #ifdef DGK
X  		msmsg(".");
X  #endif
X  #if defined(MSDOS) && !defined(TOS)
X  		nfd = open(lock, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X  #else
X  		nfd = creat(lock, FCMASK);
X  #endif
X  		if (nfd < 0)	panic("Cannot open temp file %s!\n", lock);
X  #if defined(DGK) && !defined(OLD_TOS)
X--- 307,343 ----
X  			break;
X  		getlev(fd, 0, ltmp, FALSE);
X  		glo(ltmp);
X! #if defined(DGK) || defined(MACOS)
X  		msmsg(".");
X  #endif
X  #if defined(MSDOS) && !defined(TOS)
X  		nfd = open(lock, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
X  #else
X+ # ifdef MACOS
X+ 		{
X+ 			Str255	fileName;
X+ 			OSErr	er;
X+ 			struct term_info	*t;
X+ 			short	oldVolume;
X+ 			extern WindowPtr	HackWindow;
X+ 			
X+ 			t = (term_info *)GetWRefCon(HackWindow);
X+ 			(void)GetVol(&fileName, &oldVolume);
X+ 			(void)SetVol(0L, t->system.sysVRefNum);
X+ 			fileName[0] = (uchar)strlen(lock);
X+ 			Strcpy((char *)&fileName[1], lock);
X+ 			
X+ 			if (er = Create(&fileName, 0, CREATOR, LEVEL_TYPE))
X+ 				SysBeep(1);
X+ 			else {
X+ 				msmsg(".");
X+ 				nfd = open(lock, O_WRONLY | O_BINARY);
X+ 			}
X+ 			(void)SetVol(0L, oldVolume);
X+ 		}
X+ # else
X  		nfd = creat(lock, FCMASK);
X+ # endif /* MACOS */
X  #endif
X  		if (nfd < 0)	panic("Cannot open temp file %s!\n", lock);
X  #if defined(DGK) && !defined(OLD_TOS)
X***************
X*** 470,476 ****
X--- 502,531 ----
X  		done(TRICKED);
X  	}
X  
X+ #if defined(SMALLDATA) && defined(MACOS)
X+ 	{
X+ 	/* this assumes that the size of a row of struct rm's is <128 */
X+ 		short	i, length, j;
X+ 		char	*ptr, *src, *p, *d;
X+ 		
X+ 		d = calloc(ROWNO*COLNO, sizeof(struct rm));
X+ 		p = d;
X+ 		mread(fd, (genericptr_t)&j, sizeof(short));
X+ 		mread(fd, (genericptr_t)d, j);
X+ 		for (i = 0; i < COLNO; i++) {
X+ 			length = (short)(*p++);
X+ 			ptr = p;
X+ 			src = (char *)&levl[i][0];
X+ 			UnpackBits(&ptr, &src, ROWNO * sizeof(struct rm));
X+ 			if ((ptr - p) != length) 
X+ 			    panic("restore - corrupted file on unpacking\n");
X+ 			p = ptr;
X+ 		}
X+ 		free(d);
X+ 	}
X+ #else
X  	mread(fd, (genericptr_t) levl, sizeof(levl));
X+ #endif
X  	mread(fd, (genericptr_t) &osymbol, sizeof(osymbol));
X  	if (memcmp((genericptr_t) &osymbol,
X  		   (genericptr_t) &showsyms, sizeof (struct symbols))
X***************
X*** 635,641 ****
X  
X  	/* regenerate animals while on another level */
X  	{ long tmoves = (moves > omoves) ? moves-omoves : 0;
X! 	  register struct monst *mtmp, *mtmp2;
X  
X  	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X  
X--- 690,696 ----
X  
X  	/* regenerate animals while on another level */
X  	{ long tmoves = (moves > omoves) ? moves-omoves : 0;
X! 	  register struct monst *mtmp2;
X  
X  	  for(mtmp = fmon; mtmp; mtmp = mtmp2) {
X  
X*** src/Old/rumors.c	Sun Oct 15 18:59:09 1989
X--- src/rumors.c	Sat Oct 14 22:43:14 1989
X***************
X*** 111,117 ****
X--- 111,123 ----
X  	Strcat(tmp,RUMORFILE);
X  	if(rumors = fopen(tmp, "r")) {
X  #else
X+ # ifdef MACOS
X+ 	if(rumors = fopen(RUMORFILE, "r"))
X+ 		rumors = openFile(RUMORFILE);
X+ 	if (rumors) {
X+ # else
X  	if(rumors = fopen(RUMORFILE, "r")) {
X+ # endif
X  #endif
X  		if (!end_rumor_file) {	/* if this is the first outrumor() */
X  			init_rumors();
X***************
X*** 169,175 ****
X--- 175,187 ----
X      Strcat(tmp,ORACLEFILE);
X  	if(oracles = fopen(tmp, "r")) {
X  #else
X+ # ifdef MACOS
X+ 	if(oracles = fopen(ORACLEFILE, "r"))
X+ 		oracles = openFile(ORACLEFILE);
X+ 	if (oracles) {
X+ # else
X  	if(oracles = fopen(ORACLEFILE, "r")) {
X+ # endif
X  #endif
X  		if (!oracle_size) {	/* if this is the first outrumor() */
X  			init_rumors();
X*** src/Old/save.c	Sun Oct 15 18:59:27 1989
X--- src/save.c	Sat Oct 14 22:44:55 1989
X***************
X*** 14,20 ****
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #if defined(EXPLORE_MODE) && !defined(O_RDONLY)
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X--- 14,20 ----
X  #ifndef NO_SIGNAL
X  #include <signal.h>
X  #endif /* !NO_SIGNAL */
X! #if defined(EXPLORE_MODE) && !defined(LSC) && !defined(O_RDONLY)
X  #include <fcntl.h>
X  #endif /* EXPLORE_MODE */
X  
X***************
X*** 100,105 ****
X--- 100,108 ----
X  #ifdef COMPRESS
X  	char	cmd[80];
X  #endif
X+ #ifdef MACOS
X+ 	short	savenum;
X+ #endif
X  
X  	if (!SAVEF[0])
X  		return 0;
X***************
X*** 107,113 ****
X  #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X! #if !defined(__TURBOC__) && !defined(OLD_TOS)
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  
X--- 110,116 ----
X  #if defined(UNIX) || defined(VMS)
X  	(void) signal(SIGHUP, SIG_IGN);
X  #endif
X! #if !defined(__TURBOC__) && !defined(OLD_TOS) && !defined(NO_SIGNAL)
X  	(void) signal(SIGINT, SIG_IGN);
X  #endif
X  
X***************
X*** 144,150 ****
X--- 147,185 ----
X  	    }
X  	}
X  # endif
X+ # ifdef MACOS
X+ 	{
X+ 		Str255	fileName;
X+ 		OSErr	er;
X+ 		OSType	fileType;
X+ 		Point	where;
X+ 		SFReply	reply;
X+ 		char	*prompt;
X+ 		
X+ 		savenum = 0;
X+ 		(void)GetVol(&fileName, &tmp);
X+ 		Strcpy((char *)&fileName[1], SAVEF);
X+ 		fileName[0] = strlen(SAVEF);
X+ 		where.h = where.v =
X+ 		    (SCREEN_BITS.bounds.bottom - SCREEN_BITS.bounds.top) / 4;
X+ 		prompt = "\022Save character in:";
X+ 		SFPutFile(where, prompt, fileName, 0L, &reply);
X+ 		if (reply.good) {
X+ 			SetVol(0L, savenum = reply.vRefNum);
X+ 			strncpy(SAVEF, (char *)&reply.fName[1],
X+ 					(short)reply.fName[0]);
X+ 			SAVEF[(short)reply.fName[0]] = '\0';
X+ 			Strcpy((char *)fileName, (char *)reply.fName);
X+ 		}
X+ 		
X+ 		fileType = (discover == TRUE) ? EXPLORE_TYPE : SAVE_TYPE;
X+ 		if (er = Create(&fileName, 0, CREATOR, fileType))
X+ 			SysBeep(1);
X+ 	}
X+ 	fd = open(SAVEF, O_WRONLY | O_BINARY);
X+ # else
X  	fd = creat(SAVEF, FCMASK);
X+ # endif /* MACOS */
X  #endif /* MSDOS */
X  	if(fd < 0) {
X  		if(!hu) pline("Cannot open save file.");
X***************
X*** 151,156 ****
X--- 186,194 ----
X  		(void) unlink(SAVEF);		/* ab@unido */
X  		return(0);
X  	}
X+ #ifdef MACOS
X+ 	(void)SetVol(0L,tmp);
X+ #endif
X  	if(flags.moonphase == FULL_MOON)	/* ut-sally!fletcher */
X  		change_luck(-1);		/* and unido!ab */
X  	home();
X***************
X*** 162,167 ****
X--- 200,208 ----
X  	savelev(fd, dlevel, mode);
X  	/* count_only will be set properly by savelev */
X  #else
X+ # ifdef MACOS
X+ 	printf("Saving: ");
X+ # endif
X  	savelev(fd,dlevel);
X  #endif
X  	saveobjchn(fd, invent);
X***************
X*** 240,251 ****
X  		if(ltmp == dlevel || !level_exists[ltmp]) continue;
X  #endif
X  		glo(ltmp);
X! #ifdef DGK
X  		if(!hu) msmsg(".");
X  #endif
X  		if((ofd = open(lock, OMASK)) < 0) {
X  		    if(!hu) pline("Error while saving: cannot read %s.", lock);
X  		    (void) close(fd);
X  		    (void) unlink(SAVEF);
X  		    if(!hu) done(TRICKED);
X  		    return(0);
X--- 281,298 ----
X  		if(ltmp == dlevel || !level_exists[ltmp]) continue;
X  #endif
X  		glo(ltmp);
X! #if defined(DGK) || defined(MACOS)
X! # ifdef MACOS
X! #define msmsg printf
X! # endif
X  		if(!hu) msmsg(".");
X  #endif
X  		if((ofd = open(lock, OMASK)) < 0) {
X  		    if(!hu) pline("Error while saving: cannot read %s.", lock);
X  		    (void) close(fd);
X+ #ifdef MACOS
X+ 			(void)SetVol(0L, savenum);
X+ #endif
X  		    (void) unlink(SAVEF);
X  		    if(!hu) done(TRICKED);
X  		    return(0);
X***************
X*** 349,355 ****
X--- 396,427 ----
X  #else
X  	bwrite(fd,(genericptr_t) &lev,sizeof(lev));
X  #endif
X+ #if defined(SMALLDATA) && defined(MACOS)
X+ 	/* asssumes ROWNO*sizeof(struct rm) < 128 bytes */
X+ 	{
X+ 		short	i;
X+ 		char	length;
X+ 		char	bufr[256],*ptr,*src,*d,*p;
X+ 		
X+ 		d = calloc(ROWNO*COLNO, sizeof(struct rm));
X+ 		p = d;
X+ 		for (i = 0; i < COLNO; i++) {
X+ 			ptr = &bufr[0];
X+ 			src = (char *)&levl[i][0];
X+ 			PackBits(&src, &ptr, ROWNO * sizeof(struct rm));
X+ 			length = (char)(ptr - &bufr[0]);
X+ 			BlockMove(&length, p++, (Size)1);
X+ 			BlockMove(bufr, p, (Size)length);
X+ 			p += (long)length;
X+ 		}
X+ 		i = (short)(p - d);
X+ 		bwrite(fd, (genericptr_t)&i, sizeof(short));
X+ 		bwrite(fd, (genericptr_t)d, i);
X+ 		free(d);
X+ 	}
X+ #else
X  	bwrite(fd,(genericptr_t) levl,sizeof(levl));
X+ #endif /* SMALLDATA */
X  #ifdef REINCARNATION
X  	if(dlevel == rogue_level && lev != rogue_level)
X  		/* save the symbols actually used to represent the level, not
X*** src/Old/shk.c	Sun Oct 15 19:00:18 1989
X--- src/shk.c	Sun Oct 15 17:25:15 1989
X***************
X*** 291,296 ****
X--- 291,308 ----
X  		ESHK(mtmp)->shoplevel == dlevel));
X  }
X  
X+ boolean
X+ tended_shop(roomno)
X+ register int roomno;
X+ {
X+ 	register struct monst *mtmp;
X+ 
X+ 	for(mtmp = fmon; mtmp; mtmp = mtmp->nmon)
X+ 	    if(mtmp->isshk && ESHK(mtmp)->shoproom == roomno
X+ 		&& inhishop(mtmp)) return(TRUE);
X+ 	return(FALSE);
X+ }
X+ 
X  static void
X  findshk(roomno)
X  register int roomno;
X***************
X*** 703,712 ****
X  			}
X  
X  			if (invent) {
X! 			    for(otmp = invent; otmp; otmp = otmp->nobj) {
X  				place_object(otmp, ox, oy);
X- 				otmp->age = 0;
X- 			    }
X  
X  			    /* add to main object list at end so invent is
X  			       still good */
X--- 715,722 ----
X  			}
X  
X  			if (invent) {
X! 			    for(otmp = invent; otmp; otmp = otmp->nobj)
X  				place_object(otmp, ox, oy);
X  
X  			    /* add to main object list at end so invent is
X  			       still good */
X***************
X*** 925,931 ****
X  
X  	if(!costly_spot(u.ux,u.uy))
X  		return;
X! 	subfrombill(obj);
X  	/* you dropped something of your own - probably want to sell it */
X  	if(shopkeeper->msleep || shopkeeper->mfroz || !inhishop(shopkeeper))
X  		return;
X--- 935,944 ----
X  
X  	if(!costly_spot(u.ux,u.uy))
X  		return;
X! 	if(obj->unpaid) {
X! 		subfrombill(obj);
X! 		return;
X! 	}
X  	/* you dropped something of your own - probably want to sell it */
X  	if(shopkeeper->msleep || shopkeeper->mfroz || !inhishop(shopkeeper))
X  		return;
X***************
X*** 1044,1050 ****
X  	case FOOD_SYM:
X  		/* simpler hunger check, (2-4)*cost */
X  		if (u.uhs >= HUNGRY) tmp *= u.uhs;
X! 		if (OEATEN(obj)) tmp /= 2;		/* partly eaten */
X  		break;
X  	case WAND_SYM:
X  		if (obj->spe == -1) tmp = 0;
X--- 1057,1063 ----
X  	case FOOD_SYM:
X  		/* simpler hunger check, (2-4)*cost */
X  		if (u.uhs >= HUNGRY) tmp *= u.uhs;
X! 		if (obj->oeaten) tmp /= 2;		/* partly eaten */
X  		break;
X  	case WAND_SYM:
X  		if (obj->spe == -1) tmp = 0;
X*** src/Old/sounds.c	Sun Oct 15 19:01:49 1989
X--- src/sounds.c	Tue Oct  3 21:46:49 1989
X***************
X*** 179,185 ****
X  		}
X  		break;
X  	    case SHOPBASE:
X! 		switch (rn2(2)+hallu) {
X  		    case 0:
X  			You("hear the chime of a cash register.");
X  			break;
X--- 179,186 ----
X  		}
X  		break;
X  	    case SHOPBASE:
X! 		if(tended_shop(croomno))
X! 		  switch (rn2(2)+hallu) {
X  		    case 0:
X  			You("hear the chime of a cash register.");
X  			break;
X***************
X*** 189,195 ****
X  		    case 2:
X  			You("seem to hear Neiman and Marcus arguing!");
X  			break;
X! 		}
X  		break;
X  	    default:
X  		break;
X--- 190,196 ----
X  		    case 2:
X  			You("seem to hear Neiman and Marcus arguing!");
X  			break;
X! 		  }
X  		break;
X  	    default:
X  		break;
X*** src/Old/steal.c	Mon Oct 16 13:23:36 1989
X--- src/steal.c	Mon Oct 16 13:16:26 1989
X***************
X*** 115,124 ****
X  	}
X  
X  	tmp = 0;
X! 	for(otmp = invent; otmp; otmp = otmp->nobj) if(otmp != uarmc)
X  	    tmp += ((otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1);
X  	tmp = rn2(tmp);
X! 	for(otmp = invent; otmp; otmp = otmp->nobj) if(otmp != uarmc)
X    	    if((tmp -= ((otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1))
X  			< 0) break;
X  	if(!otmp) {
X--- 115,124 ----
X  	}
X  
X  	tmp = 0;
X! 	for(otmp = invent; otmp; otmp = otmp->nobj) if(!uarm || otmp != uarmc)
X  	    tmp += ((otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1);
X  	tmp = rn2(tmp);
X! 	for(otmp = invent; otmp; otmp = otmp->nobj) if(!uarm || otmp != uarmc)
X    	    if((tmp -= ((otmp->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL)) ? 5 : 1))
X  			< 0) break;
X  	if(!otmp) {
X***************
X*** 151,157 ****
X  			break;
X  		case ARMOR_SYM:
X  			if(multi < 0 || otmp == uarms){
X! 			  setworn((struct obj *) 0, otmp->owornmask & W_ARMOR);
X  			  break;
X  			}
X  		{ int curssv = otmp->cursed;
X--- 151,163 ----
X  			break;
X  		case ARMOR_SYM:
X  			if(multi < 0 || otmp == uarms){
X! 			  if (otmp == uarm)  (void) Armor_off();
X! 			  else if (otmp == uarmc) (void) Cloak_off();
X! 			  else if (otmp == uarmf) (void) Boots_off();
X! 			  else if (otmp == uarmg) (void) Gloves_off();
X! 			  else if (otmp == uarmh) (void) Helmet_off();
X! 			  else if (otmp == uarms) (void) Shield_off();
X! 			  else setworn((struct obj *)0, otmp->owornmask & W_ARMOR);
X  			  break;
X  			}
X  		{ int curssv = otmp->cursed;
X***************
X*** 229,234 ****
X--- 235,241 ----
X  		mpickobj(mtmp,otmp);
X  		pline("%s stole %s!", Monnam(mtmp), doname(otmp));
X  		rloc(mtmp);
X+ 		return;
X  	    }
X  	}
X  }
X*** src/Old/termcap.c	Sun Oct 15 19:03:02 1989
X--- src/termcap.c	Sun Oct 15 13:05:24 1989
X***************
X*** 2,15 ****
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X- #include <ctype.h>	/* for isdigit() */
X- 
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X  #include "hack.h"	/* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X  
X  #ifndef MSDOS
X  # define TERMLIB	/* include termcap code */
X  #endif
X  
X  #if !defined(SYSV) || defined(TOS) || defined(UNIXPC)
X--- 2,17 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X  /* block some unused #defines to avoid overloading some cpp's */
X  #define MONATTK_H
X  #include "hack.h"	/* for ROWNO, COLNO, *HI, *HE, *AS, *AE */
X  
X+ #include <ctype.h>	/* for isdigit() */
X+ 
X  #ifndef MSDOS
X+ # ifndef MACOS
X  # define TERMLIB	/* include termcap code */
X+ # endif
X  #endif
X  
X  #if !defined(SYSV) || defined(TOS) || defined(UNIXPC)
X***************
X*** 63,79 ****
X  startup()
X  {
X  #ifdef TERMLIB
X! 	register char *term = getenv("TERM");
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  #endif
X  	register int i;
X  
X  	/* Set the default map symbols */
X  	(void) memcpy((genericptr_t) &showsyms, 
X  		(genericptr_t) &defsyms, sizeof(struct symbols));
X  
X! #if !defined(AMIGA) && !defined(TOS)
X  # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X  #  define IBMXASCII
X  # endif
X--- 65,90 ----
X  startup()
X  {
X  #ifdef TERMLIB
X! 	register char *term;
X  	register char *tptr;
X  	char *tbufptr, *pc;
X  #endif
X  	register int i;
X  
X+ #ifdef TERMLIB
X+ # ifdef VMS
X+ 	term = getenv("EMACS_TERM");
X+ 	if (!term)
X+ 	    term = getenv("NETHACK_TERM");
X+ 	if (!term)
X+ # endif
X+ 	term = getenv("TERM");
X+ #endif
X  	/* Set the default map symbols */
X  	(void) memcpy((genericptr_t) &showsyms, 
X  		(genericptr_t) &defsyms, sizeof(struct symbols));
X  
X! #if !defined(AMIGA) && !defined(TOS) && !defined(MACOS)
X  # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X  #  define IBMXASCII
X  # endif
X***************
X*** 120,125 ****
X--- 131,175 ----
X  #if defined(TOS) && defined(__GNUC__) && defined(TERMLIB)
X  		term = "st52";		/* library has a default */
X  #else
X+ # ifdef MACOS
X+ 	/* dummy termcap for the Mac */
X+ 	HO = "\033[H";
X+ 	CL = "\033[2J";     /* a pseudo-ANSI termcap */
X+ 	CE = "\033[K";
X+ 	CM = "\033[%d;%dH"; /* not used */
X+ 	UP = "\033[A";
X+ 	ND = "\033[C";
X+ 	XD = "\033[B";
X+  	BC = "\033[D";
X+  	TI = TE = SE = UE = US = HE = "\033[0m";
X+  	SO = "\033[1m";
X+  	AS = VS = VE = AE = "";
X+  	CO = COLNO;
X+  	LI = ROWNO + 3;
X+  	/* use special font ? */
X+ 	{
X+  	   extern short macflags;
X+  	   if (macflags & fUseCustomFont)
X+ 	    {
X+ 		Handle  theRes;
X+ 		unsigned char   *sym;
X+ 		short   i;
X+ 
X+ 		sym = &showsyms.stone;
X+ 		theRes = GetResource(HACK_DATA,102);
X+ 		HLock(theRes);
X+ 		strncpy((char *)sym,(char *)(*theRes),32);
X+ 		HUnlock(theRes);
X+ 		ReleaseResource(theRes);
X+ 	    }
X+ 	}
X+ #  ifdef TEXTCOLOR
X+ 	for (i = 0; i < MAXCOLORS; i++) {
X+ 	    hilites[i] = (char *) alloc(sizeof("E[cc"));
X+ 	    Sprintf(hilites[i], "\033[c%c", (char)(i+'a'));
X+ 	}
X+ #  endif
X+ # else /* MACOS */
X  # ifdef ANSI_DEFAULT
X  #  ifdef TOS
X  	{
X***************
X*** 190,195 ****
X--- 240,246 ----
X  # else
X  		error("Can't get TERM.");
X  # endif /* ANSI_DEFAULT */
X+ # endif /* MACOS */
X  #endif /* __GNUC__ */
X  #ifdef TERMLIB
X  	tptr = (char *) alloc(1024);
X***************
X*** 401,407 ****
X--- 452,462 ----
X  cmov(x, y)
X  register int x, y;
X  {
X+ #ifdef MACOS
X+ 	mcurs(x-1, y-1);
X+ #else
X  	xputs(tgoto(CM, x-1, y-1));
X+ #endif
X  	cury = y;
X  	curx = x;
X  }
X***************
X*** 410,416 ****
X--- 465,475 ----
X  xputc(c)
X  char c;
X  {
X+ #ifdef MACOS
X+ 	mputc(c);
X+ #else
X  	(void) fputc(c, stdout);
X+ #endif
X  }
X  
X  void
X***************
X*** 417,430 ****
X  xputs(s)
X  char *s;
X  {
X! #ifndef TERMLIB
X  	(void) fputs(s, stdout);
X- #else
X- # ifdef __STDC__
X- 	tputs(s, 1, (int (*)())xputc);
X  # else
X  	tputs(s, 1, xputc);
X  # endif
X  #endif
X  }
X  
X--- 476,493 ----
X  xputs(s)
X  char *s;
X  {
X! #ifndef MACOS
X! # ifndef TERMLIB
X  	(void) fputs(s, stdout);
X  # else
X+ #  ifdef __STDC__
X+ 	tputs(s, 1, (int (*)())xputc);
X+ #  else
X  	tputs(s, 1, xputc);
X+ #  endif
X  # endif
X+ #else
X+ 	mputs(s);
X  #endif
X  }
X  
X***************
X*** 534,540 ****
X  }
X  #endif
X  
X! #ifndef MSDOS
X  # ifdef VMS
X  static const short tmspc10[] = {		/* from termcap */
X  	0, 2000, 1333, 909, 743, 666, 333, 166, 83, 55, 50, 41, 27, 20, 13, 10,
X--- 597,603 ----
X  }
X  #endif
X  
X! #if !defined(MSDOS) && !defined(MACOS)
X  # ifdef VMS
X  static const short tmspc10[] = {		/* from termcap */
X  	0, 2000, 1333, 909, 743, 666, 333, 166, 83, 55, 50, 41, 27, 20, 13, 10,
X***************
X*** 552,558 ****
X  	/* delay 50 ms - could also use a 'nap'-system call */
X  	/* BUG: if the padding character is visible, as it is on the 5620
X  	   then this looks terrible. */
X! #ifdef MSDOS
X  	/* simulate the delay with "cursor here" */
X  	register int i;
X  	for (i = 0; i < 3; i++) {
X--- 615,621 ----
X  	/* delay 50 ms - could also use a 'nap'-system call */
X  	/* BUG: if the padding character is visible, as it is on the 5620
X  	   then this looks terrible. */
X! #if defined(MSDOS) || defined(MACOS)
X  	/* simulate the delay with "cursor here" */
X  	register int i;
X  	for (i = 0; i < 3; i++) {
X***************
X*** 559,576 ****
X  		cmov(curx, cury);
X  		(void) fflush(stdout);
X  	}
X! #else /* MSDOS /**/
X  	if(!flags.nonull)
X! #ifdef TERMINFO
X  		/* cbosgd!cbcephus!pds for SYS V R2 */
X! # ifdef __STDC__
X  		tputs("$<50>", 1, (int (*)())xputc);
X! # else
X  		tputs("$<50>", 1, xputc);
X! # endif
X! #else
X  		tputs("50", 1, xputs);
X! #endif
X  
X  	else if(ospeed > 0 || ospeed < SIZE(tmspc10)) if(CM) {
X  		/* delay by sending cm(here) an appropriate number of times */
X--- 622,639 ----
X  		cmov(curx, cury);
X  		(void) fflush(stdout);
X  	}
X! #else /* MSDOS || MACOS */
X  	if(!flags.nonull)
X! # ifdef TERMINFO
X  		/* cbosgd!cbcephus!pds for SYS V R2 */
X! #  ifdef __STDC__
X  		tputs("$<50>", 1, (int (*)())xputc);
X! #  else
X  		tputs("$<50>", 1, xputc);
X! #  endif
X! # else
X  		tputs("50", 1, xputs);
X! # endif
X  
X  	else if(ospeed > 0 || ospeed < SIZE(tmspc10)) if(CM) {
X  		/* delay by sending cm(here) an appropriate number of times */
X***************
X*** 582,588 ****
X  			i -= cmlen*tmspc10[ospeed];
X  		}
X  	}
X! #endif /* MSDOS /**/
X  }
X  
X  void
X--- 645,651 ----
X  			i -= cmlen*tmspc10[ospeed];
X  		}
X  	}
X! #endif /* MSDOS || MACOS */
X  }
X  
X  void
X*** src/Old/timeout.c	Sun Oct 15 19:03:33 1989
X--- src/timeout.c	Tue Oct  3 21:54:02 1989
X***************
X*** 25,30 ****
X--- 25,56 ----
X  		nomul(-3);
X  }
X  
X+ /* He is getting sicker and sicker prior to vomiting */
X+ static const char *vomiting_texts[] = {
X+ 	"You are feeling mildly nauseous.",	/* 11 */
X+ 	"You feel slightly confused.",		/* 8 */
X+ 	"You can't seem to think straight.",	/* 5 */
X+ 	"You feel incredibly sick.",		/* 2 */
X+ 	"You suddenly vomit!"			/* 0 */
X+ };
X+ 
X+ static void
X+ vomiting_dialogue() {
X+ 	register long i = (Vomiting & TIMEOUT) / 3L;
X+ 
X+ 	if(!((Vomiting & TIMEOUT) % 3L) &&
X+ 	   i >= 0 && i < SIZE(vomiting_texts))
X+ 		pline(vomiting_texts[SIZE(vomiting_texts) - i]);
X+ 
X+ 	switch(i) {
X+ 
X+ 	    case 0:	vomit(); morehungry(20); break;
X+ 	    case 2:	make_confused(HConfusion + d(2,4), FALSE);
X+ 	    case 3:	make_stunned(HStun + d(2,4), FALSE);
X+ 	    default:	break;
X+ 	}
X+ }
X+ 
X  static const char *choke_texts[] = {
X  	"You find it hard to breathe.",
X  	"You're gasping for air.",
X***************
X*** 50,55 ****
X--- 76,82 ----
X  	int sleeptime;
X  
X  	if(Stoned) stoned_dialogue();
X+ 	if(Vomiting) vomiting_dialogue();
X  	if(Strangled) choke_dialogue();
X  #ifdef POLYSELF
X  	if(u.mtimedone) if(!--u.mtimedone) rehumanize();
X***************
X*** 80,85 ****
X--- 107,115 ----
X  		case STONED:
X  			if (!killer) killer = "cockatrice";
X  			done(STONING);
X+ 			break;
X+ 		case VOMITING:
X+ 			make_vomiting(0L, TRUE);
X  			break;
X  		case SICK:
X  			You("die from food poisoning.");
X*** src/Old/topten.c	Sun Oct 15 19:04:05 1989
X--- src/topten.c	Sat Oct 14 22:46:36 1989
X***************
X*** 6,12 ****
X--- 6,17 ----
X  #define MONATTK_H
X  #include "hack.h"
X  
X+ #ifndef MACOS
X  #include <errno.h>	/* George Barbanis */
X+ #else
X+ extern short macflags;
X+ extern WindowPtr	HackWindow;
X+ #endif
X  #ifdef NO_FILE_LINKS
X  #include <fcntl.h>	/* Ralf Brown */
X  #endif
X***************
X*** 73,84 ****
X  # endif /* UNIX or VMS */
X  #endif /* LOGFILE */
X  
X! #ifdef MSDOS
X  #define HUP
X  #else
X  #define	HUP	if(!done_hup)
X  #endif
X! 
X  	/* create a new 'topten' entry */
X  	t0 = newttentry();
X  	t0->level = dlevel;
X--- 78,92 ----
X  # endif /* UNIX or VMS */
X  #endif /* LOGFILE */
X  
X! #if defined(MSDOS) || defined(MACOS)
X  #define HUP
X  #else
X  #define	HUP	if(!done_hup)
X  #endif
X! #ifdef MACOS
X! 	macflags &= ~fDoUpdate;
X! 	uid = TickCount();
X! #endif
X  	/* create a new 'topten' entry */
X  	t0 = newttentry();
X  	t0->level = dlevel;
X***************
X*** 178,184 ****
X--- 186,216 ----
X  		    sleep(1);
X  	}
X  #endif /* UNIX or VMS */
X+ #ifdef MACOS
X+ 	{
X+ 		term_info	*t;
X+ 		
X+ 		t = (term_info *)GetWRefCon(HackWindow);
X+ 		SetVol((StringPtr)0L, t->recordVRefNum);
X+ 		if (!(rfile = fopen(recfile,"r"))) {
X+ 			short	i;
X+ 	
X+ 			rfile = openFile(recfile);
X+ 			
X+ 			t = (term_info *)GetWRefCon(HackWindow);
X+ 			for (i = 0;i < t->maxRow; i++) {
X+ 			    MoveTo(Screen_Border,
X+ 				t->ascent + (i * t->height) + Screen_Border);
X+ 			    DrawText(&t->screen[i][0], 0, t->maxCol);
X+ 			}
X+ 			ValidRect(&(**(*HackWindow).visRgn).rgnBBox);
X+ 		}
X+ 	}
X+ 
X+ 	if (!rfile) {
X+ #else
X  	if(!(rfile = fopen(recfile,"r"))){
X+ #endif
X  		HUP (void) puts("Cannot open record file!");
X  		goto unlock;
X  	}
X***************
X*** 337,347 ****
X  	char linebuf[BUFSZ];
X  	register char *bp;
X  
X! 	Strcpy(linebuf, " No  Points   Name");
X  	bp = eos(linebuf);
X  	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
X  	Strcpy(bp, "Hp [max]");
X  	(void) puts(linebuf);
X  }
X  
X  /* so>0: standout line; so=0: ordinary line; so<0: no output, return lth */
X--- 369,382 ----
X  	char linebuf[BUFSZ];
X  	register char *bp;
X  
X! 	Strcpy(linebuf, " No  Points     Name");
X  	bp = eos(linebuf);
X  	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
X  	Strcpy(bp, "Hp [max]");
X  	(void) puts(linebuf);
X+ #ifdef MACOS
X+ 	putchar('\n');
X+ #endif
X  }
X  
X  /* so>0: standout line; so=0: ordinary line; so<0: no output, return lth */
X***************
X*** 423,429 ****
X--- 458,468 ----
X  	  if (lngr >= hppos) hppos = (2*COLNO) - 7 - strlen(hpbuf);
X  	  if(bp <= linebuf + hppos) {
X  	    /* pad any necessary blanks to the hit point entry */
X+ #ifdef MACOS
X+ 	    while(bp <= linebuf + hppos) *bp++ = ' ';
X+ #else
X  	    while(bp < linebuf + hppos) *bp++ = ' ';
X+ #endif
X  	    Strcpy(bp, hpbuf);
X  	    if(t1->maxhp < 10)
X  		 Sprintf(eos(bp), "   [%d]", t1->maxhp);
X***************
X*** 439,447 ****
X--- 478,492 ----
X  	  while(bp < linebuf + so) *bp++ = ' ';
X  	  *bp = 0;
X  	  standoutbeg();
X+ #ifdef MACOS
X+ 	  puts(linebuf);
X+ #else
X  	  (void) fputs(linebuf,stdout);
X+ #endif
X  	  standoutend();
X+ #ifndef MACOS
X  	  (void) putchar('\n');
X+ #endif
X  	}
X  	return(strlen(linebuf));
X  }
X***************
X*** 506,513 ****
X  #else
X  	char *player0;
X  #endif
X! 
X  	if(!(rfile = fopen(recfile,"r"))){
X  		(void) puts("Cannot open record file!");
X  		return;
X  	}
X--- 551,563 ----
X  #else
X  	char *player0;
X  #endif
X! #ifdef MACOS
X! 	if(!(rfile = fopen(recfile,"r")))
X! 		rfile = openFile(recfile);
X! 	if (!rfile) {
X! #else
X  	if(!(rfile = fopen(recfile,"r"))){
X+ #endif
X  		(void) puts("Cannot open record file!");
X  		return;
X  	}
X***************
X*** 679,686 ****
X--- 729,743 ----
X  
X  	if (!otmp) return((struct obj *) 0);
X  
X+ #ifdef MACOS
X  	if(!(rfile = fopen(recfile,"r")))
X+ 		rfile = openFile(recfile);
X+ 	if (!rfile) {
X+ #else
X+ 	if(!(rfile = fopen(recfile,"r"))){
X+ #endif
X  		panic("Cannot open record file!");
X+ 	}
X  
X  	tt = newttentry();
X  	rank = rnd(10);
X*** src/Old/trap.c	Sun Oct 15 19:04:46 1989
X--- src/trap.c	Sat Oct 14 20:40:15 1989
X***************
X*** 287,293 ****
X  #endif
X  			    unsee();
X  			    (void) fflush(stdout);
X! 			    goto_level(newlevel, FALSE);
X  #ifdef WALKIES
X  			}
X  #endif
X--- 287,293 ----
X  #endif
X  			    unsee();
X  			    (void) fflush(stdout);
X! 			    goto_level(newlevel, FALSE, TRUE);
X  #ifdef WALKIES
X  			}
X  #endif
X***************
X*** 695,701 ****
X  #ifdef WALKIES
X  			if(teleport_pet(mtmp)) {
X  #endif
X! 			    rloc(mtmp);
X  			    if(in_sight && !cansee(mtmp->mx,mtmp->my))
X  				pline("%s suddenly disappears!",
X  					Monnam(mtmp));
X--- 695,706 ----
X  #ifdef WALKIES
X  			if(teleport_pet(mtmp)) {
X  #endif
X! 			    /* Note: don't remove the trap if a vault.  Other-
X! 			     * the monster will be stuck there, since the guard
X! 			     * isn't going to come for it...
X! 			     */
X! 			    if (trap->once) vloc(mtmp);
X! 			    else rloc(mtmp);
X  			    if(in_sight && !cansee(mtmp->mx,mtmp->my))
X  				pline("%s suddenly disappears!",
X  					Monnam(mtmp));
X***************
X*** 989,1006 ****
X  #endif
X  
X  	trap = t_at(u.ux, u.uy);
X! 	if (trap && (!trap->tseen || trap->ttyp != TELEP_TRAP || trap->once))
X  		trap = 0;
X  
X! 	if (trap) 
X! 		You("jump onto the teleportation trap...");
X! 	else if(!Teleportation ||
X  	   (u.ulevel < (pl_character[0] == 'W' ? 8 : 12)
X  #ifdef POLYSELF
X  	    && !can_teleport(uasmon)
X  #endif
X  	   )
X! 	  ) {
X  #ifdef SPELLS
X  		/* Try to use teleport away spell. */
X  		castit = objects[SPE_TELEPORT_AWAY].oc_name_known;
X--- 994,1023 ----
X  #endif
X  
X  	trap = t_at(u.ux, u.uy);
X! 	if (trap && (!trap->tseen || trap->ttyp != TELEP_TRAP))
X  		trap = 0;
X  
X! 	if (trap) {
X! 		if (trap->once) {
X! 			pline("This is a vault teleport, usable once only.");
X! 			pline("Jump in? ");
X! 			if (yn() == 'n')
X! 				trap = 0;
X! 			else {
X! 				deltrap(trap);
X! 				newsym(u.ux, u.uy);
X! 			}
X! 		}
X! 		if (trap)
X! 			You("jump onto the teleportation trap...");
X! 	}
X! 	if(!trap && (!Teleportation ||
X  	   (u.ulevel < (pl_character[0] == 'W' ? 8 : 12)
X  #ifdef POLYSELF
X  	    && !can_teleport(uasmon)
X  #endif
X  	   )
X! 	  )) {
X  #ifdef SPELLS
X  		/* Try to use teleport away spell. */
X  		castit = objects[SPE_TELEPORT_AWAY].oc_name_known;
X***************
X*** 1053,1059 ****
X  #ifdef WALKIES
X  	if(next_to_u()) {
X  #endif
X! 		tele();
X  #ifdef WALKIES
X  		(void) next_to_u();
X  	} else {
X--- 1070,1077 ----
X  #ifdef WALKIES
X  	if(next_to_u()) {
X  #endif
X! 		if (trap && trap->once) vtele();
X! 		else tele();
X  #ifdef WALKIES
X  		(void) next_to_u();
X  	} else {
X***************
X*** 1073,1079 ****
X  		impossible("Where are your chain and ball??");
X  		return;
X  	}
X! 	place_object(uball, u.ux, u.uy);
X  	place_object(uchain, u.ux, u.uy);
X  	if(attach){
X  		uchain->nobj = fobj;
X--- 1091,1098 ----
X  		impossible("Where are your chain and ball??");
X  		return;
X  	}
X! 	if(!carried(uball))
X! 		place_object(uball, u.ux, u.uy);
X  	place_object(uchain, u.ux, u.uy);
X  	if(attach){
X  		uchain->nobj = fobj;
X***************
X*** 1190,1196 ****
X  	    You("shudder for a moment...");
X  	else
X  #endif
X! 	    goto_level(newlevel, FALSE);
X  }
X  
X  void
X--- 1209,1215 ----
X  	    You("shudder for a moment...");
X  	else
X  #endif
X! 	    goto_level(newlevel, FALSE, FALSE);
X  }
X  
X  void
X*** src/Old/uhitm.c	Sun Oct 15 19:06:01 1989
X--- src/uhitm.c	Sun Oct 15 17:25:18 1989
X***************
X*** 873,878 ****
X--- 873,885 ----
X  		    if (!Blind) pline("%s is frozen by you!", Monnam(mdef));
X  		    mdef->mfroz = 1;
X  		}
X+ 	    case AD_SLEE:
X+ 		if (!resists_sleep(mdef->data) && !mdef->msleep &&
X+ 								!mdef->mfroz) {
X+ 		    if (!Blind)
X+ 			pline("%s suddenly falls asleep!", Monnam(mdef));
X+ 		    mdef->msleep = 1;
X+ 		}
X  		break;
X  	    default:	tmp = 0;
X  			break;
X*** src/Old/unixmain.c	Wed Sep 27 23:21:24 1989
X--- src/unixmain.c	Mon Oct 16 22:34:33 1989
X***************
X*** 3,8
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* main.c - Unix NetHack */
X  
X  #include <signal.h>
X  #include <pwd.h>
X  
X
X--- 3,10 -----
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* main.c - Unix NetHack */
X  
X+ #include "hack.h"
X+ 
X  #include <signal.h>
X  #include <pwd.h>
X  
X***************
X*** 5,12
X  
X  #include <signal.h>
X  #include <pwd.h>
X- 
X- #include "hack.h"
X  
X  char SAVEF[PL_NSIZ + 11] = "save/";	/* save/99999player */
X  
X
X--- 7,12 -----
X  
X  #include <signal.h>
X  #include <pwd.h>
X  
X  char SAVEF[PL_NSIZ + 11] = "save/";	/* save/99999player */
X  
X*** src/Old/version.c	Sun Oct 15 19:07:34 1989
X--- src/version.c	Sat Oct 14 22:35:53 1989
X***************
X*** 35,40 ****
X--- 35,43 ----
X  #  endif
X  # endif
X  #endif
X+ #ifdef MACOS
X+ 		"Macintosh",
X+ #endif
X  #ifdef UNIX
X  		"Unix",
X  #endif
X*** src/Old/zap.c	Sun Oct 15 19:09:13 1989
X--- src/zap.c	Thu Oct  5 11:18:40 1989
X***************
X*** 1163,1169 ****
X  			shieldeff(mon->mx, mon->my);
X  			break;
X  		    }
X! 		    type = 0; /* so they don't get saving throws */
X  		}
X  		tmp = mon->mhp+1;
X  		break;
X--- 1163,1172 ----
X  			shieldeff(mon->mx, mon->my);
X  			break;
X  		    }
X! 		    type = -1; /* so they don't get saving throws */
X! 		} else if (resists_disint(mon->data)) {
X! 		    shieldeff(mon->mx, mon->my);
X! 		    break;
X  		}
X  		tmp = mon->mhp+1;
X  		break;
X***************
X*** 1535,1548 ****
X  				    break;
X  				case 4:		/* death */
X  				    if(type == -24) { /* disintegration */
X! 					if(uarms) {
X  					    (void) destroy_arm(uarms);
X! 					} else if (uarm) {
X! 				if (Disint_resistance & WORN_ARMOR)
X! 					Your("armor absorbs the blast!");
X! 				else (void) destroy_arm(uarm);
X  					}
X- 				    break;
X  				    }
X  #ifdef POLYSELF
X  				    else if(is_undead(uasmon)) {
X--- 1538,1553 ----
X  				    break;
X  				case 4:		/* death */
X  				    if(type == -24) { /* disintegration */
X! 					if (Disint_resistance) {
X! 					    You("are not disintegrated.");
X! 					    break;
X! 					} else if(uarms) {
X  					    (void) destroy_arm(uarms);
X! 					    break;
X! 					} else if (uarm)  {
X! 					    (void) destroy_arm(uarm);
X! 					    break;
X  					}
X  				    }
X  #ifdef POLYSELF
X  				    else if(is_undead(uasmon)) {
X*** src/Old/Makefile.src	Sun Oct 15 19:47:21 1989
X--- src/Makefile.src	Wed Oct  4 11:04:24 1989
X***************
X*** 103,113 ****
X  
X  CSOURCES = $(HACKCSRC) $(TARGSRC) $(MAKESRC) $(SPLEVSRC)
X  
X! HACKINCL = artifact.h attrib.h config.h coord.h decl.h edog.h epri.h eshk.h\
X! 	   extern.h flag.h func_tab.h global.h gold.h hack.h lev.h mfndpos.h\
X! 	   mkroom.h monattk.h mondata.h monflag.h monst.h monsym.h msdos.h\
X! 	   obj.h objclass.h permonst.h prop.h rm.h sp_lev.h spell.h tradstdc.h\
X! 	   trapname.h vault.h wseg.h you.h youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X--- 103,115 ----
X  
X  CSOURCES = $(HACKCSRC) $(TARGSRC) $(MAKESRC) $(SPLEVSRC)
X  
X! HACKINCL = amiconf.h artifact.h attrib.h color.h config.h coord.h decl.h\
X! 	   def_os2.h edog.h epri.h eshk.h extern.h flag.h func_tab.h global.h\
X! 	   gold.h hack.h lev.h mfndpos.h mkroom.h monattk.h mondata.h monflag.h\
X! 	   monst.h monsym.h msdos.h obj.h objclass.h patchlevel.h pcconf.h\
X! 	   permonst.h prop.h rm.h sp_lev.h spell.h system.h tosconf.h\
X! 	   tradstdc.h trapname.h unixconf.h vault.h vmsconf.h wseg.h you.h\
X! 	   youprop.h
X  
X  # all .h files except date.h, onames.h, pm.h & trap.h which would cause
X  # dependency loops if run through "make depend".
X***************
X*** 290,306 ****
X  #		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X  #			-e 's,<\(.*\)>,"/usr/include/\1",' \
X  #
X  #
X  	for i in ${HACKCSRC}; do \
X  		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X  			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X  			-e 's/.*\.h/..\/include\/&/' \
X  			-e H -e '$$g' -e '$$s/\n/ /g' \
X  			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X  			>> makedep); done
X  	for i in ${HACKINCL}; do \
X! 		( /bin/grep '^#[ 	]*include[ 	]*"' ../include/$$i | sed -n \
X  			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X  			-e 's/.*\.h/..\/include\/&/' \
X  			-e H -e '$$g' -e '$$s/\n/ /g' \
X  			-e '$$s/.*/..\/include\/'$$i': &\
X--- 292,318 ----
X  #		( /bin/grep '^#[ 	]*include' $$i | sed -n \
X  #			-e 's,<\(.*\)>,"/usr/include/\1",' \
X  #
X+ # extern.h is ignored, even though its declared function types may affect the
X+ # compilation of all the .c files, since extern.h changes every time the
X+ # type of an external function does, and we would spend all our time recompiling
X+ # if we did not ignore it.  the risk is minimal, as lint should pick up any
X+ # calls to the modified function that were not modified accordingly.
X  #
X+ # patchlev.h is the name MS-DOS uses to refer to patchlevel.h after it gets
X+ # through truncating the name, but it does not really exist
X+ #
X  	for i in ${HACKCSRC}; do \
X  		( /bin/grep '^#[ 	]*include[ 	]*"' $$i | sed -n \
X  			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X+ 			-e 's/patchlev.h//' \
X  			-e 's/.*\.h/..\/include\/&/' \
X  			-e H -e '$$g' -e '$$s/\n/ /g' \
X  			-e '$$s/.*/'$$i': &/' -e '$$s/\.c:/.o:/p' \
X  			>> makedep); done
X  	for i in ${HACKINCL}; do \
X! 	    ( /bin/grep '^#[ 	]*include[ 	]*"' ../include/$$i | sed -n \
X  			-e 's/[^"]*"\([^"]*\)".*/\1/' \
X+ 			-e 's/extern.h//' \
X  			-e 's/.*\.h/..\/include\/&/' \
X  			-e H -e '$$g' -e '$$s/\n/ /g' \
X  			-e '$$s/.*/..\/include\/'$$i': &\
X***************
X*** 315,321 ****
X  	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X  	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X  	@echo '# see make depend above' >> Makefile
X! 	- diff Makefile Makefile.bak
X  	@rm -f Makefile.bak
X  
X  # PC dependency for Systos that won't be made on a UNIX system
X--- 327,333 ----
X  	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
X  	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
X  	@echo '# see make depend above' >> Makefile
X! 	- diff Makefile.bak Makefile
X  	@rm -f Makefile.bak
X  
X  # PC dependency for Systos that won't be made on a UNIX system
X***************
X*** 363,373 ****
X  mon.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h ../include/wseg.h
X  mondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
X  monmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
X! monst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h ../include/decl.h
X  mthrowu.o:  ../include/hack.h
X  music.o:  ../include/hack.h
X  o_init.o:  ../include/hack.h
X! objects.o:  ../include/config.h ../include/obj.h ../include/objclass.h ../include/prop.h ../include/decl.h
X  objnam.o:  ../include/hack.h
X  options.o:  ../include/hack.h
X  pager.o:  ../include/hack.h
X--- 375,385 ----
X  mon.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h ../include/wseg.h
X  mondata.o:  ../include/hack.h ../include/eshk.h ../include/epri.h
X  monmove.o:  ../include/hack.h ../include/mfndpos.h ../include/artifact.h
X! monst.o:  ../include/config.h ../include/permonst.h ../include/monsym.h ../include/eshk.h ../include/vault.h ../include/epri.h ../include/color.h
X  mthrowu.o:  ../include/hack.h
X  music.o:  ../include/hack.h
X  o_init.o:  ../include/hack.h
X! objects.o:  ../include/config.h ../include/obj.h ../include/objclass.h ../include/prop.h ../include/color.h
X  objnam.o:  ../include/hack.h
X  options.o:  ../include/hack.h
X  pager.o:  ../include/hack.h
X***************
X*** 401,407 ****
X  u_init.o:  ../include/hack.h
X  uhitm.o:  ../include/hack.h ../include/artifact.h
X  vault.o:  ../include/hack.h ../include/vault.h
X! version.o:  ../include/hack.h ../include/date.h ../include/patchlevel.h
X  weapon.o:  ../include/hack.h
X  were.o:  ../include/hack.h
X  wield.o:  ../include/hack.h
X--- 413,419 ----
X  u_init.o:  ../include/hack.h
X  uhitm.o:  ../include/hack.h ../include/artifact.h
X  vault.o:  ../include/hack.h ../include/vault.h
X! version.o:  ../include/hack.h ../include/date.h  ../include/patchlevel.h
X  weapon.o:  ../include/hack.h
X  were.o:  ../include/hack.h
X  wield.o:  ../include/hack.h
X***************
X*** 410,425 ****
X  worn.o:  ../include/hack.h
X  write.o:  ../include/hack.h
X  zap.o:  ../include/hack.h
X  ../include/config.h:  ../include/tradstdc.h ../include/global.h
X  			touch ../include/config.h
X! ../include/decl.h:  ../include/spell.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X  			touch ../include/decl.h
X  ../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h
X  			touch ../include/global.h
X! ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h ../include/extern.h
X  			touch ../include/hack.h
X  ../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X  			touch ../include/permonst.h
X  ../include/you.h:  ../include/attrib.h ../include/monst.h ../include/youprop.h
X  			touch ../include/you.h
X  ../include/youprop.h:  ../include/prop.h ../include/permonst.h ../include/mondata.h ../include/pm.h
X--- 422,447 ----
X  worn.o:  ../include/hack.h
X  write.o:  ../include/hack.h
X  zap.o:  ../include/hack.h
X+ ../include/amiconf.h:  ../include/msdos.h ../include/pcconf.h
X+ 			touch ../include/amiconf.h
X  ../include/config.h:  ../include/tradstdc.h ../include/global.h
X  			touch ../include/config.h
X! ../include/decl.h:  ../include/spell.h ../include/color.h ../include/obj.h ../include/you.h ../include/onames.h ../include/pm.h
X  			touch ../include/decl.h
X  ../include/global.h:  ../include/coord.h ../include/vmsconf.h ../include/unixconf.h ../include/pcconf.h ../include/tosconf.h ../include/amiconf.h
X  			touch ../include/global.h
X! ../include/hack.h:  ../include/config.h ../include/decl.h ../include/monsym.h ../include/mkroom.h ../include/objclass.h ../include/gold.h ../include/trap.h ../include/flag.h ../include/rm.h 
X  			touch ../include/hack.h
X+ ../include/pcconf.h:  ../include/msdos.h ../include/system.h
X+ 			touch ../include/pcconf.h
X  ../include/permonst.h:  ../include/monattk.h ../include/monflag.h
X  			touch ../include/permonst.h
X+ ../include/tosconf.h:  ../include/msdos.h ../include/pcconf.h
X+ 			touch ../include/tosconf.h
X+ ../include/unixconf.h:  ../include/system.h
X+ 			touch ../include/unixconf.h
X+ ../include/vmsconf.h:  ../include/system.h
X+ 			touch ../include/vmsconf.h
X  ../include/you.h:  ../include/attrib.h ../include/monst.h ../include/youprop.h
X  			touch ../include/you.h
X  ../include/youprop.h:  ../include/prop.h ../include/permonst.h ../include/mondata.h ../include/pm.h
X
END_OF_FILE
if test 42408 -ne `wc -c <'patches05f'`; then
    echo shar: \"'patches05f'\" unpacked with wrong size!
fi
# end of 'patches05f'
fi
echo shar: End of archive 6 \(of 6\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
