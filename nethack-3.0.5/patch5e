Path: utzoo!attcan!utgpu!jarvis.csri.toronto.edu!mailrus!cs.utexas.edu!uunet!zephyr.ens.tek.com!tekgen!tekred!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v08i052:  NetHack3 -  display oriented dungeons & dragons (Ver. 3.0), Patch5e
Message-ID: <4703@tekred.CNA.TEK.COM>
Date: 17 Oct 89 20:27:04 GMT
Sender: nobody@tekred.CNA.TEK.COM
Lines: 2075
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Izchak Miller <izchak@linc.cis.upenn.edu>
Posting-number: Volume 8, Issue 52
Archive-name: NetHack3/Patch5e
Patch-To: NetHack3: Volume 7, Issue 56-93

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 6)."
# Contents:  patches05e
# Wrapped by billr@saab on Tue Oct 17 13:16:59 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patches05e' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patches05e'\"
else
echo shar: Extracting \"'patches05e'\" \(54469 characters\)
sed "s/^X//" >'patches05e' <<'END_OF_FILE'
X*** src/Old/makedefs.c	Sun Oct 15 18:43:44 1989
X--- src/makedefs.c	Sat Oct 14 22:04:16 1989
X***************
X*** 2,8 ****
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* makedefs.c - NetHack version 3.0 */
X  
X! #define MAKEDEFS_C
X  
X  #define EXTERN_H
X  #include	"config.h"
X--- 2,8 ----
X  /* NetHack may be freely redistributed.  See license for details. */
X  /* makedefs.c - NetHack version 3.0 */
X  
X! #define MAKEDEFS_C 1	/* needs to be defined to 1 for Mac */
X  
X  #define EXTERN_H
X  #include	"config.h"
X***************
X*** 52,57 ****
X--- 52,59 ----
X  # define DATA_FILE	 "auxil:data"
X  # define RUMOR_FILE	 "auxil:rumors"
X  #else
X+ # ifndef MACOS
X+ /* construct definitions of object constants */
X  # define MONST_FILE	 "../include/pm.h"
X  # define ONAME_FILE	 "../include/onames.h"
X  # define TRAP_FILE	 "../include/trap.h"
X***************
X*** 58,68 ****
X--- 60,93 ----
X  # define DATE_FILE	 "../include/date.h"
X  # define DATA_FILE	 "../auxil/data"
X  # define RUMOR_FILE	 "../auxil/rumors"
X+ # else
X+ /*****
X+  * MAC OS uses ':' to separate dir's and filenames.
X+  * The following (partial) pathnames assume the makedefs program
X+  * runs in the same directory as the include and auxil directories
X+  *****/
X+ # define MONST_FILE	":include:pm.h"
X+ # define ONAME_FILE	":include:onames.h"
X+ # define TRAP_FILE	":include:trap.h"
X+ # define DATE_FILE	":include:date.h"
X+ # define DATA_FILE	":auxil:data"
X+ # define RUMOR_FILE	":auxil:rumors"
X+ #  ifdef AZTEC
X+ #define	perror(x)	Printf(x)
X+ #include "Controls.h"
X+ #  else
X+ #include "ControlMgr.h"
X+ #  endif
X+ # endif
X  #endif
X  
X+ 
X  char	in_line[256];
X  extern char *gets P((char *));
X  void do_objs(), do_traps(), do_data(), do_date(), do_permonst(), do_rumors();
X+ #ifdef SMALLDATA
X+ void do_monst(), save_resource();
X+ #endif
X  char *limit P((char *,BOOLEAN_P));
X  FILE *_freopen();
X  
X***************
X*** 72,80 ****
X  char	*argv[];
X  {
X  	char	*option;
X! 
X  	if(argc == 2) {
X  	    option = argv[1];
X  	    switch (option[1]) {
X  
X  		case 'o':
X--- 97,164 ----
X  char	*argv[];
X  {
X  	char	*option;
X! #ifdef MACOS
X! 	DialogPtr	dialog;
X! 	char	params[3], *options;
X! 	short	itemHit, lastItem, type;
X! 	Rect	box;
X! 	ControlHandle	theControl;
X! 	GrafPtr	oldPort;
X! 
X! #define	OK_BUTTON	1
X! #define	CANCEL_BUTTON	2
X! #define	FIRST_RADIO_BUTTON	3
X! #define	ON	1
X! #define	OFF	0
X! 
X! 	/* standard Mac initialization */
X! 	InitGraf(&MAINGRAFPORT);
X! 	
X! 	InitFonts();
X! 	InitWindows();
X! 	InitMenus();
X! 	InitCursor();
X! 	FlushEvents(everyEvent,0);
X! 	InitDialogs(NULL);
X! 	
X! 	params[0] = '-';
X! 	options = "DVPRTOM";
X! 	dialog = GetNewDialog(200, 0L, (WindowPtr) -1);
X! 	GetPort(&oldPort);
X! 	SetPort(dialog);
X! 	GetDItem(dialog, OK_BUTTON, &type, &theControl, &box);
X! 	LocalToGlobal(&box.top);
X! 	LocalToGlobal(&box.bottom);
X! 	SetPort(oldPort);
X! 	PenSize(3, 3);
X! 	InsetRect(&box, -4, -4);
X! 	FrameRoundRect(&box, 16, 16);
X! 	PenSize(1, 1);
X! 	itemHit = 0;
X! 	do {
X! 		lastItem = itemHit;
X! 		ModalDialog(NULL, &itemHit);
X! 		if (itemHit != lastItem && itemHit > CANCEL_BUTTON) {
X! 			if (lastItem) {
X! 				GetDItem(dialog, lastItem, &type,
X! 						&theControl, &box);
X! 				SetCtlValue(theControl, OFF);
X! 			}
X! 			params[1] = options[itemHit - FIRST_RADIO_BUTTON];
X! 			GetDItem(dialog, itemHit, &type, &theControl, &box);
X! 			SetCtlValue(theControl, ON);
X! 		}
X! 	} while (itemHit >= FIRST_RADIO_BUTTON);
X! 	DisposDialog(dialog);
X! 	argc = 1;
X! 	if (itemHit == OK_BUTTON && lastItem >= FIRST_RADIO_BUTTON) {
X! 		argc = 2;
X! 		option = params;
X! 	
X! #else
X  	if(argc == 2) {
X  	    option = argv[1];
X+ #endif
X  	    switch (option[1]) {
X  
X  		case 'o':
X***************
X*** 99,107 ****
X  		case 'r':
X  		case 'R':	do_rumors();
X  				break;
X  
X  		default:
X! 				(void) fprintf(stderr, "Unknown option '%c'.\n", option[1]);
X  				(void) fflush(stderr);
X  				exit(1);
X  	    }
X--- 183,198 ----
X  		case 'r':
X  		case 'R':	do_rumors();
X  				break;
X+ #if defined(SMALLDATA) && defined(MACOS)
X+ 		case 'm':
X+ 		case 'M':	do_monst();
X+ 				break;
X+ 		
X+ #endif	/* SMALLDATA && MACOS */
X  
X  		default:
X! 				(void) fprintf(stderr,
X! 					"Unknown option '%c'.\n", option[1]);
X  				(void) fflush(stderr);
X  				exit(1);
X  	    }
X***************
X*** 217,224 ****
X--- 308,320 ----
X  	}
X  	Printf("/*\tSCCS Id: @(#)date.h\t3.0\t88/11/20 */\n\n");
X  
X+ #ifdef KR1ED
X  	(void) time(&clock);
X  	Strcpy(cbuf, ctime(&clock));
X+ #else
X+ 	(void) time((time_t *)&clock);
X+ 	Strcpy(cbuf, ctime((time_t *)&clock));
X+ #endif
X  	for(c = cbuf; *c != '\n'; c++);	*c = 0; /* strip off the '\n' */
X  	Printf("const char datestring[] = \"%s\";\n", cbuf);
X  
X***************
X*** 352,358 ****
X  		/* make sure probabilities add up to 1000 */
X  		if(objects[i].oc_olet != let) {
X  			if (sum && sum != 1000) {
X! 			    (void) fprintf(stderr, "prob error for %c (%d%%)", let, sum);
X  			    (void) fflush(stderr);
X  			    sumerr = TRUE;
X  			}
X--- 448,455 ----
X  		/* make sure probabilities add up to 1000 */
X  		if(objects[i].oc_olet != let) {
X  			if (sum && sum != 1000) {
X! 			    (void) fprintf(stderr,
X! 					"prob error for %c (%d%%)", let, sum);
X  			    (void) fflush(stderr);
X  			    sumerr = TRUE;
X  			}
X***************
X*** 381,387 ****
X  		    case GEM_SYM:
X  			/* avoid trouble with stupid C preprocessors */
X  			if(objects[i].oc_material == GLASS) {
X! 			    Printf("/* #define\t%s\t%d */\n", objects[i].oc_name, i);
X  			    continue;
X  			}
X  		    default:
X--- 478,485 ----
X  		    case GEM_SYM:
X  			/* avoid trouble with stupid C preprocessors */
X  			if(objects[i].oc_material == GLASS) {
X! 			    Printf("/* #define\t%s\t%d */\n",
X! 							objects[i].oc_name, i);
X  			    continue;
X  			}
X  		    default:
X***************
X*** 451,453 ****
X--- 549,651 ----
X  }
X  # endif
X  #endif /* MSDOS */
X+ 
X+ #if defined(SMALLDATA) && defined(MACOS)
X+ void
X+ do_monst()
X+ {
X+ 	Handle	data;
X+ 	short i,j;
X+ 	pmstr	*pmMonst;
X+ 	
X+ 	for(i = 0; mons[i].mlet; i++) {
X+ 		;
X+ 	}
X+ 	i++;
X+ 	
X+ 	/*
X+ 	 * convert to struct where character arrays instead of pointers to
X+ 	 * strings are used
X+ 	 */
X+ 	pmMonst = (pmstr *)NewPtr(i*sizeof(struct pmstr));
X+ 	for (j = 0; j < i; j++) {
X+ 		Strcpy(pmMonst[j].mname, mons[j].mname);
X+ 		BlockMove(&(mons[j].mlet), &(pmMonst[j].pmp.mlet),
X+ 				(long)sizeof(struct pmpart));
X+ 	}
X+ 	
X+ 	PtrToHand((Ptr)pmMonst, &data, (long)(i * sizeof(struct pmstr)));
X+ 	save_resource(data);
X+ 	DisposHandle(data);
X+ }
X+ 
X+ 
X+ void
X+ save_resource(data)
X+ Handle	data;
X+ {
X+ 	SFReply	reply;
X+ 	short	refNum,error;
X+ 	Str255	name;
X+ 	ResType	theType;
X+ 	Handle	theRes;
X+ 	short	findNamedFile();
X+ #define MONST_DATA_ID	101
X+ 
X+ 	strcpy((char *)&name[0], "\014Nethack.rsrc");
X+ 	if (findNamedFile(&name[1], 0, &reply)) {
X+ 	    strncpy((char *)&name[0],(char *)&reply.fName[1], reply.fName[0]);
X+ 	    name[reply.fName[0]] = '\0';
X+ 	    if ((refNum = OpenResFile(name)) != -1) {
X+ 		if (ResError() == noErr) {
X+ 		    theType = HACK_DATA;
X+ 		    strcpy((char *)&name[0], "\012MONST_DATA");
X+ 		    error = CurResFile();
X+ 		    if (theRes = GetResource(theType, MONST_DATA_ID)) {
X+ 			RmveResource(theRes);
X+ 			error = ResError();
X+ 			if (error == noErr) {
X+ 			    DisposHandle(theRes);
X+ 			    UpdateResFile(refNum);
X+ 			    error = ResError();
X+ 			    if (error != noErr)
X+ 				SysBeep(1);
X+ 			} else {
X+ 			    Printf("Couldn't remove old copy of data resource.");
X+ 			    return;
X+ 			}
X+ 		    } else if (ResError() != resNotFound && ResError() != noErr) {
X+ 			SysBeep(1);
X+ 			Printf("Resource file is protected.");
X+ 			return;
X+ 		    }
X+ 		    AddResource(data, theType, MONST_DATA_ID, name);
X+ 		    error = ResError();
X+ 		    if (error != noErr) {
X+ 			SysBeep(1);
X+ 			Printf("Couldn't add data resource.");
X+ 		    } else {
X+ 			WriteResource(data);
X+ 			error = ResError();
X+ 			if (error != noErr) {
X+ 			    SysBeep(1);
X+ 			    Printf("Couldn't write data resource.");
X+ 			}
X+ 		    }
X+ 		    CloseResFile(refNum);
X+ 		    if (ResError() != noErr) {
X+ 			SysBeep(1);
X+ 			Printf("Couldn't close resource file.");
X+ 		    }
X+ 		}
X+ 	    }
X+ 	}
X+ }
X+ # if defined(AZTEC) || defined(THINKC4)
X+ int
X+ getpid()
X+ {
X+ 	return 1;
X+ }
X+ # endif
X+ #endif	/* SMALLDATA && MACOS */
X*** src/Old/makemon.c	Sun Oct 15 18:44:24 1989
X--- src/makemon.c	Sat Oct 14 23:23:07 1989
X***************
X*** 522,527 ****
X--- 522,528 ----
X  		case S_LEPRECHAUN:
X  			mtmp->msleep = 1;
X  			break;
X+ 		case S_JABBERWOCK:
X  		case S_NYMPH:
X  			if(rn2(5) && !u.uhave_amulet) mtmp->msleep = 1;
X  			break;
X***************
X*** 658,691 ****
X  	return 1;
X  }
X  
X! void
X! rloc(mtmp)
X  struct monst *mtmp;
X  {
X- 	register int tx, ty;
X- 
X  #ifdef WORM		/* do not relocate worms */
X  	if(mtmp->wormno && mtmp->mx) return;
X  #endif
X- 	/* if the wiz teleports away to heal, try the up staircase,
X- 	   to block the player's escaping before he's healed */
X- 	if(!mtmp->iswiz || !goodpos(tx = xupstair, ty = yupstair, mtmp->data))
X- 	   do {
X- 		tx = rn1(COLNO-3,2);
X- 		ty = rn2(ROWNO);
X- 	   } while(!goodpos(tx,ty,mtmp->data));
X  	if(mtmp->mx != 0 && mtmp->my != 0)
X  		remove_monster(mtmp->mx, mtmp->my);
X! 	place_monster(mtmp, tx, ty);
X  	if(u.ustuck == mtmp){
X  		if(u.uswallow) {
X! 			u.ux = tx;
X! 			u.uy = ty;
X  			docrt();
X  		} else	u.ustuck = 0;
X  	}
X  	pmon(mtmp);
X  	set_apparxy(mtmp);
X  }
X  
X  static int
X--- 659,719 ----
X  	return 1;
X  }
X  
X! static void
X! rloc_to(mtmp, x, y)
X  struct monst *mtmp;
X+ register int x,y;
X  {
X  #ifdef WORM		/* do not relocate worms */
X  	if(mtmp->wormno && mtmp->mx) return;
X  #endif
X  	if(mtmp->mx != 0 && mtmp->my != 0)
X  		remove_monster(mtmp->mx, mtmp->my);
X! 	place_monster(mtmp, x, y);
X  	if(u.ustuck == mtmp){
X  		if(u.uswallow) {
X! 			u.ux = x;
X! 			u.uy = y;
X  			docrt();
X  		} else	u.ustuck = 0;
X  	}
X  	pmon(mtmp);
X  	set_apparxy(mtmp);
X+ }
X+ 
X+ void
X+ rloc(mtmp)
X+ struct monst *mtmp;
X+ {
X+ 	register int x, y;
X+ 
X+ 	/* if the wiz teleports away to heal, try the up staircase,
X+ 	   to block the player's escaping before he's healed */
X+ 	if(!mtmp->iswiz || !goodpos(x = xupstair, y = yupstair, mtmp->data))
X+ 	   do {
X+ 		x = rn1(COLNO-3,2);
X+ 		y = rn2(ROWNO);
X+ 	   } while(!goodpos(x,y,mtmp->data));
X+ 	rloc_to(mtmp, x, y);
X+ }
X+ 
X+ void
X+ vloc(mtmp)
X+ struct monst *mtmp;
X+ {
X+ 	register struct mkroom *croom;
X+ 	register int x, y;
X+ 
X+ 	for(croom = &rooms[0]; croom->hx >= 0; croom++)
X+ 	    if(croom->rtype == VAULT) {
X+ 		x = rn2(2) ? croom->lx : croom->hx;
X+ 		y = rn2(2) ? croom->ly : croom->hy;
X+ 		if(goodpos(x, y, mtmp->data)) {
X+ 		    rloc_to(mtmp, x, y);
X+ 		    return;
X+ 		}
X+ 	    }
X+ 	rloc(mtmp);
X  }
X  
X  static int
X*** src/Old/mhitm.c	Sun Oct 15 18:45:23 1989
X--- src/mhitm.c	Sun Oct 15 17:25:06 1989
X***************
X*** 453,459 ****
X  		}
X  		break;
X  	    case AD_SLEE:
X! 		if(!resists_sleep(pd) && !magr->mcan && vis && !mdef->msleep) {
X  		    pline("%s falls asleep.", Monnam(mdef));
X  		    mdef->msleep = 1;
X  		}
X--- 453,460 ----
X  		}
X  		break;
X  	    case AD_SLEE:
X! 		if(!resists_sleep(pd) && !magr->mcan && vis && !mdef->msleep
X! 							&& !mdef->mfroz) {
X  		    pline("%s falls asleep.", Monnam(mdef));
X  		    mdef->msleep = 1;
X  		}
X*** src/Old/mkobj.c	Sun Oct 15 18:47:44 1989
X--- src/mkobj.c	Fri Oct  6 18:42:51 1989
X***************
X*** 239,245 ****
X  #endif
X  		break;
X  	case FOOD_SYM:
X! 		OEATEN(otmp) = 0L;
X  		if(otmp->otyp == CORPSE) {
X  		    /* overridden by mkcorpstat() */
X  		    do otmp->corpsenm = rndmonnum();
X--- 239,245 ----
X  #endif
X  		break;
X  	case FOOD_SYM:
X! 		otmp->oeaten = FALSE;
X  		if(otmp->otyp == CORPSE) {
X  		    /* overridden by mkcorpstat() */
X  		    do otmp->corpsenm = rndmonnum();
X***************
X*** 574,579 ****
X--- 574,586 ----
X  register struct obj *otmp;
X  {
X  	return(objects[otmp->otyp].oc_material == COPPER);
X+ }
X+ 
X+ boolean
X+ OBJ_AT(x, y)
X+ int x, y;
X+ {
X+ 	return(level.objects[x][y] != (struct obj *)0);
X  }
X  #endif
X  
X*** src/Old/mon.c	Sun Oct 15 18:48:23 1989
X--- src/mon.c	Sun Oct 15 17:25:11 1989
X***************
X*** 2,7 ****
X--- 2,11 ----
X  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ #ifdef MICROPORT_BUG
X+ #define MKROOM_H
X+ #endif
X+ 
X  #include "hack.h"
X  #include "mfndpos.h"
X  #ifdef NAMED_ITEMS
X***************
X*** 174,185 ****
X  		  inpool = is_pool(mtmp->mx,mtmp->my);
X  		  iseel = mtmp->data->mlet == S_EEL;
X  		  isgremlin = mtmp->data->mlet == S_GREMLIN;
X  		  infountain = IS_FOUNTAIN(levl[mtmp->mx][mtmp->my].typ);
X  		/* Gremlin multiplying won't go on forever since the hit points
X  		 * keep going down, and when it gets to 1 hit point the clone
X  		 * function will fail.
X  		 */
X! 		  if((inpool || infountain) && isgremlin && rn2(3)) {
X  			struct monst *mtmp2 = clone_mon(mtmp);
X  
X  			if (mtmp2) {
X--- 178,195 ----
X  		  inpool = is_pool(mtmp->mx,mtmp->my);
X  		  iseel = mtmp->data->mlet == S_EEL;
X  		  isgremlin = mtmp->data->mlet == S_GREMLIN;
X+ #ifdef FOUNTAINS
X  		  infountain = IS_FOUNTAIN(levl[mtmp->mx][mtmp->my].typ);
X+ #endif
X  		/* Gremlin multiplying won't go on forever since the hit points
X  		 * keep going down, and when it gets to 1 hit point the clone
X  		 * function will fail.
X  		 */
X! 		  if((inpool
X! #ifdef FOUNTAINS
X! 			     || infountain
X! #endif
X! 					  ) && isgremlin && rn2(3)) {
X  			struct monst *mtmp2 = clone_mon(mtmp);
X  
X  			if (mtmp2) {
X***************
X*** 819,825 ****
X  	    if(!cansee(mtmp->mx,mtmp->my)) You("destroy it!");
X  	    else {
X  		You("destroy %s!",
X! 			mtmp->mtame ? a_monnam(mtmp, "poor") : mon_nam(mtmp));
X  	    }
X  	}
X  
X--- 829,835 ----
X  	    if(!cansee(mtmp->mx,mtmp->my)) You("destroy it!");
X  	    else {
X  		You("destroy %s!",
X! 			mtmp->mtame ? a2_monnam(mtmp, "poor") : mon_nam(mtmp));
X  	    }
X  	}
X  
X***************
X*** 1155,1161 ****
X  	if(cansee(mtmp->mx,mtmp->my) &&
X  		(!Stealth || (mtmp->data == &mons[PM_ETTIN] && rn2(10))) &&
X  		(!(mtmp->data->mlet == S_NYMPH
X! 		   || mtmp->data->mlet == S_LEPRECHAUN) || !rn2(50)) &&
X  		(Aggravate_monster ||
X  		 (mtmp->data->mlet == S_DOG || mtmp->data->mlet == S_HUMAN) ||
X  		(!rn2(7) && !mtmp->mimic))) {
X--- 1165,1172 ----
X  	if(cansee(mtmp->mx,mtmp->my) &&
X  		(!Stealth || (mtmp->data == &mons[PM_ETTIN] && rn2(10))) &&
X  		(!(mtmp->data->mlet == S_NYMPH
X! 			|| mtmp->data == &mons[PM_JABBERWOCK]
X! 			|| mtmp->data->mlet == S_LEPRECHAUN) || !rn2(50)) &&
X  		(Aggravate_monster ||
X  		 (mtmp->data->mlet == S_DOG || mtmp->data->mlet == S_HUMAN) ||
X  		(!rn2(7) && !mtmp->mimic))) {
X*** src/Old/monmove.c	Sun Oct 15 18:49:29 1989
X--- src/monmove.c	Fri Oct 13 21:26:40 1989
X***************
X*** 108,115 ****
X  int x, y;
X  struct monst *mtmp;
X  {
X  	if (mtmp->isshk || mtmp->isgd || mtmp->iswiz || !mtmp->mcansee ||
X! 			mtmp->data->mlet == S_HUMAN || mtmp->mpeaceful)
X  		return(FALSE);
X  	return(
X  #ifdef ELBERETH
X--- 108,120 ----
X  int x, y;
X  struct monst *mtmp;
X  {
X+ 	/* Note: minotaurs must be immune to scare monster to avoid abuse
X+ 	 * from creating them and taking their wands, then polymorphing 60
X+ 	 * or so wands to get wishing...
X+ 	 */
X  	if (mtmp->isshk || mtmp->isgd || mtmp->iswiz || !mtmp->mcansee ||
X! 			mtmp->data->mlet == S_HUMAN || mtmp->mpeaceful ||
X! 			mtmp->data == &mons[PM_MINOTAUR])
X  		return(FALSE);
X  	return(
X  #ifdef ELBERETH
X***************
X*** 740,745 ****
X--- 745,757 ----
X  /*
X   * Functions for encapsulation of level.monsters references.
X   */
X+ boolean
X+ MON_AT(x, y)
X+ int x, y;
X+ {
X+     return(level.monsters[x][y] != (struct monst *)0);
X+ }
X+ 
X  void place_monster(mtmp, x, y)
X  register struct monst *mtmp;
X  int x, y;
X*** src/Old/monst.c	Sun Oct 15 18:50:20 1989
X--- src/monst.c	Sun Oct 15 17:15:18 1989
X***************
X*** 6,11 ****
X--- 6,12 ----
X   * function declarations for all of nethack
X   */
X  #define EXTERN_H
X+ /* #define MAKEDEFS_C	1	/* define for Macs when compiling makedefs */
X  #include "config.h"
X  #include "permonst.h"
X  #include "monsym.h"
X***************
X*** 19,25 ****
X  #undef C
X  #endif
X  #ifdef TEXTCOLOR
X! #include "decl.h"	/* for colors */
X  #define C(color)	color
X  #else
X  #define C(color)
X--- 20,26 ----
X  #undef C
X  #endif
X  #ifdef TEXTCOLOR
X! #include "color.h"
X  #define C(color)	color
X  #else
X  #define C(color)
X***************
X*** 65,70 ****
X--- 66,74 ----
X   * unconsciously. Use your common sense.
X   */
X  
X+ #if defined(MACOS) && !defined(MAKEDEFS_C)
X+ struct permonst *mons;	   /* for SMALLDATA - mons data stored in NetHack app */
X+ #else
X  #ifndef SPLITMON_2
X  struct permonst mons[] = {
X  /*      ants    */
X***************
X*** 253,259 ****
X            { { AT_BITE, AD_PHYS, 1, 7 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X            30, 300, 0, MS_SQAWK, M1_VSMALL | M1_POIS_RES | M1_TPORT |
X            M1_TPORT_CONTROL | M1_STALK, 0, C(CYAN) },
X! /*      j ??? */
X  /*      kobolds         */
X          { "kobold", S_KOBOLD,  0, 6, 7, 0, -2, (G_GENO | 1),
X            { { AT_WEAP, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X--- 257,278 ----
X            { { AT_BITE, AD_PHYS, 1, 7 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X            30, 300, 0, MS_SQAWK, M1_VSMALL | M1_POIS_RES | M1_TPORT |
X            M1_TPORT_CONTROL | M1_STALK, 0, C(CYAN) },
X! /*      jellies         */
X!         { "blue jelly", S_JELLY, 4, 0, 8, 10, 0, (G_GENO | 2),
X!           { { AT_NONE, AD_COLD, 0, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X!           2, 20, 0, MS_SILENT, M1_BIG | M1_NOEYES | M1_NOHANDS |
X!           M1_POIS_RES | M1_COLD_RES,
X!           M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE | M2_AMORPHOUS, C(BLUE) },
X!         { "spotted jelly", S_JELLY, 5, 0, 8, 10, 0, (G_GENO | 1),
X!           { { AT_NONE, AD_ACID, 0, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X!           2, 20, 0, MS_SILENT,
X!           M1_BIG | M1_NOEYES | M1_NOHANDS | M1_POIS | M1_STON_RES,
X!           M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE | M2_AMORPHOUS, C(GREEN) },
X!         { "ochre jelly", S_JELLY, 6, 3, 8, 20, 0, (G_GENO | 2),
X!           { { AT_ENGL, AD_ACID, 3, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X!           2, 20, 0, MS_SILENT, M1_BIG | M1_NOEYES | M1_NOHANDS | M1_POIS |
X!           M1_STON_RES, M2_HOSTILE | M2_OMNIVORE | M2_NOLIMBS | M2_AMORPHOUS,
X! 	  C(HI_GOLD)},
X  /*      kobolds         */
X          { "kobold", S_KOBOLD,  0, 6, 7, 0, -2, (G_GENO | 1),
X            { { AT_WEAP, AD_PHYS, 1, 4 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X***************
X*** 814,820 ****
X            M1_COLLECT, M2_STRONG | M2_ROCKTHROW | M2_NASTY, C(MAGENTA) },
X          { "minotaur", S_GIANT, 15, 15, 6, 0, 0, (G_GENO | G_NOGEN),
X            { { AT_CLAW, AD_PHYS, 3, 10 }, { AT_CLAW, AD_PHYS, 3, 10 },
X!             AT_BUTT, AD_PHYS, 2, 8, NO_ATTK, NO_ATTK},
X            70, 700, 0, MS_SILENT, M1_BIG | M1_ANIMAL | M1_HUMANOID,
X            M2_HOSTILE | M2_STRONG | M2_NASTY | M2_CARNIVORE, C(BROWN) },
X          { "owlbear", S_GIANT, 5, 12, 5, 0, 0, (G_GENO | 3),
X--- 833,839 ----
X            M1_COLLECT, M2_STRONG | M2_ROCKTHROW | M2_NASTY, C(MAGENTA) },
X          { "minotaur", S_GIANT, 15, 15, 6, 0, 0, (G_GENO | G_NOGEN),
X            { { AT_CLAW, AD_PHYS, 3, 10 }, { AT_CLAW, AD_PHYS, 3, 10 },
X!             { AT_BUTT, AD_PHYS, 2, 8}, NO_ATTK, NO_ATTK},
X            70, 700, 0, MS_SILENT, M1_BIG | M1_ANIMAL | M1_HUMANOID,
X            M2_HOSTILE | M2_STRONG | M2_NASTY | M2_CARNIVORE, C(BROWN) },
X          { "owlbear", S_GIANT, 5, 12, 5, 0, 0, (G_GENO | 3),
X***************
X*** 828,849 ****
X            40, 400, 0, MS_SILENT,
X            M1_BIG | M1_ANIMAL | M1_FLY | M1_SEE_INVIS | M1_STALK,
X            M2_WANDER | M2_HOSTILE | M2_STRONG, C(WHITE) },
X! /*      Jellies         */
X!         { "blue jelly", S_JELLY, 4, 0, 8, 10, 0, (G_GENO | 2),
X!           { { AT_NONE, AD_COLD, 0, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X!           2, 20, 0, MS_SILENT, M1_BIG | M1_NOEYES | M1_NOHANDS |
X!           M1_POIS_RES | M1_COLD_RES,
X!           M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE | M2_AMORPHOUS, C(BLUE) },
X!         { "spotted jelly", S_JELLY, 5, 0, 8, 10, 0, (G_GENO | 1),
X!           { { AT_NONE, AD_ACID, 0, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X!           2, 20, 0, MS_SILENT,
X!           M1_BIG | M1_NOEYES | M1_NOHANDS | M1_POIS | M1_STON_RES,
X!           M2_HOSTILE | M2_NOLIMBS | M2_OMNIVORE | M2_AMORPHOUS, C(GREEN) },
X!         { "ochre jelly", S_JELLY, 6, 3, 8, 20, 0, (G_GENO | 2),
X!           { { AT_ENGL, AD_ACID, 3, 6 }, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK },
X!           2, 20, 0, MS_SILENT, M1_BIG | M1_NOEYES | M1_NOHANDS | M1_POIS |
X!           M1_STON_RES, M2_HOSTILE | M2_OMNIVORE | M2_NOLIMBS | M2_AMORPHOUS,
X! 	  C(HI_GOLD)},
X  /*      Kops    */
X  #ifdef KOPS
X          { "Keystone Kop", S_KOP, 1, 6, 7, 10, 9, (G_GENO | G_LGROUP | G_NOGEN),
X--- 847,858 ----
X            40, 400, 0, MS_SILENT,
X            M1_BIG | M1_ANIMAL | M1_FLY | M1_SEE_INVIS | M1_STALK,
X            M2_WANDER | M2_HOSTILE | M2_STRONG, C(WHITE) },
X! /*      Jabberwock */
X!         { "jabberwock", S_JABBERWOCK, 15, 12, -2, 50, 0, G_GENO,
X!           { { AT_BITE, AD_PHYS, 2, 10 }, { AT_BITE, AD_PHYS, 2, 10 },
X!           { AT_CLAW, AD_PHYS, 2, 10 }, { AT_CLAW, AD_PHYS, 2, 10 }, NO_ATTK },
X!           60, 600, 0, MS_SILENT, M1_BIG | M1_ANIMAL | M1_COLLECT | M1_FLY,
X! 	  M2_HOSTILE | M2_STRONG | M2_NASTY | M2_CARNIVORE, C(RED) },
X  /*      Kops    */
X  #ifdef KOPS
X          { "Keystone Kop", S_KOP, 1, 6, 7, 10, 9, (G_GENO | G_LGROUP | G_NOGEN),
X***************
X*** 1453,1471 ****
X  	  C(MAGENTA)},
X  #endif
X  #ifdef MAIL
X- # ifdef VMS
X-         { "broadcast daemon", S_DEMON, 56, 24, 10, 127, 0, (G_NOGEN | G_NOCORPSE),
X-           { NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK }, 30, 300, 0,
X-           MS_SILENT, M1_NOPOLY | M1_FLY | M1_SWIM | M1_SEE_INVIS |
X-           M1_HUMANOID | M1_POIS | M1_FIRE_RES | M1_COLD_RES | M1_SLEE_RES |
X-           M1_STALK, M2_PEACEFUL, C(BRIGHT|BLUE) },
X- # else
X          { "mail daemon", S_DEMON, 56, 24, 10, 127, 0, (G_NOGEN | G_NOCORPSE),
X            { NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK }, 30, 300, 0,
X            MS_SILENT, M1_NOPOLY | M1_FLY | M1_SWIM | M1_SEE_INVIS |
X            M1_HUMANOID | M1_POIS | M1_FIRE_RES | M1_COLD_RES | M1_SLEE_RES |
X            M1_STALK, M2_PEACEFUL, C(BRIGHT|BLUE) },
X- # endif
X  /* Neither rain nor sleet nor gloom of night shall stay this courier... */
X  #endif
X          { "djinni", S_DEMON, 7, 12, 4, 30, 0, (G_NOGEN | G_NOCORPSE),
X--- 1462,1472 ----
X***************
X*** 1566,1568 ****
X--- 1567,1570 ----
X            0, 0, 0, 0, 0, 0, C(0) }
X  };
X  #endif /* !SPLITMON_1 */
X+ #endif /* !MAKEDEFS_C */
X*** src/Old/music.c	Sun Oct 15 18:53:02 1989
X--- src/music.c	Wed Oct 11 17:14:52 1989
X***************
X*** 223,229 ****
X  					else {
X  					    You("destroy %s!",
X  					    mtmp->mtame ?
X! 						a_monnam(mtmp, "poor") :
X  						mon_nam(mtmp));
X  					}
X  					xkilled(mtmp,0);
X--- 223,229 ----
X  					else {
X  					    You("destroy %s!",
X  					    mtmp->mtame ?
X! 						a2_monnam(mtmp, "poor") :
X  						mon_nam(mtmp));
X  					}
X  					xkilled(mtmp,0);
X*** src/Old/o_init.c	Sun Oct 15 18:53:21 1989
X--- src/o_init.c	Sat Oct 14 22:09:03 1989
X***************
X*** 9,14 ****
X--- 9,19 ----
X   * in the objects array
X   */
X  #define TOTAL_OBJS	(NROFOBJECTS+2)
X+ #ifdef MACOS
X+ short *switches;    /* used to allow position independent loads of app */
X+ 		    /* by storing the number of the description string */
X+ 		    /* [at startup of the game] not the pointer to the string */
X+ #endif
X  
X  const char obj_symbols[] = {
X  	ILLOBJ_SYM, AMULET_SYM, FOOD_SYM, WEAPON_SYM, TOOL_SYM,
X***************
X*** 70,75 ****
X--- 75,83 ----
X  	int color;
X  #endif /* TEXTCOLOR */
X  	int tmp;
X+ #ifdef MACOS
X+ 	short	sw;
X+ #endif
X  
X  	for(j=o_low; j <= o_high; j++) {
X  		i = o_low + rn2(j+1-o_low);
X***************
X*** 91,96 ****
X--- 99,110 ----
X  			objects[j].oc_material = objects[i].oc_material;
X  			objects[i].oc_material = tmp;
X  		}
X+ #ifdef MACOS
X+ 		/* keep track of shuffling of object descriptions */
X+ 		sw=switches[j];
X+ 		switches[j]=switches[i];
X+ 		switches[i]=sw;
X+ #endif
X  	}
X  }
X  
X***************
X*** 142,165 ****
X  			j = last;
X  			if (let == GEM_SYM) {
X  			    while(--j > first)
X- 				/* NOTE:  longest color name must be default */
X  				if(!strcmp(objects[j].oc_name,"turquoise")) {
X! 				    if(rn2(2)) /* change from green? */
X! 					Strcpy(objects[j].oc_descr, blue);
X  				} else if (!strcmp(objects[j].oc_name,"aquamarine")) {
X! 				    if(rn2(2)) /* change from green? */
X! 					Strcpy(objects[j].oc_descr, blue);
X  				} else if (!strcmp(objects[j].oc_name,"fluorite")) {
X  				    switch (rn2(4)) { /* change from violet? */
X  					case 0:  break;
X  					case 1:
X! 					    Strcpy(objects[j].oc_descr, blue);
X  					    break;
X  					case 2:
X! 					    Strcpy(objects[j].oc_descr, white);
X  					    break;
X  					case 3:
X! 					    Strcpy(objects[j].oc_descr, green);
X  					    break;
X  					}
X  				}
X--- 156,195 ----
X  			j = last;
X  			if (let == GEM_SYM) {
X  			    while(--j > first)
X  				if(!strcmp(objects[j].oc_name,"turquoise")) {
X! 				    if(rn2(2)) { /* change from green? */
X! 					objects[j].oc_descr = blue;
X! #ifdef TEXTCOLOR
X! 					objects[j].oc_color = BLUE;
X! #endif
X! 				    }
X  				} else if (!strcmp(objects[j].oc_name,"aquamarine")) {
X! 				    if(rn2(2)) { /* change from green? */
X! 					objects[j].oc_descr = blue;
X! #ifdef TEXTCOLOR
X! 					objects[j].oc_color = BLUE;
X! #endif
X! 				    }
X  				} else if (!strcmp(objects[j].oc_name,"fluorite")) {
X  				    switch (rn2(4)) { /* change from violet? */
X  					case 0:  break;
X  					case 1:
X! 					    objects[j].oc_descr = blue;
X! #ifdef TEXTCOLOR
X! 					    objects[j].oc_color = BLUE;
X! #endif
X  					    break;
X  					case 2:
X! 					    objects[j].oc_descr = white;
X! #ifdef TEXTCOLOR
X! 					    objects[j].oc_color = WHITE;
X! #endif
X  					    break;
X  					case 3:
X! 					    objects[j].oc_descr = green;
X! #ifdef TEXTCOLOR
X! 					    objects[j].oc_color = GREEN;
X! #endif
X  					    break;
X  					}
X  				}
X***************
X*** 198,212 ****
X--- 228,254 ----
X  {
X  	register int i;
X  	unsigned int len;
X+ #ifdef MACOS
X+ 	char	*descr[TOTAL_OBJS];
X+ #endif
X  	struct objclass *now = &objects[0];
X  	bwrite(fd, (genericptr_t)&now, sizeof now);
X  	bwrite(fd, (genericptr_t)bases, sizeof bases);
X  	bwrite(fd, (genericptr_t)disco, sizeof disco);
X+ #ifdef MACOS
X+ 	for (i = 0 ; i < TOTAL_OBJS; i++) {
X+ 		descr[i] = objects[i].oc_descr;
X+ 		objects[i].oc_descr = (char *)switches[i];
X+ 	}
X+ #endif
X  	bwrite(fd, (genericptr_t)objects, sizeof(struct objclass) * TOTAL_OBJS);
X  	/* as long as we use only one version of Hack we
X  	   need not save oc_name and oc_descr, but we must save
X  	   oc_uname for all objects */
X  	for(i=0; i < TOTAL_OBJS; i++) {
X+ #ifdef MACOS
X+ 		objects[i].oc_descr = descr[i];
X+ #endif
X  		if(objects[i].oc_uname) {
X  			len = strlen(objects[i].oc_uname)+1;
X  			bwrite(fd, (genericptr_t)&len, sizeof len);
X***************
X*** 223,254 ****
X  	unsigned int len;
X  	struct objclass *then;
X  	long differ;
X  	mread(fd, (genericptr_t) &then, sizeof then);
X  	mread(fd, (genericptr_t) bases, sizeof bases);
X  	mread(fd, (genericptr_t) disco, sizeof disco);
X  	mread(fd, (genericptr_t) objects, sizeof(struct objclass) * TOTAL_OBJS);
X! #if !defined(MSDOS) && !defined(M_XENIX)
X! 	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X  #else
X  	differ = (long)&objects[0] - (long)then;
X! #endif
X  	for(i=0; i < TOTAL_OBJS; i++) {
X  		if (objects[i].oc_name) {
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_name += differ;
X! #else
X  			objects[i].oc_name =
X  			    (char *)((long)(objects[i].oc_name) + differ);
X! #endif
X  		}
X  		if (objects[i].oc_descr) {
X! #if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_descr += differ;
X! #else
X  			objects[i].oc_descr =
X  			    (char *)((long)(objects[i].oc_descr) + differ);
X! #endif
X  		}
X  		if (objects[i].oc_uname) {
X  			mread(fd, (genericptr_t) &len, sizeof len);
X  			objects[i].oc_uname = (char *) alloc(len);
X--- 265,325 ----
X  	unsigned int len;
X  	struct objclass *then;
X  	long differ;
X+ #ifdef MACOS
X+ 	/* provides position-independent save & restore */
X+ 	/* by giving each object a number, keep track of it */
X+ 	/* when shuffled and save the numbers instead of the */
X+ 	/* description strings (which can change between */
X+ 	/* executions of the program) */
X+ 	/* On restore, the retrieved numbers are matched with the */
X+ 	/* numbers and object descriptions in the program */
X+ 	struct descr {
X+ 		char	*name,
X+ 				*descr;
X+ 	} d[TOTAL_OBJS];
X+ 
X+ 	/* save the current object descriptions */
X+ 	for (i = 0; i < TOTAL_OBJS; i++) {
X+ 		d[i].name = objects[i].oc_name;
X+ 		d[i].descr = objects[i].oc_descr;
X+ 	}
X+ #endif
X  	mread(fd, (genericptr_t) &then, sizeof then);
X  	mread(fd, (genericptr_t) bases, sizeof bases);
X  	mread(fd, (genericptr_t) disco, sizeof disco);
X  	mread(fd, (genericptr_t) objects, sizeof(struct objclass) * TOTAL_OBJS);
X! #ifdef MACOS
X! 	for (i = 0; i < TOTAL_OBJS; i++) {
X! 		objects[i].oc_name = d[i].name;
X! 		switches[i] = (short)objects[i].oc_descr;
X! 		objects[i].oc_descr = d[switches[i]].descr;
X! 	}
X  #else
X+ # if !defined(MSDOS) && !defined(M_XENIX)
X+ 	differ = (genericptr_t)&objects[0] - (genericptr_t)then;
X+ # else
X  	differ = (long)&objects[0] - (long)then;
X! # endif
X! #endif	/* MACOS */
X  	for(i=0; i < TOTAL_OBJS; i++) {
X+ #ifndef MACOS
X  		if (objects[i].oc_name) {
X! # if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_name += differ;
X! # else
X  			objects[i].oc_name =
X  			    (char *)((long)(objects[i].oc_name) + differ);
X! # endif
X  		}
X  		if (objects[i].oc_descr) {
X! # if !defined(MSDOS) && !defined(M_XENIX)
X  			objects[i].oc_descr += differ;
X! # else
X  			objects[i].oc_descr =
X  			    (char *)((long)(objects[i].oc_descr) + differ);
X! # endif
X  		}
X+ #endif /* MACOS */
X  		if (objects[i].oc_uname) {
X  			mread(fd, (genericptr_t) &len, sizeof len);
X  			objects[i].oc_uname = (char *) alloc(len);
X*** src/Old/objects.c	Sun Oct 15 18:53:44 1989
X--- src/objects.c	Tue Oct  3 20:23:31 1989
X***************
X*** 10,16 ****
X  #include "obj.h"
X  #include "objclass.h"
X  #include "prop.h"
X- #include "decl.h"
X  #undef BOW
X  
X  /* objects have letter " % ) ( 0 _ ` [ ! ? / = * + . */
X--- 10,15 ----
X***************
X*** 19,24 ****
X--- 18,24 ----
X  #undef C
X  #endif
X  #ifdef TEXTCOLOR
X+ #include "color.h"
X  #define C(n)	n
X  #else
X  #define C(n)
X***************
X*** 49,54 ****
X--- 49,56 ----
X  	name, NULL, NULL, 1,1,uk,0,tin, 0, FOOD_SYM, prob, delay, wt, \
X  	nutrition/20 + 5, 0, 0, nutrition, C(color) }
X  
X+ /* all types of food (except tins & corpses) must have a delay of at least 1. */
X+ /* delay on corpses is computed and is weight dependant */
X  /* dog eats foods 0-4 but prefers tripe rations above all others */
X  /* fortune cookies can be read */
X  /* carrots improve your vision */
X***************
X*** 58,92 ****
X  
X  	/* meat */
X  #ifdef TOLKIEN
X! 	FOOD("tripe ration",	   145, 1, 2, 0, 0, 200, BROWN),
X  #else
X! 	FOOD("tripe ration",	   150, 1, 2, 0, 0, 200, BROWN),
X  #endif
X! 	FOOD("dead lizard",	    35, 0, 1, 0, 0,  40, GREEN),
X! 	FOOD("corpse",		     0, 0, 0, 0, 0,   0, BROWN),
X! 	FOOD("egg",		    75, 0, 1, 1, 0,  80, WHITE),
X  	/* fruits & veggies */
X! 	FOOD("apple",		    10, 0, 1, 0, 0,  50, RED),
X! 	FOOD("orange",		     7, 0, 1, 0, 0,  80, ORANGE_COLORED),
X! 	FOOD("pear",		     7, 0, 1, 0, 0,  50, GREEN+BRIGHT),
X! 	FOOD("melon",		     7, 0, 1, 0, 0, 100, GREEN+BRIGHT),
X! 	FOOD("banana",		     7, 0, 1, 0, 0,  80, YELLOW),
X! 	FOOD("carrot",		    15, 0, 1, 0, 0,  50, ORANGE_COLORED),
X! 	FOOD("clove of garlic",      5, 0, 1, 0, 0,  40, WHITE),
X  #ifdef TUTTI_FRUTTI
X! 	FOOD("slime mold",	    75, 0, 1, 0, 0, 250, BROWN),
X  #else
X! 	FOOD("slice of pizza",	    75, 0, 1, 0, 0, 250, RED),
X  #endif
X  	/* human food */
X! 	FOOD("lump of royal jelly",  0, 0, 1, 0, 0, 200, YELLOW),
X! 	FOOD("cream pie",	    25, 0, 1, 0, 0, 100, WHITE),
X! 	FOOD("candy bar",	     7, 0, 1, 0, 0, 100, BROWN),
X! 	FOOD("fortune cookie",	    55, 0, 1, 0, 0,  40, BROWN),
X  #ifdef TOLKIEN
X! 	FOOD("pancake", 	    25, 1, 1, 0, 0, 200, BROWN),
X! 	FOOD("lembas wafer",	    20, 1, 1, 0, 0, 800, WHITE+BRIGHT),
X! 	FOOD("cram ration",	    20, 1, 3, 0, 0, 600, HI_ORGANIC),
X  	FOOD("food ration",	   385, 5, 4, 0, 0, 800, HI_ORGANIC),
X  #else
X  	FOOD("pancake", 	    40, 1, 1, 0, 0, 200, BROWN),
X--- 60,94 ----
X  
X  	/* meat */
X  #ifdef TOLKIEN
X! 	FOOD("tripe ration",	   145, 2, 2, 0, 0, 200, BROWN),
X  #else
X! 	FOOD("tripe ration",	   150, 2, 2, 0, 0, 200, BROWN),
X  #endif
X! 	FOOD("dead lizard",	    35, 1, 1, 0, 0,  40, GREEN),
X! 	FOOD("corpse",		     0, 1, 0, 0, 0,   0, BROWN),
X! 	FOOD("egg",		    75, 1, 1, 1, 0,  80, WHITE),
X  	/* fruits & veggies */
X! 	FOOD("apple",		    10, 1, 1, 0, 0,  50, RED),
X! 	FOOD("orange",		     7, 1, 1, 0, 0,  80, ORANGE_COLORED),
X! 	FOOD("pear",		     7, 1, 1, 0, 0,  50, GREEN+BRIGHT),
X! 	FOOD("melon",		     7, 1, 1, 0, 0, 100, GREEN+BRIGHT),
X! 	FOOD("banana",		     7, 1, 1, 0, 0,  80, YELLOW),
X! 	FOOD("carrot",		    15, 1, 1, 0, 0,  50, ORANGE_COLORED),
X! 	FOOD("clove of garlic",      5, 1, 1, 0, 0,  40, WHITE),
X  #ifdef TUTTI_FRUTTI
X! 	FOOD("slime mold",	    75, 1, 1, 0, 0, 250, BROWN),
X  #else
X! 	FOOD("slice of pizza",	    75, 1, 1, 0, 0, 250, RED),
X  #endif
X  	/* human food */
X! 	FOOD("lump of royal jelly",  0, 1, 1, 0, 0, 200, YELLOW),
X! 	FOOD("cream pie",	    25, 1, 1, 0, 0, 100, WHITE),
X! 	FOOD("candy bar",	     7, 1, 1, 0, 0, 100, BROWN),
X! 	FOOD("fortune cookie",	    55, 1, 1, 0, 0,  40, BROWN),
X  #ifdef TOLKIEN
X! 	FOOD("pancake", 	    25, 2, 1, 0, 0, 200, BROWN),
X! 	FOOD("lembas wafer",	    20, 2, 1, 0, 0, 800, WHITE+BRIGHT),
X! 	FOOD("cram ration",	    20, 3, 3, 0, 0, 600, HI_ORGANIC),
X  	FOOD("food ration",	   385, 5, 4, 0, 0, 800, HI_ORGANIC),
X  #else
X  	FOOD("pancake", 	    40, 1, 1, 0, 0, 200, BROWN),
X*** src/Old/objnam.c	Sun Oct 15 18:54:30 1989
X--- src/objnam.c	Sun Oct 15 17:48:14 1989
X***************
X*** 5,11 ****
X  #include	"hack.h"
X  #include <ctype.h>	/* for isalpha() */
X  
X! #define	PREFIX	30
X  #define SCHAR_MAX 127
X  
X  /*	We want the player to be able to learn what key goes in what lock.  */
X--- 5,12 ----
X  #include	"hack.h"
X  #include <ctype.h>	/* for isalpha() */
X  
X! /* "an uncursed partly eaten guardian naga hatchling corpse" */
X! #define	PREFIX	50
X  #define SCHAR_MAX 127
X  
X  /*	We want the player to be able to learn what key goes in what lock.  */
X***************
X*** 503,509 ****
X  		}
X  		break;
X  	case FOOD_SYM:
X! 		if(OEATEN(obj))
X  		    Strcat(prefix, "partly eaten ");
X  		if(obj->otyp == CORPSE) {
X  		    Strcat(prefix, mons[obj->corpsenm].mname);
X--- 504,510 ----
X  		}
X  		break;
X  	case FOOD_SYM:
X! 		if(obj->oeaten)
X  		    Strcat(prefix, "partly eaten ");
X  		if(obj->otyp == CORPSE) {
X  		    Strcat(prefix, mons[obj->corpsenm].mname);
X***************
X*** 547,552 ****
X--- 548,578 ----
X  	return(bp);
X  }
X  
X+ /*
X+  * Used if only one of a collection of objects is named (e.g. in eat.c).
X+  */
X+ 
X+ char *
X+ singular(otmp)
X+ register struct obj *otmp;
X+ {
X+ 	int savequan;
X+ 	char *nam;
X+ 
X+ 	/* Note: using xname for corpses will not give the monster type */
X+ 	if (otmp->otyp == CORPSE) {
X+ 		static char buf[31];
X+ 
X+ 		sprintf(buf, "%s corpse", mons[otmp->corpsenm].mname);
X+ 		return buf;
X+ 	}
X+ 	savequan = otmp->quan;
X+ 	otmp->quan = 1;
X+ 	nam = xname(otmp);
X+ 	otmp->quan = savequan;
X+ 	return nam;
X+ }
X+ 
X  /* used only in mthrowu.c (thitu) */
X  void
X  setan(str,buf)
X***************
X*** 725,732 ****
X  		goto bottom;
X  	}
X  
X! 	/* fungus/fungi, homunculus/homunculi */
X! 	if (!strcmp(spot-1, "us")) {
X  		*(spot--) = (char)0;
X  		*spot = 'i';
X  		goto bottom;
X--- 751,758 ----
X  		goto bottom;
X  	}
X  
X! 	/* fungus/fungi, homunculus/homunculi, but wumpuses */
X! 	if (!strcmp(spot-1, "us") && strcmp(spot-6, "wumpus")) {
X  		*(spot--) = (char)0;
X  		*spot = 'i';
X  		goto bottom;
X***************
X*** 1435,1441 ****
X  	if (name) otmp = oname(otmp, name, 0);
X  	otmp->owt = weight(otmp);
X  	if (heavy) otmp->owt += 15;
X! 	if (halfeaten && otmp->olet == FOOD_SYM) OEATEN(otmp) = 1;
X  	return(otmp);
X  }
X  
X--- 1461,1467 ----
X  	if (name) otmp = oname(otmp, name, 0);
X  	otmp->owt = weight(otmp);
X  	if (heavy) otmp->owt += 15;
X! 	if (halfeaten && otmp->olet == FOOD_SYM) otmp->oeaten = TRUE;
X  	return(otmp);
X  }
X  
X*** src/Old/options.c	Sun Oct 15 18:55:16 1989
X--- src/options.c	Sat Oct 14 21:52:05 1989
X***************
X*** 25,30 ****
X--- 25,34 ----
X  	flags.confirm = TRUE;
X  	flags.safe_dog = TRUE;
X  	flags.silent = 	flags.pickup = TRUE;
X+ #ifdef MACOS
X+ 	flags.standout = TRUE;
X+ 	flags.end_around = 3;	/* Mac display routines don't scroll */
X+ #endif
X  #ifdef TUTTI_FRUTTI
X  	nmcpy(pl_fruit, objects[SLIME_MOLD].oc_name, PL_FSIZ);
X  #endif
X***************
X*** 693,699 ****
X  		i = strlen(str);
X  	}
X  	if (*str)
X! 		strcat(buf, str);
X  	else
X  		(void) page_line(str);	/* always returns 0 on "" */
X  	return r;
X--- 697,703 ----
X  		i = strlen(str);
X  	}
X  	if (*str)
X! 		Strcat(buf, str);
X  	else
X  		(void) page_line(str);	/* always returns 0 on "" */
X  	return r;
X*** src/Old/pager.c	Sun Oct 15 19:43:16 1989
X--- src/pager.c	Sat Oct 14 22:10:16 1989
X***************
X*** 16,21 ****
X--- 16,25 ----
X  #if defined(BSD) || defined(ULTRIX)
X  #include <sys/wait.h>
X  #endif
X+ #ifdef MACOS
X+ extern WindowPtr	HackWindow;
X+ extern short macflags;
X+ #endif
X  
X  static char hc = 0;
X  
X***************
X*** 35,48 ****
X  	Strcpy(tmp,hackdir);
X  	append_slash(tmp);
X  	Strcat(tmp,DATAFILE);
X! 	if(!(fp = fopen(tmp,"r")))
X  #else
X! 	if(!(fp = fopen(DATAFILE, "r")))
X  #endif
X  		pline("Cannot open data file!");
X  	else {
X  		coord	cc;
X  		uchar	r;
X  
X  		pline ("Specify unknown object by cursor? ");
X  		q = ynq();
X--- 39,58 ----
X  	Strcpy(tmp,hackdir);
X  	append_slash(tmp);
X  	Strcat(tmp,DATAFILE);
X! 	fp = fopen(tmp,"r"));
X  #else
X! 	fp = fopen(DATAFILE, "r");
X! #endif
X! 	if(!fp)
X! #ifdef MACOS
X! 		fp = openFile(DATAFILE);
X! 	if (!fp)
X  #endif
X  		pline("Cannot open data file!");
X  	else {
X  		coord	cc;
X  		uchar	r;
X+ 		boolean oldverb = flags.verbose;
X  
X  		pline ("Specify unknown object by cursor? ");
X  		q = ynq();
X***************
X*** 59,69 ****
X--- 69,83 ----
X  	selobj:
X  		    if(flags.verbose)
X  			pline("Please move the cursor to an unknown object.");
X+ 		    else
X+ 			pline("Pick an object.");
X  		    getpos(&cc, FALSE, "an unknown object");
X  		    if (cc.x < 0) {
X  			    (void) fclose(fp); /* sweet@scubed */
X+ 			    flags.verbose = oldverb;
X  			    return 0;
X  		    }
X+ 		    flags.verbose = FALSE;
X  		    r = levl[cc.x][cc.y].scrsym;
X  		    if (!r || !levl[cc.x][cc.y].seen) r = ' ';
X  		}
X***************
X*** 112,117 ****
X--- 126,132 ----
X  			q = r;
X  			if (index(quitchars, q)) {
X  				(void) fclose(fp); /* sweet@scubed */
X+ 				flags.verbose = oldverb;
X  				return 0;
X  			}
X  		}
X***************
X*** 166,173 ****
X  				}
X  			    }
X  #ifdef SPELLS
X! 			    else
X! 			    if (q == SPBOOK_SYM && OBJ_AT(cc.x, cc.y))
X  				    pline("(spellbook)");
X  #endif
X  #ifdef STRONGHOLD
X--- 181,187 ----
X  				}
X  			    }
X  #ifdef SPELLS
X! 			    else if (q == SPBOOK_SYM && OBJ_AT(cc.x, cc.y))
X  				    pline("(spellbook)");
X  #endif
X  #ifdef STRONGHOLD
X***************
X*** 178,185 ****
X  				    pline("(raised drawbridge)");
X  #endif
X  #ifdef SINKS
X! 			    else
X! 			    if (r == showsyms.sink && q == defsyms.sink &&
X  				IS_SINK(levl[cc.x][cc.y].typ))
X  				    pline("(sink)");
X  #endif
X--- 192,198 ----
X  				    pline("(raised drawbridge)");
X  #endif
X  #ifdef SINKS
X! 			    else if (r == showsyms.sink && q == defsyms.sink &&
X  				IS_SINK(levl[cc.x][cc.y].typ))
X  				    pline("(sink)");
X  #endif
X***************
X*** 211,216 ****
X--- 224,230 ----
X  				pline("More info? ");
X  				if(yn() == 'y') {
X  					page_more(fp,1); /* does fclose() */
X+ 					flags.verbose = oldverb;
X  					return 0;
X  				}
X  			}
X***************
X*** 221,230 ****
X--- 235,246 ----
X  				goto selobj;
X  			}
X  			(void) fclose(fp); 	/* kopper@psuvax1 */
X+ 			flags.verbose = oldverb;
X  			return 0;
X  		    }
X  		pline("I've never heard of such things.");
X  		(void) fclose(fp);
X+ 		flags.verbose = oldverb;
X  	}
X  	return 0;
X  }
X***************
X*** 243,249 ****
X--- 259,271 ----
X  	Strcat(tmp,CMDHELPFILE);
X  	if(!(fp = fopen(tmp,"r"))) {
X  #else
X+ # ifdef MACOS
X+ 	if(!(fp = fopen(CMDHELPFILE, "r")))
X+ 		fp = openFile(CMDHELPFILE);
X+ 	if (!fp) {
X+ # else
X  	if(!(fp = fopen(CMDHELPFILE, "r"))) {
X+ # endif
X  #endif
X  		pline("Cannot open data file!");
X  		return 0;
X***************
X*** 290,296 ****
X  /* make the paging of a file interruptible */
X  static int got_intrup;
X  
X! #if !defined(MSDOS) && !defined(TOS)
X  static int
X  intruph(){
X  	(void) signal(SIGINT, (SIG_RET_TYPE) intruph);
X--- 312,318 ----
X  /* make the paging of a file interruptible */
X  static int got_intrup;
X  
X! #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X  static int
X  intruph(){
X  	(void) signal(SIGINT, (SIG_RET_TYPE) intruph);
X***************
X*** 309,315 ****
X  #if !defined(MSDOS) && !defined(MINIMAL_TERM)
X  	register char *ep;
X  #endif
X! #if !defined(MSDOS) && !defined(TOS)
X  	int (*prevsig)() = (int (*)())signal(SIGINT, (SIG_RET_TYPE) intruph);
X  #endif
X  #if defined(MSDOS) || defined(MINIMAL_TERM)
X--- 331,337 ----
X  #if !defined(MSDOS) && !defined(MINIMAL_TERM)
X  	register char *ep;
X  #endif
X! #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X  	int (*prevsig)() = (int (*)())signal(SIGINT, (SIG_RET_TYPE) intruph);
X  #endif
X  #if defined(MSDOS) || defined(MINIMAL_TERM)
X***************
X*** 353,359 ****
X  ret:
X  	free((genericptr_t) bufr);
X  	(void) fclose(fp);
X! #if !defined(MSDOS) && !defined(TOS)
X  	(void) signal(SIGINT, (SIG_RET_TYPE) prevsig);
X  	got_intrup = 0;
X  #endif
X--- 375,381 ----
X  ret:
X  	free((genericptr_t) bufr);
X  	(void) fclose(fp);
X! #if !defined(MSDOS) && !defined(TOS) && !defined(MACOS)
X  	(void) signal(SIGINT, (SIG_RET_TYPE) prevsig);
X  	got_intrup = 0;
X  #endif
X***************
X*** 439,444 ****
X--- 461,469 ----
X  	xputs(s); xputc('\n');
X  #else
X  	(void) puts(s);
X+ # ifdef MACOS
X+ 	(void) putchar('\n');
X+ # endif
X  #endif
X  	cury++;
X  	return(0);
X***************
X*** 656,661 ****
X--- 681,694 ----
X  int
X  dohelp()
X  {
X+ #ifdef MACOS
X+ 	term_info	*t;
X+ 	
X+ 	macflags &= ~(fDoUpdate | fDoNonKeyEvt);
X+ 	t = (term_info *)GetWRefCon(HackWindow);
X+ 	SetVol((StringPtr)NULL,
X+ 		(t->auxFileVRefNum) ? t->auxFileVRefNum : t->recordVRefNum);
X+ #endif
X  	help_menu();
X  	if (!index(quitchars, hc)) {
X  		switch(hc) {
X***************
X*** 673,678 ****
X--- 706,715 ----
X  #endif
X  		}
X  	}
X+ #ifdef MACOS
X+ 	macflags |= (fDoUpdate | fDoNonKeyEvt);
X+ 	SetVol((StringPtr)NULL, t->recordVRefNum);
X+ #endif
X  	return 0;
X  }
X  
X***************
X*** 724,730 ****
X--- 761,778 ----
X  	Strcat(tmp,fnam);
X  	if ((f = fopen (tmp, "r")) == (FILE *) 0) {
X  #else
X+ # ifdef MACOS
X+ 	if ((f = fopen (fnam, "r")) == (FILE *) 0)
X+ 		f = openFile(fnam);
X+ 	/* refresh screen kluge */
X+ 	if (!f) {
X+ 		cls();
X+ 		docrt();
X+ 		clrlin();
X+ 		ValidRect(&(**(*HackWindow).visRgn).rgnBBox);
X+ # else
X  	if ((f = fopen (fnam, "r")) == (FILE *) 0) {
X+ # endif
X  #endif
X  		if(!silent) {
X  			home(); perror (fnam); flags.toplin = 1;
X*** src/Old/panic.c	Sun Oct 15 19:43:46 1989
X--- src/panic.c	Sat Oct 14 22:11:30 1989
X***************
X*** 6,11 ****
X--- 6,12 ----
X   */
X  /* NetHack may be freely redistributed.  See license for details. */
X  
X+ /* #define MAKEDEFS_C	1   /* define for Macs */
X  #define NEED_VARARGS
X  #include	"config.h"
X  
X***************
X*** 12,17 ****
X--- 13,21 ----
X  #ifdef MSDOS
X  #undef exit
X  extern void exit P((int));
X+ #endif
X+ #ifdef AZTEC
X+ #define abort() exit()
X  #endif
X   
X  /*VARARGS1*/
X*** src/Old/pickup.c	Sun Oct 15 19:44:00 1989
X--- src/pickup.c	Wed Oct  4 13:57:43 1989
X***************
X*** 268,286 ****
X  		}
X  	lift_some:
X  		if(inv_cnt() >= 52) {
X! 		    Your("knapsack cannot accommodate any more items.");
X! 		    if(obj->otyp == SCR_SCARE_MONSTER)
X! 			    if(obj->spe) obj->spe = 0;
X! 		    break;
X  		}
X- 		addtobill(obj, TRUE);       /* sets obj->unpaid if necessary */
X- 		freeobj(obj);
X- 		if(Invisible) newsym(u.ux,u.uy);
X- 		if(wt > -5) You("have a little trouble lifting");
X  		{ int pickquan = obj->quan;
X  		  int mergquan;
X  		  if(!Blind) obj->dknown = 1;
X- 		  obj = addinv(obj);    /* might merge it with other objects */
X  		  mergquan = obj->quan;
X  		  obj->quan = pickquan; /* to fool prinv() */
X  		  if(uwep && uwep == obj) mrg_to_wielded = TRUE;
X--- 268,284 ----
X  		}
X  	lift_some:
X  		if(inv_cnt() >= 52) {
X! 			Your("knapsack cannot accommodate any more items.");
X! 			if(obj->otyp == SCR_SCARE_MONSTER)
X! 				if(obj->spe) obj->spe = 0;
X! 			break;
X  		}
X  		{ int pickquan = obj->quan;
X  		  int mergquan;
X+ 
X+ 		  obj = pick_obj(obj);
X+ 		  if(wt > -5) You("have a little trouble lifting");
X  		  if(!Blind) obj->dknown = 1;
X  		  mergquan = obj->quan;
X  		  obj->quan = pickquan; /* to fool prinv() */
X  		  if(uwep && uwep == obj) mrg_to_wielded = TRUE;
X***************
X*** 290,295 ****
X--- 288,303 ----
X  		}
X  	    }
X  	}
X+ }
X+ 
X+ struct obj *
X+ pick_obj(otmp)
X+ register struct obj *otmp;
X+ {
X+ 	addtobill(otmp, TRUE);       /* sets obj->unpaid if necessary */
X+ 	freeobj(otmp);
X+ 	if(Invisible) newsym(u.ux,u.uy);
X+ 	return(addinv(otmp));    /* might merge it with other objects */
X  }
X  
X  int
X*** src/Old/potion.c	Sun Oct 15 19:44:48 1989
X--- src/potion.c	Sat Oct 14 19:23:40 1989
X***************
X*** 74,79 ****
X--- 74,93 ----
X  }
X  
X  void
X+ make_vomiting(xtime, talk)
X+ long xtime;
X+ boolean talk;
X+ {
X+ 	long old = Vomiting;
X+ 
X+ 	if(!xtime && old)
X+ 	    if(talk) You("feel much less nauseous now.");
X+ 
X+ 	Vomiting = xtime;
X+ }
X+ 
X+ 
X+ void
X  make_blinded(xtime, talk)
X  long xtime;
X  boolean talk;
X***************
X*** 168,173 ****
X--- 182,188 ----
X  
X  	otmp = getobj(beverages, "drink");
X  	if(!otmp) return(0);
X+ 	otmp->in_use = TRUE;		/* you've opened the stopper */
X  	if(objects[otmp->otyp].oc_descr && !strcmp(objects[otmp->otyp].oc_descr, "smoky") && !rn2(13)) {
X  		ghost_from_bottle();
X  		useup(otmp);
X***************
X*** 473,479 ****
X  			/* they went up a level */
X  			if(dlevel > 1 && dlevel <= MAXLEVEL) { 
X  				You("rise up, through the ceiling!");
X! 				goto_level(dlevel-1, FALSE);
X  			} else You("have an uneasy feeling.");
X  			break;
X  		}
X--- 488,494 ----
X  			/* they went up a level */
X  			if(dlevel > 1 && dlevel <= MAXLEVEL) { 
X  				You("rise up, through the ceiling!");
X! 				goto_level(dlevel-1, FALSE, FALSE);
X  			} else You("have an uneasy feeling.");
X  			break;
X  		}
X*** src/Old/pray.c	Sun Oct 15 19:45:28 1989
X--- src/pray.c	Wed Oct 11 18:22:44 1989
X***************
X*** 655,661 ****
X  	else {			/* exactly one warning */
X  #ifdef ALTARS
X  		pline("The voice of %s booms out:  \"Thou hast angered me.\"",
X! 				a_gname());
X  #else
X  		pline("A voice booms out:  \"Thou hast angered me.\"");
X  #endif
X--- 655,661 ----
X  	else {			/* exactly one warning */
X  #ifdef ALTARS
X  		pline("The voice of %s booms out:  \"Thou hast angered me.\"",
X! 				on_altar() ? a_gname() : u_gname());
X  #else
X  		pline("A voice booms out:  \"Thou hast angered me.\"");
X  #endif
X***************
X*** 721,726 ****
X--- 721,729 ----
X  
X  	    if (otmp->corpsenm == PM_ACID_BLOB || (monstermoves <= otmp->age + 50))
X  		value = monstr[otmp->corpsenm] + 1;
X+ 	    if (otmp->oeaten)
X+ 		value =
X+ 		    value * otmp->owt / mons[otmp->corpsenm].cwt / otmp->quan;
X  
X  	    if (is_human(mtmp)) { /* Human sacrifice! */
X  #ifdef POLYSELF
X*** src/Old/pri.c	Sun Oct 15 19:46:09 1989
X--- src/pri.c	Sat Oct 14 22:41:37 1989
X***************
X*** 22,28 ****
X  #endif
X  
X  /* This is the same logic used for "#define IBMXASCII" in file "termcap.c" */
X! #if !defined(AMIGA) && !defined(TOS)
X  # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X  #  define g_putch  (void) putchar
X  # endif
X--- 22,28 ----
X  #endif
X  
X  /* This is the same logic used for "#define IBMXASCII" in file "termcap.c" */
X! #if !defined(AMIGA)
X  # if defined(TERMLIB) || !(defined(DECRAINBOW) || defined(OS2))
X  #  define g_putch  (void) putchar
X  # endif
X***************
X*** 46,62 ****
X--- 46,78 ----
X  	if(first) cls();
X  	else {
X  		curs(u.ustuck->mdx-1, u.ustuck->mdy+1);
X+ #ifdef MACOS
X+ 		puts("   ");
X+ #else
X  		(void) fputs("   ", stdout);
X+ #endif
X  		curx = u.ustuck->mdx+2;
X  		curs(u.ustuck->mdx-1, u.ustuck->mdy+2);
X+ #ifdef MACOS
X+ 		puts("   ");
X+ #else
X  		(void) fputs("   ", stdout);
X+ #endif
X  		curx = u.ustuck->mdx+2;
X  		curs(u.ustuck->mdx-1, u.ustuck->mdy+3);
X+ #ifdef MACOS
X+ 		puts("   ");
X+ #else
X  		(void) fputs("   ", stdout);
X+ #endif
X  		curx = u.ustuck->mdx+2;
X  	}
X  	curs(u.ux-1, u.uy+1);
X+ #ifdef MACOS
X+ 	puts("/-\\");
X+ #else
X  	(void) fputs("/-\\", stdout);
X+ #endif
X  	curx = u.ux+2;
X  	curs(u.ux-1, u.uy+2);
X  	(void) putchar('|');
X***************
X*** 64,70 ****
X--- 80,90 ----
X  	(void) putchar('|');
X  	curx = u.ux+2;
X  	curs(u.ux-1, u.uy+3);
X+ #ifdef MACOS
X+ 	puts("\\-/");
X+ #else
X  	(void) fputs("\\-/", stdout);
X+ #endif
X  	curx = u.ux+2;
X  	u.udispl = 1;
X  	u.udisx = u.ux;
X***************
X*** 134,140 ****
X  	}
X  
X  	if (typ == AT_APP
X! #ifndef MSDOS
X  	    && flags.standout
X  #endif
X  	   )
X--- 154,160 ----
X  	}
X  
X  	if (typ == AT_APP
X! #if !defined(MSDOS) && !defined(MACOS)
X  	    && flags.standout
X  #endif
X  	   )
X***************
X*** 220,225 ****
X--- 240,249 ----
X  	register int x,y;
X  	register struct rm *room;
X  	register struct monst *mtmp;
X+ #ifdef MACOS
X+ 	term_info	*t;
X+ 	extern WindowPtr HackWindow;
X+ #endif
X  
X  	if(u.uswallow) {
X  		swallowed(1);
X***************
X*** 245,251 ****
X  		mtmp->mdispl = 0;
X  	seemons();	/* force new positions to be shown */
X  
X! #if defined(DGK) && !defined(TEXTCOLOR)
X  	/* Otherwise, line buffer the output to do the redraw in
X  	 * about 2/3 of the time.
X  	 */
X--- 269,279 ----
X  		mtmp->mdispl = 0;
X  	seemons();	/* force new positions to be shown */
X  
X! #if (defined(DGK) && !defined(TEXTCOLOR)) || defined(MACOS)
X! # ifdef MACOS
X! 	t = (term_info *)GetWRefCon(HackWindow);
X! 	if (!t->inColor)
X! # endif
X  	/* Otherwise, line buffer the output to do the redraw in
X  	 * about 2/3 of the time.
X  	 */
X***************
X*** 252,262 ****
X  		for(y = 0; y < ROWNO; y++) {
X  			char buf[COLNO+1];
X  			int start, end;
X! #ifdef OLD_TOS
X  			setmem(buf, COLNO, ' ');
X! #else
X  			memset(buf, ' ', COLNO);
X! #endif /* OLD_TOS */
X  			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X  				if((room = &levl[x][y])->new) {
X  					room->new = 0;
X--- 280,290 ----
X  		for(y = 0; y < ROWNO; y++) {
X  			char buf[COLNO+1];
X  			int start, end;
X! # if defined(OLD_TOS) || defined(LSC) || defined(AZTEC)
X  			setmem(buf, COLNO, ' ');
X! # else
X  			memset(buf, ' ', COLNO);
X! # endif /* OLD_TOS */
X  			for(x = 0, start = -1, end = -1; x < COLNO; x++)
X  				if((room = &levl[x][y])->new) {
X  					room->new = 0;
X***************
X*** 273,283 ****
X  			if (end >= 0) {
X  				buf[end + 1] = '\0';
X  				curs(start, y + 2);
X  				(void) fputs(buf + start, stdout);
X  				curx = end + 1;
X  			}
X  		}
X! #else /* DGK && !TEXTCOLOR */
X  	for(y = 0; y < ROWNO; y++)
X  		for(x = 0; x < COLNO; x++)
X  			if((room = &levl[x][y])->new) {
X--- 301,326 ----
X  			if (end >= 0) {
X  				buf[end + 1] = '\0';
X  				curs(start, y + 2);
X+ # ifdef MACOS
X+ 				puts(buf + start);
X+ # else
X  				(void) fputs(buf + start, stdout);
X+ # endif
X  				curx = end + 1;
X  			}
X  		}
X! # ifdef MACOS
X! 	else {
X! 		for(y = 0; y < ROWNO; y++)
X! 		for(x = 0; x < COLNO; x++)
X! 			if((room = &levl[x][y])->new) {
X! 				room->new = 0;
X! 				at(x,y,room->scrsym,AT_APP);
X! 			} else if(room->seen)
X! 				at(x,y,room->scrsym,AT_APP);
X! 	}
X! # endif
X! #else
X  	for(y = 0; y < ROWNO; y++)
X  		for(x = 0; x < COLNO; x++)
X  			if((room = &levl[x][y])->new) {
X***************
X*** 846,852 ****
X  		if(!*nb) {
X  			if(*ob || flags.botlx) {
X  				/* last char printed may be in middle of line */
X! 				curs(strlen(newbot)+1,row);
X  				cl_end();
X  			}
X  			break;
X--- 889,895 ----
X  		if(!*nb) {
X  			if(*ob || flags.botlx) {
X  				/* last char printed may be in middle of line */
X! 				curs((int)strlen(newbot)+1,row);
X  				cl_end();
X  			}
X  			break;
X***************
X*** 1089,1095 ****
X  {
X  
X  	if (let == ' '
X! #ifndef MSDOS
X  	    || !flags.standout
X  #endif
X  	    ) {
X--- 1132,1138 ----
X  {
X  
X  	if (let == ' '
X! #if !defined(MSDOS) && !defined(MACOS)
X  	    || !flags.standout
X  #endif
X  	    ) {
X***************
X*** 1111,1153 ****
X  			typ = AT_MON;
X  	}
X  #ifdef TEXTCOLOR
X! 	switch (typ) {
X! 	    case AT_MON:
X! 		switch (let) {
X! 		    case S_MIMIC_DEF:
X! 			typ = HI_OBJ;
X! 			break;
X! 		    default:
X!                         if (u.ux == x && u.uy == y)
X!                             typ = uasmon->mcolor;
X! 			else
X! 			    typ = level.monsters[x][y]->data->mcolor;
X! 		}
X! 		break;
X! 	    case AT_OBJ:
X! 		if (let == GOLD_SYM)
X! 		    typ = HI_GOLD;
X! 		else if (level.objects[x][y] && 
X! 			 let == objects[level.objects[x][y]->otyp].oc_olet)
X! 		    typ = objects[level.objects[x][y]->otyp].oc_color;
X! 		else
X! 		    typ = mimic_color(let);
X  		break;
X! 	    case AT_MAP:
X  #ifdef FOUNTAINS
X! 		typ = ((let == POOL_SYM || let == FOUNTAIN_SYM)
X! #else
X! 		typ = (let == POOL_SYM
X  #endif
X! 			&& hilites[BLUE] != HI ? BLUE :
X  #ifdef THRONES
X! 		       let == THRONE_SYM && hilites[HI_GOLD] != HI ? HI_GOLD :
X  #endif
X! 		       0);
X! 		break;
X! 	    case AT_ZAP:
X! 		typ = HI_ZAP;
X! 		break;
X  	}
X  	if (typ && flags.use_color)
X  		xputs(hilites[typ]);
X--- 1154,1202 ----
X  			typ = AT_MON;
X  	}
X  #ifdef TEXTCOLOR
X! 	if (flags.use_color) {
X! 	    switch (typ) {
X! 		case AT_MON:
X! 		    switch (let) {
X! 			case S_MIMIC_DEF:
X! 			    typ = HI_OBJ;
X! 			    break;
X! 		        default:
X! 			    if (u.ux == x && u.uy == y)
X! 				typ = uasmon->mcolor;
X! 			    else
X! 			        typ = level.monsters[x][y]->data->mcolor;
X! 		    }
X  		break;
X! 		case AT_OBJ:
X! 		    if (let == GOLD_SYM)
X! 			typ = HI_GOLD;
X! 		    else if (level.objects[x][y] && 
X! 			   let == objects[level.objects[x][y]->otyp].oc_olet)
X! 			typ = objects[level.objects[x][y]->otyp].oc_color;
X! 		    else
X! 			typ = mimic_color(let);
X! 		    break;
X! 		case AT_MAP:
X! 		    if ( ((let == POOL_SYM && IS_POOL(levl[x][y].typ))
X  #ifdef FOUNTAINS
X! 		    || (let == FOUNTAIN_SYM && IS_FOUNTAIN(levl[x][y].typ))
X  #endif
X! 		     ) && hilites[BLUE] != HI)
X! 
X! 			typ = BLUE;
X  #ifdef THRONES
X! 		    else if (let == THRONE_SYM && IS_THRONE(levl[x][y].typ)
X! 				&& hilites[HI_GOLD] != HI)
X! 			typ = HI_GOLD;
X  #endif
X! 		    else
X! 			typ = 0;
X! 		    break;
X! 		case AT_ZAP:
X! 		    typ = HI_ZAP;
X! 		    break;
X! 		}
X  	}
X  	if (typ && flags.use_color)
X  		xputs(hilites[typ]);
X
END_OF_FILE
if test 54469 -ne `wc -c <'patches05e'`; then
    echo shar: \"'patches05e'\" unpacked with wrong size!
fi
# end of 'patches05e'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
